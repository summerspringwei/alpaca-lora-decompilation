import json
import os
import subprocess
import re
import shlex
import multiprocessing
from functools import partial
from tqdm import tqdm
import pickle
import fire

# --- Configuration ---
# Path to the compile_commands.json file
COMPILE_COMMANDS_PATH = "compile_commands.json"

# Path to the clang compiler (if not in PATH, specify the full path)
# If your compile_commands.json already specifies clang, this might not be strictly needed
# for the IR generation part, but it's good to have for consistency.
# CLANG_PATH = "clang" # Assumes clang is in your PATH
CLANG_PATH = "/home/xiachunwei/Software//llvm-project-release/myrelease-17.0.2/bin/clang"

# Path to the llvm-extract tool (if not in PATH, specify the full path)
LLVM_EXTRACT_PATH = "/home/xiachunwei/Software//llvm-project-release/myrelease-17.0.2/bin/llvm-extract" # Assumes llvm-extract is in your PATH

# --- Helper Functions ---

def ensure_dir(directory_path):
    """Creates a directory if it doesn't exist."""
    os.makedirs(directory_path, exist_ok=True)

def run_command(command, working_dir=None, description="command"):
    """Executes a shell command and prints its output."""
    try:
        print(f"Running {description}: {' '.join(command)}")
        if working_dir:
            print(f"  In directory: {working_dir}")
        
        # Use shlex.join for better command string representation if needed for logging
        # For subprocess.run, a list of arguments is generally safer
        process = subprocess.run(command, cwd=working_dir, capture_output=True, text=True, check=False)
        
        if process.stdout:
            print(f"  STDOUT:\n{process.stdout.strip()}")
        if process.stderr:
            print(f"  STDERR:\n{process.stderr.strip()}")
        
        process.check_returncode() # Raise an exception if the command failed
        print(f"  Successfully executed {description}.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"  Error executing {description}:")
        print(f"  Command: {' '.join(e.cmd)}")
        if e.stdout:
            print(f"  STDOUT:\n{e.stdout.strip()}")
        if e.stderr:
            print(f"  STDERR:\n{e.stderr.strip()}")
        return False
    except FileNotFoundError:
        print(f"  Error: Command not found - {command[0]}. Please ensure it's in your PATH or configured correctly.")
        return False
    except Exception as e:
        print(f"  An unexpected error occurred while running {description}: {e}")
        return False

def modify_compile_command_for_llvm_ir(original_command_parts, output_ll_file_abs, extra_compile_args="-O0"):
    """
    Modifies a compilation command from compile_commands.json to output LLVM IR.
    """
    new_command = []
    
    # Find the original compiler and replace if necessary, or ensure it's clang
    # The first element is usually the compiler.
    # compile_commands.json generated by `bear` should already have the correct compiler (clang in this case).
    
    # Make sure the compiler is clang
    # If the original command uses gcc, we might need to be more careful with flag compatibility.
    # Assuming `bear -- make CC=clang` was used, the command should already start with clang.
    if not original_command_parts[0].endswith("clang") and not original_command_parts[0].endswith("clang++"):
        print(f"Warning: Original compiler '{original_command_parts[0]}' is not clang. Attempting to use '{CLANG_PATH}'.")
        new_command.append(CLANG_PATH)
        # Skip the original compiler, add the rest of the flags
        # This is a simplification; some flags might be GCC-specific.
        # For Redis with `CC=clang`, this branch is less likely to be hit.
        new_command.extend(original_command_parts[1:])
    else:
        new_command.extend(original_command_parts)

    # Remove original output file options (-o somefile.o) and the -c flag
    filtered_command = []
    skip_next = False
    for i, part in enumerate(new_command):
        if skip_next:
            skip_next = False
            continue
        if part == "-o":
            skip_next = True  # Skip this and the next part (the output filename)
            continue
        if part == "-c":
            continue # Remove compile-only flag, -S implies it for single file
        if part == "-g":
            continue
        if part == "-ggdb":
            continue
        if part.startswith("-g") or part.startswith("-O"):
            continue

        filtered_command.append(part)
    
    new_command = filtered_command

    # Add LLVM IR generation flags
    new_command.extend([
        "-S",              # Output assembly/LLVM IR
        "-emit-llvm",      # Specifically emit LLVM IR
        "-fno-discard-value-names", # Try to keep variable names in IR
        extra_compile_args, # Add any extra compile arguments (e.g., -O0 for no optimization)
        "-o", output_ll_file_abs # Specify the output .ll file
    ])
    
    return new_command


def find_functions_in_ll_file(ll_filepath):
    """
    Scans an LLVM IR file and returns a list of defined function names.
    Function names in LLVM IR usually start with '@'.
    """
    functions = []
    # Regex to find global function definitions: define [linkage] [cconv] type @name(...)
    # We are interested in @name. It can contain alphanumeric, '.', '$', '_'
    # Example: define dso_local void @main(i32 %0, ptr %1) #0 {
    # Example: define available_externally void @llvm.dbg.value(metadata, metadata, metadata)
    # We want to capture the name after '@' and before '('.
    function_pattern = re.compile(r"^\s*define\s+.*\s+(@[a-zA-Z0-9_$.]+)\s*\(")
    
    try:
        with open(ll_filepath, 'r') as f:
            for line in f:
                match = function_pattern.match(line)
                if match:
                    func_name = match.group(1)
                    # We need the name without '@' for llvm-extract's --func argument
                    functions.append(func_name.lstrip('@')) 
    except FileNotFoundError:
        print(f"Error: LL file not found for function extraction: {ll_filepath}")
    except Exception as e:
        print(f"Error reading LL file {ll_filepath}: {e}")
    return functions

# --- Main Logic ---

def process_single_file(args):
    """Process a single file to generate LLVM IR."""
    entry, base_source_dir, llvm_ir_output_dir, extra_compile_args = args
    source_file_path = entry['file']
    command_directory = entry['directory']

    # Construct absolute path to the source file
    if os.path.isabs(source_file_path):
        source_file_abs = source_file_path
    else:
        source_file_abs = os.path.normpath(os.path.join(command_directory, source_file_path))
    
    if not source_file_abs.endswith(".c"): # Process only C files
        return None
    
    try:
        relative_source_path = os.path.relpath(source_file_abs, base_source_dir)
    except ValueError: # Happens if source_file_abs is on a different drive (Windows)
        relative_source_path = os.path.basename(source_file_abs)

    output_ll_filename = os.path.splitext(relative_source_path)[0] + ".ll"
    output_ll_file_abs = os.path.join(base_source_dir, llvm_ir_output_dir, output_ll_filename)
    
    ensure_dir(os.path.dirname(output_ll_file_abs))

    if 'arguments' in entry:
        original_command_parts = entry['arguments']
    elif 'command' in entry:
        original_command_parts = shlex.split(entry['command'])
    else:
        return None
    
    modified_command = modify_compile_command_for_llvm_ir(
        original_command_parts,
        output_ll_file_abs,
        extra_compile_args=extra_compile_args
    )
    
    if run_command(modified_command, working_dir=command_directory, description=f"LLVM IR generation for {os.path.basename(source_file_abs)}"):
        return output_ll_file_abs
    return None

def process_single_ll_file(args):
    """Process a single LL file to extract functions."""
    ll_filepath_abs, base_source_dir, extracted_functions_dir, llvm_ir_output_dir = args
    if not os.path.exists(ll_filepath_abs):
        return

    functions_to_extract = find_functions_in_ll_file(ll_filepath_abs)
    if not functions_to_extract:
        return
    
    relative_ll_path_to_output_dir = os.path.relpath(ll_filepath_abs, os.path.join(base_source_dir, llvm_ir_output_dir))
    module_func_subdir_name = relative_ll_path_to_output_dir.replace(os.sep, "_").replace(".ll", "")
    
    output_dir_for_this_module_functions = os.path.join(base_source_dir, extracted_functions_dir, module_func_subdir_name)
    ensure_dir(output_dir_for_this_module_functions)

    for func_name in functions_to_extract:
        safe_func_name_for_file = func_name.replace("@", "").replace(".", "_").replace("$", "_")
        output_func_ll_file = os.path.join(output_dir_for_this_module_functions, f"{safe_func_name_for_file}.ll")
        
        extract_command = [
            LLVM_EXTRACT_PATH,
            "-S",
            f"--func={func_name}",
            ll_filepath_abs,
            "-o", output_func_ll_file
        ]
        run_command(extract_command, description=f"Extracting function '{func_name}'")

def main(base_source_dir = None, 
         llvm_ir_output_dir = "generated_llvm_ir", 
         extracted_functions_dir = "extracted_functions",
         extra_compile_args="-O0"):
    ensure_dir(llvm_ir_output_dir)
    ensure_dir(extracted_functions_dir)

    base_source_dir = os.getcwd() if base_source_dir is None else base_source_dir
    print(f"Base source directory: {base_source_dir}")
    print(f"LLVM IR output directory: {llvm_ir_output_dir}")
    print(f"Extracted functions directory: {extracted_functions_dir}")

    try:
        with open(os.path.join(base_source_dir, COMPILE_COMMANDS_PATH), 'r') as f:
            compile_entries = json.load(f)
    except FileNotFoundError:
        print(f"Error: {COMPILE_COMMANDS_PATH} not found. Make sure it's in the current directory.")
        return
    except json.JSONDecodeError:
        print(f"Error: Could not decode {COMPILE_COMMANDS_PATH}. Is it a valid JSON file?")
        return
    # Filter out entries where 'directory' contains '/deps/'
    compile_entries = [entry for entry in compile_entries if '/deps/' not in entry['directory']]
    # Part 1: Generate LLVM IR for each C file using parallel processing
    print("\n--- Part 1: Generating LLVM IR Files ---")
    num_processes = multiprocessing.cpu_count()
    print(f"Using {num_processes} processes for parallel processing")
    
    with multiprocessing.Pool(processes=num_processes) as pool:
        args = [(entry, base_source_dir, llvm_ir_output_dir, extra_compile_args) 
                for entry in compile_entries]
        generated_ll_files = list(filter(None, tqdm(
            pool.imap(process_single_file, args),
            total=len(args),
            desc="Generating LLVM IR files"
        )))

    # Part 2: Extract functions from each generated .ll file using parallel processing
    print("\n--- Part 2: Extracting Functions from LLVM IR Files ---")
    if not generated_ll_files:
        print("No LLVM IR files were generated. Skipping function extraction.")
        return

    with multiprocessing.Pool(processes=num_processes) as pool:
        args = [(ll_file, base_source_dir, extracted_functions_dir, llvm_ir_output_dir) for ll_file in generated_ll_files]
        list(tqdm(
            pool.imap(process_single_ll_file, args),
            total=len(args),
            desc="Extracting functions"
        ))

    print("\n--- Processing Complete ---")

if __name__ == "__main__":
    fire.Fire(main)
