{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfastcgi.c_send_eos_and_close",
    "input":"\n0000000000000000 <send_eos_and_close>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \ttestl\t%esi, %esi\n9: \tje\t0x21 <send_eos_and_close+0x21>\nb: \tmovq\t16(%rbx), %rdi\nf: \tcmpq\t$0, 8(%rdi)\n14: \tje\t0x21 <send_eos_and_close+0x21>\n16: \tmovq\t8(%rbx), %rsi\n1a: \tcallq\t0x1f <send_eos_and_close+0x1f>\n1f: \tjmp\t0x2a <send_eos_and_close+0x2a>\n21: \tmovq\t8(%rbx), %rdi\n25: \tcallq\t0x2a <send_eos_and_close+0x2a>\n2a: \tmovq\t$0, 8(%rbx)\n32: \tleaq\t4(%rbx), %r14\n36: \tmovq\t%r14, %rdi\n39: \tcallq\t0x3e <send_eos_and_close+0x3e>\n3e: \ttestq\t%rax, %rax\n41: \tje\t0x4b <send_eos_and_close+0x4b>\n43: \tmovq\t%r14, %rdi\n46: \tcallq\t0x4b <send_eos_and_close+0x4b>\n4b: \tcmpl\t$0, (%rbx)\n4e: \tje\t0x58 <send_eos_and_close+0x58>\n50: \taddq\t$8, %rsp\n54: \tpopq\t%rbx\n55: \tpopq\t%r14\n57: \tretq\n58: \tmovq\t%rbx, %rdi\n5b: \taddq\t$8, %rsp\n5f: \tpopq\t%rbx\n60: \tpopq\t%r14\n62: \tjmp\t0x67 <send_eos_and_close+0x67>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  inflight; } ;\nstruct TYPE_6__ {TYPE_1__ sending; } ;\nstruct st_fcgi_generator_t {TYPE_2__ resp; int /*<<< orphan*/  timeout; int /*<<< orphan*/ * sock; TYPE_4__* handler; } ;\nstruct TYPE_7__ {scalar_t__ keepalive_timeout; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  sockpool; TYPE_3__ config; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_send (struct st_fcgi_generator_t*) ;\nint /*<<< orphan*/  h2o_socket_close (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socketpool_return (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nscalar_t__ h2o_timer_is_linked (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timer_unlink (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void send_eos_and_close(struct st_fcgi_generator_t *generator, int can_keepalive)\n{\nif (generator->handler->config.keepalive_timeout != 0 && can_keepalive)\nh2o_socketpool_return(&generator->handler->sockpool, generator->sock);\nelse\nh2o_socket_close(generator->sock);\ngenerator->sock = NULL;\nif (h2o_timer_is_linked(&generator->timeout))\nh2o_timer_unlink(&generator->timeout);\nif (!generator->resp.sending.inflight)\ndo_send(generator);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  eos_sent; int /*<<< orphan*/ * out; TYPE_1__* priv_data; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  pb; int /*<<< orphan*/ * pb_eos; } ;\ntypedef  TYPE_1__ MpegMuxContext ;\ntypedef  TYPE_2__ AVFormatContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  av_packet_unref (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ff_format_io_close (TYPE_2__*,int) ;\nscalar_t__ ff_interleaved_frame_filter (TYPE_2__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ff_write_chapters (TYPE_2__*) ;\nint /*<<< orphan*/  ff_write_packet (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void send_eos_and_close(AVFormatContext *s, int flush)\n{\nMpegMuxContext *mux = s->priv_data;\n\nif (flush && mux->pb_eos) {\nff_write_packet(s->out, mux->pb_eos);\nmux->pb_eos = NULL;\n}\n\nif (ff_interleaved_frame_filter(s, NULL))\nff_write_packet(s->out, NULL);\n\nff_write_chapters(s);\n\nif (!s->eos_sent) {\ns->eos_sent = 1;\nff_format_io_close(s, flush);\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfastcgi.c_append_content",
    "input":"\n0000000000000000 <append_content>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %r14\n8: \tmovq\t%rsi, %r15\nb: \tmovq\t%rdi, %rbx\ne: \tmovq\t(%rdi), %rax\n11: \tcmpq\t(%rip), %rax  # 0x18 <append_content+0x18>\n18: \tje\t0x2d <append_content+0x2d>\n1a: \tcmpq\t%r14, %rax\n1d: \tjae\t0x27 <append_content+0x27>\n1f: \tmovq\t%rax, %r14\n22: \ttestq\t%rax, %rax\n25: \tje\t0x55 <append_content+0x55>\n27: \tsubq\t%r14, %rax\n2a: \tmovq\t%rax, (%rbx)\n2d: \taddq\t$8, %rbx\n31: \tmovq\t%rbx, %rdi\n34: \tmovq\t%r14, %rsi\n37: \tcallq\t0x3c <append_content+0x3c>\n3c: \ttestq\t%rax, %rax\n3f: \tje\t0x59 <append_content+0x59>\n41: \tmovq\t%rax, %rdi\n44: \tmovq\t%r15, %rsi\n47: \tmovq\t%r14, %rdx\n4a: \tcallq\t0x4f <append_content+0x4f>\n4f: \tmovq\t(%rbx), %rax\n52: \taddq\t%r14, (%rax)\n55: \txorl\t%eax, %eax\n57: \tjmp\t0x5e <append_content+0x5e>\n59: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n5e: \tpopq\t%rbx\n5f: \tpopq\t%r14\n61: \tpopq\t%r15\n63: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_4__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_4__* receiving; } ;\nstruct st_fcgi_generator_t {size_t leftsize; TYPE_1__ resp; } ;\nstruct TYPE_6__ {int /*<<< orphan*/ * base; } ;\ntypedef  TYPE_2__ h2o_iovec_t ;\nstruct TYPE_7__ {size_t size; } ;\n\n/* Variables and functions */\nsize_t SIZE_MAX ;\nTYPE_2__ h2o_buffer_try_reserve (TYPE_4__**,size_t) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,void const*,size_t) ;\n\n__attribute__((used)) static int append_content(struct st_fcgi_generator_t *generator, const void *src, size_t len)\n{\n/* do not accumulate more than content-length bytes */\nif (generator->leftsize != SIZE_MAX) {\nif (generator->leftsize < len) {\nlen = generator->leftsize;\nif (len == 0)\nreturn 0;\n}\ngenerator->leftsize -= len;\n}\nh2o_iovec_t reserved = h2o_buffer_try_reserve(&generator->resp.receiving, len);\nif (reserved.base == NULL) {\nreturn -1;\n}\nmemcpy(reserved.base, src, len);\ngenerator->resp.receiving->size += len;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ size; } ;\ntypedef  TYPE_1__* StringInfo ;\ntypedef  int /*<<< orphan*/  Datum ;\n\n/* Variables and functions */\nscalar_t__ MaxAllocSize ;\nint /*<<< orphan*/ * enlargeStringInfo (TYPE_1__*,scalar_t__) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,scalar_t__) ;\n\n__attribute__((used)) static int\nappend_content(StringInfo str, const Datum datum, size_t size)\n{\nif (str->size < size)\n{\nsize_t\t\tnewsize = str->size;\n\nif (newsize == 0)\nnewsize = 1;\nwhile (newsize < size)\nnewsize *= 2;\nif (newsize > MaxAllocSize)\nnewsize = MaxAllocSize;\nstr->size = newsize;\n}\n\nif (!enlargeStringInfo(str, size))\nreturn -1;\n\nmemcpy(str->data + str->size - size, datum, size);\nstr->size += size;\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_send_method_not_allowed",
    "input":"\n0000000000000000 <send_method_not_allowed>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdi, %rbx\n7: \tleaq\t4(%rdi), %r14\nb: \tmovl\t(%rip), %ebp  # 0x11 <send_method_not_allowed+0x11>\n11: \tmovl\t$0, %edi\n16: \tcallq\t0x1b <send_method_not_allowed+0x1b>\n1b: \tmovq\t%r14, %rdi\n1e: \tmovq\t%rbx, %rsi\n21: \tmovl\t%ebp, %edx\n23: \txorl\t%ecx, %ecx\n25: \tmovl\t%eax, %r8d\n28: \tcallq\t0x2d <send_method_not_allowed+0x2d>\n2d: \tmovl\t(%rip), %ecx  # 0x33 <send_method_not_allowed+0x33>\n33: \tmovl\t$0, %esi\n38: \tmovl\t$0, %edx\n3d: \tmovq\t%rbx, %rdi\n40: \tpopq\t%rbx\n41: \tpopq\t%r14\n43: \tpopq\t%rbp\n44: \tjmp\t0x49 <send_method_not_allowed+0x49>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  headers; } ;\nstruct TYPE_6__ {TYPE_1__ res; int /*<<< orphan*/  pool; } ;\ntypedef  TYPE_2__ h2o_req_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SEND_ERROR_KEEP_HEADERS ;\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  H2O_TOKEN_ALLOW ;\nint /*<<< orphan*/  h2o_add_header (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_send_error_405 (TYPE_2__*,char*,char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void send_method_not_allowed(h2o_req_t *req)\n{\nh2o_add_header(&req->pool, &req->res.headers, H2O_TOKEN_ALLOW, NULL, H2O_STRLIT(\"GET, HEAD\"));\nh2o_send_error_405(req, \"Method Not Allowed\", \"method not allowed\", H2O_SEND_ERROR_KEEP_HEADERS);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  method; int /*<<< orphan*/  out; } ;\ntypedef  TYPE_1__ GLogSocket ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HTTP_STATUS_METHOD_NOT_ALLOWED ;\nint /*<<< orphan*/  SEND_ERROR (int /*<<< orphan*/ *,char*,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*,char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  write_http_header (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void send_method_not_allowed (GLogSocket *s) {\nfprintf (stderr, \"send_method_not_allowed\\n\");\nwrite_http_header (&s->out, s, HTTP_STATUS_METHOD_NOT_ALLOWED, 0, 0);\nSEND_ERROR (&s->out, \"Method Not Allowed\", \"Method Not Allowed\", s->method, 0);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_add_headers_unconditional",
    "input":"\n0000000000000000 <add_headers_unconditional>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tcmpq\t$0, 16(%rdi)\nf: \tje\t0x37 <add_headers_unconditional+0x37>\n11: \tmovl\t8(%rbx), %esi\n14: \tmovl\t12(%rbx), %edi\n17: \tcallq\t0x1c <add_headers_unconditional+0x1c>\n1c: \tleaq\t4(%r14), %rdi\n20: \tmovl\t(%rip), %edx  # 0x26 <add_headers_unconditional+0x26>\n26: \tmovl\t8(%rbx), %r8d\n2a: \tmovq\t%r14, %rsi\n2d: \txorl\t%ecx, %ecx\n2f: \tmovq\t%rax, %r9\n32: \tcallq\t0x37 <add_headers_unconditional+0x37>\n37: \tcmpq\t$0, (%rbx)\n3b: \tje\t0x64 <add_headers_unconditional+0x64>\n3d: \tleaq\t4(%r14), %rbx\n41: \tmovl\t(%rip), %ebp  # 0x47 <add_headers_unconditional+0x47>\n47: \tmovl\t$0, %edi\n4c: \tcallq\t0x51 <add_headers_unconditional+0x51>\n51: \tmovq\t%rbx, %rdi\n54: \tmovq\t%r14, %rsi\n57: \tmovl\t%ebp, %edx\n59: \tmovl\t%eax, %ecx\n5b: \tpopq\t%rbx\n5c: \tpopq\t%r14\n5e: \tpopq\t%rbp\n5f: \tjmp\t0x64 <add_headers_unconditional+0x64>\n64: \tpopq\t%rbx\n65: \tpopq\t%r14\n67: \tpopq\t%rbp\n68: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  etag; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  ref; } ;\nstruct st_h2o_sendfile_generator_t {scalar_t__ send_vary; TYPE_3__ header_bufs; TYPE_2__ file; scalar_t__ send_etag; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  headers; } ;\nstruct TYPE_9__ {TYPE_1__ res; int /*<<< orphan*/  pool; } ;\ntypedef  TYPE_4__ h2o_req_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  H2O_TOKEN_ETAG ;\nint /*<<< orphan*/  H2O_TOKEN_VARY ;\nint /*<<< orphan*/  h2o_add_header (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,size_t) ;\nsize_t h2o_filecache_get_etag (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_set_header_token (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void add_headers_unconditional(struct st_h2o_sendfile_generator_t *self, h2o_req_t *req)\n{\n/* RFC 7232 4.1: The server generating a 304 response MUST generate any of the following header fields that would have been sent\n* in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary (snip) a sender\n* SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of\n* guiding cache updates. */\nif (self->send_etag) {\nsize_t etag_len = h2o_filecache_get_etag(self->file.ref, self->header_bufs.etag);\nh2o_add_header(&req->pool, &req->res.headers, H2O_TOKEN_ETAG, NULL, self->header_bufs.etag, etag_len);\n}\nif (self->send_vary)\nh2o_set_header_token(&req->pool, &req->res.headers, H2O_TOKEN_VARY, H2O_STRLIT(\"accept-encoding\"));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ add_headers; int /*<<< orphan*/  headers; int /*<<< orphan*/  headers_len; int /*<<< orphan*/  headers_str; } ;\ntypedef  TYPE_1__ GLogWriter ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  g_string_append_printf (char**,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_string_new (char*) ;\nint /*<<< orphan*/  g_string_sized_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_string_sprintf (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_string_truncate (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nadd_headers_unconditional(GLogWriter *writer, char *buf)\n{\nif (writer->headers_str)\n{\ng_string_sprintf(&writer->headers_str, \"%s%s\",\nwriter->headers, writer->headers_str->str);\n}\n\nif (writer->add_headers)\n{\nchar *headers = g_string_sized_new(writer->headers_len);\ng_string_append_printf(&headers, \"%s%s\",\nwriter->headers, buf);\ng_string_truncate(writer->headers_str, 0);\ng_string_sprintf(writer->headers_str, \"%s%s\",\nwriter->headers, headers);\ng_string_free(headers, FALSE);\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerheaders.c_on_setup_ostream",
    "input":"\n0000000000000000 <on_setup_ostream>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rdx, %r14\nb: \tmovq\t%rsi, %r15\ne: \tmovq\t(%rdi), %rbx\n11: \tmovq\t(%rip), %rax  # 0x18 <on_setup_ostream+0x18>\n18: \tcmpq\t%rax, (%rbx)\n1b: \tjne\t0x33 <on_setup_ostream+0x33>\n1d: \tmovq\t%r15, %rdi\n20: \tmovq\t%r14, %rsi\n23: \taddq\t$8, %rsp\n27: \tpopq\t%rbx\n28: \tpopq\t%r12\n2a: \tpopq\t%r14\n2c: \tpopq\t%r15\n2e: \tjmp\t0x33 <on_setup_ostream+0x33>\n33: \tleaq\t4(%r15), %r12\n37: \tjmp\t0x4a <on_setup_ostream+0x4a>\n39: \tnopl\t(%rax)\n40: \tcmpq\t%rax, 16(%rbx)\n44: \tleaq\t16(%rbx), %rbx\n48: \tje\t0x1d <on_setup_ostream+0x1d>\n4a: \tmovq\t8(%rbx), %rcx\n4e: \tcmpq\t(%rip), %rcx  # 0x55 <on_setup_ostream+0x55>\n55: \tje\t0x40 <on_setup_ostream+0x40>\n57: \tmovq\t%r12, %rdi\n5a: \tmovq\t%r15, %rsi\n5d: \tmovq\t%rbx, %rdx\n60: \tcallq\t0x65 <on_setup_ostream+0x65>\n65: \tmovq\t(%rip), %rax  # 0x6c <on_setup_ostream+0x6c>\n6c: \tjmp\t0x40 <on_setup_ostream+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_headers_filter_t {TYPE_3__* cmds; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  headers; } ;\nstruct TYPE_8__ {TYPE_1__ res; int /*<<< orphan*/  pool; } ;\ntypedef  TYPE_2__ h2o_req_t ;\ntypedef  int /*<<< orphan*/  h2o_ostream_t ;\nstruct TYPE_9__ {scalar_t__ cmd; scalar_t__ when; } ;\ntypedef  TYPE_3__ h2o_headers_command_t ;\ntypedef  int /*<<< orphan*/  h2o_filter_t ;\n\n/* Variables and functions */\nscalar_t__ H2O_HEADERS_CMD_NULL ;\nscalar_t__ H2O_HEADERS_CMD_WHEN_EARLY ;\nint /*<<< orphan*/  h2o_rewrite_headers (int /*<<< orphan*/ *,int /*<<< orphan*/ *,TYPE_3__*) ;\nint /*<<< orphan*/  h2o_setup_next_ostream (TYPE_2__*,int /*<<< orphan*/ **) ;\n\n__attribute__((used)) static void on_setup_ostream(h2o_filter_t *_self, h2o_req_t *req, h2o_ostream_t **slot)\n{\nstruct st_headers_filter_t *self = (void *)_self;\nh2o_headers_command_t *cmd;\n\nfor (cmd = self->cmds; cmd->cmd != H2O_HEADERS_CMD_NULL; ++cmd) {\nif (cmd->when != H2O_HEADERS_CMD_WHEN_EARLY)\nh2o_rewrite_headers(&req->pool, &req->res.headers, cmd);\n}\n\nh2o_setup_next_ostream(req, slot);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* priv_data; } ;\nstruct TYPE_9__ {scalar_t__ state; TYPE_1__* ostreams; } ;\nstruct TYPE_8__ {scalar_t__ state; int /*<<< orphan*/  (* on_setup_ostream ) (TYPE_3__*,char const*,TYPE_2__*) ;} ;\ntypedef  TYPE_2__ RTMPContext ;\ntypedef  TYPE_3__ URLContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  stub1 (TYPE_3__*,char const*,TYPE_2__*) ;\nint /*<<< orphan*/  stub2 (TYPE_3__*,char const*,TYPE_2__*) ;\nint /*<<< orphan*/  stub3 (TYPE_3__*,char const*,TYPE_2__*) ;\nscalar_t__ RTMP_STATE_DISCONNECTED ;\nscalar_t__ RTMP_STATE_HANDSHAKE ;\nscalar_t__ RTMP_STATE_SERVER_WINDOW_ACKNOWLEDGED ;\nint /*<<< orphan*/  rtmp_send_connect (TYPE_3__*,char const*,TYPE_2__*) ;\n\n__attribute__((used)) static void on_setup_ostream(URLContext *h, const char *url, RTMPContext *rtmp)\n{\nwhile (rtmp->priv_data->state != RTMP_STATE_DISCONNECTED) {\nif (rtmp->priv_data->state == RTMP_STATE_HANDSHAKE) {\nrtmp_send_connect(h, url, rtmp);\nreturn;\n}\nif (rtmp->priv_data->state == RTMP_STATE_SERVER_WINDOW_ACKNOWLEDGED) {\nrtmp->priv_data->ostreams[0].on_setup_ostream(h, url, rtmp);\nreturn;\n}\nrtmp->priv_data++;\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerredirect.c_on_dispose",
    "input":"\n0000000000000000 <on_dispose>:\n0: \tmovl\t(%rdi), %edi\n2: \tjmp\t0x7 <on_dispose+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  base; } ;\nstruct TYPE_4__ {TYPE_1__ prefix; } ;\ntypedef  TYPE_2__ h2o_redirect_handler_t ;\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_dispose(h2o_handler_t *_self)\n{\nh2o_redirect_handler_t *self = (void *)_self;\nfree(self->prefix.base);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  hwnd; } ;\ntypedef  TYPE_1__ State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DestroyWindow (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_dispose(void *data)\n{\nState *state = data;\nDestroyWindow(state->hwnd);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_h2o_file_get_mimemap",
    "input":"\n0000000000000000 <h2o_file_get_mimemap>:\n0: \tmovq\t(%rdi), %rax\n3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mimemap_t ;\nstruct TYPE_3__ {int /*<<< orphan*/ * mimemap; } ;\ntypedef  TYPE_1__ h2o_file_handler_t ;\n\n/* Variables and functions */\n\nh2o_mimemap_t *h2o_file_get_mimemap(h2o_file_handler_t *handler)\n{\nreturn handler->mimemap;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * mimemap; } ;\ntypedef  TYPE_1__ h2o_file_context_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static h2o_mimemap_t *h2o_file_get_mimemap(h2o_file_context_t *ctx)\n{\nreturn ctx->mimemap;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerheaders.c_on_req",
    "input":"\n0000000000000000 <on_req>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r15\n8: \tmovq\t%rdi, %r14\nb: \tleaq\t8(%rsi), %rdi\nf: \tmovl\t(%rip), %edx  # 0x15 <on_req+0x15>\n15: \tmovl\t$16, %esi\n1a: \tcallq\t0x1f <on_req+0x1f>\n1f: \tmovq\t%rax, %rbx\n22: \tmovq\t%r15, 8(%rax)\n26: \tmovl\t(%r14), %eax\n29: \tmovl\t%eax, 4(%rbx)\n2c: \tmovl\t(%rip), %esi  # 0x32 <on_req+0x32>\n32: \tmovq\t%rbx, %rdi\n35: \tcallq\t0x3a <on_req+0x3a>\n3a: \tmovq\t(%r15), %rax\n3d: \tmovq\t(%rax), %rax\n40: \tmovl\t(%rax), %edi\n42: \txorl\t%esi, %esi\n44: \tmovq\t%rbx, %rdx\n47: \tcallq\t0x4c <on_req+0x4c>\n4c: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tpopq\t%r15\n56: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_headers_early_hints_sender_t {int /*<<< orphan*/  deferred_timeout_entry; int /*<<< orphan*/  cmds; TYPE_3__* req; } ;\nstruct st_headers_early_hints_handler_t {int /*<<< orphan*/  cmds; } ;\nstruct TYPE_7__ {TYPE_2__* conn; int /*<<< orphan*/  pool; } ;\ntypedef  TYPE_3__ h2o_req_t ;\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\nstruct TYPE_6__ {TYPE_1__* ctx; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  loop; } ;\n\n/* Variables and functions */\nstruct st_headers_early_hints_sender_t* h2o_mem_alloc_shared (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timer_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timer_link (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  on_sender_deferred_timeout ;\nint /*<<< orphan*/  on_sender_dispose ;\n\n__attribute__((used)) static int on_req(h2o_handler_t *_handler, h2o_req_t *req)\n{\nstruct st_headers_early_hints_handler_t *handler = (void *)_handler;\n\nstruct st_headers_early_hints_sender_t *sender = h2o_mem_alloc_shared(&req->pool, sizeof(*sender), on_sender_dispose);\nsender->req = req;\nsender->cmds = handler->cmds;\nh2o_timer_init(&sender->deferred_timeout_entry, on_sender_deferred_timeout);\nh2o_timer_link(req->conn->ctx->loop, 0, &sender->deferred_timeout_entry);\n\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  fd; } ;\nstruct TYPE_9__ {TYPE_3__* priv_data; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ AVFormatContext ;\ntypedef  TYPE_2__ URLContext ;\ntypedef  TYPE_3__ RTMPContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AVIO_FLAG_READ ;\nint /*<<< orphan*/  RTMP_TYPE_INVOKE ;\nint /*<<< orphan*/  av_freep (TYPE_3__**) ;\nTYPE_1__* avformat_alloc_context () ;\nint /*<<< orphan*/  ffurl_connect (int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_3__*) ;\nint /*<<< orphan*/  ffurl_get_file_handle (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int on_req(URLContext *h, const char *uri)\n{\nRTMPContext *s = av_mallocz(sizeof(*s));\nAVFormatContext *fc;\n\nfc = avformat_alloc_context();\nfc->priv_data = s;\nfc->pb = h;\n\nffurl_get_file_handle(h->priv_data->fd, &s->fd);\n\ns->type = RTMP_TYPE_INVOKE;\n\nffurl_connect(fc, AVIO_FLAG_READ, s);\n\nav_freep(&s);\n\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfastcgi.c_on_handler_dispose",
    "input":"\n0000000000000000 <on_handler_dispose>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t16(%rdi), %rax\n8: \ttestq\t%rax, %rax\nb: \tje\t0x15 <on_handler_dispose+0x15>\nd: \tmovl\t8(%rbx), %esi\n10: \tmovq\t%rbx, %rdi\n13: \tcallq\t*%rax\n15: \tleaq\t24(%rbx), %rdi\n19: \tcallq\t0x1e <on_handler_dispose+0x1e>\n1e: \tmovl\t(%rbx), %edi\n20: \tpopq\t%rbx\n21: \tjmp\t0x26 <on_handler_dispose+0x26>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  base; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  data; int /*<<< orphan*/  (* dispose ) (TYPE_4__*,int /*<<< orphan*/ ) ;} ;\nstruct TYPE_8__ {TYPE_2__ document_root; TYPE_1__ callbacks; } ;\nstruct TYPE_9__ {TYPE_3__ config; int /*<<< orphan*/  sockpool; } ;\ntypedef  TYPE_4__ h2o_fastcgi_handler_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socketpool_dispose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  stub1 (TYPE_4__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_handler_dispose(h2o_handler_t *_handler)\n{\nh2o_fastcgi_handler_t *handler = (void *)_handler;\n\nif (handler->config.callbacks.dispose != NULL)\nhandler->config.callbacks.dispose(handler, handler->config.callbacks.data);\n\nh2o_socketpool_dispose(&handler->sockpool);\nfree(handler->config.document_root.base);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  handler; int /*<<< orphan*/  event_id; TYPE_1__* dispose; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  (* p ) (TYPE_2__*,int /*<<< orphan*/ ) ;} ;\ntypedef  TYPE_2__ on_handler ;\n\n/* Variables and functions */\nint /*<<< orphan*/  heap_free (TYPE_2__*) ;\nint /*<<< orphan*/  list_remove (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub1 (TYPE_2__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_handler_dispose(on_handler *handler)\n{\nif (handler->dispose)\nhandler->dispose->p(handler, handler->event_id);\n\nheap_free(handler);\nlist_remove(handler->handler);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerheaders.c_h2o_headers_register",
    "input":"\n0000000000000000 <h2o_headers_register>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %rbx\nb: \tmovl\t$16, %esi\n10: \tcallq\t0x15 <h2o_headers_register+0x15>\n15: \tmovl\t(%rip), %ecx  # 0x1b <h2o_headers_register+0x1b>\n1b: \tmovl\t%ecx, 12(%rax)\n1e: \tmovl\t(%rip), %ecx  # 0x24 <h2o_headers_register+0x24>\n24: \tmovl\t%ecx, 8(%rax)\n27: \tmovq\t%r14, (%rax)\n2a: \tmovq\t%rax, %rdi\n2d: \tcallq\t0x32 <h2o_headers_register+0x32>\n32: \ttestq\t%rax, %rax\n35: \tje\t0x71 <h2o_headers_register+0x71>\n37: \tmovq\t%rbx, %rdi\n3a: \tmovl\t$16, %esi\n3f: \tcallq\t0x44 <h2o_headers_register+0x44>\n44: \tmovq\t%rax, %r15\n47: \tmovq\t%r14, 8(%rax)\n4b: \tmovl\t(%rip), %eax  # 0x51 <h2o_headers_register+0x51>\n51: \tmovl\t%eax, (%r15)\n54: \tmovq\t8(%rbx), %rsi\n58: \tleaq\t8(%rsi), %rdi\n5c: \tmovl\t(%rbx), %eax\n5e: \tleal\t-8(,%rax,8), %edx\n65: \tcallq\t0x6a <h2o_headers_register+0x6a>\n6a: \tmovq\t8(%rbx), %rax\n6e: \tmovq\t%r15, (%rax)\n71: \tpopq\t%rbx\n72: \tpopq\t%r14\n74: \tpopq\t%r15\n76: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  on_informational; int /*<<< orphan*/  on_setup_ostream; } ;\nstruct st_headers_filter_t {int /*<<< orphan*/ * cmds; TYPE_1__ super; } ;\nstruct TYPE_12__ {int /*<<< orphan*/  on_req; } ;\nstruct st_headers_early_hints_handler_t {TYPE_4__ super; int /*<<< orphan*/ * cmds; } ;\nstruct TYPE_10__ {int size; TYPE_4__** entries; } ;\nstruct TYPE_11__ {TYPE_2__ handlers; } ;\ntypedef  TYPE_3__ h2o_pathconf_t ;\ntypedef  int /*<<< orphan*/  h2o_headers_command_t ;\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\n\n/* Variables and functions */\nscalar_t__ h2o_create_filter (TYPE_3__*,int) ;\nscalar_t__ h2o_create_handler (TYPE_3__*,int) ;\nint /*<<< orphan*/  memmove (TYPE_4__**,TYPE_4__**,int) ;\nint /*<<< orphan*/  on_informational ;\nint /*<<< orphan*/  on_req ;\nint /*<<< orphan*/  on_setup_ostream ;\nscalar_t__ requires_early_hints_handler (struct st_headers_filter_t*) ;\n\nvoid h2o_headers_register(h2o_pathconf_t *pathconf, h2o_headers_command_t *cmds)\n{\nstruct st_headers_filter_t *self = (void *)h2o_create_filter(pathconf, sizeof(*self));\n\nself->super.on_setup_ostream = on_setup_ostream;\nself->super.on_informational = on_informational;\nself->cmds = cmds;\n\nif (requires_early_hints_handler(self)) {\nstruct st_headers_early_hints_handler_t *handler = (void *)h2o_create_handler(pathconf, sizeof(*handler));\nhandler->cmds = cmds;\nhandler->super.on_req = on_req;\n\n/* move this handler to first */\nmemmove(pathconf->handlers.entries + 1, pathconf->handlers.entries,\nsizeof(h2o_handler_t *) * (pathconf->handlers.size - 1));\npathconf->handlers.entries[0] = &handler->super;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  (* on_header_value ) (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;} ;\nstruct TYPE_9__ {int /*<<< orphan*/  (* on_header_value ) (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;} ;\nstruct TYPE_8__ {int /*<<< orphan*/  (* on_header_value ) (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;} ;\ntypedef  TYPE_1__ h2o_headers_t ;\ntypedef  TYPE_2__ h2o_headers_callback_t ;\ntypedef  TYPE_3__ h2o_headers_callback_t__ ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_HEADERS_CALLBACK_FLAG_IS_REGISTERED ;\nint /*<<< orphan*/  H2O_HEADERS_CALLBACK_FLAG_IS_REGISTERED_AS_FINAL ;\nint /*<<< orphan*/  H2O_HEADERS_CALLBACK_FLAG_IS_REGISTERED_AS_INTERMEDIATE ;\nint /*<<< orphan*/  H2O_MEM_INITIALIZER ;\nTYPE_1__* h2o_mem_alloc_pool (int,int) ;\nTYPE_2__* h2o_mem_alloc_pool_link (TYPE_1__*,int) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void h2o_headers_register(h2o_headers_t *headers, h2o_headers_callback_t *callback)\n{\nh2o_headers_callback_t__ *cb = h2o_mem_alloc_pool(sizeof(*cb), 16);\nmemset(cb, 0, sizeof(*cb));\ncb->on_header_value = callback->on_header_value;\ncb->on_header_value.data = callback;\ncb->on_header_value.flags = H2O_HEADERS_CALLBACK_FLAG_IS_REGISTERED;\nheaders->on_header_value.data = cb;\nheaders->on_header_value.flags = H2O_HEADERS_CALLBACK_FLAG_IS_REGISTERED_AS_INTERMEDIATE;\nh2o_mem_alloc_pool_link(headers, sizeof(*headers) + 8 * headers->on_header_value.flags);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_on_link",
    "input":"\n0000000000000000 <on_link>:\n0: \tcmpl\t$129, (%rsi)\n6: \tjne\t0xb <on_link+0xb>\n8: \taddl\t$1, (%rdi)\nb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int type; } ;\ntypedef  TYPE_1__ h2o_mimemap_type_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  num_dynamic; } ;\ntypedef  TYPE_2__ h2o_mimemap_t ;\n\n/* Variables and functions */\n#define  H2O_MIMEMAP_TYPE_DYNAMIC 129\n#define  H2O_MIMEMAP_TYPE_MIMETYPE 128\n\n__attribute__((used)) static void on_link(h2o_mimemap_t *mimemap, h2o_mimemap_type_t *type)\n{\nswitch (type->type) {\ncase H2O_MIMEMAP_TYPE_MIMETYPE:\nbreak;\ncase H2O_MIMEMAP_TYPE_DYNAMIC:\n++mimemap->num_dynamic;\nbreak;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct connection {int /*<<< orphan*/  link_count; } ;\nstruct message {int type; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void on_link (struct connection *c, struct message *m) {\nif (m->type == 129) {\nc->link_count++;\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_set_default_type",
    "input":"\n0000000000000000 <set_default_type>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovq\t(%rdi), %rsi\nd: \tcallq\t0x12 <set_default_type+0x12>\n12: \tmovq\t(%rbx), %rdi\n15: \tcallq\t0x1a <set_default_type+0x1a>\n1a: \tmovq\t%r14, %rdi\n1d: \tcallq\t0x22 <set_default_type+0x22>\n22: \tmovq\t%r14, (%rbx)\n25: \tmovq\t%rbx, %rdi\n28: \tmovq\t%r14, %rsi\n2b: \tcallq\t0x30 <set_default_type+0x30>\n30: \tmovq\t%rbx, %rdi\n33: \taddq\t$8, %rsp\n37: \tpopq\t%rbx\n38: \tpopq\t%r14\n3a: \tjmp\t0x3f <set_default_type+0x3f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mimemap_type_t ;\nstruct TYPE_6__ {int /*<<< orphan*/ * default_type; } ;\ntypedef  TYPE_1__ h2o_mimemap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mem_addref_shared (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mem_release_shared (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  on_link (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  on_unlink (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  rebuild_typeset (TYPE_1__*) ;\n\nvoid set_default_type(h2o_mimemap_t *mimemap, h2o_mimemap_type_t *type)\n{\n/* unlink the old one */\non_unlink(mimemap, mimemap->default_type);\nh2o_mem_release_shared(mimemap->default_type);\n\n/* update */\nh2o_mem_addref_shared(type);\nmimemap->default_type = type;\non_link(mimemap, type);\nrebuild_typeset(mimemap);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * default_type; } ;\ntypedef  int /*<<< orphan*/  GType ;\ntypedef  TYPE_1__ GtkSettings ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_object_notify (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_type_name (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_type_name_from_instance (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_type_name_from_class (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_type_name_from_instance (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_type_name_from_class (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_type_name_from_instance (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\nset_default_type (GtkSettings *settings,\nGType         type)\n{\nconst char *old_type_name;\nconst char *new_type_name;\n\nold_type_name = g_type_name (settings->default_type);\nnew_type_name = g_type_name (type);\n\nsettings->default_type = type;\n\ng_object_notify (settings, \"gtk-default-theme-name\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-palette\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_notify (settings, \"gtk-default-icon-theme-name\");\ng_object_notify (settings, \"gtk-default-icon-theme-dirs\");\ng_object_notify (settings, \"gtk-default-font-name\");\ng_object_notify (settings, \"gtk-default-font-features\");\ng_object_notify (settings, \"gtk-default-font-variations\");\ng_object_notify (settings, \"gtk-default-monospace-font-name\");\ng_object_notify (settings, \"gtk-default-serif-font-name\");\ng_object_notify (settings, \"gtk-default-sans-font-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-name\");\ng_object_notify (settings, \"gtk-default-cursor-theme-size\");\ng_object_"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_sendvec_update_refcnt",
    "input":"\n0000000000000000 <sendvec_update_refcnt>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t(%rax), %rdi\n6: \ttestl\t%edx, %edx\n8: \tje\t0xf <sendvec_update_refcnt+0xf>\na: \tjmp\t0xf <sendvec_update_refcnt+0xf>\nf: \tjmp\t0x14 <sendvec_update_refcnt+0x14>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_h2o_sendfile_generator_t {int dummy; } ;\nstruct TYPE_3__ {scalar_t__* cb_arg; } ;\ntypedef  TYPE_1__ h2o_sendvec_t ;\ntypedef  int /*<<< orphan*/  h2o_req_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mem_addref_shared (struct st_h2o_sendfile_generator_t*) ;\nint /*<<< orphan*/  h2o_mem_release_shared (struct st_h2o_sendfile_generator_t*) ;\n\n__attribute__((used)) static void sendvec_update_refcnt(h2o_sendvec_t *vec, h2o_req_t *req, int is_incr)\n{\nstruct st_h2o_sendfile_generator_t *self = (void *)vec->cb_arg[0];\n\nif (is_incr) {\nh2o_mem_addref_shared(self);\n} else {\nh2o_mem_release_shared(self);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* priv_data; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  refcnt; } ;\ntypedef  TYPE_1__ SendvecContext ;\ntypedef  TYPE_2__ AVFormatContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  atomic_fetch_add (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  atomic_fetch_sub (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void sendvec_update_refcnt(AVFormatContext *s, int incr, int decr)\n{\nSendvecContext *ctx = s->priv_data;\n\nif (incr)\natomic_fetch_add(&ctx->refcnt, incr);\nelse\natomic_fetch_sub(&ctx->refcnt, decr);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_close_file",
    "input":"\n0000000000000000 <close_file>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t(%rdi), %rdi\n7: \ttestq\t%rdi, %rdi\na: \tje\t0x18 <close_file+0x18>\nc: \tcallq\t0x11 <close_file+0x11>\n11: \tmovq\t$0, (%rbx)\n18: \tpopq\t%rbx\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * ref; } ;\nstruct st_h2o_sendfile_generator_t {TYPE_1__ file; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_filecache_close_file (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void close_file(struct st_h2o_sendfile_generator_t *self)\n{\nif (self->file.ref != NULL) {\nh2o_filecache_close_file(self->file.ref);\nself->file.ref = NULL;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * fp; } ;\ntypedef  TYPE_1__ FILE_INFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void close_file(FILE_INFO *file)\n{\nif (file->fp)\n{\nfclose(file->fp);\nfile->fp = NULL;\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerheaders.c_requires_early_hints_handler",
    "input":"\n0000000000000000 <requires_early_hints_handler>:\n0: \tmovq\t(%rdi), %rcx\n3: \tmovq\t(%rcx), %rdi\n6: \tmovq\t(%rip), %rdx  # 0xd <requires_early_hints_handler+0xd>\nd: \txorl\t%eax, %eax\nf: \tcmpq\t%rdx, %rdi\n12: \tjne\t0x15 <requires_early_hints_handler+0x15>\n14: \tretq\n15: \tmovq\t(%rip), %rsi  # 0x1c <requires_early_hints_handler+0x1c>\n1c: \tmovq\t(%rip), %r8   # 0x23 <requires_early_hints_handler+0x23>\n23: \taddq\t$16, %rcx\n27: \tjmp\t0x3c <requires_early_hints_handler+0x3c>\n29: \tnopl\t(%rax)\n30: \tmovq\t(%rcx), %rdi\n33: \taddq\t$16, %rcx\n37: \tcmpq\t%rdx, %rdi\n3a: \tje\t0x14 <requires_early_hints_handler+0x14>\n3c: \tcmpq\t%rsi, %rdi\n3f: \tje\t0x30 <requires_early_hints_handler+0x30>\n41: \tcmpq\t%r8, -8(%rcx)\n45: \tje\t0x30 <requires_early_hints_handler+0x30>\n47: \tmovl\t$1, %eax\n4c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_headers_filter_t {TYPE_1__* cmds; } ;\nstruct TYPE_2__ {scalar_t__ cmd; scalar_t__ when; } ;\ntypedef  TYPE_1__ h2o_headers_command_t ;\n\n/* Variables and functions */\nscalar_t__ H2O_HEADERS_CMD_NULL ;\nscalar_t__ H2O_HEADERS_CMD_UNSET ;\nscalar_t__ H2O_HEADERS_CMD_WHEN_FINAL ;\n\n__attribute__((used)) static int requires_early_hints_handler(struct st_headers_filter_t *self)\n{\nh2o_headers_command_t *cmd;\nfor (cmd = self->cmds; cmd->cmd != H2O_HEADERS_CMD_NULL; ++cmd) {\nif (cmd->cmd != H2O_HEADERS_CMD_UNSET && cmd->when != H2O_HEADERS_CMD_WHEN_FINAL)\nreturn 1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ type; scalar_t__ status; } ;\ntypedef  TYPE_1__ GLogItem ;\n\n/* Variables and functions */\nscalar_t__ GLOG_TYPE_HEADER ;\nscalar_t__ GLOG_TYPE_RESPONSE ;\nscalar_t__ GLOG_TYPE_STATUS ;\nscalar_t__ GLOG_STATUS_EARLY_HINTS ;\n\n__attribute__((used)) static int requires_early_hints_handler(GLogItem *item) {\nif (item->type != GLOG_TYPE_RESPONSE) {\nreturn 0;\n}\n\nwhile (item->type == GLOG_TYPE_RESPONSE) {\nif (item->status == GLOG_STATUS_EARLY_HINTS) {\nreturn 1;\n}\n\nitem++;\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_fastcgi.c_test_lib__handler__fastcgi_c",
    "input":"\n0000000000000000 <test_lib__handler__fastcgi_c>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tleaq\t8(%rsp), %rbx\na: \tmovq\t%rbx, %rdi\nd: \tcallq\t0x12 <test_lib__handler__fastcgi_c+0x12>\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <test_lib__handler__fastcgi_c+0x1c>\n1c: \tmovl\t%eax, %edi\n1e: \tcallq\t0x23 <test_lib__handler__fastcgi_c+0x23>\n23: \tmovl\t%eax, 8(%rsp)\n27: \tmovl\t$0, %edi\n2c: \tcallq\t0x31 <test_lib__handler__fastcgi_c+0x31>\n31: \tmovl\t%eax, %edi\n33: \tcallq\t0x38 <test_lib__handler__fastcgi_c+0x38>\n38: \tmovq\t%rbx, %rdi\n3b: \tmovl\t%eax, %esi\n3d: \tmovl\t$65535, %edx  # imm = 0xFFFF\n42: \tcallq\t0x47 <test_lib__handler__fastcgi_c+0x47>\n47: \tmovl\t$0, %esi\n4c: \tmovq\t%rax, %rdi\n4f: \txorl\t%edx, %edx\n51: \tcallq\t0x56 <test_lib__handler__fastcgi_c+0x56>\n56: \tmovl\t(%rip), %esi  # 0x5c <test_lib__handler__fastcgi_c+0x5c>\n5c: \tmovl\t$0, %edi\n61: \tmovq\t%rbx, %rdx\n64: \tcallq\t0x69 <test_lib__handler__fastcgi_c+0x69>\n69: \tmovl\t(%rip), %esi  # 0x6f <test_lib__handler__fastcgi_c+0x6f>\n6f: \tmovl\t$0, %edi\n74: \tcallq\t0x79 <test_lib__handler__fastcgi_c+0x79>\n79: \tmovl\t$0, %edi\n7e: \tcallq\t0x83 <test_lib__handler__fastcgi_c+0x83>\n83: \tmovq\t%rbx, %rdi\n86: \tcallq\t0x8b <test_lib__handler__fastcgi_c+0x8b>\n8b: \taddq\t$16, %rsp\n8f: \tpopq\t%rbx\n90: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_pathconf_t ;\ntypedef  int /*<<< orphan*/  h2o_hostconf_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  server_name; } ;\ntypedef  TYPE_1__ h2o_globalconf_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  ctx ;\nint /*<<< orphan*/  h2o_config_dispose (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_config_init (TYPE_1__*) ;\nint /*<<< orphan*/ * h2o_config_register_host (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/ * h2o_config_register_path (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_context_dispose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_context_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  h2o_iovec_init (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_build_request ;\nint /*<<< orphan*/  test_loop ;\n\nvoid test_lib__handler__fastcgi_c()\n{\nh2o_globalconf_t globalconf;\nh2o_hostconf_t *hostconf;\nh2o_pathconf_t *pathconf;\n\nh2o_config_init(&globalconf);\nglobalconf.server_name = h2o_iovec_init(H2O_STRLIT(\"h2o/1.2.1-alpha1\"));\nhostconf = h2o_config_register_host(&globalconf, h2o_iovec_init(H2O_STRLIT(\"default\")), 65535);\npathconf = h2o_config_register_path(hostconf, \"/\", 0);\n\nh2o_context_init(&ctx, test_loop, &globalconf);\n\nsubtest(\"build-request\", test_build_request);\n\nh2o_context_dispose(&ctx);\nh2o_config_dispose(&globalconf);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fcgi_request ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FCGX_Accept_r (int /*<<< orphan*/ **) ;\nint /*<<< orphan*/  FCGX_Finish_r (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  FCGX_InitRequest (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  FCGX_PutStr (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  FCGX_PutS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  FCGX_StdIn ;\nint /*<<< orphan*/  FCGX_StdOut ;\nint /*<<< orphan*/  fcgi_init () ;\nint /*<<< orphan*/  fcgi_init_request (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fcgi_request_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fcgi_request_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  fcgi_request_set_keep_conn (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fcgi_request_set_max_conns (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_max_reqs (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_role (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fcgi_request_set_streams (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fcgi_request_set_timeout (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_type (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fcgi_request_set_xid (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_init (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_init_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_init_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_init_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_step (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_step_inc (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_step_max (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_xid_step_size_step_size_step_size_step_min (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  fcgi_request_set_"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfastcgi.c_on_connect",
    "input":"\n0000000000000000 <on_connect>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdx, %rbx\n7: \tmovq\t$0, 24(%rdx)\nf: \ttestq\t%rdi, %rdi\n12: \tje\t0x6f <on_connect+0x6f>\n14: \tmovq\t%rdi, %r14\n17: \tmovq\t%rdi, 8(%rbx)\n1b: \tmovq\t%rbx, (%rdi)\n1e: \tmovl\t16(%rbx), %edi\n21: \tmovq\t(%rbx), %r8\n24: \tmovq\t%rsp, %rsi\n27: \tmovl\t$1, %edx\n2c: \tmovl\t$65535, %ecx  # imm = 0xFFFF\n31: \tcallq\t0x36 <on_connect+0x36>\n36: \tmovq\t8(%rbx), %rdi\n3a: \tmovl\t(%rsp), %edx\n3d: \tmovl\t4(%rsp), %esi\n41: \tmovl\t(%rip), %ecx  # 0x47 <on_connect+0x47>\n47: \tcallq\t0x4c <on_connect+0x4c>\n4c: \tmovq\t(%rbx), %rax\n4f: \tmovl\t(%rax), %esi\n51: \tmovl\t(%rip), %edx  # 0x57 <on_connect+0x57>\n57: \tmovq\t%rbx, %rdi\n5a: \tcallq\t0x5f <on_connect+0x5f>\n5f: \tmovl\t(%rip), %esi  # 0x65 <on_connect+0x65>\n65: \tmovq\t%r14, %rdi\n68: \tcallq\t0x6d <on_connect+0x6d>\n6d: \tjmp\t0x8d <on_connect+0x8d>\n6f: \tmovq\t%rsi, %rcx\n72: \tmovl\t16(%rbx), %edi\n75: \tmovl\t(%rip), %esi  # 0x7b <on_connect+0x7b>\n7b: \tmovl\t$0, %edx\n80: \tcallq\t0x85 <on_connect+0x85>\n85: \tmovq\t%rbx, %rdi\n88: \tcallq\t0x8d <on_connect+0x8d>\n8d: \taddq\t$8, %rsp\n91: \tpopq\t%rbx\n92: \tpopq\t%r14\n94: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_8__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_fcgi_generator_t {TYPE_1__* handler; TYPE_3__* sock; int /*<<< orphan*/  req; int /*<<< orphan*/ * connect_req; } ;\nstruct TYPE_10__ {int /*<<< orphan*/  size; int /*<<< orphan*/  entries; } ;\ntypedef  TYPE_2__ iovec_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_url_t ;\nstruct TYPE_11__ {struct st_fcgi_generator_t* data; } ;\ntypedef  TYPE_3__ h2o_socket_t ;\nstruct TYPE_12__ {int /*<<< orphan*/  io_timeout; } ;\nstruct TYPE_9__ {TYPE_8__ config; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MODULE_NAME ;\nint /*<<< orphan*/  build_request (int /*<<< orphan*/ ,TYPE_2__*,int,int,TYPE_8__*) ;\nint /*<<< orphan*/  errorclose (struct st_fcgi_generator_t*) ;\nint /*<<< orphan*/  h2o_req_log_error (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,char const*) ;\nint /*<<< orphan*/  h2o_socket_read_start (TYPE_3__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write (TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  on_read ;\nint /*<<< orphan*/  on_rw_timeout ;\nint /*<<< orphan*/  on_send_complete ;\nint /*<<< orphan*/  set_timeout (struct st_fcgi_generator_t*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_connect(h2o_socket_t *sock, const char *errstr, void *data, h2o_url_t *_dummy)\n{\nstruct st_fcgi_generator_t *generator = data;\niovec_vector_t vecs;\n\ngenerator->connect_req = NULL;\n\nif (sock == NULL) {\nh2o_req_log_error(generator->req, MODULE_NAME, \"connection failed:%s\", errstr);\nerrorclose(generator);\nreturn;\n}\n\ngenerator->sock = sock;\nsock->data = generator;\n\nbuild_request(generator->req, &vecs, 1, 65535, &generator->handler->config);\n\n/* start sending the response */\nh2o_socket_write(generator->sock, vecs.entries, vecs.size, on_send_complete);\n\nset_timeout(generator, generator->handler->config.io_timeout, on_rw_timeout);\n\n/* activate the receiver; note: FCGI spec allows the app to start sending the response before it receives FCGI_STDIN */\nh2o_socket_read_start(sock, on_read);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  fd; } ;\nstruct TYPE_9__ {TYPE_3__* priv_data; TYPE_3__* parent; int /*<<< orphan*/  buf; int /*<<< orphan*/  buf_size; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ URLContext ;\ntypedef  TYPE_2__ hb_tcp_connection_t ;\ntypedef  TYPE_3__ hb_tcp_connection_private_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AV_LOG_ERROR ;\nint /*<<< orphan*/  AV_LOG_INFO ;\nint /*<<< orphan*/  HB_TCP_CONNECTION_STATE_CONNECTED ;\nint /*<<< orphan*/  HB_TCP_CONNECTION_STATE_DISCONNECTED ;\nint /*<<< orphan*/  HB_TCP_CONNECTION_STATE_ERROR ;\nint /*<<< orphan*/  HB_TCP_CONNECTION_STATE_READY ;\nint /*<<< orphan*/  HB_TCP_CONNECTION_STATE_WAITING ;\nint /*<<< orphan*/  hb_tcp_connection_set_state (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_error (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_ready (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_connection (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_data (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_data (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_data (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_data_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_data (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_data_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_data_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end (TYPE_2__*) ;\nint /*<<< orphan*/  hb_tcp_connection_set_state_waiting_for_response_header_end_end_end_end_end"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_h2o_file_send",
    "input":"\n0000000000000000 <h2o_file_send>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$24, %rsp\ne: \tmovl\t%r9d, %r13d\n11: \tmovl\t%r8d, %r14d\n14: \tmovq\t%rcx, %rbp\n17: \tmovq\t%rdx, %r15\n1a: \tmovl\t%esi, %r12d\n1d: \tmovq\t%rdi, %rbx\n20: \tmovq\t%rcx, %rdi\n23: \tcallq\t0x28 <h2o_file_send+0x28>\n28: \tleaq\t20(%rsp), %rcx\n2d: \tmovq\t%rbx, %rdi\n30: \tmovq\t%rbp, %rsi\n33: \tmovl\t%eax, %edx\n35: \tmovl\t%r13d, %r8d\n38: \tcallq\t0x3d <h2o_file_send+0x3d>\n3d: \ttestq\t%rax, %rax\n40: \tje\t0x64 <h2o_file_send+0x64>\n42: \tmovl\t$1, (%rsp)\n49: \txorl\t%ebp, %ebp\n4b: \tmovq\t%rax, %rdi\n4e: \tmovq\t%rbx, %rsi\n51: \tmovl\t%r12d, %edx\n54: \tmovq\t%r15, %rcx\n57: \tmovl\t%r14d, %r8d\n5a: \txorl\t%r9d, %r9d\n5d: \tcallq\t0x62 <h2o_file_send+0x62>\n62: \tjmp\t0x69 <h2o_file_send+0x69>\n64: \tmovl\t$4294967295, %ebp  # imm = 0xFFFFFFFF\n69: \tmovl\t%ebp, %eax\n6b: \taddq\t$24, %rsp\n6f: \tpopq\t%rbx\n70: \tpopq\t%r12\n72: \tpopq\t%r13\n74: \tpopq\t%r14\n76: \tpopq\t%r15\n78: \tpopq\t%rbp\n79: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_sendfile_generator_t {int dummy; } ;\ntypedef  int /*<<< orphan*/  h2o_req_t ;\ntypedef  int /*<<< orphan*/  h2o_iovec_t ;\n\n/* Variables and functions */\nstruct st_h2o_sendfile_generator_t* create_generator (int /*<<< orphan*/ *,char const*,int /*<<< orphan*/ ,int*,int) ;\nint /*<<< orphan*/  do_send_file (struct st_h2o_sendfile_generator_t*,int /*<<< orphan*/ *,int,char const*,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  strlen (char const*) ;\n\nint h2o_file_send(h2o_req_t *req, int status, const char *reason, const char *path, h2o_iovec_t mime_type, int flags)\n{\nstruct st_h2o_sendfile_generator_t *self;\nint is_dir;\n\nif ((self = create_generator(req, path, strlen(path), &is_dir, flags)) == NULL)\nreturn -1;\n/* note: is_dir is not handled */\ndo_send_file(self, req, status, reason, mime_type, NULL, 1);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_file_send_args_t ;\ntypedef  int /*<<< orphan*/  h2o_file_context_t ;\ntypedef  int /*<<< orphan*/  h2o_file_handle_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_send_file_callback ;\ntypedef  int /*<<< orphan*/  h2o_send_file_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_file_send_file (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * h2o_file_open (int /*<<< orphan*/ *,char const*,int,int*) ;\n\n__attribute__((used)) static int h2o_file_send(h2o_file_context_t *ctx, h2o_socket_t *sock, h2o_file_handle_t *file, h2o_send_file_cb cb,\nh2o_file_send_args_t *args, int flags)\n{\nint err;\nh2o_file_handle_t *f;\n\nf = h2o_file_open(ctx, args->path, flags, &err);\nif (f == NULL)\nreturn -1;\nh2o_file_send_file(sock, f, args->offset, args->length, flags, cb, NULL);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_compress.c_test_lib__handler__gzip_c",
    "input":"\n0000000000000000 <test_lib__handler__gzip_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__handler__gzip_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__handler__gzip_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__handler__gzip_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tpopq\t%rax\n1d: \tjmp\t0x22 <test_lib__handler__gzip_c+0x22>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_gzip_multi ;\nint /*<<< orphan*/  test_gzip_simple ;\n\nvoid test_lib__handler__gzip_c()\n{\nsubtest(\"gzip_simple\", test_gzip_simple);\nsubtest(\"gzip_multi\", test_gzip_multi);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_HANDLER (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_FAILURE_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_FAILURE_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_FAILURE_EX_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_FAILURE_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_FAILURE_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_FAILURE_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_FAILURE_EX_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_FAILURE_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_FAILURE_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_FAILURE_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_FAILURE_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE_EX_FAILURE (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_FAILURE_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SUCCESS_EX (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_HANDLER_EXPECT_SUCCESS_SUCCESS_SUCCESS_SUCCESS_SU"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_h2o_mimemap_get_type_by_extension",
    "input":"\n0000000000000000 <h2o_mimemap_get_type_by_extension>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tsubq\t$264, %rsp    # imm = 0x108\ne: \tmovq\t%rsi, %rbx\n11: \tmovq\t%rdi, %r14\n14: \ttestl\t%ebx, %ebx\n16: \tjle\t0x6a <h2o_mimemap_get_type_by_extension+0x6a>\n18: \tmovslq\t%ebx, %r12\n1b: \tcmpq\t$255, %r12\n22: \tja\t0x6a <h2o_mimemap_get_type_by_extension+0x6a>\n24: \tmovq\t%rbx, %rsi\n27: \tshrq\t$32, %rsi\n2b: \tmovq\t%rsp, %r15\n2e: \tmovq\t%r15, %rdi\n31: \tmovl\t%ebx, %edx\n33: \tcallq\t0x38 <h2o_mimemap_get_type_by_extension+0x38>\n38: \tmovq\t%r15, %rdi\n3b: \tmovl\t%ebx, %esi\n3d: \tcallq\t0x42 <h2o_mimemap_get_type_by_extension+0x42>\n42: \tmovb\t$0, (%rsp,%r12)\n47: \tmovl\t(%rip), %edi  # 0x4d <h2o_mimemap_get_type_by_extension+0x4d>\n4d: \tmovl\t8(%r14), %esi\n51: \tmovq\t%r15, %rdx\n54: \tcallq\t0x59 <h2o_mimemap_get_type_by_extension+0x59>\n59: \tmovq\t%rax, %rbx\n5c: \tmovl\t8(%r14), %edi\n60: \tcallq\t0x65 <h2o_mimemap_get_type_by_extension+0x65>\n65: \tcmpq\t%rax, %rbx\n68: \tjne\t0x7c <h2o_mimemap_get_type_by_extension+0x7c>\n6a: \tmovq\t(%r14), %rax\n6d: \taddq\t$264, %rsp    # imm = 0x108\n74: \tpopq\t%rbx\n75: \tpopq\t%r12\n77: \tpopq\t%r14\n79: \tpopq\t%r15\n7b: \tretq\n7c: \tmovl\t8(%r14), %edi\n80: \tmovq\t%rbx, %rsi\n83: \tcallq\t0x88 <h2o_mimemap_get_type_by_extension+0x88>\n88: \tjmp\t0x6d <h2o_mimemap_get_type_by_extension+0x6d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lcbuf ;\ntypedef  scalar_t__ khiter_t ;\ntypedef  int /*<<< orphan*/  h2o_mimemap_type_t ;\nstruct TYPE_5__ {int /*<<< orphan*/ * default_type; int /*<<< orphan*/  extmap; } ;\ntypedef  TYPE_1__ h2o_mimemap_t ;\nstruct TYPE_6__ {int len; int /*<<< orphan*/  base; } ;\ntypedef  TYPE_2__ h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  extmap ;\nint /*<<< orphan*/  h2o_strtolower (char*,int) ;\nscalar_t__ kh_end (int /*<<< orphan*/ ) ;\nscalar_t__ kh_get (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/ * kh_val (int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  memcpy (char*,int /*<<< orphan*/ ,int) ;\n\nh2o_mimemap_type_t *h2o_mimemap_get_type_by_extension(h2o_mimemap_t *mimemap, h2o_iovec_t ext)\n{\nchar lcbuf[256];\n\nif (0 < ext.len && ext.len < sizeof(lcbuf)) {\nmemcpy(lcbuf, ext.base, ext.len);\nh2o_strtolower(lcbuf, ext.len);\nlcbuf[ext.len] = '\\0';\nkhiter_t iter = kh_get(extmap, mimemap->extmap, lcbuf);\nif (iter != kh_end(mimemap->extmap))\nreturn kh_val(mimemap->extmap, iter);\n}\nreturn mimemap->default_type;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {char* exts; int /*<<< orphan*/  exts_by_type; } ;\ntypedef  TYPE_1__ h2o_mimemap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_MIME_MAP_EXT_TO_TYPE_MAP ;\nint /*<<< orphan*/  h2o_mem_addref_shared (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_init_pool (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_release_shared (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_set_secure (char*,int,int) ;\nint /*<<< orphan*/  h2o_mimemap_get_type_by_ext (int /*<<< orphan*/ ,char*,char*) ;\n\nh2o_mimemap_t *h2o_mimemap_get_type_by_extension(h2o_mimemap_t *mimemap, const char *ext, size_t ext_len)\n{\nif (ext_len == 0 || ext_len > 255)\nreturn mimemap;\nh2o_mem_init_pool(H2O_MIME_MAP_EXT_TO_TYPE_MAP, mimemap->exts_by_type);\nh2o_mem_set_secure(ext, ext_len, 0);\nh2o_mimemap_t *ret = h2o_mimemap_get_type_by_ext(mimemap->exts_by_type, ext, ext);\nh2o_mem_release_shared(mimemap->exts_by_type, H2O_MIME_MAP_EXT_TO_TYPE_MAP);\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_h2o_mimemap_remove_type",
    "input":"\n0000000000000000 <h2o_mimemap_remove_type>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rsi, %rdx\nb: \tmovq\t%rdi, %rbx\ne: \tmovl\t(%rip), %edi  # 0x14 <h2o_mimemap_remove_type+0x14>\n14: \tmovl\t(%rbx), %esi\n16: \tcallq\t0x1b <h2o_mimemap_remove_type+0x1b>\n1b: \tmovq\t%rax, %r14\n1e: \tmovl\t(%rbx), %edi\n20: \tcallq\t0x25 <h2o_mimemap_remove_type+0x25>\n25: \tcmpq\t%rax, %r14\n28: \tjne\t0x36 <h2o_mimemap_remove_type+0x36>\n2a: \taddq\t$8, %rsp\n2e: \tpopq\t%rbx\n2f: \tpopq\t%r12\n31: \tpopq\t%r14\n33: \tpopq\t%r15\n35: \tretq\n36: \tmovl\t(%rbx), %edi\n38: \tmovq\t%r14, %rsi\n3b: \tcallq\t0x40 <h2o_mimemap_remove_type+0x40>\n40: \tmovq\t%rax, %r15\n43: \tmovl\t(%rbx), %edi\n45: \tmovq\t%r14, %rsi\n48: \tcallq\t0x4d <h2o_mimemap_remove_type+0x4d>\n4d: \tmovq\t%rax, %r12\n50: \tmovq\t%rbx, %rdi\n53: \tmovq\t%rax, %rsi\n56: \tcallq\t0x5b <h2o_mimemap_remove_type+0x5b>\n5b: \tmovq\t%r12, %rdi\n5e: \tcallq\t0x63 <h2o_mimemap_remove_type+0x63>\n63: \tmovl\t(%rip), %edi  # 0x69 <h2o_mimemap_remove_type+0x69>\n69: \tmovl\t(%rbx), %esi\n6b: \tmovq\t%r14, %rdx\n6e: \tcallq\t0x73 <h2o_mimemap_remove_type+0x73>\n73: \tmovq\t%r15, %rdi\n76: \tcallq\t0x7b <h2o_mimemap_remove_type+0x7b>\n7b: \tmovq\t%rbx, %rdi\n7e: \taddq\t$8, %rsp\n82: \tpopq\t%rbx\n83: \tpopq\t%r12\n85: \tpopq\t%r14\n87: \tpopq\t%r15\n89: \tjmp\t0x8e <h2o_mimemap_remove_type+0x8e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ khiter_t ;\ntypedef  char h2o_mimemap_type_t ;\nstruct TYPE_5__ {int /*<<< orphan*/  extmap; } ;\ntypedef  TYPE_1__ h2o_mimemap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  extmap ;\nint /*<<< orphan*/  h2o_mem_release_shared (char*) ;\nint /*<<< orphan*/  kh_del (int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__) ;\nscalar_t__ kh_end (int /*<<< orphan*/ ) ;\nscalar_t__ kh_get (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char const*) ;\nchar* kh_key (int /*<<< orphan*/ ,scalar_t__) ;\nchar* kh_val (int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  on_unlink (TYPE_1__*,char*) ;\nint /*<<< orphan*/  rebuild_typeset (TYPE_1__*) ;\n\nvoid h2o_mimemap_remove_type(h2o_mimemap_t *mimemap, const char *ext)\n{\nkhiter_t iter = kh_get(extmap, mimemap->extmap, ext);\nif (iter != kh_end(mimemap->extmap)) {\nconst char *key = kh_key(mimemap->extmap, iter);\nh2o_mimemap_type_t *type = kh_val(mimemap->extmap, iter);\non_unlink(mimemap, type);\nh2o_mem_release_shared(type);\nkh_del(extmap, mimemap->extmap, iter);\nh2o_mem_release_shared((char *)key);\nrebuild_typeset(mimemap);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  types; } ;\ntypedef  TYPE_1__ h2o_mimemap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_MIMEMAP_ENTRY_TYPE_NAME_LEN ;\nint /*<<< orphan*/  H2O_MIMEMAP_ENTRY_TYPE_NAME_OFFSET ;\nint /*<<< orphan*/  h2o_mimemap_remove_type_from_list (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mimemap_remove_type_from_list_by_name (TYPE_1__*,int /*<<< orphan*/ ,char const*) ;\nint /*<<< orphan*/  h2o_mimemap_update_hash (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_mem_add_ref_shared (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_release_shared (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_strdup (int /*<<< orphan*/ ,char const*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_strdup_shared (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_strdup_shared_for_cstr (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid h2o_mimemap_remove_type(h2o_mimemap_t *map, const char *type)\n{\nh2o_mem_add_ref_shared(map->types, h2o_mem_strdup_shared_for_cstr(map->types, type));\nh2o_mimemap_remove_type_from_list_by_name(map, map->types, type);\nh2o_mimemap_update_hash(map);\nh2o_mem_release_shared(h2o_mem_strdup(map->types, type, H2O_MIMEMAP_ENTRY_TYPE_NAME_LEN));\nh2o_mimemap_remove_type_from_list(map, map->types);\nh2o_mimemap_update_hash(map);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_specific_handler_on_req",
    "input":"\n0000000000000000 <specific_handler_on_req>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rsi, %rbx\n6: \tmovq\t%rdi, %rbp\n9: \tmovl\t4(%rdi), %edx\nc: \tmovl\t8(%rdi), %esi\nf: \tmovl\t12(%rdi), %r8d\n13: \tleaq\t4(%rsp), %rcx\n18: \tmovq\t%rbx, %rdi\n1b: \tcallq\t0x20 <specific_handler_on_req+0x20>\n20: \ttestq\t%rax, %rax\n23: \tje\t0x41 <specific_handler_on_req+0x41>\n25: \tmovl\t(%rbx), %edx\n27: \tmovl\t8(%rbp), %ecx\n2a: \tmovl\t(%rbp), %r9d\n2e: \tmovl\t4(%rbp), %r8d\n32: \tmovq\t%rax, %rdi\n35: \tmovq\t%rbx, %rsi\n38: \tcallq\t0x3d <specific_handler_on_req+0x3d>\n3d: \tmovl\t%eax, %ebp\n3f: \tjmp\t0x5e <specific_handler_on_req+0x5e>\n41: \tcmpl\t$0, 4(%rsp)\n46: \tje\t0x67 <specific_handler_on_req+0x67>\n48: \txorl\t%ebp, %ebp\n4a: \tmovl\t$0, %esi\n4f: \tmovl\t$0, %edx\n54: \tmovq\t%rbx, %rdi\n57: \txorl\t%ecx, %ecx\n59: \tcallq\t0x5e <specific_handler_on_req+0x5e>\n5e: \tmovl\t%ebp, %eax\n60: \taddq\t$8, %rsp\n64: \tpopq\t%rbx\n65: \tpopq\t%rbp\n66: \tretq\n67: \tmovq\t(%rip), %rax  # 0x6e <specific_handler_on_req+0x6e>\n6e: \tmovl\t$4294967295, %ebp  # imm = 0xFFFFFFFF\n73: \tcmpq\t(%rip), %rax  # 0x7a <specific_handler_on_req+0x7a>\n7a: \tje\t0x5e <specific_handler_on_req+0x5e>\n7c: \tcmpq\t(%rip), %rax  # 0x83 <specific_handler_on_req+0x83>\n83: \tje\t0x8e <specific_handler_on_req+0x8e>\n85: \tcmpq\t(%rip), %rax  # 0x8c <specific_handler_on_req+0x8c>\n8c: \tjne\t0x48 <specific_handler_on_req+0x48>\n8e: \txorl\t%ebp, %ebp\n90: \tmovl\t$0, %esi\n95: \tmovl\t$0, %edx\n9a: \tmovq\t%rbx, %rdi\n9d: \txorl\t%ecx, %ecx\n9f: \tcallq\t0xa4 <specific_handler_on_req+0xa4>\na4: \tjmp\t0x5e <specific_handler_on_req+0x5e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  len; int /*<<< orphan*/  base; } ;\nstruct st_h2o_specific_file_handler_t {int /*<<< orphan*/  mime_type; TYPE_1__ real_path; int /*<<< orphan*/  flags; } ;\nstruct st_h2o_sendfile_generator_t {int dummy; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  path_normalized; } ;\ntypedef  TYPE_2__ h2o_req_t ;\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\n\n/* Variables and functions */\nscalar_t__ EMFILE ;\nscalar_t__ ENFILE ;\nscalar_t__ ENOENT ;\nstruct st_h2o_sendfile_generator_t* create_generator (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ ) ;\nscalar_t__ errno ;\nint /*<<< orphan*/  h2o_send_error_403 (TYPE_2__*,char*,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_send_error_503 (TYPE_2__*,char*,char*,int /*<<< orphan*/ ) ;\nint serve_with_generator (struct st_h2o_sendfile_generator_t*,TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int specific_handler_on_req(h2o_handler_t *_self, h2o_req_t *req)\n{\nstruct st_h2o_specific_file_handler_t *self = (void *)_self;\nstruct st_h2o_sendfile_generator_t *generator;\nint is_dir;\n\n/* open file (or send error or return -1) */\nif ((generator = create_generator(req, self->real_path.base, self->real_path.len, &is_dir, self->flags)) == NULL) {\nif (is_dir) {\nh2o_send_error_403(req, \"Access Forbidden\", \"access forbidden\", 0);\n} else if (errno == ENOENT) {\nreturn -1;\n} else if (errno == ENFILE || errno == EMFILE) {\nh2o_send_error_503(req, \"Service Unavailable\", \"please try again later\", 0);\n} else {\nh2o_send_error_403(req, \"Access Forbidden\", \"access forbidden\", 0);\n}\nreturn 0;\n}\n\nreturn serve_with_generator(generator, req, req->path_normalized, self->real_path.base, self->real_path.len, self->mime_type);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  port; int /*<<< orphan*/  host; int /*<<< orphan*/  protocol; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ GLogHandler ;\ntypedef  int /*<<< orphan*/  GLogMessage ;\ntypedef  int /*<<< orphan*/  GLogLevelFlags ;\ntypedef  int /*<<< orphan*/  GLogLevel ;\ntypedef  int /*<<< orphan*/  GLogDomain ;\ntypedef  int /*<<< orphan*/  GLogContext ;\n\n/* Variables and functions */\nscalar_t__ G_LOG_LEVEL_ERROR ;\nscalar_t__ G_LOG_LEVEL_WARNING ;\nscalar_t__ G_LOG_LEVEL_WARNING_ENABLED ;\nscalar_t__ G_LOG_LEVEL_WARNING_ONCE ;\nscalar_t__ G_LOG_LEVEL_WARNING_PENDING ;\nint /*<<< orphan*/  g_log_default_handler (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_log_message_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * g_log_message_new (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_log_message_set_prefix (int /*<<< orphan*/ *,char*,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nspecific_handler_on_req(GLogContext *context, GLogDomain *domain,\nGLogLevelFlags level_flags, GLogLevel level,\nconst char *message, gpointer unused_data)\n{\nGLogHandler *handler = (GLogHandler *)context;\nGLogMessage *msg;\n\nmsg = g_log_message_new(domain, handler->type, handler->protocol,\nhandler->host, handler->port, level, level_flags);\nif (msg == NULL)\nreturn 0;\n\ng_log_message_set_prefix(msg, \"glib-specific\", \"glib-specific\",\n0, 0);\n\ng_log_default_handler(msg, domain, level, level_flags, message,\n0, 0);\n\ng_log_message_free(msg);\n\nif (level_flags & G_LOG_LEVEL_WARNING) {\nif (level == G_LOG_LEVEL_WARNING_ENABLED ||\nlevel == G_LOG_LEVEL_WARNING_ONCE ||\nlevel == G_LOG_LEVEL_WARNING_PENDING) {\nreturn 0;\n}\n}\n\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerheaders.c_on_sender_dispose",
    "input":"\n0000000000000000 <on_sender_dispose>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <on_sender_dispose+0x9>\n9: \ttestq\t%rax, %rax\nc: \tje\t0x17 <on_sender_dispose+0x17>\ne: \tmovq\t%rbx, %rdi\n11: \tpopq\t%rbx\n12: \tjmp\t0x17 <on_sender_dispose+0x17>\n17: \tpopq\t%rbx\n18: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_headers_early_hints_sender_t {int /*<<< orphan*/  deferred_timeout_entry; } ;\n\n/* Variables and functions */\nscalar_t__ h2o_timer_is_linked (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timer_unlink (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_sender_dispose(void *_sender)\n{\nstruct st_headers_early_hints_sender_t *sender = (struct st_headers_early_hints_sender_t *)_sender;\nif (h2o_timer_is_linked(&sender->deferred_timeout_entry))\nh2o_timer_unlink(&sender->deferred_timeout_entry);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_drop_colorspace (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fz_keep_colorspace (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_sender_dispose(fz_context *ctx, void *arg)\n{\nfz_colorspace *cs = (fz_colorspace *)arg;\nif (fz_keep_colorspace(ctx, cs))\nfz_drop_colorspace(ctx, cs);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_create_dynamic_type",
    "input":"\n0000000000000000 <create_dynamic_type>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %r15\nb: \tmovq\t(%rip), %rdx  # 0x12 <create_dynamic_type+0x12>\n12: \txorl\t%edi, %edi\n14: \tmovl\t$8, %esi\n19: \tcallq\t0x1e <create_dynamic_type+0x1e>\n1e: \tmovq\t%rax, %rbx\n21: \tmovl\t(%rip), %eax  # 0x27 <create_dynamic_type+0x27>\n27: \tmovl\t%eax, 4(%rbx)\n2a: \tmovq\t%rbx, %rdi\n2d: \txorl\t%esi, %esi\n2f: \tmovl\t$4, %edx\n34: \tcallq\t0x39 <create_dynamic_type+0x39>\n39: \tmovq\t%rbx, %rdi\n3c: \tmovq\t%r15, %rsi\n3f: \txorl\t%edx, %edx\n41: \tmovq\t%r14, %rcx\n44: \tcallq\t0x49 <create_dynamic_type+0x49>\n49: \tmovq\t%rbx, %rax\n4c: \tpopq\t%rbx\n4d: \tpopq\t%r14\n4f: \tpopq\t%r15\n51: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  pathconf; } ;\nstruct TYPE_6__ {TYPE_3__ dynamic; } ;\nstruct TYPE_7__ {TYPE_1__ data; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_2__ h2o_mimemap_type_t ;\ntypedef  int /*<<< orphan*/  h2o_mimemap_t ;\ntypedef  int /*<<< orphan*/  h2o_globalconf_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_MIMEMAP_TYPE_DYNAMIC ;\nscalar_t__ dispose_dynamic_type ;\nint /*<<< orphan*/  h2o_config_init_pathconf (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nTYPE_2__* h2o_mem_alloc_shared (int /*<<< orphan*/ *,int,void (*) (void*)) ;\nint /*<<< orphan*/  memset (TYPE_3__*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static h2o_mimemap_type_t *create_dynamic_type(h2o_globalconf_t *globalconf, h2o_mimemap_t *mimemap)\n{\nh2o_mimemap_type_t *type = h2o_mem_alloc_shared(NULL, sizeof(*type), (void (*)(void *))dispose_dynamic_type);\n\ntype->type = H2O_MIMEMAP_TYPE_DYNAMIC;\nmemset(&type->data.dynamic, 0, sizeof(type->data.dynamic));\nh2o_config_init_pathconf(&type->data.dynamic.pathconf, globalconf, NULL, mimemap);\n\nreturn type;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  type; int /*<<< orphan*/  type_id; } ;\ntypedef  TYPE_1__ type_t ;\ntypedef  int /*<<< orphan*/  type_id_t ;\ntypedef  int /*<<< orphan*/  type_table_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TYPE_DYNAMIC ;\nTYPE_1__* alloc_type (int /*<<< orphan*/ *,int,int) ;\nint /*<<< orphan*/  memcpy (TYPE_1__*,int /*<<< orphan*/ *,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * type_table ;\n\n__attribute__((used)) static type_t *create_dynamic_type(type_id_t *type_id, type_table_t *table)\n{\ntype_t *type = alloc_type(NULL, sizeof(type_t), 4);\ntype->type_id = type_id[0];\nmemcpy(type, type_table, sizeof(type_t));\ntype->type = TYPE_DYNAMIC;\nreturn type;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_compress.c_test_gzip_simple",
    "input":"\n0000000000000000 <test_gzip_simple>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$32, %rsp\n9: \tleaq\t28(%rsp), %r14\ne: \tmovq\t%r14, %rdi\n11: \tcallq\t0x16 <test_gzip_simple+0x16>\n16: \tmovl\t(%rip), %esi  # 0x1c <test_gzip_simple+0x1c>\n1c: \tmovq\t%r14, %rdi\n1f: \tcallq\t0x24 <test_gzip_simple+0x24>\n24: \tmovq\t%rax, %rbx\n27: \tmovl\t$0, %edi\n2c: \tcallq\t0x31 <test_gzip_simple+0x31>\n31: \tleaq\t24(%rsp), %r15\n36: \tmovq\t%r15, %rdi\n39: \tmovl\t%eax, %esi\n3b: \tcallq\t0x40 <test_gzip_simple+0x40>\n40: \tleaq\t8(%rsp), %rax\n45: \tmovq\t%rax, (%rsp)\n49: \tleaq\t16(%rsp), %r9\n4e: \tmovq\t%rbx, %rdi\n51: \tmovl\t$0, %esi\n56: \tmovq\t%r15, %rdx\n59: \tmovl\t$1, %ecx\n5e: \tmovl\t$1, %r8d\n64: \tcallq\t0x69 <test_gzip_simple+0x69>\n69: \tmovq\t16(%rsp), %rbx\n6e: \tmovq\t8(%rsp), %r15\n73: \tmovl\t$0, %edi\n78: \tcallq\t0x7d <test_gzip_simple+0x7d>\n7d: \tmovq\t%rbx, %rdi\n80: \tmovq\t%r15, %rsi\n83: \tmovl\t%eax, %edx\n85: \tcallq\t0x8a <test_gzip_simple+0x8a>\n8a: \tmovq\t%r14, %rdi\n8d: \tcallq\t0x92 <test_gzip_simple+0x92>\n92: \taddq\t$32, %rsp\n96: \tpopq\t%rbx\n97: \tpopq\t%r14\n99: \tpopq\t%r15\n9b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_sendvec_t ;\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\ntypedef  int /*<<< orphan*/  h2o_compress_context_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  Z_BEST_SPEED ;\nint /*<<< orphan*/  check_result (int /*<<< orphan*/ *,size_t,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * h2o_compress_gzip_open (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_compress_transform (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ **,size_t*) ;\nint /*<<< orphan*/  h2o_mem_clear_pool (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mem_init_pool (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_sendvec_init_raw (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nvoid test_gzip_simple(void)\n{\nh2o_mem_pool_t pool;\nh2o_sendvec_t inbuf, *outbufs;\nsize_t outbufcnt;\n\nh2o_mem_init_pool(&pool);\n\nh2o_compress_context_t *compressor = h2o_compress_gzip_open(&pool, Z_BEST_SPEED);\nh2o_sendvec_init_raw(&inbuf, H2O_STRLIT(\"hello world\"));\nh2o_compress_transform(compressor, NULL, &inbuf, 1, 1, &outbufs, &outbufcnt);\n\ncheck_result(outbufs, outbufcnt, H2O_STRLIT(\"hello world\"));\n\nh2o_mem_clear_pool(&pool);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  BIO_write (int /*<<< orphan*/ *,char*,int) ;\nint /*<<< orphan*/  BIO_write_filename (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  BIO_zlib_compress () ;\nint /*<<< orphan*/  BIO_zlib_decompress () ;\nint /*<<< orphan*/  BIO_zlib_filter (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_mem_eq (char*,char*,int) ;\nint /*<<< orphan*/  TEST_info (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_mem_str (char*,char*,int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_str_eq (char*,char*) ;\nint /*<<< orphan*/  bio_f_zlib_filter ;\nint /*<<< orphan*/  bio_f_zlib_filter_compress ;\nint /*<<< orphan*/  bio_f_zlib_filter_decompress ;\n\n__attribute__((used)) static void test_gzip_simple(void)\n{\nBIO *out = NULL, *in = NULL;\nchar *outbuf = NULL, *inbuf = NULL;\n\nout = BIO_new(BIO_s_mem());\nTEST_ptr(out);\n\nin = BIO_new(BIO_s_mem());\nTEST_ptr(in);\n\nTEST_mem_str(inbuf = \"hello world\", \"hello world\", 11);\n\nBIO_write_filename(in, \"testdata/gzip-simple.txt\");\n\nBIO_zlib_filter(out, bio_f_zlib_filter_compress, in, 1, 1, NULL);\n\nTEST_mem_eq(outbuf = \"hello world\", \"hello world\", 11);\n\nBIO_zlib_filter(in, bio_f_zlib_filter_decompress, out, 1, 1, NULL);\n\nBIO_free(out);\nBIO_free(in);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlercompressgzip.c_gzip_open",
    "input":"\n0000000000000000 <gzip_open>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %edx  # 0x7 <gzip_open+0x7>\n7: \tmovl\t$48, %esi\nc: \tcallq\t0x11 <gzip_open+0x11>\n11: \tmovq\t%rax, %rbx\n14: \tmovl\t$0, %edi\n19: \tcallq\t0x1e <gzip_open+0x1e>\n1e: \tmovl\t%eax, %edi\n20: \tcallq\t0x25 <gzip_open+0x25>\n25: \tmovl\t%eax, 40(%rbx)\n28: \txorps\t%xmm0, %xmm0\n2b: \tmovups\t%xmm0, 24(%rbx)\n2f: \tmovl\t(%rip), %eax  # 0x35 <gzip_open+0x35>\n35: \tmovl\t%eax, 20(%rbx)\n38: \tmovl\t(%rip), %eax  # 0x3e <gzip_open+0x3e>\n3e: \tmovl\t%eax, 16(%rbx)\n41: \tmovq\t$0, 8(%rbx)\n49: \tmovl\t$1, (%rbx)\n4f: \tleaq\t4(%rbx), %rdi\n53: \txorl\t%esi, %esi\n55: \tmovl\t$4, %edx\n5a: \tcallq\t0x5f <gzip_open+0x5f>\n5f: \tmovq\t%rbx, %rdi\n62: \tcallq\t0x67 <gzip_open+0x67>\n67: \tmovq\t%rbx, %rax\n6a: \tpopq\t%rbx\n6b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * opaque; int /*<<< orphan*/  zfree; int /*<<< orphan*/  zalloc; } ;\nstruct TYPE_4__ {int /*<<< orphan*/ * push_buf; int /*<<< orphan*/ * do_transform; int /*<<< orphan*/  name; } ;\nstruct st_gzip_context_t {int zs_is_open; int /*<<< orphan*/  bufs; TYPE_1__ zs; TYPE_2__ super; } ;\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  alloc_cb ;\nint /*<<< orphan*/  do_free ;\nint /*<<< orphan*/  expand_buf (struct st_gzip_context_t*) ;\nint /*<<< orphan*/  free_cb ;\nint /*<<< orphan*/  h2o_iovec_init (int /*<<< orphan*/ ) ;\nstruct st_gzip_context_t* h2o_mem_alloc_shared (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static struct st_gzip_context_t *gzip_open(h2o_mem_pool_t *pool)\n{\nstruct st_gzip_context_t *self = h2o_mem_alloc_shared(pool, sizeof(*self), do_free);\n\nself->super.name = h2o_iovec_init(H2O_STRLIT(\"gzip\"));\nself->super.do_transform = NULL;\nself->super.push_buf = NULL;\nself->zs.zalloc = alloc_cb;\nself->zs.zfree = free_cb;\nself->zs.opaque = NULL;\nself->zs_is_open = 1;\nmemset(&self->bufs, 0, sizeof(self->bufs));\nexpand_buf(self);\n\nreturn self;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  zalloc; int /*<<< orphan*/  zfree; int /*<<< orphan*/  opaque; int /*<<< orphan*/  data_type; int /*<<< orphan*/  adler; int /*<<< orphan*/  stream; int /*<<< orphan*/  stream_size; int /*<<< orphan*/  stream_pos; int /*<<< orphan*/  stream_start; int /*<<< orphan*/  stream_end; } ;\ntypedef  TYPE_1__ gzFile ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GZ_DEFAULT_COMPRESSION ;\nint /*<<< orphan*/  GZ_DEFAULT_STRATEGY ;\nint /*<<< orphan*/  GZ_HEADER ;\nint /*<<< orphan*/  Z_NO_FLUSH ;\nint /*<<< orphan*/  Z_OK ;\nint /*<<< orphan*/  Z_STREAM_END ;\nint /*<<< orphan*/  Z_STREAM_ERROR ;\nint /*<<< orphan*/  Z_SYNC_FLUSH ;\nint /*<<< orphan*/  Z_UNKNOWN ;\nint /*<<< orphan*/  Z_VERSION_ERROR ;\nint /*<<< orphan*/  Z_VERSION_MASK ;\nint /*<<< orphan*/  Z_VERSION_ZLIB ;\nint /*<<< orphan*/  deflateInit2 (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  memzero (TYPE_1__*,int) ;\nint /*<<< orphan*/  zcalloc (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  zcfree (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  zfree (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static gzFile gzip_open(const char *path, int fd)\n{\ngzFile gz;\n\ngz = (gzFile)zcalloc(NULL, 1, sizeof(gzFile));\nif (gz == NULL)\nreturn NULL;\n\ngz->stream_start = gz->stream_pos = gz->stream_end = 0;\ngz->stream_size = 0;\ngz->stream_size = 48;\ngz->stream = zcalloc(NULL, 1, gz->stream_size);\nif (gz->stream == NULL) {\nzcfree(NULL, gz);\nreturn NULL;\n}\n\ngz->stream_end = gz->stream + gz->stream_size;\ngz->stream_pos = gz->stream;\ngz->stream_start = gz->stream;\ngz->adler = zcalloc(NULL, 1, sizeof(unsigned long));\nif (gz->adler == NULL) {\nzcfree(NULL, gz->stream);\nzcfree(NULL, gz);\nreturn NULL;\n}\n\ngz->data_type = GZ_UNKNOWN;\n\n/* Initialize the compression state. */\nif (deflateInit2(&(gz->stream), GZ_DEFAULT_COMPRESSION, Z_DEFLATED,\nGZ_DEFAULT_STRATEGY,\n8, Z_VERSION_ZLIB, Z_STREAM_END) != Z_OK) {\nzcfree(NULL, gz->stream);\nzcfree(NULL, gz->adler);\nzcfree(NULL, gz);\nreturn NULL;\n}\n\nmemset(&(gz->stream), 0, sizeof(gz->stream));\nmemset(&(gz->zfree), 0, sizeof(gz->zfree));\nmemset(&(gz->zalloc), 0, sizeof(gz->zalloc));\nmemset(&(gz->opaque), 0, sizeof(gz->opaque));\n\nreturn gz;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlercompressgzip.c_h2o_compress_gunzip_open",
    "input":"\n0000000000000000 <h2o_compress_gunzip_open>:\n0: \tpushq\t%rbx\n1: \tcallq\t0x6 <h2o_compress_gunzip_open+0x6>\n6: \tmovq\t%rax, %rbx\n9: \tmovl\t$0, %edi\ne: \tcallq\t0x13 <h2o_compress_gunzip_open+0x13>\n13: \tmovl\t%eax, %edi\n15: \tcallq\t0x1a <h2o_compress_gunzip_open+0x1a>\n1a: \tmovl\t%eax, 12(%rbx)\n1d: \tmovl\t(%rip), %eax  # 0x23 <h2o_compress_gunzip_open+0x23>\n23: \tmovl\t%eax, 8(%rbx)\n26: \tmovq\t$0, (%rbx)\n2d: \tleaq\t16(%rbx), %rdi\n31: \tmovl\t(%rip), %esi  # 0x37 <h2o_compress_gunzip_open+0x37>\n37: \tcallq\t0x3c <h2o_compress_gunzip_open+0x3c>\n3c: \tmovq\t%rbx, %rax\n3f: \tpopq\t%rbx\n40: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * push_buf; int /*<<< orphan*/  do_transform; int /*<<< orphan*/  name; } ;\nstruct st_gzip_context_t {TYPE_1__ super; int /*<<< orphan*/  zs; } ;\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\ntypedef  TYPE_1__ h2o_compress_context_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  WINDOW_BITS ;\nint /*<<< orphan*/  do_decompress ;\nstruct st_gzip_context_t* gzip_open (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_iovec_init (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  inflateInit2 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nh2o_compress_context_t *h2o_compress_gunzip_open(h2o_mem_pool_t *pool)\n{\nstruct st_gzip_context_t *self = gzip_open(pool);\nself->super.name = h2o_iovec_init(H2O_STRLIT(\"gunzip\"));\nself->super.do_transform = do_decompress;\nself->super.push_buf = NULL;\ninflateInit2(&self->zs, WINDOW_BITS);\n\nreturn &self->super;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * stream; int /*<<< orphan*/  (* on_close ) (int /*<<< orphan*/ *) ;int /*<<< orphan*/  (* on_update ) (int /*<<< orphan*/ *) ;int /*<<< orphan*/  (* on_update_gzip_header ) (int /*<<< orphan*/ *) ;int /*<<< orphan*/  (* on_update_gzip_footer ) (int /*<<< orphan*/ *) ;} ;\ntypedef  TYPE_1__ h2o_compress_gunzip_context_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Z_NO_FLUSH ;\nint /*<<< orphan*/  Z_OK ;\nint /*<<< orphan*/  Z_SYNC_FLUSH ;\nint /*<<< orphan*/  Z_STREAM_END ;\nint /*<<< orphan*/  Z_STREAM_ERROR ;\nint /*<<< orphan*/  Z_STREAM_FINISHED ;\nint /*<<< orphan*/  Z_STREAM_INVALID ;\nint /*<<< orphan*/  Z_STREAM_NEED_DICT ;\nint /*<<< orphan*/  Z_STREAM_OK ;\nint /*<<< orphan*/  Z_STREAM_PARAM ;\nint /*<<< orphan*/  Z_STREAM_RESET ;\nint /*<<< orphan*/  Z_STREAM_SEEK ;\nint /*<<< orphan*/  Z_STREAM_WRONG ;\nint /*<<< orphan*/  Z_VERSION_ERROR ;\nint /*<<< orphan*/  Z_VERSION_ERROR_ ;\nint /*<<< orphan*/  Z_VERSION_ERROR_2 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_3 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_4 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_5 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_6 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_7 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_8 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_9 ;\nint /*<<< orphan*/  Z_VERSION_ERROR_A ;\nint /*<<< orphan*/  Z_VERSION_ERROR_B ;\nint /*<<< orphan*/  Z_VERSION_ERROR_C ;\nint /*<<< orphan*/  Z_VERSION_ERROR_D ;\nint /*<<< orphan*/  Z_VERSION_ERROR_E ;\nint /*<<< orphan*/  Z_VERSION_ERROR_F ;\nint /*<<< orphan*/  Z_VERSION_ERROR_G ;\nint /*<<< orphan*/  Z_VERSION_ERROR_H ;\nint /*<<< orphan*/  Z_VERSION_ERROR_I ;\nint /*<<< orphan*/  Z_VERSION_ERROR_J ;\nint /*<<< orphan*/  Z_VERSION_ERROR_K ;\nint /*<<< orphan*/  Z_VERSION_ERROR_L ;\nint /*<<< orphan*/  Z_VERSION_ERROR_M ;\nint /*<<< orphan*/  Z_VERSION_ERROR_N ;\nint /*<<< orphan*/  Z_VERSION_ERROR_O ;\nint /*<<< orphan*/  Z_VERSION_ERROR_P ;\nint /*<<< orphan*/  Z_VERSION_ERROR_Q ;\nint /*<<< orphan*/  Z_VERSION_ERROR_R ;\nint /*<<< orphan*/  Z_VERSION_ERROR_S ;\nint /*<<< orphan*/  Z_VERSION_ERROR_T ;\nint /*<<< orphan*/  Z_VERSION_ERROR_U ;\nint /*<<< orphan*/  Z_VERSION_ERROR_V ;\nint /*<<< orphan*/  Z_VERSION_ERROR_W ;\nint /*<<< orphan*/  Z_VERSION_ERROR_X ;\nint /*<<< orphan*/  Z_VERSION_ERROR_Y ;\nint /*<<< orphan*/  Z_VERSION_ERROR_Z ;\nint /*<<< orphan*/  Z_VERSION_ERROR_a ;\nint /*<<< orphan*/  Z_VERSION_ERROR_b ;\nint /*<<< orphan*/  Z_VERSION_ERROR_c ;\nint /*<<< orphan*/  Z_VERSION_ERROR_d ;\nint /*<<< orphan*/  Z_VERSION_ERROR_e ;\nint /*<<< orphan*/  Z_VERSION_ERROR_f ;\nint /*<<< orphan*/  Z_VERSION_ERROR_g ;\nint /*<<< orphan*/  Z_VERSION_ERROR_h ;\nint /*<<< orphan*/  Z_VERSION_ERROR_i ;\nint /*<<< orphan*/  Z_VERSION_ERROR_j ;\nint /*<<< orphan*/  Z_VERSION_ERROR_k ;\nint /*<<< orphan*/  Z_VERSION_ERROR_l ;\nint /*<<< orphan*/  Z_VERSION_ERROR_m ;\nint /*<<< orphan*/  Z_VERSION_ERROR_n ;\nint /*<<< orphan*/  Z_VERSION_ERROR_o ;\nint /*<<< orphan*/  Z_VERSION_ERROR_p ;\nint /*<<< orphan*/  Z_VERSION_ERROR_q ;\nint /*<<< orphan*/  Z_VERSION_ERROR_r ;\nint /*<<< orphan*/  Z_VERSION_ERROR_s ;\nint /*<<< orphan*/  Z_VERSION_ERROR_t ;\nint /*<<< orphan*/  Z_VERSION_ERROR_u ;\nint /*<<< orphan*/  Z_VERSION_ERROR_v ;\nint /*<<< orphan*/  Z_VERSION_ERROR_w ;\nint /*<<< orphan*/  Z_VERSION_ERROR_x ;\nint /*<<< orphan*/  Z_VERSION_ERROR_y ;\nint /*<<< orphan*/  Z_VERSION_ERROR_z ;\nint /*<<< orphan*/  Z_VERSION_ERROR_A ;\nint /*<<< orphan*/  Z_VERSION_ERROR_B ;\nint /*<<< orphan*/  Z_VERSION_ERROR_C ;\nint /*<<< orphan*/  Z_VERSION_ERROR_D ;\nint /*<<< orphan*/  Z_VERSION_ERROR_E ;\nint /*<<< orphan*/  Z_VERSION_ERROR_F ;\nint /*<<< orphan*/  Z_VERSION_ERROR_G ;\nint /*<<< orphan*/  Z_VERSION_ERROR_H ;\nint /*<<< orphan*/  Z_VERSION_ERROR_I ;\nint /*<<< orphan*/  Z_VERSION_ERROR_J ;\nint /*<<< orphan*/  Z_VERSION_ERROR_K ;\nint /*<<< orphan*/  Z_VERSION_ERROR_L ;\nint /*<<< orphan*/  Z_VERSION_ERROR_M ;\nint /*<<< orphan*/  Z_VERSION_ERROR_N ;\nint /*<<< orphan*/  Z_VERSION_ERROR_O ;\nint /*<<< orphan*/  Z_VERSION_ERROR_P ;\nint /*<<< orphan*/  Z_VERSION_ERROR_Q ;\nint /*<<< orphan*/  Z_VERSION_ERROR_R ;\nint /*<<< orphan*/  Z_VERSION_ERROR_S ;\nint /*<<< orphan*/  Z_VERSION_ERROR_T ;\nint /*<<< orphan*/  Z_VERSION_ERROR_U ;\nint /*<<< orphan*/  Z_VERSION_ERROR_V ;\nint /*<<< orphan*/  Z_VERSION_ERROR_W ;\nint /*<<< orphan*/  Z_VERSION_ERROR_X ;\nint /*<<< orphan*/  Z_VERSION_ERROR_Y ;\nint /*<<< orphan*/  Z_VERSION_ERROR_Z ;\nint /*<<< orphan*/  Z_VERSION_ERROR_a ;\nint /*<<< orphan*/  Z_VERSION_ERROR_b ;\nint /*<<< orphan*/  Z_"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_on_context_dispose",
    "input":"\n0000000000000000 <on_context_dispose>:\n0: \tmovl\t(%rdi), %edi\n2: \tjmp\t0x7 <on_context_dispose+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\nstruct TYPE_2__ {int /*<<< orphan*/  mimemap; } ;\ntypedef  TYPE_1__ h2o_file_handler_t ;\ntypedef  int /*<<< orphan*/  h2o_context_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mimemap_on_context_dispose (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_context_dispose(h2o_handler_t *_self, h2o_context_t *ctx)\n{\nh2o_file_handler_t *self = (void *)_self;\n\nh2o_mimemap_on_context_dispose(self->mimemap, ctx);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  ctx; } ;\ntypedef  TYPE_1__ GLogContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_free (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\non_context_dispose (GLogContext *context)\n{\ng_free (context->ctx);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfastcgi.c_decode_header",
    "input":"\n0000000000000000 <decode_header>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t$16, %edx\n9: \tcallq\t0xe <decode_header+0xe>\ne: \tmovq\t8(%rbx), %rdi\n12: \tcallq\t0x17 <decode_header+0x17>\n17: \tmovq\t%rax, 8(%rbx)\n1b: \tmovq\t(%rbx), %rdi\n1e: \tcallq\t0x23 <decode_header+0x23>\n23: \tmovq\t%rax, (%rbx)\n26: \tpopq\t%rbx\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_fcgi_record_header_t {void* contentLength; void* requestId; } ;\n\n/* Variables and functions */\nvoid* htons (void*) ;\nint /*<<< orphan*/  memcpy (struct st_fcgi_record_header_t*,void const*,int) ;\n\n__attribute__((used)) static void decode_header(struct st_fcgi_record_header_t *decoded, const void *s)\n{\nmemcpy(decoded, s, sizeof(*decoded));\ndecoded->requestId = htons(decoded->requestId);\ndecoded->contentLength = htons(decoded->contentLength);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * pb; int /*<<< orphan*/ * pb_end; } ;\ntypedef  TYPE_1__ AVCodecParserContext ;\n\n/* Variables and functions */\nscalar_t__ bytestream2_get_le16 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  bytestream2_skip (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static int decode_header(AVCodecParserContext *s)\n{\nbytestream2_skip(s->pb, 16);\ns->pict_type = bytestream2_get_le16(s->pb);\ns->key_frame = 1;\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_h2o_mimemap_define_dynamic",
    "input":"\n0000000000000000 <h2o_mimemap_define_dynamic>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %rbx\n8: \tmovq\t%rdi, %r14\nb: \tmovq\t%rdx, %rdi\ne: \tmovq\t%r14, %rsi\n11: \tcallq\t0x16 <h2o_mimemap_define_dynamic+0x16>\n16: \tmovq\t%rax, %r15\n19: \tmovq\t(%rbx), %rsi\n1c: \ttestq\t%rsi, %rsi\n1f: \tje\t0x59 <h2o_mimemap_define_dynamic+0x59>\n21: \taddq\t$8, %rbx\n25: \tjmp\t0x47 <h2o_mimemap_define_dynamic+0x47>\n27: \tnopw\t(%rax,%rax)\n30: \tmovq\t%r14, %rdi\n33: \tmovq\t%r15, %rdx\n36: \tcallq\t0x3b <h2o_mimemap_define_dynamic+0x3b>\n3b: \tmovq\t(%rbx), %rsi\n3e: \taddq\t$8, %rbx\n42: \ttestq\t%rsi, %rsi\n45: \tje\t0x59 <h2o_mimemap_define_dynamic+0x59>\n47: \tcmpb\t$0, (%rsi)\n4a: \tjne\t0x30 <h2o_mimemap_define_dynamic+0x30>\n4c: \tmovq\t%r14, %rdi\n4f: \tmovq\t%r15, %rsi\n52: \tcallq\t0x57 <h2o_mimemap_define_dynamic+0x57>\n57: \tjmp\t0x3b <h2o_mimemap_define_dynamic+0x3b>\n59: \tmovq\t%r15, %rdi\n5c: \tcallq\t0x61 <h2o_mimemap_define_dynamic+0x61>\n61: \tmovq\t%r15, %rax\n64: \tpopq\t%rbx\n65: \tpopq\t%r14\n67: \tpopq\t%r15\n69: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mimemap_type_t ;\ntypedef  int /*<<< orphan*/  h2o_mimemap_t ;\ntypedef  int /*<<< orphan*/  h2o_globalconf_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * create_dynamic_type (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mem_release_shared (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  set_default_type (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  set_type (int /*<<< orphan*/ *,char const*,int /*<<< orphan*/ *) ;\n\nh2o_mimemap_type_t *h2o_mimemap_define_dynamic(h2o_mimemap_t *mimemap, const char **exts, h2o_globalconf_t *globalconf)\n{\n/* FIXME: fix memory leak introduced by this a cyclic link (mimemap -> new_type -> mimemap)\n* note also that we may want to update the reference from the dynamic type to the mimemap as we clone the mimemap,\n* but doing so naively would cause unnecessary copies of fastcgi.spawns... */\nh2o_mimemap_type_t *new_type = create_dynamic_type(globalconf, mimemap);\nsize_t i;\n\nfor (i = 0; exts[i] != NULL; ++i) {\nif (exts[i][0] == '\\0') {\n/* empty string means default */\nset_default_type(mimemap, new_type);\n} else {\nset_type(mimemap, exts[i], new_type);\n}\n}\nh2o_mem_release_shared(new_type);\nreturn new_type;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct h2o_mimemap_type {char* extension; struct h2o_mimemap_type* next; } ;\nstruct h2o_mimemap {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mimemap_add_type (struct h2o_mimemap*,char const*,struct h2o_mimemap_type*) ;\nint /*<<< orphan*/  h2o_mimemap_add_type_dynamic (struct h2o_mimemap*,char const*,struct h2o_mimemap_type*) ;\nstruct h2o_mimemap* h2o_mimemap_create () ;\nint /*<<< orphan*/  h2o_mimemap_dispose (struct h2o_mimemap*) ;\n\nstruct h2o_mimemap *h2o_mimemap_define_dynamic(struct h2o_mimemap *map, const char *type, struct h2o_mimemap_type *types)\n{\nstruct h2o_mimemap *map_new = h2o_mimemap_create();\nh2o_mimemap_add_type_dynamic(map_new, type, types);\nwhile (types->extension != NULL) {\nif (types->extension[0] == '\\0')\nh2o_mimemap_add_type(map_new, type, types);\ntypes = types->next;\n}\nh2o_mimemap_dispose(map_new);\nreturn map;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_mimemap_type_equals",
    "input":"\n0000000000000000 <mimemap_type_equals>:\n0: \tmovl\t(%rdi), %eax\n2: \tmovl\t4(%rdi), %edi\n5: \tmovl\t(%rsi), %ecx\n7: \tmovl\t4(%rsi), %edx\na: \tmovl\t%eax, %esi\nc: \tjmp\t0x11 <mimemap_type_equals+0x11>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  len; int /*<<< orphan*/  base; } ;\nstruct TYPE_7__ {TYPE_1__ mimetype; } ;\nstruct TYPE_8__ {TYPE_2__ data; } ;\ntypedef  TYPE_3__ h2o_mimemap_type_t ;\n\n/* Variables and functions */\nint h2o_memis (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static inline int mimemap_type_equals(h2o_mimemap_type_t *x, h2o_mimemap_type_t *y)\n{\nreturn h2o_memis(x->data.mimetype.base, x->data.mimetype.len, y->data.mimetype.base, y->data.mimetype.len);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  type; int /*<<< orphan*/  subtype; } ;\ntypedef  TYPE_1__ mime_type_t ;\n\n/* Variables and functions */\nint strcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nmimemap_type_equals(const mime_type_t *type, const mime_type_t *other)\n{\nreturn strcmp(type->type, other->type) == 0 &&\nstrcmp(type->subtype, other->subtype) == 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfastcgi.c_append_pair",
    "input":"\n0000000000000000 <append_pair>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$24, %rsp\ne: \tmovq\t%r9, %r15\n11: \tmovq\t%r8, 8(%rsp)\n16: \tmovq\t%rcx, %r13\n19: \tmovq\t%rdx, %rbp\n1c: \tmovq\t%rsi, %r12\n1f: \tmovq\t%rdi, %rbx\n22: \tleaq\t16(%rsp), %r14\n27: \tmovq\t%r14, %rdi\n2a: \tmovq\t%rcx, %rsi\n2d: \tcallq\t0x32 <append_pair+0x32>\n32: \tmovq\t%rax, %rdi\n35: \tmovq\t%r15, %rsi\n38: \tcallq\t0x3d <append_pair+0x3d>\n3d: \tsubq\t%r14, %rax\n40: \tmovq\t%rbx, %rdi\n43: \tmovq\t%r12, %rsi\n46: \tmovq\t%r14, %rdx\n49: \tmovq\t%rax, %rcx\n4c: \tcallq\t0x51 <append_pair+0x51>\n51: \tmovq\t%rbx, %rdi\n54: \tmovq\t%r12, %rsi\n57: \tmovq\t%rbp, %rdx\n5a: \tmovq\t%r13, %rcx\n5d: \tcallq\t0x62 <append_pair+0x62>\n62: \tmovq\t%rax, %r13\n65: \ttestq\t%r15, %r15\n68: \tje\t0x7d <append_pair+0x7d>\n6a: \tmovq\t%rbx, %rdi\n6d: \tmovq\t%r12, %rsi\n70: \tmovq\t8(%rsp), %rdx\n75: \tmovq\t%r15, %rcx\n78: \tcallq\t0x7d <append_pair+0x7d>\n7d: \tmovq\t%r13, %rax\n80: \taddq\t$24, %rsp\n84: \tpopq\t%rbx\n85: \tpopq\t%r12\n87: \tpopq\t%r13\n89: \tpopq\t%r14\n8b: \tpopq\t%r15\n8d: \tpopq\t%rbp\n8e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  iovec_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\n\n/* Variables and functions */\nvoid* append (int /*<<< orphan*/ *,int /*<<< orphan*/ *,char const*,size_t) ;\nchar* encode_length_of_pair (char*,size_t) ;\n\n__attribute__((used)) static void *append_pair(h2o_mem_pool_t *pool, iovec_vector_t *blocks, const char *name, size_t namelen, const char *value,\nsize_t valuelen)\n{\nchar lenbuf[8];\nvoid *name_buf;\n\nappend(pool, blocks, lenbuf, encode_length_of_pair(encode_length_of_pair(lenbuf, namelen), valuelen) - lenbuf);\nname_buf = append(pool, blocks, name, namelen);\nif (valuelen != 0)\nappend(pool, blocks, value, valuelen);\n\nreturn name_buf;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WCHAR ;\ntypedef  int /*<<< orphan*/  WCHAR_LIST ;\ntypedef  int /*<<< orphan*/  LPCWSTR ;\ntypedef  int /*<<< orphan*/  LPCSTR ;\ntypedef  int /*<<< orphan*/  BOOL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  append_string (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  append_string_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strlenW (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static BOOL append_pair(WCHAR_LIST *list, LPCSTR key, LPCSTR value, LPCSTR sep, LPCWSTR sepW,\nLPCWSTR valueW)\n{\nWCHAR *str;\n\nstr = append_string(list, key, sep, sepW);\nstr = append_string_len(list, str, strlenW(key), valueW);\nappend_string(list, str, value, valueW);\n\nif (valueW)\nappend_string(list, str, sep, sepW);\n\nreturn TRUE;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_h2o_mimemap_set_default_type",
    "input":"\n0000000000000000 <h2o_mimemap_set_default_type>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rdx, %r15\nb: \tmovq\t%rsi, %r12\ne: \tmovq\t%rdi, %r14\n11: \tmovq\t%rsi, %rdi\n14: \tcallq\t0x19 <h2o_mimemap_set_default_type+0x19>\n19: \tmovq\t%r12, %rdi\n1c: \tmovl\t%eax, %esi\n1e: \tcallq\t0x23 <h2o_mimemap_set_default_type+0x23>\n23: \tmovq\t%r14, %rdi\n26: \tmovl\t%eax, %esi\n28: \tmovl\t$1, %edx\n2d: \tcallq\t0x32 <h2o_mimemap_set_default_type+0x32>\n32: \ttestq\t%rax, %rax\n35: \tje\t0x54 <h2o_mimemap_set_default_type+0x54>\n37: \tmovq\t%rax, %rbx\n3a: \ttestq\t%r15, %r15\n3d: \tje\t0x64 <h2o_mimemap_set_default_type+0x64>\n3f: \tmovq\t%rbx, %rdi\n42: \tmovq\t%r15, %rsi\n45: \tmovl\t$4, %edx\n4a: \tcallq\t0x4f <h2o_mimemap_set_default_type+0x4f>\n4f: \ttestq\t%rax, %rax\n52: \tje\t0x64 <h2o_mimemap_set_default_type+0x64>\n54: \tmovq\t%r12, %rdi\n57: \tmovq\t%r15, %rsi\n5a: \tcallq\t0x5f <h2o_mimemap_set_default_type+0x5f>\n5f: \tmovq\t%rax, %rbx\n62: \tjmp\t0x6c <h2o_mimemap_set_default_type+0x6c>\n64: \tmovq\t%rbx, %rdi\n67: \tcallq\t0x6c <h2o_mimemap_set_default_type+0x6c>\n6c: \tmovq\t%r14, %rdi\n6f: \tmovq\t%rbx, %rsi\n72: \tcallq\t0x77 <h2o_mimemap_set_default_type+0x77>\n77: \tmovq\t%rbx, %rdi\n7a: \taddq\t$8, %rsp\n7e: \tpopq\t%rbx\n7f: \tpopq\t%r12\n81: \tpopq\t%r14\n83: \tpopq\t%r15\n85: \tjmp\t0x8a <h2o_mimemap_set_default_type+0x8a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  attr; } ;\nstruct TYPE_9__ {TYPE_1__ data; } ;\ntypedef  TYPE_2__ h2o_mimemap_type_t ;\ntypedef  int /*<<< orphan*/  h2o_mimemap_t ;\ntypedef  int /*<<< orphan*/  h2o_mime_attributes_t ;\n\n/* Variables and functions */\nTYPE_2__* create_extension_type (char const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_iovec_init (char const*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_addref_shared (TYPE_2__*) ;\nint /*<<< orphan*/  h2o_mem_release_shared (TYPE_2__*) ;\nTYPE_2__* h2o_mimemap_get_type_by_mimetype (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nscalar_t__ memcmp (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  set_default_type (int /*<<< orphan*/ *,TYPE_2__*) ;\nint /*<<< orphan*/  strlen (char const*) ;\n\nvoid h2o_mimemap_set_default_type(h2o_mimemap_t *mimemap, const char *mime, h2o_mime_attributes_t *attr)\n{\nh2o_mimemap_type_t *new_type;\n\n/* obtain or create new type */\nif ((new_type = h2o_mimemap_get_type_by_mimetype(mimemap, h2o_iovec_init(mime, strlen(mime)), 1)) != NULL &&\n(attr == NULL || memcmp(&new_type->data.attr, attr, sizeof(*attr)) == 0)) {\nh2o_mem_addref_shared(new_type);\n} else {\nnew_type = create_extension_type(mime, attr);\n}\n\nset_default_type(mimemap, new_type);\nh2o_mem_release_shared(new_type);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mimemap_type_t ;\ntypedef  int /*<<< orphan*/  h2o_mimemap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mimemap_add_type (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * h2o_mimemap_create () ;\nint /*<<< orphan*/ * h2o_mimemap_get_type (int /*<<< orphan*/ *,char const*) ;\nint /*<<< orphan*/ * h2o_mimemap_set_type (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ * h2o_strdup (char const*,int) ;\nint /*<<< orphan*/ * h2o_strdup_share (char const*,int) ;\nint /*<<< orphan*/  h2o_strtolower (char const*,int) ;\n\nvoid h2o_mimemap_set_default_type(h2o_mimemap_t *mimemap, const char *type, const char *default_type)\n{\nh2o_mimemap_type_t *t;\n\nt = h2o_mimemap_get_type(mimemap, h2o_strtolower(type, strlen(type)));\nif (t == NULL) {\nt = h2o_mimemap_create();\nif (default_type != NULL) {\nif ((t = h2o_mimemap_set_type(mimemap, t, 1)) == NULL)\nreturn;\n}\n}\nif (default_type != NULL) {\nif ((t = h2o_mimemap_set_type(mimemap, h2o_strdup_share(default_type, strlen(default_type)), 1)) == NULL)\nreturn;\n}\nh2o_mimemap_add_type(mimemap, t);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlermimemap.c_dupref",
    "input":"\n0000000000000000 <dupref>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdi, %r14\na: \tcallq\t0xf <dupref+0xf>\nf: \tmovq\t%rax, %r15\n12: \tleaq\t1(%rax), %rbx\n16: \txorl\t%edi, %edi\n18: \tmovq\t%rbx, %rsi\n1b: \txorl\t%edx, %edx\n1d: \tcallq\t0x22 <dupref+0x22>\n22: \tmovl\t%eax, %ebp\n24: \tmovl\t%eax, %edi\n26: \tmovq\t%r14, %rsi\n29: \tmovq\t%rbx, %rdx\n2c: \tcallq\t0x31 <dupref+0x31>\n31: \tmovq\t%r15, %rax\n34: \tmovl\t%ebp, %edx\n36: \taddq\t$8, %rsp\n3a: \tpopq\t%rbx\n3b: \tpopq\t%r14\n3d: \tpopq\t%r15\n3f: \tpopq\t%rbp\n40: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ len; int /*<<< orphan*/  base; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mem_alloc_shared (int /*<<< orphan*/ *,scalar_t__,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ ,char const*,scalar_t__) ;\nscalar_t__ strlen (char const*) ;\n\n__attribute__((used)) static h2o_iovec_t dupref(const char *s)\n{\nh2o_iovec_t ret;\nret.len = strlen(s);\nret.base = h2o_mem_alloc_shared(NULL, ret.len + 1, NULL);\nmemcpy(ret.base, s, ret.len + 1);\nreturn ret;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  lua_pushvalue (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_upvalueindex (int) ;\n\n__attribute__((used)) static int dupref (lua_State *L) {\nlua_State *L1 = lua_tothread(L, lua_upvalueindex(1));\nlua_pushvalue(L1, lua_upvalueindex(2));\nlua_settop(L, 1);\nreturn 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/handler/extr_........libhandlerfile.c_on_context_init",
    "input":"\n0000000000000000 <on_context_init>:\n0: \tmovl\t(%rdi), %edi\n2: \tjmp\t0x7 <on_context_init+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_handler_t ;\nstruct TYPE_2__ {int /*<<< orphan*/  mimemap; } ;\ntypedef  TYPE_1__ h2o_file_handler_t ;\ntypedef  int /*<<< orphan*/  h2o_context_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mimemap_on_context_init (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_context_init(h2o_handler_t *_self, h2o_context_t *ctx)\n{\nh2o_file_handler_t *self = (void *)_self;\n\nh2o_mimemap_on_context_init(self->mimemap, ctx);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  ctx; } ;\ntypedef  TYPE_1__ SSL_TEST_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_max_proto_version (int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void on_context_init(SSL_TEST_CTX *ctx)\n{\nSSL_CTX_set_max_proto_version(ctx->ctx, 0);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_timerwheel.c_test_lib__common__timerwheel_c",
    "input":"\n0000000000000000 <test_lib__common__timerwheel_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__timerwheel_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__timerwheel_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__timerwheel_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_lib__common__timerwheel_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_lib__common__timerwheel_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tcallq\t0x31 <test_lib__common__timerwheel_c+0x31>\n31: \tmovl\t(%rip), %esi  # 0x37 <test_lib__common__timerwheel_c+0x37>\n37: \tmovl\t$0, %edi\n3c: \tcallq\t0x41 <test_lib__common__timerwheel_c+0x41>\n41: \tmovl\t(%rip), %esi  # 0x47 <test_lib__common__timerwheel_c+0x47>\n47: \tmovl\t$0, %edi\n4c: \tcallq\t0x51 <test_lib__common__timerwheel_c+0x51>\n51: \tmovl\t(%rip), %esi  # 0x57 <test_lib__common__timerwheel_c+0x57>\n57: \tmovl\t$0, %edi\n5c: \tcallq\t0x61 <test_lib__common__timerwheel_c+0x61>\n61: \tmovl\t(%rip), %esi  # 0x67 <test_lib__common__timerwheel_c+0x67>\n67: \tmovl\t$0, %edi\n6c: \tcallq\t0x71 <test_lib__common__timerwheel_c+0x71>\n71: \tmovl\t(%rip), %esi  # 0x77 <test_lib__common__timerwheel_c+0x77>\n77: \tmovl\t$0, %edi\n7c: \tcallq\t0x81 <test_lib__common__timerwheel_c+0x81>\n81: \tmovl\t(%rip), %esi  # 0x87 <test_lib__common__timerwheel_c+0x87>\n87: \tmovl\t$0, %edi\n8c: \tpopq\t%rax\n8d: \tjmp\t0x92 <test_lib__common__timerwheel_c+0x92>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_add_fixed_timers ;\nint /*<<< orphan*/  test_add_rand_timers ;\nint /*<<< orphan*/  test_del_timers ;\nint /*<<< orphan*/  test_exhaustive ;\nint /*<<< orphan*/  test_get_wake_at ;\nint /*<<< orphan*/  test_invalid_timer ;\nint /*<<< orphan*/  test_multiple_cascade_in_sparse_wheels ;\nint /*<<< orphan*/  test_overflow ;\nint /*<<< orphan*/  test_slot_calc ;\n\nvoid test_lib__common__timerwheel_c()\n{\nsubtest(\"slot calculation\", test_slot_calc);\nsubtest(\"add fixed timers\", test_add_fixed_timers);\nsubtest(\"add random timers\", test_add_rand_timers);\nsubtest(\"del fixed timers\", test_del_timers);\nsubtest(\"test out-of-range timer\", test_invalid_timer);\nsubtest(\"exhaustive\", test_exhaustive);\nsubtest(\"overflow\", test_overflow);\nsubtest(\"get_wake_at\", test_get_wake_at);\nsubtest(\"multiple_cascade_in_sparse_wheels\", test_multiple_cascade_in_sparse_wheels);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_ASSERT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_NULL (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_TRUE (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_FAIL () ;\nint /*<<< orphan*/  TEST_IGNORE () ;\nint /*<<< orphan*/  TEST_PASS () ;\nint /*<<< orphan*/  TEST_SKIP () ;\nint /*<<< orphan*/  TEST_UNUSED (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_INVALID_ARG ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_NO_MEMORY ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_OK ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_TIMEOUT ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_UNEXPECTED ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_UNIMPLEMENTED ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_UNKNOWN ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WOULDBLOCK ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_STATE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_WRONG_DIFF ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_WRONG_DIFF_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_WRONG_DIFF_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_WRONG_TOO_LARGE ;\nint /*<<< orphan*/  TIMERWHEEL_ERR_WRONG_TICK_WRONG_WRONG_WRONG_WRONG_WRONG_WRONG_TOO_SMALL ;\nint /*<<< orphan*/  TIMERWHE"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_get_picotls_context",
    "input":"\n0000000000000000 <h2o_socket_ssl_get_picotls_context>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <h2o_socket_ssl_get_picotls_context+0xb>\nb: \tmovq\t%rbx, %rdi\ne: \tmovl\t%eax, %esi\n10: \tpopq\t%rbx\n11: \tjmp\t0x16 <h2o_socket_ssl_get_picotls_context+0x16>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ptls_context_t ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * SSL_CTX_get_ex_data (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  get_ptls_index () ;\n\nptls_context_t *h2o_socket_ssl_get_picotls_context(SSL_CTX *ossl)\n{\nreturn SSL_CTX_get_ex_data(ossl, get_ptls_index());\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ptls_context_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_socket_get_ssl_context (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ptls_get_context (int /*<<< orphan*/ ) ;\n\nptls_context_t *h2o_socket_ssl_get_picotls_context(h2o_socket_t *sock)\n{\nreturn ptls_get_context(h2o_socket_get_ssl_context(sock));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_h2o_cache_destroy",
    "input":"\n0000000000000000 <h2o_cache_destroy>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <h2o_cache_destroy+0x9>\n9: \tmovl\t8(%rbx), %esi\nc: \tmovq\t%rbx, %rdi\nf: \tcallq\t0x14 <h2o_cache_destroy+0x14>\n14: \tmovl\t(%rip), %eax  # 0x1a <h2o_cache_destroy+0x1a>\n1a: \ttestl\t%eax, (%rbx)\n1c: \tje\t0x27 <h2o_cache_destroy+0x27>\n1e: \tleaq\t4(%rbx), %rdi\n22: \tcallq\t0x27 <h2o_cache_destroy+0x27>\n27: \tmovq\t%rbx, %rdi\n2a: \tpopq\t%rbx\n2b: \tjmp\t0x30 <h2o_cache_destroy+0x30>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int flags; int /*<<< orphan*/  mutex; int /*<<< orphan*/  table; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\nint H2O_CACHE_FLAG_MULTITHREADED ;\nint /*<<< orphan*/  free (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_cache_clear (TYPE_1__*) ;\nint /*<<< orphan*/  kh_destroy (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pthread_mutex_destroy (int /*<<< orphan*/ *) ;\n\nvoid h2o_cache_destroy(h2o_cache_t *cache)\n{\nh2o_cache_clear(cache);\nkh_destroy(cache, cache->table);\nif ((cache->flags & H2O_CACHE_FLAG_MULTITHREADED) != 0)\npthread_mutex_destroy(&cache->mutex);\nfree(cache);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  num_entries; int /*<<< orphan*/  entries; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\nint H2O_CACHE_FLAG_DO_NOT_FREE_ENTRIES ;\nint /*<<< orphan*/  h2o_cache_clear (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_cache_do_free_entries (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_mem_release_shared (TYPE_1__*) ;\n\nvoid h2o_cache_destroy(h2o_cache_t *cache)\n{\nh2o_cache_clear(cache);\nif ((cache->flags & H2O_CACHE_FLAG_DO_NOT_FREE_ENTRIES) == 0)\nh2o_cache_do_free_entries(cache);\nh2o_mem_release_shared(cache);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ssl_cipher",
    "input":"\n0000000000000000 <h2o_socket_get_ssl_cipher>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rdi), %rax\n4: \ttestq\t%rax, %rax\n7: \tje\t0x32 <h2o_socket_get_ssl_cipher+0x32>\n9: \tmovq\t8(%rax), %rdi\nd: \ttestq\t%rdi, %rdi\n10: \tje\t0x24 <h2o_socket_get_ssl_cipher+0x24>\n12: \tcallq\t0x17 <h2o_socket_get_ssl_cipher+0x17>\n17: \ttestq\t%rax, %rax\n1a: \tje\t0x32 <h2o_socket_get_ssl_cipher+0x32>\n1c: \tmovq\t(%rax), %rax\n1f: \tmovq\t(%rax), %rax\n22: \tpopq\t%rcx\n23: \tretq\n24: \tmovq\t(%rax), %rdi\n27: \ttestq\t%rdi, %rdi\n2a: \tje\t0x32 <h2o_socket_get_ssl_cipher+0x32>\n2c: \tpopq\t%rax\n2d: \tjmp\t0x32 <h2o_socket_get_ssl_cipher+0x32>\n32: \txorl\t%eax, %eax\n34: \tpopq\t%rcx\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {TYPE_1__* aead; } ;\ntypedef  TYPE_3__ ptls_cipher_suite_t ;\nstruct TYPE_10__ {TYPE_2__* ssl; } ;\ntypedef  TYPE_4__ h2o_socket_t ;\nstruct TYPE_8__ {int /*<<< orphan*/ * ossl; int /*<<< orphan*/ * ptls; } ;\nstruct TYPE_7__ {char const* name; } ;\n\n/* Variables and functions */\nchar const* SSL_get_cipher_name (int /*<<< orphan*/ *) ;\nTYPE_3__* ptls_get_cipher (int /*<<< orphan*/ *) ;\n\nconst char *h2o_socket_get_ssl_cipher(h2o_socket_t *sock)\n{\nif (sock->ssl != NULL) {\nif (sock->ssl->ptls != NULL) {\nptls_cipher_suite_t *cipher = ptls_get_cipher(sock->ssl->ptls);\nif (cipher != NULL)\nreturn cipher->aead->name;\n} else if (sock->ssl->ossl != NULL) {\nreturn SSL_get_cipher_name(sock->ssl->ossl);\n}\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_3__* ssl; } ;\nstruct TYPE_9__ {TYPE_2__* ssl; TYPE_1__* quic; } ;\nstruct TYPE_8__ {int /*<<< orphan*/ * cipher; } ;\nstruct TYPE_7__ {int /*<<< orphan*/ * cipher; } ;\ntypedef  TYPE_4__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * SSL_get_cipher (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * h2o_quic_get_cipher (TYPE_3__*) ;\n\nconst char *h2o_socket_get_ssl_cipher(h2o_socket_t *sock)\n{\nif (sock->ssl == NULL)\nreturn NULL;\nif (sock->ssl->quic != NULL)\nreturn h2o_quic_get_cipher(sock->ssl->quic);\nreturn SSL_get_cipher(sock->ssl->ssl);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ssl_server_name",
    "input":"\n0000000000000000 <h2o_socket_get_ssl_server_name>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0x1b <h2o_socket_get_ssl_server_name+0x1b>\n8: \tmovq\t(%rax), %rdi\nb: \ttestq\t%rdi, %rdi\ne: \tje\t0x1b <h2o_socket_get_ssl_server_name+0x1b>\n10: \tmovl\t(%rip), %esi  # 0x16 <h2o_socket_get_ssl_server_name+0x16>\n16: \tjmp\t0x1b <h2o_socket_get_ssl_server_name+0x1b>\n1b: \txorl\t%eax, %eax\n1d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * ossl; int /*<<< orphan*/ * ptls; } ;\n\n/* Variables and functions */\nchar const* SSL_get_servername (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TLSEXT_NAMETYPE_host_name ;\nchar const* ptls_get_server_name (int /*<<< orphan*/ *) ;\n\nconst char *h2o_socket_get_ssl_server_name(const h2o_socket_t *sock)\n{\nif (sock->ssl != NULL) {\n#if H2O_USE_PICOTLS\nif (sock->ssl->ptls != NULL) {\nreturn ptls_get_server_name(sock->ssl->ptls);\n} else\n#endif\nif (sock->ssl->ossl != NULL) {\nreturn SSL_get_servername(sock->ssl->ossl, TLSEXT_NAMETYPE_host_name);\n}\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_get_servername (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TLSEXT_NAMETYPE_host_name ;\n\nconst char *h2o_socket_get_ssl_server_name(h2o_socket_t *sock)\n{\nif (sock->ssl == NULL || sock->ssl->handshake.server_name == NULL)\nreturn NULL;\nreturn SSL_get_servername(sock->ssl, TLSEXT_NAMETYPE_host_name);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_getport",
    "input":"\n0000000000000000 <h2o_socket_getport>:\n0: \tmovl\t(%rdi), %edi\n2: \tmovl\t%edi, %eax\n4: \tandl\t$-2, %eax\n7: \tcmpl\t$128, %eax\nc: \tjne\t0x13 <h2o_socket_getport+0x13>\ne: \tjmp\t0x13 <h2o_socket_getport+0x13>\n13: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n18: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_in6 {int /*<<< orphan*/  sin6_port; } ;\nstruct sockaddr_in {int /*<<< orphan*/  sin_port; } ;\nstruct sockaddr {int sa_family; } ;\ntypedef  int int32_t ;\n\n/* Variables and functions */\n#define  AF_INET 129\n#define  AF_INET6 128\nint htons (int /*<<< orphan*/ ) ;\n\nint32_t h2o_socket_getport(struct sockaddr *sa)\n{\nswitch (sa->sa_family) {\ncase AF_INET:\nreturn htons(((struct sockaddr_in *)sa)->sin_port);\ncase AF_INET6:\nreturn htons(((struct sockaddr_in6 *)sa)->sin6_port);\ndefault:\nreturn -1;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int sockfd; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint h2o_socket_get_port (int) ;\n\nint h2o_socket_getport(h2o_socket_t *sock)\n{\nint ret;\n\nif ((ret = sock->sockfd) < 0)\nreturn -1;\nif ((ret & 0x80) != 0)\nreturn h2o_socket_get_port(ret);\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_get_peername_uncached",
    "input":"\n0000000000000000 <get_peername_uncached>:\n0: \tpushq\t%rax\n1: \tmovl\t$4, 4(%rsp)\n9: \tmovl\t(%rdi), %edi\nb: \tleaq\t4(%rsp), %rdx\n10: \tcallq\t0x15 <get_peername_uncached+0x15>\n15: \tmovq\t%rax, %rcx\n18: \txorl\t%eax, %eax\n1a: \ttestq\t%rcx, %rcx\n1d: \tjne\t0x23 <get_peername_uncached+0x23>\n1f: \tmovl\t4(%rsp), %eax\n23: \tpopq\t%rcx\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  fd; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr {int dummy; } ;\ntypedef  int socklen_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nscalar_t__ getpeername (int /*<<< orphan*/ ,struct sockaddr*,int*) ;\n\nsocklen_t get_peername_uncached(h2o_socket_t *_sock, struct sockaddr *sa)\n{\nstruct st_h2o_evloop_socket_t *sock = (void *)_sock;\nsocklen_t len = sizeof(struct sockaddr_storage);\nif (getpeername(sock->fd, sa, &len) != 0)\nreturn 0;\nreturn len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr_un {int dummy; } ;\nstruct sockaddr {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct TYPE_3__ {int /*<<< orphan*/  sock; } ;\ntypedef  TYPE_1__ PGconn ;\n\n/* Variables and functions */\nscalar_t__ getpeername (int /*<<< orphan*/ ,struct sockaddr*,int*) ;\n\n__attribute__((used)) static int\nget_peername_uncached(PGconn *conn, struct sockaddr_storage *addr,\nsocklen_t *addrlen)\n{\nstruct sockaddr_storage addr_s;\nstruct sockaddr *addr_p = (struct sockaddr *) &addr_s;\nsocklen_t\tlen = sizeof(addr_s);\n\nif (getpeername(conn->sock, addr_p, &len) < 0)\nreturn -1;\n\n*addrlen = len;\n\nswitch (addr_p->sa_family)\n{\n#ifdef HAVE_UNIX_SOCKETS\ncase AF_UNIX:\n{\nstruct sockaddr_un *addr_u = (struct sockaddr_un *) addr_p;\n\nmemcpy(addr, addr_u, len);\nbreak;\n}\n#endif\n\n#ifdef HAVE_IPV6\ncase AF_INET6:\n{\nstruct sockaddr_in6 *addr_i = (struct sockaddr_in6 *) addr_p;\n\nmemcpy(addr, addr_i, len);\nbreak;\n}\n#endif\n\ncase AF_INET:\n{\nstruct sockaddr_in *addr_i = (struct sockaddr_in *) addr_p;\n\nmemcpy(addr, addr_i, len);\nbreak;\n}\n\ndefault:\n/* shouldn't happen */\nreturn -1;\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloopepoll.c.h_evloop_do_on_socket_create",
    "input":"\n0000000000000000 <evloop_do_on_socket_create>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int dummy; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void evloop_do_on_socket_create(struct st_h2o_evloop_socket_t *sock)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  evloop ;\n\n/* Variables and functions */\n\nvoid evloop_do_on_socket_create (evloop *loop, int fd) {\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_h2o_time2str_rfc1123",
    "input":"\n0000000000000000 <h2o_time2str_rfc1123>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovl\t48(%rsi), %esi\nd: \tcallq\t0x12 <h2o_time2str_rfc1123+0x12>\n12: \tmovw\t$8236, (%rax) # imm = 0x202C\n17: \tleaq\t2(%rax), %rdi\n1b: \tmovq\t40(%rbx), %rsi\n1f: \tmovl\t$2, %edx\n24: \tcallq\t0x29 <h2o_time2str_rfc1123+0x29>\n29: \tmovb\t$32, (%rax)\n2c: \tleaq\t1(%rax), %rdi\n30: \tmovl\t32(%rbx), %esi\n33: \tcallq\t0x38 <h2o_time2str_rfc1123+0x38>\n38: \tmovb\t$32, (%rax)\n3b: \tleaq\t1(%rax), %rdi\n3f: \tmovl\t$1900, %esi   # imm = 0x76C\n44: \taddq\t24(%rbx), %rsi\n48: \tmovl\t$4, %edx\n4d: \tcallq\t0x52 <h2o_time2str_rfc1123+0x52>\n52: \tmovb\t$32, (%rax)\n55: \tleaq\t1(%rax), %rdi\n59: \tmovq\t16(%rbx), %rsi\n5d: \tmovl\t$2, %edx\n62: \tcallq\t0x67 <h2o_time2str_rfc1123+0x67>\n67: \tmovb\t$58, (%rax)\n6a: \tleaq\t1(%rax), %rdi\n6e: \tmovq\t8(%rbx), %rsi\n72: \tmovl\t$2, %edx\n77: \tcallq\t0x7c <h2o_time2str_rfc1123+0x7c>\n7c: \tmovb\t$58, (%rax)\n7f: \tleaq\t1(%rax), %rdi\n83: \tmovq\t(%rbx), %rsi\n86: \tmovl\t$2, %edx\n8b: \tcallq\t0x90 <h2o_time2str_rfc1123+0x90>\n90: \tmovq\t%rax, %rbx\n93: \tmovl\t$0, %esi\n98: \tmovq\t%rax, %rdi\n9b: \tmovl\t$4, %edx\na0: \tcallq\t0xa5 <h2o_time2str_rfc1123+0xa5>\na5: \tmovb\t$0, 4(%rbx)\na9: \taddq\t$4, %rbx\nad: \tsubq\t%r14, %rbx\nb0: \tmovslq\t(%rip), %rax  # 0xb7 <h2o_time2str_rfc1123+0xb7>\nb7: \txorl\t%edi, %edi\nb9: \tcmpq\t%rax, %rbx\nbc: \tsete\t%dil\nc0: \taddq\t$8, %rsp\nc4: \tpopq\t%rbx\nc5: \tpopq\t%r14\nc7: \tjmp\t0xcc <h2o_time2str_rfc1123+0xcc>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct tm {scalar_t__ tm_sec; scalar_t__ tm_min; scalar_t__ tm_hour; scalar_t__ tm_year; int /*<<< orphan*/  tm_mon; scalar_t__ tm_mday; int /*<<< orphan*/  tm_wday; } ;\n\n/* Variables and functions */\nint H2O_TIMESTR_RFC1123_LEN ;\nint /*<<< orphan*/  assert (int) ;\nchar* emit_digits (char*,scalar_t__,int) ;\nchar* emit_mon (char*,int /*<<< orphan*/ ) ;\nchar* emit_wday (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memcpy (char*,char*,int) ;\n\nvoid h2o_time2str_rfc1123(char *buf, struct tm *gmt)\n{\nchar *p = buf;\n\n/* format: Fri, 19 Sep 2014 05:24:04 GMT */\np = emit_wday(p, gmt->tm_wday);\n*p++ = ',';\n*p++ = ' ';\np = emit_digits(p, gmt->tm_mday, 2);\n*p++ = ' ';\np = emit_mon(p, gmt->tm_mon);\n*p++ = ' ';\np = emit_digits(p, gmt->tm_year + 1900, 4);\n*p++ = ' ';\np = emit_digits(p, gmt->tm_hour, 2);\n*p++ = ':';\np = emit_digits(p, gmt->tm_min, 2);\n*p++ = ':';\np = emit_digits(p, gmt->tm_sec, 2);\nmemcpy(p, \" GMT\", 4);\np += 4;\n*p = '\\0';\n\nassert(p - buf == H2O_TIMESTR_RFC1123_LEN);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; } ;\ntypedef  TYPE_1__ h2o_time_t ;\n\n/* Variables and functions */\nint H2O_TIMESTR_RFC1123_LEN ;\nchar* h2o_mem_alloc_pool (size_t,int) ;\nchar* h2o_mem_alloc_pool_relative (char*,size_t,int) ;\nchar* h2o_mem_alloc_pool_relative_str (char*,char*,int) ;\n\nchar *h2o_time2str_rfc1123(char *buf, h2o_time_t *ltime)\n{\nchar *p = buf;\n\np = h2o_mem_alloc_pool_relative(p, ltime->tm_wday, 3);\n*p++ = ',';\np = h2o_mem_alloc_pool_relative(p, ltime->tm_mday, 2);\n*p++ = ' ';\np = h2o_mem_alloc_pool_relative(p, ltime->tm_mon, 3);\n*p++ = ' ';\np = h2o_mem_alloc_pool_relative(p, ltime->tm_year + 1900, 4);\n*p++ = ' ';\np = h2o_mem_alloc_pool_relative(p, ltime->tm_hour, 2);\n*p++ = ':';\np = h2o_mem_alloc_pool_relative(p, ltime->tm_min, 2);\n*p++ = ':';\np = h2o_mem_alloc_pool_relative(p, ltime->tm_sec, 2);\n*p++ = ' ';\np = h2o_mem_alloc_pool_relative(p, \"GMT\", 3);\n*p++ = '\\0';\n\n/* sanity check */\n{\nsize_t len = p - buf;\nassert(len == H2O_TIMESTR_RFC1123_LEN);\n}\n\nreturn buf;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_sem_destroy",
    "input":"\n0000000000000000 <h2o_sem_destroy>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t(%rdi), %rax\n7: \txorl\t%edi, %edi\n9: \tcmpq\t8(%rbx), %rax\nd: \tsete\t%dil\n11: \tcallq\t0x16 <h2o_sem_destroy+0x16>\n16: \tleaq\t20(%rbx), %rdi\n1a: \tcallq\t0x1f <h2o_sem_destroy+0x1f>\n1f: \taddq\t$16, %rbx\n23: \tmovq\t%rbx, %rdi\n26: \tpopq\t%rbx\n27: \tjmp\t0x2c <h2o_sem_destroy+0x2c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ _cur; scalar_t__ _capacity; int /*<<< orphan*/  _mutex; int /*<<< orphan*/  _cond; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  pthread_cond_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_destroy (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_destroy(h2o_sem_t *sem)\n{\nassert(sem->_cur == sem->_capacity);\npthread_cond_destroy(&sem->_cond);\npthread_mutex_destroy(&sem->_mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ count; scalar_t__ max; int /*<<< orphan*/  cond; int /*<<< orphan*/  mutex; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  pthread_cond_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_destroy (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_destroy(h2o_sem_t *sem)\n{\nassert(sem->count == 0);\npthread_mutex_destroy(&sem->mutex);\npthread_cond_destroy(&sem->cond);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_lock_cache",
    "input":"\n0000000000000000 <lock_cache>:\n0: \tmovl\t(%rip), %eax  # 0x6 <lock_cache+0x6>\n6: \ttestl\t%eax, (%rdi)\n8: \tje\t0x13 <lock_cache+0x13>\na: \taddq\t$4, %rdi\ne: \tjmp\t0x13 <lock_cache+0x13>\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  mutex; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\nint H2O_CACHE_FLAG_MULTITHREADED ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void lock_cache(h2o_cache_t *cache)\n{\nif ((cache->flags & H2O_CACHE_FLAG_MULTITHREADED) != 0)\npthread_mutex_lock(&cache->mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  lock; } ;\ntypedef  TYPE_1__ cache_t ;\n\n/* Variables and functions */\nint CACHE_FLAG_LOCKED ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void lock_cache (cache_t *cache) {\nif (cache->flags & CACHE_FLAG_LOCKED) {\npthread_mutex_lock (&cache->lock);\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_init_async",
    "input":"\n0000000000000000 <init_async>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$128, %rsp\nb: \tmovq\t%rsi, %r14\ne: \tmovq\t%rdi, %rbx\n11: \tmovl\t(%rip), %esi  # 0x17 <init_async+0x17>\n17: \torl\t(%rip), %esi  # 0x1d <init_async+0x1d>\n1d: \txorl\t%edi, %edi\n1f: \tcallq\t0x24 <init_async+0x24>\n24: \tmovl\t%eax, %ebp\n26: \tcmpl\t$-1, %eax\n29: \tjne\t0x4a <init_async+0x4a>\n2b: \tmovl\t(%rip), %edi  # 0x31 <init_async+0x31>\n31: \tmovq\t%rsp, %rsi\n34: \tmovl\t$128, %edx\n39: \tcallq\t0x3e <init_async+0x3e>\n3e: \tmovl\t$0, %edi\n43: \tmovl\t%eax, %esi\n45: \tcallq\t0x4a <init_async+0x4a>\n4a: \tmovl\t%ebp, (%rbx)\n4c: \tmovq\t%r14, %rdi\n4f: \tmovl\t%ebp, %esi\n51: \txorl\t%edx, %edx\n53: \tcallq\t0x58 <init_async+0x58>\n58: \tmovq\t%rax, 8(%rbx)\n5c: \tmovq\t%rbx, (%rax)\n5f: \tmovl\t(%rip), %esi  # 0x65 <init_async+0x65>\n65: \tmovq\t%rax, %rdi\n68: \tcallq\t0x6d <init_async+0x6d>\n6d: \taddq\t$128, %rsp\n74: \tpopq\t%rbx\n75: \tpopq\t%r14\n77: \tpopq\t%rbp\n78: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_4__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int write; TYPE_4__* read; } ;\nstruct TYPE_6__ {TYPE_1__ async; } ;\ntypedef  TYPE_2__ h2o_multithread_queue_t ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\ntypedef  int /*<<< orphan*/  buf ;\nstruct TYPE_7__ {TYPE_2__* data; } ;\n\n/* Variables and functions */\nint EFD_CLOEXEC ;\nint EFD_NONBLOCK ;\nint /*<<< orphan*/  F_SETFL ;\nint /*<<< orphan*/  O_NONBLOCK ;\nscalar_t__ cloexec_pipe (int*) ;\nint /*<<< orphan*/  errno ;\nint eventfd (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  fcntl (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nvoid* h2o_evloop_socket_create (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_fatal (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_read_start (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_strerror_r (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  on_read ;\n\n__attribute__((used)) static void init_async(h2o_multithread_queue_t *queue, h2o_loop_t *loop)\n{\n#if defined(__linux__)\n/**\n* The kernel overhead of an eventfd file descriptor is\n* much lower than that of a pipe, and only one file descriptor is required\n*/\nint fd;\nchar buf[128];\n\nfd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);\nif (fd == -1) {\nh2o_fatal(\"eventfd: %s\", h2o_strerror_r(errno, buf, sizeof(buf)));\n}\nqueue->async.write = fd;\nqueue->async.read = h2o_evloop_socket_create(loop, fd, 0);\n#else\nint fds[2];\nchar buf[128];\n\nif (cloexec_pipe(fds) != 0) {\nh2o_fatal(\"pipe: %s\", h2o_strerror_r(errno, buf, sizeof(buf)));\n}\nfcntl(fds[1], F_SETFL, O_NONBLOCK);\nqueue->async.write = fds[1];\nqueue->async.read = h2o_evloop_socket_create(loop, fds[0], 0);\n#endif\nqueue->async.read->data = queue;\nh2o_socket_read_start(queue->async.read, on_read);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/ * async_ctx; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  fd; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ SSL ;\ntypedef  TYPE_2__ BIO ;\ntypedef  TYPE_3__ SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_C_SET_FD ;\nint /*<<< orphan*/  BIO_C_SET_SSL ;\nint /*<<< orphan*/  BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_bio () ;\nint /*<<< orphan*/  BIO_set_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_set_ssl (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_set_write_buffer_size (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  BIO_s_null () ;\nint /*<<< orphan*/  BIO_s_socket () ;\nint /*<<< orphan*/  BIO_s_socket_nbio () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_accept_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_accept () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio () ;\nint /*<<< orphan*/  BIO_s_socket_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect_accept_wait_fd_nbio_connect () ;\nint /*<<< or"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_read_start",
    "input":"\n0000000000000000 <h2o_socket_read_start>:\n0: \tmovl\t%esi, (%rdi)\n2: \tjmp\t0x7 <h2o_socket_read_start+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  read; } ;\nstruct TYPE_6__ {TYPE_1__ _cb; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_read_start (TYPE_2__*) ;\n\nvoid h2o_socket_read_start(h2o_socket_t *sock, h2o_socket_cb cb)\n{\nsock->_cb.read = cb;\ndo_read_start(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_socket_read_task_t {int /*<<< orphan*/  cb; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_cb ;\nstruct st_h2o_socket_t {int /*<<< orphan*/  read; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_socket_read_start_internal (struct st_h2o_socket_t*,int /*<<< orphan*/ ) ;\n\nvoid h2o_socket_read_start(struct st_h2o_socket_t *sock, h2o_socket_cb cb)\n{\nstruct st_h2o_socket_read_task_t *task = (void *)sock->read;\ntask->cb = cb;\nh2o_socket_read_start_internal(sock, cb);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_httpclient.c_test_lib__common__httpclient_c",
    "input":"\n0000000000000000 <test_lib__common__httpclient_c>:\n0: \tmovl\t(%rip), %esi  # 0x6 <test_lib__common__httpclient_c+0x6>\n6: \tmovl\t$0, %edi\nb: \tjmp\t0x10 <test_lib__common__httpclient_c+0x10>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_should_use_h2 ;\n\nvoid test_lib__common__httpclient_c(void)\n{\nsubtest(\"should_use_h2\", test_should_use_h2);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_LIB__COMMON__HTTPCLIENT_C ;\nint test_lib__common__httpclient (char*,int /*<<< orphan*/ ) ;\n\nint test_lib__common__httpclient_c() {\nreturn test_lib__common__httpclient(\"test_lib__common__httpclient_c\", TEST_LIB__COMMON__HTTPCLIENT_C);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_dispose_socket",
    "input":"\n0000000000000000 <dispose_socket>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %rbx\n8: \tmovq\t32(%rdi), %rdi\nc: \ttestq\t%rdi, %rdi\nf: \tje\t0x1e <dispose_socket+0x1e>\n11: \tcallq\t0x16 <dispose_socket+0x16>\n16: \tmovq\t$0, 32(%rbx)\n1e: \tleaq\t24(%rbx), %rdi\n22: \tcallq\t0x27 <dispose_socket+0x27>\n27: \tmovq\t16(%rbx), %rdi\n2b: \ttestq\t%rdi, %rdi\n2e: \tje\t0x3d <dispose_socket+0x3d>\n30: \tcallq\t0x35 <dispose_socket+0x35>\n35: \tmovq\t$0, 16(%rbx)\n3d: \tmovq\t(%rbx), %r15\n40: \tmovq\t8(%rbx), %r14\n44: \tmovq\t%rbx, %rdi\n47: \tcallq\t0x4c <dispose_socket+0x4c>\n4c: \ttestq\t%r15, %r15\n4f: \tje\t0x5e <dispose_socket+0x5e>\n51: \tmovq\t%r15, %rax\n54: \tmovq\t%r14, %rdi\n57: \tpopq\t%rbx\n58: \tpopq\t%r14\n5a: \tpopq\t%r15\n5c: \tjmpq\t*%rax\n5e: \tpopq\t%rbx\n5f: \tpopq\t%r14\n61: \tpopq\t%r15\n63: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {void (* cb ) (void*) ;void* data; } ;\nstruct TYPE_6__ {TYPE_1__ on_close; int /*<<< orphan*/ * _peername; int /*<<< orphan*/  input; int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  destroy_ssl (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  do_dispose_socket (TYPE_2__*) ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_buffer_dispose (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void dispose_socket(h2o_socket_t *sock, const char *err)\n{\nvoid (*close_cb)(void *data);\nvoid *close_cb_data;\n\nif (sock->ssl != NULL) {\ndestroy_ssl(sock->ssl);\nsock->ssl = NULL;\n}\nh2o_buffer_dispose(&sock->input);\nif (sock->_peername != NULL) {\nfree(sock->_peername);\nsock->_peername = NULL;\n}\n\nclose_cb = sock->on_close.cb;\nclose_cb_data = sock->on_close.data;\n\ndo_dispose_socket(sock);\n\nif (close_cb != NULL)\nclose_cb(close_cb_data);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  (* dispose ) (TYPE_1__*,TYPE_2__*) ;} ;\nstruct TYPE_4__ {int /*<<< orphan*/ * private_data; int /*<<< orphan*/ * private_data_free; int /*<<< orphan*/ * private_data_dispose; int /*<<< orphan*/ * private_data_init; int /*<<< orphan*/ * private_data_init_free; } ;\ntypedef  TYPE_1__ socket_t ;\ntypedef  TYPE_2__ connection_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  stub1 (TYPE_1__*,TYPE_2__*) ;\n\n__attribute__((used)) static void dispose_socket(socket_t *s)\n{\nif (s->private_data_init)\n{\nfree(s->private_data_init);\ns->private_data_init = NULL;\n}\nif (s->private_data_init_free)\n{\nfree(s->private_data_init_free);\ns->private_data_init_free = NULL;\n}\nif (s->private_data_dispose)\n{\nfree(s->private_data_dispose);\ns->private_data_dispose = NULL;\n}\nif (s->private_data_free)\n{\nfree(s->private_data_free);\ns->private_data_free = NULL;\n}\nif (s->private_data)\n{\ns->private_data->dispose(s, s);\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontimerwheel.c_timer_slot",
    "input":"\n0000000000000000 <timer_slot>:\n0: \tmovq\t%rdi, %rcx\n3: \timull\t(%rip), %ecx  # 0xa <timer_slot+0xa>\na: \tmovq\t%rsi, %rax\nd: \tshrq\t%cl, %rax\n10: \tandq\t(%rip), %rax  # 0x17 <timer_slot+0x17>\n17: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t uint64_t ;\n\n/* Variables and functions */\nsize_t H2O_TIMERWHEEL_BITS_PER_WHEEL ;\nsize_t H2O_TIMERWHEEL_SLOTS_MASK ;\n\n__attribute__((used)) static size_t timer_slot(size_t wheel, uint64_t expire)\n{\nreturn H2O_TIMERWHEEL_SLOTS_MASK & (expire >> (wheel * H2O_TIMERWHEEL_BITS_PER_WHEEL));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint TIMER_SLOT_BITS ;\nint TIMER_SLOT_MASK ;\n\n__attribute__((used)) static inline int timer_slot (int t, int slot) {\nreturn (t >> (slot * TIMER_SLOT_BITS)) & TIMER_SLOT_MASK;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontimerwheel.c_h2o_timerwheel_validate",
    "input":"\n0000000000000000 <h2o_timerwheel_validate>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t(%rdi), %rax\na: \ttestq\t%rax, %rax\nd: \tje\t0x78 <h2o_timerwheel_validate+0x78>\nf: \tmovq\t%rdi, %r14\n12: \tmovl\t$1, %ebp\n17: \tmovq\t(%rip), %rcx  # 0x1e <h2o_timerwheel_validate+0x1e>\n1e: \txorl\t%r15d, %r15d\n21: \tjmp\t0x3b <h2o_timerwheel_validate+0x3b>\n23: \tnopw\t%cs:(%rax,%rax)\n2d: \tnopl\t(%rax)\n30: \txorl\t%ecx, %ecx\n32: \taddq\t$1, %r15\n36: \tcmpq\t%rax, %r15\n39: \tjae\t0x7d <h2o_timerwheel_validate+0x7d>\n3b: \ttestq\t%rcx, %rcx\n3e: \tje\t0x30 <h2o_timerwheel_validate+0x30>\n40: \txorl\t%ebx, %ebx\n42: \tnopw\t%cs:(%rax,%rax)\n4c: \tnopl\t(%rax)\n50: \tmovq\t%r14, %rdi\n53: \tmovq\t%r15, %rsi\n56: \tmovq\t%rbx, %rdx\n59: \tcallq\t0x5e <h2o_timerwheel_validate+0x5e>\n5e: \ttestl\t%eax, %eax\n60: \tcmovel\t%eax, %ebp\n63: \taddq\t$1, %rbx\n67: \tmovq\t(%rip), %rcx  # 0x6e <h2o_timerwheel_validate+0x6e>\n6e: \tcmpq\t%rcx, %rbx\n71: \tjb\t0x50 <h2o_timerwheel_validate+0x50>\n73: \tmovq\t(%r14), %rax\n76: \tjmp\t0x32 <h2o_timerwheel_validate+0x32>\n78: \tmovl\t$1, %ebp\n7d: \tmovl\t%ebp, %eax\n7f: \taddq\t$8, %rsp\n83: \tpopq\t%rbx\n84: \tpopq\t%r14\n86: \tpopq\t%r15\n88: \tpopq\t%rbp\n89: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t num_wheels; } ;\ntypedef  TYPE_1__ h2o_timerwheel_t ;\n\n/* Variables and functions */\nsize_t H2O_TIMERWHEEL_SLOTS_PER_WHEEL ;\nint /*<<< orphan*/  validate_slot (TYPE_1__*,size_t,size_t) ;\n\nint h2o_timerwheel_validate(h2o_timerwheel_t *ctx)\n{\nsize_t wheel, slot;\nint success = 1;\n\nfor (wheel = 0; wheel < ctx->num_wheels; ++wheel)\nfor (slot = 0; slot < H2O_TIMERWHEEL_SLOTS_PER_WHEEL; ++slot)\nif (!validate_slot(ctx, wheel, slot))\nsuccess = 0;\n\nreturn success;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__* slots; } ;\ntypedef  TYPE_1__ h2o_timerwheel_t ;\n\n/* Variables and functions */\nscalar_t__ H2O_TIMERWHEEL_SLOT_SIZE ;\nint h2o_timerwheel_slot_validate (TYPE_1__*,size_t,scalar_t__) ;\n\n__attribute__((used)) static int h2o_timerwheel_validate(h2o_timerwheel_t *tw)\n{\nsize_t slot;\n\nfor (slot = 0; slot < H2O_TIMERWHEEL_SLOT_SIZE; ++slot) {\nint valid = 1;\nfor (size_t i = 0; i != H2O_TIMERWHEEL_SLOT_SIZE; ++i) {\nvalid &= h2o_timerwheel_slot_validate(tw, slot, i);\n}\nif (!valid)\nreturn 0;\n}\nreturn 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_timerwheel.c_test_add_rand_timers",
    "input":"\n0000000000000000 <test_add_rand_timers>:\n0: \tpushq\t%rbp\n1: \tmovq\t%rsp, %rbp\n4: \tpushq\t%r15\n6: \tpushq\t%r14\n8: \tpushq\t%r12\na: \tpushq\t%rbx\nb: \tmovl\t$6, %edi\n10: \tmovl\t$3, %esi\n15: \tcallq\t0x1a <test_add_rand_timers+0x1a>\n1a: \tmovq\t%rax, %r14\n1d: \tmovl\t(%rip), %esi  # 0x23 <test_add_rand_timers+0x23>\n23: \tmovq\t%rsp, %r12\n26: \tleaq\t15(,%rsi,4), %rax\n2e: \tandq\t$-16, %rax\n32: \tsubq\t%rax, %r12\n35: \tmovq\t%r12, %rsp\n38: \ttestl\t%esi, %esi\n3a: \tjle\t0x85 <test_add_rand_timers+0x85>\n3c: \txorl\t%ebx, %ebx\n3e: \tnop\n40: \txorl\t%eax, %eax\n42: \tcallq\t0x47 <test_add_rand_timers+0x47>\n47: \tcltd\n48: \tidivl\t(%rip)   # 0x4e <test_add_rand_timers+0x4e>\n4e: \tmovl\t%edx, %r15d\n51: \taddl\t$3, %r15d\n55: \tmovl\t(%rip), %esi  # 0x5b <test_add_rand_timers+0x5b>\n5b: \tmovq\t%r12, %rdi\n5e: \tcallq\t0x63 <test_add_rand_timers+0x63>\n63: \tmovq\t%r14, %rdi\n66: \tmovq\t%r12, %rsi\n69: \tmovl\t%r15d, %edx\n6c: \tcallq\t0x71 <test_add_rand_timers+0x71>\n71: \taddq\t$1, %rbx\n75: \tmovslq\t(%rip), %rsi  # 0x7c <test_add_rand_timers+0x7c>\n7c: \taddq\t$4, %r12\n80: \tcmpq\t%rsi, %rbx\n83: \tjl\t0x40 <test_add_rand_timers+0x40>\n85: \tmovl\t(%rip), %ebx  # 0x8b <test_add_rand_timers+0x8b>\n8b: \taddl\t$2, %esi\n8e: \tmovq\t%r14, %rdi\n91: \tcallq\t0x96 <test_add_rand_timers+0x96>\n96: \txorl\t%edi, %edi\n98: \tcmpl\t(%rip), %eax  # 0x9e <test_add_rand_timers+0x9e>\n9e: \tsete\t%dil\na2: \tcallq\t0xa7 <test_add_rand_timers+0xa7>\na7: \tmovl\t(%rip), %eax  # 0xad <test_add_rand_timers+0xad>\nad: \tsubl\t%ebx, %eax\naf: \txorl\t%edi, %edi\nb1: \tcmpl\t(%rip), %eax  # 0xb7 <test_add_rand_timers+0xb7>\nb7: \tsete\t%dil\nbb: \tcallq\t0xc0 <test_add_rand_timers+0xc0>\nc0: \tmovq\t%r14, %rdi\nc3: \tcallq\t0xc8 <test_add_rand_timers+0xc8>\nc8: \tmovq\t%r14, %rdi\ncb: \tcallq\t0xd0 <test_add_rand_timers+0xd0>\nd0: \tleaq\t-32(%rbp), %rsp\nd4: \tpopq\t%rbx\nd5: \tpopq\t%r12\nd7: \tpopq\t%r14\nd9: \tpopq\t%r15\ndb: \tpopq\t%rbp\ndc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint32_t ;\ntypedef  int /*<<< orphan*/  h2o_timerwheel_t ;\ntypedef  int /*<<< orphan*/  h2o_timerwheel_entry_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DUMP_WHEEL (int /*<<< orphan*/ *) ;\nint N ;\nint /*<<< orphan*/ * h2o_timerwheel_create (int,int) ;\nint /*<<< orphan*/  h2o_timerwheel_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timerwheel_init_entry (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timerwheel_link_abs (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint h2o_timerwheel_run (int /*<<< orphan*/ *,int) ;\nint invokes ;\nint lcg_rand () ;\nint /*<<< orphan*/  my_callback ;\nint /*<<< orphan*/  ok (int) ;\n\nvoid test_add_rand_timers()\n{\nuint32_t abs_wtime = 3;\nh2o_timerwheel_t *testwheel = h2o_timerwheel_create(6, abs_wtime);\nh2o_timerwheel_entry_t timers[N];\nint i;\n\n/* add timers */\nfor (i = 0; i < N; i++) {\nuint32_t expiry = abs_wtime + lcg_rand() % N;\nh2o_timerwheel_init_entry(&timers[i], my_callback);\nh2o_timerwheel_link_abs(testwheel, &timers[i], expiry);\n}\n\nint start = invokes;\n/* run the wheel: the timers has a max expiry N-1 + abs_wtime  */\nok(h2o_timerwheel_run(testwheel, N - 1 + abs_wtime) == N);\nok(invokes - start == N);\nDUMP_WHEEL(testwheel);\n\nh2o_timerwheel_destroy(testwheel);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  timer_t ;\ntypedef  int /*<<< orphan*/  timer_list ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TIMER_RELTIME ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  create_timer_list (int,int) ;\nint /*<<< orphan*/  delete_timer_list (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  get_rand_time () ;\nint /*<<< orphan*/  init_timer_list (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  insert_timer_list (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  remove_timer_list (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  test_timer_list ;\nint /*<<< orphan*/  test_timer_list_size ;\nint /*<<< orphan*/  test_timer_list_size_max ;\nint /*<<< orphan*/  test_timer_list_size_min ;\n\n__attribute__((used)) static void test_add_rand_timers(void)\n{\nint i;\ntimer_t *timer;\ntimer_list *list = create_timer_list(6, 3);\n\nfor (i = 0; i < test_timer_list_size; i++)\n{\nint time = get_rand_time() % test_timer_list_size_max + test_timer_list_size_min + 3;\n\ninit_timer_list(list, TIMER_RELTIME);\ninsert_timer_list(list, timer = &test_timer_list[i], time);\nremove_timer_list(list, timer);\n}\n\nassert(!delete_timer_list(list));\nassert(test_timer_list_size == test_timer_list_size_max - test_timer_list_size_min - 2);\ndelete_timer_list(list);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_multithread.c_on_ping",
    "input":"\n0000000000000000 <on_ping>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tmovq\t%rsi, %rdi\n7: \tjmp\t0x1d <on_ping+0x1d>\n9: \tnopl\t(%rax)\n10: \tmovl\t$0, %edi\n15: \tcallq\t0x1a <on_ping+0x1a>\n1a: \tmovq\t%rbx, %rdi\n1d: \tcallq\t0x22 <on_ping+0x22>\n22: \ttestl\t%eax, %eax\n24: \tjne\t0x5b <on_ping+0x5b>\n26: \tmovq\t%rbx, %rdi\n29: \tcallq\t0x2e <on_ping+0x2e>\n2e: \tmovl\t(%rip), %eax  # 0x34 <on_ping+0x34>\n34: \tleal\t1(%rax), %ecx\n37: \tmovl\t%ecx, (%rip)  # 0x3d <on_ping+0x3d>\n3d: \tcmpl\t$98, %eax\n40: \tjle\t0x10 <on_ping+0x10>\n42: \tmovl\t$0, %edi\n47: \tcallq\t0x4c <on_ping+0x4c>\n4c: \tmovl\t$1, (%rip)    # 0x56 <on_ping+0x56>\n56: \tmovq\t%rbx, %rdi\n59: \tjmp\t0x1d <on_ping+0x1d>\n5b: \tpopq\t%rbx\n5c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_multithread_receiver_t ;\ntypedef  int /*<<< orphan*/  h2o_linklist_t ;\nstruct TYPE_4__ {int /*<<< orphan*/  shutdown_receiver; int /*<<< orphan*/  pong_receiver; } ;\nstruct TYPE_3__ {int num_ping_received; int should_exit; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_is_empty (int /*<<< orphan*/ *) ;\nTYPE_2__ main_thread ;\nint /*<<< orphan*/  pop_empty_message (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  send_empty_message (int /*<<< orphan*/ *) ;\nTYPE_1__ worker_thread ;\n\n__attribute__((used)) static void on_ping(h2o_multithread_receiver_t *receiver, h2o_linklist_t *list)\n{\nwhile (!h2o_linklist_is_empty(list)) {\npop_empty_message(list);\nif (++worker_thread.num_ping_received < 100) {\nsend_empty_message(&main_thread.pong_receiver);\n} else {\nsend_empty_message(&main_thread.shutdown_receiver);\nworker_thread.should_exit = 1;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  lua_pushstring (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  lua_pushvalue (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_setglobal (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_tostring (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_yield (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_yieldk (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_yieldk_aux ;\nint /*<<< orphan*/  lua_yieldk_aux_arg ;\nint /*<<< orphan*/  lua_yieldk_aux_arg2 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg3 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg4 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg5 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg6 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg7 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg8 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg9 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg10 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg11 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg12 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg13 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg14 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg15 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg16 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg17 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg18 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg19 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg20 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg21 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg22 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg23 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg24 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg25 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg26 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg27 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg28 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg29 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg30 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg31 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg32 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg33 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg34 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg35 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg36 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg37 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg38 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg39 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg40 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg41 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg42 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg43 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg44 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg45 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg46 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg47 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg48 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg49 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg50 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg51 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg52 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg53 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg54 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg55 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg56 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg57 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg58 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg59 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg60 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg61 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg62 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg63 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg64 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg65 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg66 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg67 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg68 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg69 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg70 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg71 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg72 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg73 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg74 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg75 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg76 ;\nint /*<<< orphan*/  lua_yieldk_aux_arg77 ;\nint /*<<< orphan"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_clear_output_buffer",
    "input":"\n0000000000000000 <clear_output_buffer>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \taddq\t$4, %rdi\n8: \txorl\t%esi, %esi\na: \tmovl\t$4, %edx\nf: \tcallq\t0x14 <clear_output_buffer+0x14>\n14: \tmovq\t%rbx, %rdi\n17: \tpopq\t%rbx\n18: \tjmp\t0x1d <clear_output_buffer+0x1d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  pool; int /*<<< orphan*/  bufs; } ;\nstruct st_h2o_socket_ssl_t {TYPE_1__ output; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mem_clear_pool (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void clear_output_buffer(struct st_h2o_socket_ssl_t *ssl)\n{\nmemset(&ssl->output.bufs, 0, sizeof(ssl->output.bufs));\nh2o_mem_clear_pool(&ssl->output.pool);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  output_buffer; int /*<<< orphan*/  output_buffer_size; } ;\ntypedef  TYPE_1__ fz_output ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_free (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void\nclear_output_buffer(fz_output *out)\n{\nmemset(&out->output_buffer[0], 0, out->output_buffer_size);\nfz_free(out, out->output_buffer);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_import",
    "input":"\n0000000000000000 <h2o_socket_import>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \txorl\t%edi, %edi\nc: \tcmpl\t$-1, (%rsi)\nf: \tsetne\t%dil\n13: \tcallq\t0x18 <h2o_socket_import+0x18>\n18: \tmovq\t%rbx, %rdi\n1b: \tmovq\t%r14, %rsi\n1e: \tcallq\t0x23 <h2o_socket_import+0x23>\n23: \tmovq\t%rax, %rbx\n26: \tmovl\t$4294967295, (%r14)# imm = 0xFFFFFFFF\n2d: \tmovq\t8(%r14), %rax\n31: \tmovq\t%rax, 8(%rbx)\n35: \ttestq\t%rax, %rax\n38: \tje\t0x50 <h2o_socket_import+0x50>\n3a: \tmovq\t%rbx, %rdi\n3d: \tcallq\t0x42 <h2o_socket_import+0x42>\n42: \tmovq\t8(%rbx), %rdi\n46: \tmovl\t$0, %esi\n4b: \tcallq\t0x50 <h2o_socket_import+0x50>\n50: \tmovl\t4(%r14), %eax\n54: \tmovl\t%eax, (%rbx)\n56: \tmovl\t$0, %esi\n5b: \tmovq\t%rbx, %rdi\n5e: \tcallq\t0x63 <h2o_socket_import+0x63>\n63: \tmovq\t%rbx, %rax\n66: \taddq\t$8, %rsp\n6a: \tpopq\t%rbx\n6b: \tpopq\t%r14\n6d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_4__ ;\ntypedef  struct TYPE_12__   TYPE_3__ ;\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_12__ {int /*<<< orphan*/  input; TYPE_2__* ssl; } ;\ntypedef  TYPE_3__ h2o_socket_t ;\nstruct TYPE_13__ {int fd; int /*<<< orphan*/  input; TYPE_2__* ssl; } ;\ntypedef  TYPE_4__ h2o_socket_export_t ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\nstruct TYPE_10__ {int /*<<< orphan*/  encrypted; } ;\nstruct TYPE_11__ {TYPE_1__ input; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nTYPE_3__* do_import (int /*<<< orphan*/ *,TYPE_4__*) ;\nint /*<<< orphan*/  h2o_buffer_set_prototype (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_buffer_prototype ;\nint /*<<< orphan*/  setup_bio (TYPE_3__*) ;\n\nh2o_socket_t *h2o_socket_import(h2o_loop_t *loop, h2o_socket_export_t *info)\n{\nh2o_socket_t *sock;\n\nassert(info->fd != -1);\n\nsock = do_import(loop, info);\ninfo->fd = -1; /* just in case */\nif ((sock->ssl = info->ssl) != NULL) {\nsetup_bio(sock);\nh2o_buffer_set_prototype(&sock->ssl->input.encrypted, &h2o_socket_buffer_prototype);\n}\nsock->input = info->input;\nh2o_buffer_set_prototype(&sock->input, &h2o_socket_buffer_prototype);\nreturn sock;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int fd; int /*<<< orphan*/  flags; int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_ssl_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_socket_set_nonblocking (TYPE_1__*) ;\nTYPE_1__* h2o_socket_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_set_ssl (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_set_timeout (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_write_timeout (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nh2o_socket_t *h2o_socket_import(h2o_socket_t *src, h2o_socket_ssl_t *ssl)\n{\nh2o_socket_t *sock;\n\nassert(src->fd != -1);\nsock = h2o_socket_create(NULL, ssl);\nsock->fd = src->fd;\nsock->data = src->data;\nif (sock->data != NULL)\nh2o_socket_set_ssl(sock, ssl);\nh2o_socket_set_timeout(sock, src->flags);\nh2o_socket_set_write_timeout(sock, src->flags);\nif (ssl != NULL)\nh2o_socket_set_nonblocking(sock);\nreturn sock;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_write_pending",
    "input":"\n0000000000000000 <write_pending>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovq\t%rdi, %rbx\nc: \txorl\t%edi, %edi\ne: \tcmpq\t$0, 32(%rbx)\n13: \tsetne\t%dil\n17: \tcallq\t0x1c <write_pending+0x1c>\n1c: \tcmpq\t$0, 8(%rbx)\n21: \tje\t0x4b <write_pending+0x4b>\n23: \tleaq\t8(%rbx), %r15\n27: \tmovl\t24(%rbx), %edi\n2a: \tleaq\t16(%rbx), %r14\n2e: \tleaq\t8(%rsp), %rcx\n33: \tmovq\t%r14, %rsi\n36: \tmovq\t%r15, %rdx\n39: \tcallq\t0x3e <write_pending+0x3e>\n3e: \ttestq\t%rax, %rax\n41: \tje\t0x6d <write_pending+0x6d>\n43: \tmovq\t%rbx, %rdi\n46: \tcallq\t0x4b <write_pending+0x4b>\n4b: \tmovl\t(%rip), %eax  # 0x51 <write_pending+0x51>\n51: \torl\t%eax, (%rbx)\n53: \tmovq\t%rbx, %rdi\n56: \tcallq\t0x5b <write_pending+0x5b>\n5b: \tmovq\t%rbx, %rdi\n5e: \tcallq\t0x63 <write_pending+0x63>\n63: \taddq\t$16, %rsp\n67: \tpopq\t%rbx\n68: \tpopq\t%r14\n6a: \tpopq\t%r15\n6c: \tretq\n6d: \tcmpq\t$0, (%r15)\n71: \tje\t0x43 <write_pending+0x43>\n73: \tmovq\t8(%rsp), %rax\n78: \tmovq\t(%r14), %rcx\n7b: \taddq\t%rax, (%rcx)\n7e: \tmovq\t8(%rsp), %rax\n83: \tsubq\t%rax, 8(%rcx)\n87: \tjmp\t0x63 <write_pending+0x63>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {scalar_t__ cnt; TYPE_4__* bufs; } ;\nstruct TYPE_5__ {int /*<<< orphan*/ * write; } ;\nstruct TYPE_6__ {TYPE_1__ _cb; } ;\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  _flags; TYPE_3__ _wreq; int /*<<< orphan*/  fd; TYPE_2__ super; } ;\nstruct TYPE_8__ {size_t base; size_t len; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_FLAG_IS_WRITE_NOTIFY ;\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  link_to_pending (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  link_to_statechanged (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  wreq_free_buffer_if_allocated (struct st_h2o_evloop_socket_t*) ;\nscalar_t__ write_core (int /*<<< orphan*/ ,TYPE_4__**,scalar_t__*,size_t*) ;\n\nvoid write_pending(struct st_h2o_evloop_socket_t *sock)\n{\nsize_t first_buf_written;\n\nassert(sock->super._cb.write != NULL);\n\n/* DONT_WRITE poll */\nif (sock->_wreq.cnt == 0)\ngoto Complete;\n\n/* write */\nif (write_core(sock->fd, &sock->_wreq.bufs, &sock->_wreq.cnt, &first_buf_written) == 0 && sock->_wreq.cnt != 0) {\n/* partial write */\nsock->_wreq.bufs[0].base += first_buf_written;\nsock->_wreq.bufs[0].len -= first_buf_written;\nreturn;\n}\n\n/* either completed or failed */\nwreq_free_buffer_if_allocated(sock);\n\nComplete:\nsock->_flags |= H2O_SOCKET_FLAG_IS_WRITE_NOTIFY;\nlink_to_pending(sock);\nlink_to_statechanged(sock); /* might need to disable the write polling */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ pending_bytes; scalar_t__ pending_bytes_total; scalar_t__ pending_bytes_max; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  pending_bytes; TYPE_3__* stats; TYPE_1__* out; TYPE_2__* in; } ;\nstruct TYPE_8__ {scalar_t__ pending_bytes; } ;\ntypedef  TYPE_2__ GLogSocket ;\ntypedef  TYPE_3__ GLogStats ;\ntypedef  TYPE_1__ GLogBuffer ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  flush_buffer (TYPE_2__*) ;\nint /*<<< orphan*/  flush_stats (TYPE_3__*) ;\nscalar_t__ g_write (int /*<<< orphan*/ ,TYPE_1__*,TYPE_2__*,scalar_t__*) ;\nint /*<<< orphan*/  pending_bytes ;\n\n__attribute__((used)) static void\nwrite_pending (GLogSocket *s)\n{\nassert (s->in != NULL);\nif (s->out != NULL)\n{\nif (g_write (s->in->pending_bytes, s->out, s->in, &s->in->pending_bytes))\n{\nflush_buffer (s->out);\n}\n}\ns->stats->pending_bytes |= pending_bytes;\nflush_stats (s->stats);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ssl_protocol_version",
    "input":"\n0000000000000000 <h2o_socket_get_ssl_protocol_version>:\n0: \tmovq\t(%rdi), %rcx\n3: \ttestq\t%rcx, %rcx\n6: \tje\t0x22 <h2o_socket_get_ssl_protocol_version+0x22>\n8: \tmovl\t$0, %eax\nd: \tcmpq\t$0, 8(%rcx)\n12: \tje\t0x15 <h2o_socket_get_ssl_protocol_version+0x15>\n14: \tretq\n15: \tmovq\t(%rcx), %rdi\n18: \ttestq\t%rdi, %rdi\n1b: \tje\t0x22 <h2o_socket_get_ssl_protocol_version+0x22>\n1d: \tjmp\t0x22 <h2o_socket_get_ssl_protocol_version+0x22>\n22: \txorl\t%eax, %eax\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * ossl; int /*<<< orphan*/ * ptls; } ;\n\n/* Variables and functions */\nchar const* SSL_get_version (int /*<<< orphan*/ *) ;\n\nconst char *h2o_socket_get_ssl_protocol_version(h2o_socket_t *sock)\n{\nif (sock->ssl != NULL) {\nif (sock->ssl->ptls != NULL)\nreturn \"TLSv1.3\";\nif (sock->ssl->ossl != NULL)\nreturn SSL_get_version(sock->ssl->ossl);\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ ssl; scalar_t__ is_proxied; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nchar const* SSL_get_version (scalar_t__) ;\n\nconst char *h2o_socket_get_ssl_protocol_version(h2o_socket_t *sock)\n{\nif (sock->ssl == NULL || !sock->is_proxied)\nreturn NULL;\nreturn SSL_get_version(sock->ssl);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_run_pending",
    "input":"\n0000000000000000 <run_pending>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tjmp\t0x21 <run_pending+0x21>\n6: \tnopw\t%cs:(%rax,%rax)\n10: \tmovq\t(%rax), %rcx\n13: \tmovq\t%rcx, (%rbx)\n16: \tmovq\t%rax, (%rax)\n19: \tmovq\t%rax, %rdi\n1c: \tcallq\t0x21 <run_pending+0x21>\n21: \tmovq\t(%rbx), %rax\n24: \tmovq\t8(%rbx), %rdi\n28: \ttestq\t%rax, %rax\n2b: \tje\t0x40 <run_pending+0x40>\n2d: \ttestq\t%rdi, %rdi\n30: \tjne\t0x50 <run_pending+0x50>\n32: \tjmp\t0x10 <run_pending+0x10>\n34: \tnopw\t%cs:(%rax,%rax)\n3e: \tnop\n40: \ttestq\t%rdi, %rdi\n43: \tje\t0x72 <run_pending+0x72>\n45: \tnopw\t%cs:(%rax,%rax)\n4f: \tnop\n50: \tmovq\t(%rdi), %rax\n53: \tmovq\t%rax, 8(%rbx)\n57: \tmovq\t%rdi, (%rdi)\n5a: \tcallq\t0x5f <run_pending+0x5f>\n5f: \tmovq\t8(%rbx), %rdi\n63: \ttestq\t%rdi, %rdi\n66: \tjne\t0x50 <run_pending+0x50>\n68: \tmovq\t(%rbx), %rax\n6b: \ttestq\t%rax, %rax\n6e: \tje\t0x21 <run_pending+0x21>\n70: \tjmp\t0x10 <run_pending+0x10>\n72: \tpopq\t%rbx\n73: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {struct st_h2o_evloop_socket_t* _next_pending; } ;\nstruct TYPE_3__ {struct st_h2o_evloop_socket_t* _pending_as_server; struct st_h2o_evloop_socket_t* _pending_as_client; } ;\ntypedef  TYPE_1__ h2o_evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  run_socket (struct st_h2o_evloop_socket_t*) ;\n\n__attribute__((used)) static void run_pending(h2o_evloop_t *loop)\n{\nstruct st_h2o_evloop_socket_t *sock;\n\nwhile (loop->_pending_as_server != NULL || loop->_pending_as_client != NULL) {\nwhile ((sock = loop->_pending_as_client) != NULL) {\nloop->_pending_as_client = sock->_next_pending;\nsock->_next_pending = sock;\nrun_socket(sock);\n}\nif ((sock = loop->_pending_as_server) != NULL) {\nloop->_pending_as_server = sock->_next_pending;\nsock->_next_pending = sock;\nrun_socket(sock);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; struct TYPE_3__* prev; } ;\ntypedef  TYPE_1__ pending_action ;\n\n/* Variables and functions */\nint /*<<< orphan*/  run_pending_action (TYPE_1__*) ;\n\n__attribute__((used)) static void run_pending(pending_action **pending)\n{\npending_action *action;\n\nwhile ((action = *pending)) {\n*pending = action->next;\nif (action->prev)\naction->prev->next = action->next;\nif (action->next)\naction->next->prev = action->prev;\nrun_pending_action(action);\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhostinfo.c_h2o_hostinfo_aton",
    "input":"\n0000000000000000 <h2o_hostinfo_aton>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdx, %r14\na: \tmovslq\t%esi, %rbx\nd: \taddq\t%rdi, %rbx\n10: \tmovq\t%rsp, %rdx\n13: \tmovq\t%rbx, %rsi\n16: \tcallq\t0x1b <h2o_hostinfo_aton+0x1b>\n1b: \tmovl\t$4294967295, %r15d # imm = 0xFFFFFFFF\n21: \ttestq\t%rax, %rax\n24: \tje\t0x6c <h2o_hostinfo_aton+0x6c>\n26: \tmovl\t$1, %ebp\n2b: \tnopl\t(%rax,%rax)\n30: \tcmpq\t$4, %rbp\n34: \tje\t0x5e <h2o_hostinfo_aton+0x5e>\n36: \tcmpq\t%rbx, %rax\n39: \tje\t0x6c <h2o_hostinfo_aton+0x6c>\n3b: \tcmpb\t$46, (%rax)\n3e: \tjne\t0x6c <h2o_hostinfo_aton+0x6c>\n40: \taddq\t$1, %rax\n44: \tleaq\t(%rsp,%rbp), %rdx\n48: \tmovq\t%rax, %rdi\n4b: \tmovq\t%rbx, %rsi\n4e: \tcallq\t0x53 <h2o_hostinfo_aton+0x53>\n53: \taddq\t$1, %rbp\n57: \ttestq\t%rax, %rax\n5a: \tjne\t0x30 <h2o_hostinfo_aton+0x30>\n5c: \tjmp\t0x6c <h2o_hostinfo_aton+0x6c>\n5e: \tcmpq\t%rbx, %rax\n61: \tjne\t0x6c <h2o_hostinfo_aton+0x6c>\n63: \tmovl\t(%rsp), %eax\n66: \tmovl\t%eax, (%r14)\n69: \txorl\t%r15d, %r15d\n6c: \tmovl\t%r15d, %eax\n6f: \taddq\t$8, %rsp\n73: \tpopq\t%rbx\n74: \tpopq\t%r14\n76: \tpopq\t%r15\n78: \tpopq\t%rbp\n79: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct in_addr {int /*<<< orphan*/  s_addr; } ;\ntypedef  int /*<<< orphan*/  int32_t ;\nstruct TYPE_3__ {char* base; int len; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nchar* fetch_aton_digit (char const*,char const*,unsigned char*) ;\n\nint h2o_hostinfo_aton(h2o_iovec_t host, struct in_addr *addr)\n{\nunion {\nint32_t n;\nunsigned char c[4];\n} value;\nconst char *p = host.base, *end = p + host.len;\nsize_t ndots = 0;\n\nwhile (1) {\nif ((p = fetch_aton_digit(p, end, value.c + ndots)) == NULL)\nreturn -1;\nif (ndots == 3)\nbreak;\nif (p == end || !(*p == '.'))\nreturn -1;\n++p;\n++ndots;\n}\nif (p != end)\nreturn -1;\n\naddr->s_addr = value.n;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint16_t ;\n\n/* Variables and functions */\nscalar_t__ memchr (char const*,char,size_t) ;\nsize_t strlen (char const*) ;\n\nint h2o_hostinfo_aton(const char *host, size_t hostlen, uint16_t *port)\n{\nconst char *p = host + hostlen;\n\nif ((p = memchr(host, ':', hostlen)) == NULL)\nreturn -1;\n\nfor (++p; p != host + hostlen; ++p) {\nif (*p == ':') {\nif (p + 1 == host + hostlen)\nreturn -1;\n*port = (uint16_t)strtol(p + 1, NULL, 10);\nreturn 0;\n}\nif (*p != '.')\nreturn -1;\n}\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloopepoll.c.h_h2o_evloop_create",
    "input":"\n0000000000000000 <h2o_evloop_create>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tsubq\t$136, %rsp\na: \tmovl\t$8, %edi\nf: \tcallq\t0x14 <h2o_evloop_create+0x14>\n14: \tmovq\t%rax, %rbx\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <h2o_evloop_create+0x21>\n21: \tmovl\t$10, %edi\n26: \tcallq\t0x2b <h2o_evloop_create+0x2b>\n2b: \tmovl\t%eax, 4(%rbx)\n2e: \tmovl\t(%rip), %esi  # 0x34 <h2o_evloop_create+0x34>\n34: \tmovl\t(%rip), %edx  # 0x3a <h2o_evloop_create+0x3a>\n3a: \tmovl\t%eax, %edi\n3c: \tcallq\t0x41 <h2o_evloop_create+0x41>\n41: \tcmpl\t$-1, %eax\n44: \tje\t0x5e <h2o_evloop_create+0x5e>\n46: \tmovl\t$0, %edi\n4b: \tcallq\t0x50 <h2o_evloop_create+0x50>\n50: \tmovq\t%rbx, %rax\n53: \taddq\t$136, %rsp\n5a: \tpopq\t%rbx\n5b: \tpopq\t%r14\n5d: \tretq\n5e: \tmovq\t%rsp, %r14\n61: \tjmp\t0x89 <h2o_evloop_create+0x89>\n63: \tnopw\t%cs:(%rax,%rax)\n6d: \tnopl\t(%rax)\n70: \tmovl\t4(%rbx), %edi\n73: \tmovl\t(%rip), %esi  # 0x79 <h2o_evloop_create+0x79>\n79: \tmovl\t(%rip), %edx  # 0x7f <h2o_evloop_create+0x7f>\n7f: \tcallq\t0x84 <h2o_evloop_create+0x84>\n84: \tcmpl\t$-1, %eax\n87: \tjne\t0x46 <h2o_evloop_create+0x46>\n89: \tmovq\t(%rip), %rdi  # 0x90 <h2o_evloop_create+0x90>\n90: \tcmpq\t(%rip), %rdi  # 0x97 <h2o_evloop_create+0x97>\n97: \tje\t0x70 <h2o_evloop_create+0x70>\n99: \tmovq\t%r14, %rsi\n9c: \tmovl\t$128, %edx\na1: \tcallq\t0xa6 <h2o_evloop_create+0xa6>\na6: \tmovl\t$0, %edi\nab: \tmovl\t%eax, %esi\nad: \tcallq\t0xb2 <h2o_evloop_create+0xb2>\nb2: \tjmp\t0x70 <h2o_evloop_create+0x70>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_epoll_t {int /*<<< orphan*/  super; int /*<<< orphan*/  ep; } ;\ntypedef  int /*<<< orphan*/  h2o_evloop_t ;\ntypedef  int /*<<< orphan*/  buf ;\n\n/* Variables and functions */\nscalar_t__ EAGAIN ;\nint /*<<< orphan*/  FD_CLOEXEC ;\nint /*<<< orphan*/  F_SETFD ;\nint /*<<< orphan*/  cloexec_mutex ;\nscalar_t__ create_evloop (int) ;\nint /*<<< orphan*/  epoll_create (int) ;\nscalar_t__ errno ;\nint fcntl (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_fatal (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_strerror_r (scalar_t__,char*,int) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\nh2o_evloop_t *h2o_evloop_create(void)\n{\nstruct st_h2o_evloop_epoll_t *loop = (struct st_h2o_evloop_epoll_t *)create_evloop(sizeof(*loop));\n\npthread_mutex_lock(&cloexec_mutex);\nloop->ep = epoll_create(10);\nwhile (fcntl(loop->ep, F_SETFD, FD_CLOEXEC) == -1) {\nif (errno != EAGAIN) {\nchar buf[128];\nh2o_fatal(\"h2o_evloop_create: failed to set FD_CLOEXEC: %s\\n\", h2o_strerror_r(errno, buf, sizeof(buf)));\n}\n}\npthread_mutex_unlock(&cloexec_mutex);\n\nreturn &loop->super;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  fd_read; } ;\ntypedef  TYPE_1__ h2o_evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EVLOOP_POLL ;\nint /*<<< orphan*/  EVLOOP_SELECT ;\nint /*<<< orphan*/  EVLOOP_SELECT_SLEEP ;\nint /*<<< orphan*/  EVLOOP_SELECT_SLEEP_USEC ;\nint /*<<< orphan*/  EVLOOP_SLEEP ;\nint /*<<< orphan*/  EVLOOP_SLEEP_USEC ;\nint /*<<< orphan*/  EVLOOP_TIMER ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MAX ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_STEP_MIN ;\nint /*<<< orphan*/  EVLOOP_TIMER_USEC_STEP_STEP_STEP_STEP_ST"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhttpclient.c_create_client",
    "input":"\n0000000000000000 <create_client>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovl\t%ecx, %r14d\ne: \tmovq\t%rdx, %r15\n11: \tmovq\t%rsi, %r12\n14: \tmovq\t%rdi, %r13\n17: \tmovl\t(%rip), %eax  # 0x1d <create_client+0x1d>\n1d: \tmovl\t(%rip), %ecx  # 0x23 <create_client+0x23>\n23: \tcmpl\t%ecx, %eax\n25: \tcmovgel\t%eax, %ecx\n28: \tmovslq\t%ecx, %rbp\n2b: \tmovq\t%rbp, %rdi\n2e: \tcallq\t0x33 <create_client+0x33>\n33: \tmovq\t%rax, %rbx\n36: \tmovq\t%rax, %rdi\n39: \txorl\t%esi, %esi\n3b: \tmovq\t%rbp, %rdx\n3e: \tcallq\t0x43 <create_client+0x43>\n43: \tmovq\t%r13, 64(%rbx)\n47: \tmovq\t%r15, 56(%rbx)\n4b: \tmovq\t%r12, 48(%rbx)\n4f: \tmovl\t(%rip), %eax  # 0x55 <create_client+0x55>\n55: \tmovl\t%eax, 40(%rbx)\n58: \txorps\t%xmm0, %xmm0\n5b: \tmovups\t%xmm0, 24(%rbx)\n5f: \tmovups\t%xmm0, 8(%rbx)\n63: \tmovl\t%r14d, 4(%rbx)\n67: \tmovl\t(%rip), %eax  # 0x6d <create_client+0x6d>\n6d: \tmovl\t%eax, (%rbx)\n6f: \tmovq\t%rbx, %rax\n72: \taddq\t$8, %rsp\n76: \tpopq\t%rbx\n77: \tpopq\t%r12\n79: \tpopq\t%r13\n7b: \tpopq\t%r14\n7d: \tpopq\t%r15\n7f: \tpopq\t%rbp\n80: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\nstruct TYPE_8__ {int /*<<< orphan*/  cb; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  on_connect; } ;\nstruct TYPE_9__ {TYPE_2__ _timeout; TYPE_1__ _cb; int /*<<< orphan*/ * write_req; int /*<<< orphan*/ * update_window; int /*<<< orphan*/ * get_socket; int /*<<< orphan*/ * steal_socket; int /*<<< orphan*/  cancel; void* data; int /*<<< orphan*/ * ctx; int /*<<< orphan*/ * pool; } ;\ntypedef  TYPE_3__ h2o_httpclient_t ;\ntypedef  int /*<<< orphan*/  h2o_httpclient_ctx_t ;\ntypedef  int /*<<< orphan*/  h2o_httpclient_connect_cb ;\n\n/* Variables and functions */\nsize_t SZ_MAX (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  do_cancel ;\nint /*<<< orphan*/  h2o_httpclient__h1_size ;\nint /*<<< orphan*/  h2o_httpclient__h2_size ;\nTYPE_3__* h2o_mem_alloc (size_t) ;\nint /*<<< orphan*/  memset (TYPE_3__*,int /*<<< orphan*/ ,size_t) ;\nint /*<<< orphan*/  on_connect_timeout ;\n\n__attribute__((used)) static h2o_httpclient_t *create_client(h2o_mem_pool_t *pool, void *data, h2o_httpclient_ctx_t *ctx,\nh2o_httpclient_connect_cb on_connect)\n{\n#define SZ_MAX(x, y) ((x) > (y) ? (x) : (y))\nsize_t sz = SZ_MAX(h2o_httpclient__h1_size, h2o_httpclient__h2_size);\n#undef SZ_MAX\nh2o_httpclient_t *client = h2o_mem_alloc(sz);\nmemset(client, 0, sz);\nclient->pool = pool;\nclient->ctx = ctx;\nclient->data = data;\nclient->cancel = do_cancel;\nclient->steal_socket = NULL;\nclient->get_socket = NULL;\nclient->update_window = NULL;\nclient->write_req = NULL;\nclient->_cb.on_connect = on_connect;\nclient->_timeout.cb = on_connect_timeout;\n\nreturn client;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/ * hwnd; int /*<<< orphan*/ * hwnd_parent; int /*<<< orphan*/ * hwnd_notify; int /*<<< orphan*/ * hwnd_target; int /*<<< orphan*/ * hwnd_toolbar; int /*<<< orphan*/ * hwnd_status; int /*<<< orphan*/ * hwnd_list; int /*<<< orphan*/ * hwnd_main; int /*<<< orphan*/ * hwnd_client; int /*<<< orphan*/ * hwnd_appbar; int /*<<< orphan*/ * hwnd_taskbar; int /*<<< orphan*/ * hwnd_desktop; int /*<<< orphan*/ * hwnd_active; int /*<<< orphan*/ * hwnd_active_prev; int /*<<< orphan*/ * hwnd_active_next; int /*<<< orphan*/ * hwnd_active_last; int /*<<< orphan*/ * hwnd_active_first; int /*<<< orphan*/ * hwnd_active_last_prev; int /*<<< orphan*/ * hwnd_active_last_next; int /*<<< orphan*/ * hwnd_active_first_prev; int /*<<< orphan*/ * hwnd_active_first_next; int /*<<< orphan*/ * hwnd_active_last_last; int /*<<< orphan*/ * hwnd_active_first_first; int /*<<< orphan*/ * hwnd_active_last_first; int /*<<< orphan*/ * hwnd_active_first_last; int /*<<< orphan*/ * hwnd_active_first_first_prev; int /*<<< orphan*/ * hwnd_active_first_first_next; int /*<<< orphan*/ * hwnd_active_last_last_prev; int /*<<< orphan*/ * hwnd_active_last_last_next; int /*<<< orphan*/ * hwnd_active_last_last_last; int /*<<< orphan*/ * hwnd_active_first_first_first; int /*<<< orphan*/ * hwnd_active_last_last_first; int /*<<< orphan*/ * hwnd_active_first_last_first; int /*<<< orphan*/ * hwnd_active_first_first_last; int /*<<< orphan*/ * hwnd_active_last_first_last; int /*<<< orphan*/ * hwnd_active_last_first_first; int /*<<< orphan*/ * hwnd_active_last_last_first; int /*<<< orphan*/ * hwnd_active_first_last_last; int /*<<< orphan*/ * hwnd_active_first_first_last; int /*<<< orphan*/ * hwnd_active_last_first_first; int /*<<< orphan*/ * hwnd_active_first_first_first; int /*<<< orphan*/ * hwnd_active_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last; int /*<<< orphan*/ * hwnd_active_first_first_first_prev; int /*<<< orphan*/ * hwnd_active_first_first_first_next; int /*<<< orphan*/ * hwnd_active_last_last_last_prev; int /*<<< orphan*/ * hwnd_active_last_last_last_next; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_first_first_first; int /*<<< orphan*/ * hwnd_active_last_last_last_first; int /*<<< orphan*/ * hwnd_active_first_first_first_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_first_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<< orphan*/ * hwnd_active_last_last_last_last; int /*<<< orphan*/ * hwnd_active_first_last_last_last; int /*<<<"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o__lcstris_core",
    "input":"\n0000000000000000 <h2o__lcstris_core>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t$1, %r14d\ne: \ttestq\t%rdx, %rdx\n11: \tje\t0x41 <h2o__lcstris_core+0x41>\n13: \tmovq\t%rdx, %rbx\n16: \tmovq\t%rsi, %r15\n19: \tmovq\t%rdi, %r12\n1c: \txorl\t%ebp, %ebp\n1e: \tnop\n20: \tmovsbl\t(%r12,%rbp), %edi\n25: \tcallq\t0x2a <h2o__lcstris_core+0x2a>\n2a: \tmovsbl\t(%r15,%rbp), %ecx\n2f: \tcmpl\t%ecx, %eax\n31: \tjne\t0x3e <h2o__lcstris_core+0x3e>\n33: \taddq\t$1, %rbp\n37: \tcmpq\t%rbp, %rbx\n3a: \tjne\t0x20 <h2o__lcstris_core+0x20>\n3c: \tjmp\t0x41 <h2o__lcstris_core+0x41>\n3e: \txorl\t%r14d, %r14d\n41: \tmovl\t%r14d, %eax\n44: \tpopq\t%rbx\n45: \tpopq\t%r12\n47: \tpopq\t%r14\n49: \tpopq\t%r15\n4b: \tpopq\t%rbp\n4c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_tolower (int /*<<< orphan*/ ) ;\n\nint h2o__lcstris_core(const char *target, const char *test, size_t test_len)\n{\nfor (; test_len != 0; --test_len)\nif (h2o_tolower(*target++) != *test++)\nreturn 0;\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint h2o__tolower (char) ;\n\n__attribute__((used)) static int h2o__lcstris_core(const char *s, const char *t, size_t len)\n{\nsize_t i;\n\nfor (i = 0; i != len; ++i) {\nif (h2o__tolower(s[i]) != h2o__tolower(t[i]))\nreturn 0;\n}\nreturn 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_hostinfo.c_test_lib__common__hostinfo_c",
    "input":"\n0000000000000000 <test_lib__common__hostinfo_c>:\n0: \tmovl\t(%rip), %esi  # 0x6 <test_lib__common__hostinfo_c+0x6>\n6: \tmovl\t$0, %edi\nb: \tjmp\t0x10 <test_lib__common__hostinfo_c+0x10>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_aton ;\n\nvoid test_lib__common__hostinfo_c(void)\n{\n/* TODO add tests for h2o_hostinfo_getaddr and related */\nsubtest(\"aton\", test_aton);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_HOSTINFO_C ;\nint test__common__hostinfo (char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int test_lib__common__hostinfo_c(void)\n{\nreturn test__common__hostinfo(\"test_lib__common__hostinfo_c\", TEST_HOSTINFO_C);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhttpclient.c_should_use_h2",
    "input":"\n0000000000000000 <should_use_h2>:\n0: \tmovl\t(%rsi), %eax\n2: \ttestl\t%eax, %eax\n4: \tjns\t0x19 <should_use_h2+0x19>\n6: \ttestl\t%edi, %edi\n8: \tje\t0x15 <should_use_h2+0x15>\na: \tmovl\t$50, %eax\nf: \txorl\t%edx, %edx\n11: \tidivl\t%edi\n13: \tjmp\t0x17 <should_use_h2+0x17>\n15: \txorl\t%eax, %eax\n17: \tmovl\t%eax, (%rsi)\n19: \tmovl\t%eax, %ecx\n1b: \timull\t%edi, %ecx\n1e: \tmovslq\t%ecx, %rdx\n21: \timulq\t$1374389535, %rdx, %rcx # imm = 0x51EB851F\n28: \tmovq\t%rcx, %r8\n2b: \tshrq\t$63, %r8\n2f: \tsarq\t$37, %rcx\n33: \taddl\t%r8d, %ecx\n36: \timull\t$100, %ecx, %ecx\n39: \tsubl\t%ecx, %edx\n3b: \taddl\t%edi, %edx\n3d: \txorl\t%ecx, %ecx\n3f: \tcmpl\t$99, %edx\n42: \tsetg\t%cl\n45: \taddl\t$1, %eax\n48: \txorl\t%edx, %edx\n4a: \tcmpl\t$100, %eax\n4d: \tcmovnel\t%eax, %edx\n50: \tmovl\t%edx, (%rsi)\n52: \tmovl\t%ecx, %eax\n54: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int int8_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int should_use_h2(int8_t ratio, int8_t *counter)\n{\n/* weighted fair queueing */\nif (*counter < 0)\n*counter = ratio == 0 ? 0 : 50 / ratio; /* set initial counter value */\nint use_h2 = (((int)ratio * *counter) % 100) + ratio >= 100;\nif (++*counter == 100)\n*counter = 0;\nreturn use_h2;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int should_use_h2(int speed, int *last_speed)\n{\nint new_speed;\n\nif (speed < 0) {\nnew_speed = *last_speed;\n} else {\nnew_speed = speed / 100;\n}\n\n*last_speed = new_speed;\n\nreturn new_speed > *last_speed;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_getnumerichost",
    "input":"\n0000000000000000 <h2o_socket_getnumerichost>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdx, %rbx\n6: \tmovq\t(%rdi), %rax\n9: \tcmpq\t(%rip), %rax  # 0x10 <h2o_socket_getnumerichost+0x10>\n10: \tjne\t0x43 <h2o_socket_getnumerichost+0x43>\n12: \tmovl\t%eax, %edi\n14: \tcallq\t0x19 <h2o_socket_getnumerichost+0x19>\n19: \tmovl\t%eax, %ecx\n1b: \tmovzbl\t%ah, %ebp\n1e: \tmovzbl\t%al, %r9d\n22: \tmovl\t%eax, %edx\n24: \tsarl\t$24, %edx\n27: \tshrl\t$16, %ecx\n2a: \tmovzbl\t%cl, %ecx\n2d: \tmovl\t$0, %esi\n32: \tmovq\t%rbx, %rdi\n35: \tmovl\t%ebp, %r8d\n38: \taddq\t$8, %rsp\n3c: \tpopq\t%rbx\n3d: \tpopq\t%rbp\n3e: \tjmp\t0x43 <h2o_socket_getnumerichost+0x43>\n43: \tmovl\t(%rip), %ecx  # 0x49 <h2o_socket_getnumerichost+0x49>\n49: \tmovl\t(%rip), %eax  # 0x4f <h2o_socket_getnumerichost+0x4f>\n4f: \tmovl\t%eax, (%rsp)\n52: \tmovq\t%rbx, %rdx\n55: \txorl\t%r8d, %r8d\n58: \txorl\t%r9d, %r9d\n5b: \tcallq\t0x60 <h2o_socket_getnumerichost+0x60>\n60: \ttestq\t%rax, %rax\n63: \tje\t0x73 <h2o_socket_getnumerichost+0x73>\n65: \tmovq\t(%rip), %rax  # 0x6c <h2o_socket_getnumerichost+0x6c>\n6c: \taddq\t$8, %rsp\n70: \tpopq\t%rbx\n71: \tpopq\t%rbp\n72: \tretq\n73: \tmovq\t%rbx, %rdi\n76: \taddq\t$8, %rsp\n7a: \tpopq\t%rbx\n7b: \tpopq\t%rbp\n7c: \tjmp\t0x81 <h2o_socket_getnumerichost+0x81>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int uint32_t ;\nstruct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;\nstruct sockaddr_in {TYPE_1__ sin_addr; } ;\nstruct sockaddr {scalar_t__ sa_family; } ;\ntypedef  int /*<<< orphan*/  socklen_t ;\n\n/* Variables and functions */\nscalar_t__ AF_INET ;\nint /*<<< orphan*/  NI_MAXHOST ;\nint /*<<< orphan*/  NI_NUMERICHOST ;\nsize_t SIZE_MAX ;\nscalar_t__ getnameinfo (struct sockaddr*,int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint htonl (int /*<<< orphan*/ ) ;\nsize_t sprintf (char*,char*,int,int,int,int) ;\nsize_t strlen (char*) ;\n\nsize_t h2o_socket_getnumerichost(struct sockaddr *sa, socklen_t salen, char *buf)\n{\nif (sa->sa_family == AF_INET) {\n/* fast path for IPv4 addresses */\nstruct sockaddr_in *sin = (void *)sa;\nuint32_t addr;\naddr = htonl(sin->sin_addr.s_addr);\nreturn sprintf(buf, \"%d.%d.%d.%d\", addr >> 24, (addr >> 16) & 255, (addr >> 8) & 255, addr & 255);\n}\n\nif (getnameinfo(sa, salen, buf, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) != 0)\nreturn SIZE_MAX;\nreturn strlen(buf);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr {int dummy; } ;\nstruct TYPE_3__ {scalar_t__ family; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  AF_INET6 ;\nint /*<<< orphan*/  EINVAL ;\nint /*<<< orphan*/  ENAMETOOLONG ;\nint /*<<< orphan*/  h2o_socket_getpeername (TYPE_1__ const*,struct sockaddr*,size_t*) ;\nint /*<<< orphan*/  h2o_socket_getsockname (TYPE_1__ const*,struct sockaddr*,size_t*) ;\nint /*<<< orphan*/  h2o_socket_getsockname_ex (TYPE_1__ const*,struct sockaddr*,size_t*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nscalar_t__ h2o_socket_is_connected (TYPE_1__ const*) ;\nint /*<<< orphan*/  snprintf (char*,size_t,char*,unsigned char,unsigned char,unsigned char,unsigned char) ;\n\n__attribute__((used)) static int h2o_socket_getnumerichost(const h2o_socket_t *sock, char *buf, size_t bufsize)\n{\nstruct sockaddr sa;\nsize_t salen;\n\nif (h2o_socket_is_connected(sock)) {\nif (h2o_socket_getpeername(sock, &sa, &salen) != 0)\nreturn EINVAL;\n} else {\nif (h2o_socket_getsockname(sock, &sa, &salen) != 0)\nreturn EINVAL;\n}\n\nif (sa.sa_family == AF_INET) {\nstruct sockaddr_in *sin = (void *)&sa;\nsnprintf(buf, bufsize, \"%u.%u.%u.%u\", (unsigned)(((uint8_t *)&sin->sin_addr)[0]), (unsigned)(((uint8_t *)&sin->sin_addr)[1]),\n(unsigned)(((uint8_t *)&sin->sin_addr)[2]), (unsigned)(((uint8_t *)&sin->sin_addr)[3]));\n} else if (sa.sa_family == AF_INET6) {\nstruct sockaddr_in6 *sin6 = (void *)&sa;\nsnprintf(buf, bufsize, \"%x:%x:%x:%x:%x:%x:%x:%x\", (unsigned)(((uint8_t *)&sin6->sin6_addr)[0]),\n(unsigned)(((uint8_t *)&sin6->sin6_addr)[1]), (unsigned)(((uint8_t *)&sin6->sin6_addr)[2]),\n(unsigned)(((uint8_t *)&sin6->sin6_addr)[3]), (unsigned)(((uint8_t *)&sin6->sin6_addr)[4]),\n(unsigned)(((uint8_t *)&sin6->sin6_addr)[5]), (unsigned)(((uint8_t *)&sin6->sin6_addr)[6]),\n(unsigned)(((uint8_t *)&sin6->sin6_addr)[7]));\n} else {\nreturn EINVAL;\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommon....depsssl-conservatoryopensslopenssl_hostname_validation.c_lowercase",
    "input":"\n0000000000000000 <lowercase>:\n0: \tleal\t-65(%rdi), %ecx\n3: \tleal\t32(%rdi), %eax\n6: \tcmpl\t$26, %ecx\n9: \tcmovael\t%edi, %eax\nc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int lowercase(int ch) {\nif ('A' <= ch && ch <= 'Z')\nreturn ch - 'A' + 'a';\nreturn ch;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static inline char lowercase(char c)\n{\nreturn (c >= 'A' && c <= 'Z') ? c + 32 : c;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_read_stop",
    "input":"\n0000000000000000 <h2o_socket_read_stop>:\n0: \tmovq\t$0, (%rdi)\n7: \tjmp\t0xc <h2o_socket_read_stop+0xc>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * read; } ;\nstruct TYPE_6__ {TYPE_1__ _cb; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_read_stop (TYPE_2__*) ;\n\nvoid h2o_socket_read_stop(h2o_socket_t *sock)\n{\nsock->_cb.read = NULL;\ndo_read_stop(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_socket_read_task_t {int /*<<< orphan*/ * cb; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_socket_read_stop_with_error (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void h2o_socket_read_stop(struct st_h2o_socket_read_task_t *self)\n{\nself->cb = NULL;\nh2o_socket_read_stop_with_error(self, NULL);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_string.c_test_strstr",
    "input":"\n0000000000000000 <test_strstr>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, %edi\n6: \tmovl\t$0, %edx\nb: \tmovl\t$4, %esi\n10: \tmovl\t$2, %ecx\n15: \tcallq\t0x1a <test_strstr+0x1a>\n1a: \txorl\t%edi, %edi\n1c: \tcmpl\t$1, %eax\n1f: \tsete\t%dil\n23: \tcallq\t0x28 <test_strstr+0x28>\n28: \tmovl\t$0, %edi\n2d: \tmovl\t$0, %edx\n32: \tmovl\t$3, %esi\n37: \tmovl\t$2, %ecx\n3c: \tcallq\t0x41 <test_strstr+0x41>\n41: \txorl\t%edi, %edi\n43: \tcmpl\t$1, %eax\n46: \tsete\t%dil\n4a: \tcallq\t0x4f <test_strstr+0x4f>\n4f: \tmovl\t$0, %edi\n54: \tmovl\t$0, %edx\n59: \tmovl\t$2, %esi\n5e: \tmovl\t$2, %ecx\n63: \tcallq\t0x68 <test_strstr+0x68>\n68: \txorl\t%edi, %edi\n6a: \tcmpl\t$-1, %eax\n6d: \tsete\t%dil\n71: \tpopq\t%rax\n72: \tjmp\t0x77 <test_strstr+0x77>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint h2o_strstr (char*,int,char*,int) ;\nint /*<<< orphan*/  ok (int) ;\n\n__attribute__((used)) static void test_strstr(void)\n{\nok(h2o_strstr(\"abcd\", 4, \"bc\", 2) == 1);\nok(h2o_strstr(\"abcd\", 3, \"bc\", 2) == 1);\nok(h2o_strstr(\"abcd\", 2, \"bc\", 2) == -1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_int (int,int /*<<< orphan*/ ) ;\nint strstr (char const*,char const*,int,int) ;\n\n__attribute__((used)) static void test_strstr(void)\n{\nTEST_int(strstr(\"abcdef\", \"cd\", 4, 2), 1);\nTEST_int(strstr(\"abcdef\", \"cd\", 3, 2), 0);\nTEST_int(strstr(\"abcdef\", \"cd\", 2, 2), -1);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_read_bio",
    "input":"\n0000000000000000 <read_bio>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovl\t%edx, %ebx\na: \tmovq\t%rsi, %r14\nd: \tmovq\t%rdi, %r12\n10: \tcallq\t0x15 <read_bio+0x15>\n15: \ttestl\t%ebx, %ebx\n17: \tje\t0x46 <read_bio+0x46>\n19: \tmovq\t%rax, %r15\n1c: \tmovq\t(%rax), %rax\n1f: \tmovq\t(%rax), %rax\n22: \tmovl\t(%rax), %ecx\n24: \ttestl\t%ecx, %ecx\n26: \tje\t0x4a <read_bio+0x4a>\n28: \tcmpl\t%ebx, %ecx\n2a: \tcmovlel\t%ecx, %ebx\n2d: \tmovl\t4(%rax), %esi\n30: \tmovq\t%r14, %rdi\n33: \tmovl\t%ebx, %edx\n35: \tcallq\t0x3a <read_bio+0x3a>\n3a: \tmovq\t(%r15), %rdi\n3d: \tmovl\t%ebx, %esi\n3f: \tcallq\t0x44 <read_bio+0x44>\n44: \tjmp\t0x57 <read_bio+0x57>\n46: \txorl\t%ebx, %ebx\n48: \tjmp\t0x57 <read_bio+0x57>\n4a: \tmovq\t%r12, %rdi\n4d: \tcallq\t0x52 <read_bio+0x52>\n52: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\n57: \tmovl\t%ebx, %eax\n59: \taddq\t$8, %rsp\n5d: \tpopq\t%rbx\n5e: \tpopq\t%r12\n60: \tpopq\t%r14\n62: \tpopq\t%r15\n64: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {TYPE_2__* ssl; } ;\ntypedef  TYPE_3__ h2o_socket_t ;\nstruct TYPE_9__ {int size; int /*<<< orphan*/  bytes; } ;\nstruct TYPE_6__ {TYPE_4__* encrypted; } ;\nstruct TYPE_7__ {TYPE_1__ input; } ;\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nTYPE_3__* BIO_get_data (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  BIO_set_retry_read (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_buffer_consume (TYPE_4__**,int) ;\nint /*<<< orphan*/  memcpy (char*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static int read_bio(BIO *b, char *out, int len)\n{\nh2o_socket_t *sock = BIO_get_data(b);\n\nif (len == 0)\nreturn 0;\n\nif (sock->ssl->input.encrypted->size == 0) {\nBIO_set_retry_read(b);\nreturn -1;\n}\n\nif (sock->ssl->input.encrypted->size < len) {\nlen = (int)sock->ssl->input.encrypted->size;\n}\nmemcpy(out, sock->ssl->input.encrypted->bytes, len);\nh2o_buffer_consume(&sock->ssl->input.encrypted, len);\n\nreturn len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* ptr; } ;\nstruct TYPE_9__ {TYPE_1__* data; } ;\nstruct TYPE_8__ {int len; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__ BIO_DATA ;\ntypedef  TYPE_2__ BIO_BUF_MEM ;\ntypedef  TYPE_3__ BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_clear_retry_flags (TYPE_3__*) ;\nint /*<<< orphan*/  BIO_copy_next_retry (TYPE_3__*) ;\nint /*<<< orphan*/  BIO_set_retry_read (TYPE_3__*) ;\nint /*<<< orphan*/  memcpy (unsigned char*,int /*<<< orphan*/ ,int) ;\nTYPE_2__* BIO_get_data (TYPE_3__*) ;\n\n__attribute__((used)) static int read_bio(BIO *bio, char *buf, int size)\n{\nBIO_BUF_MEM *bmem;\nBIO_DATA *data;\nint ret;\n\nBIO_clear_retry_flags(bio);\n\nbmem = BIO_get_data(bio);\nif (size == 0)\nreturn 0;\n\ndata = bmem->ptr;\nif (data->len == 0) {\nBIO_set_retry_read(bio);\nreturn -1;\n}\n\nif (size > data->len)\nsize = data->len;\n\nmemcpy(buf, data->data, size);\nret = size;\n\nBIO_copy_next_retry(bio);\n\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_contains_token",
    "input":"\n0000000000000000 <h2o_contains_token>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$24, %rsp\ne: \tmovl\t%r8d, %ebx\n11: \tmovq\t%rcx, %r14\n14: \tmovq\t%rdx, %r15\n17: \tcallq\t0x1c <h2o_contains_token+0x1c>\n1c: \tmovl\t%eax, 12(%rsp)\n20: \tmovq\t$0, 16(%rsp)\n29: \tleaq\t12(%rsp), %r12\n2e: \tleaq\t16(%rsp), %r13\n33: \tnopw\t%cs:(%rax,%rax)\n3d: \tnopl\t(%rax)\n40: \txorl\t%ebp, %ebp\n42: \tmovq\t%r12, %rdi\n45: \tmovl\t%ebx, %esi\n47: \tmovq\t%r13, %rdx\n4a: \txorl\t%ecx, %ecx\n4c: \tcallq\t0x51 <h2o_contains_token+0x51>\n51: \ttestq\t%rax, %rax\n54: \tje\t0x73 <h2o_contains_token+0x73>\n56: \tmovq\t16(%rsp), %rsi\n5b: \tmovq\t%rax, %rdi\n5e: \tmovq\t%r15, %rdx\n61: \tmovq\t%r14, %rcx\n64: \tcallq\t0x69 <h2o_contains_token+0x69>\n69: \ttestq\t%rax, %rax\n6c: \tje\t0x40 <h2o_contains_token+0x40>\n6e: \tmovl\t$1, %ebp\n73: \tmovl\t%ebp, %eax\n75: \taddq\t$24, %rsp\n79: \tpopq\t%rbx\n7a: \tpopq\t%r12\n7c: \tpopq\t%r13\n7e: \tpopq\t%r14\n80: \tpopq\t%r15\n82: \tpopq\t%rbp\n83: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_iovec_init (char const*,size_t) ;\nscalar_t__ h2o_lcstris (char const*,size_t,char const*,size_t) ;\nchar* h2o_next_token (int /*<<< orphan*/ *,int,size_t*,int /*<<< orphan*/ *) ;\n\nint h2o_contains_token(const char *haysack, size_t haysack_len, const char *needle, size_t needle_len, int separator)\n{\nh2o_iovec_t iter = h2o_iovec_init(haysack, haysack_len);\nconst char *token = NULL;\nsize_t token_len = 0;\n\nwhile ((token = h2o_next_token(&iter, separator, &token_len, NULL)) != NULL) {\nif (h2o_lcstris(token, token_len, needle, needle_len)) {\nreturn 1;\n}\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_iovec_t ;\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\n\n/* Variables and functions */\nscalar_t__ h2o_next_token (int /*<<< orphan*/ *,int,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_strcasecmp (scalar_t__,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int h2o_contains_token(h2o_mem_pool_t *pool, const h2o_iovec_t *tokens, const h2o_iovec_t *token, int case_insensitive)\n{\nh2o_iovec_t token_iter;\nh2o_iovec_t token_iter_copy;\n\ntoken_iter_copy = *token;\nwhile ((token_iter = h2o_next_token(pool, case_insensitive, &token_iter_copy, NULL)) != NULL) {\nif (h2o_strcasecmp(token_iter, token) == 0)\nreturn 1;\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_string.c_test_get_filext",
    "input":"\n0000000000000000 <test_get_filext>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t$0, %edi\n8: \tcallq\t0xd <test_get_filext+0xd>\nd: \tmovl\t%eax, %edi\nf: \tcallq\t0x14 <test_get_filext+0x14>\n14: \tmovq\t%rax, %rbx\n17: \tmovl\t%edx, %ebp\n19: \tmovl\t$0, %edi\n1e: \tcallq\t0x23 <test_get_filext+0x23>\n23: \tmovq\t%rbx, %rdi\n26: \tmovl\t%ebp, %esi\n28: \tmovl\t%eax, %edx\n2a: \tcallq\t0x2f <test_get_filext+0x2f>\n2f: \tmovl\t%eax, %edi\n31: \tcallq\t0x36 <test_get_filext+0x36>\n36: \tmovl\t$0, %edi\n3b: \tcallq\t0x40 <test_get_filext+0x40>\n40: \tmovl\t%eax, %edi\n42: \tcallq\t0x47 <test_get_filext+0x47>\n47: \tmovq\t%rax, %rbx\n4a: \tmovl\t%edx, %ebp\n4c: \tmovl\t$0, %edi\n51: \tcallq\t0x56 <test_get_filext+0x56>\n56: \tmovq\t%rbx, %rdi\n59: \tmovl\t%ebp, %esi\n5b: \tmovl\t%eax, %edx\n5d: \tcallq\t0x62 <test_get_filext+0x62>\n62: \tmovl\t%eax, %edi\n64: \tcallq\t0x69 <test_get_filext+0x69>\n69: \tmovl\t$0, %edi\n6e: \tcallq\t0x73 <test_get_filext+0x73>\n73: \tmovl\t%eax, %edi\n75: \tcallq\t0x7a <test_get_filext+0x7a>\n7a: \tmovq\t%rax, %rbx\n7d: \tmovl\t%edx, %ebp\n7f: \tmovl\t$0, %edi\n84: \tcallq\t0x89 <test_get_filext+0x89>\n89: \tmovq\t%rbx, %rdi\n8c: \tmovl\t%ebp, %esi\n8e: \tmovl\t%eax, %edx\n90: \tcallq\t0x95 <test_get_filext+0x95>\n95: \tmovl\t%eax, %edi\n97: \tcallq\t0x9c <test_get_filext+0x9c>\n9c: \tmovl\t$0, %edi\na1: \tcallq\t0xa6 <test_get_filext+0xa6>\na6: \tmovl\t%eax, %edi\na8: \tcallq\t0xad <test_get_filext+0xad>\nad: \txorl\t%edi, %edi\naf: \ttestq\t%rax, %rax\nb2: \tsete\t%dil\nb6: \tcallq\t0xbb <test_get_filext+0xbb>\nbb: \tmovl\t$0, %edi\nc0: \tcallq\t0xc5 <test_get_filext+0xc5>\nc5: \tmovl\t%eax, %edi\nc7: \tcallq\t0xcc <test_get_filext+0xcc>\ncc: \txorl\t%edi, %edi\nce: \ttestq\t%rax, %rax\nd1: \tsete\t%dil\nd5: \tcallq\t0xda <test_get_filext+0xda>\nda: \tmovl\t$0, %edi\ndf: \tcallq\t0xe4 <test_get_filext+0xe4>\ne4: \tmovl\t%eax, %edi\ne6: \tcallq\t0xeb <test_get_filext+0xeb>\neb: \txorl\t%edi, %edi\ned: \ttestq\t%rax, %rax\nf0: \tsete\t%dil\nf4: \taddq\t$8, %rsp\nf8: \tpopq\t%rbx\nf9: \tpopq\t%rbp\nfa: \tjmp\t0xff <test_get_filext+0xff>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * base; int /*<<< orphan*/  len; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nTYPE_1__ h2o_get_filext (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_memis (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ok (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void test_get_filext(void)\n{\nh2o_iovec_t ext;\n\next = h2o_get_filext(H2O_STRLIT(\"/abc.txt\"));\nok(h2o_memis(ext.base, ext.len, H2O_STRLIT(\"txt\")));\next = h2o_get_filext(H2O_STRLIT(\"/abc.txt.gz\"));\nok(h2o_memis(ext.base, ext.len, H2O_STRLIT(\"gz\")));\next = h2o_get_filext(H2O_STRLIT(\"/abc.\"));\nok(h2o_memis(ext.base, ext.len, H2O_STRLIT(\"\")));\next = h2o_get_filext(H2O_STRLIT(\"/abc\"));\nok(ext.base == NULL);\next = h2o_get_filext(H2O_STRLIT(\"/abc.def/abc\"));\nok(ext.base == NULL);\next = h2o_get_filext(H2O_STRLIT(\"/abc.def/\"));\nok(ext.base == NULL);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WCHAR ;\ntypedef  int /*<<< orphan*/  HRESULT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GetProcessHeap () ;\nint /*<<< orphan*/  HeapFree (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_OK ;\nint /*<<< orphan*/  ok (int,char*) ;\nint /*<<< orphan*/  pGetFileExtensionW (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetFileExtensionW_str (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetFileTitleW (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetFileTitleW_str (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetFileNameW (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetFileNameW_str (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetPathW (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetPathW_str (int /*<<< orphan*/  const*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pGetSystemDirectoryW (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pGetSystemDirectoryW_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pGetWindowsDirectoryW (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pGetWindowsDirectoryW_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpec (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpec_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchSkipRoot (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchSkipRoot_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchStripPrefix (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchStripPrefix_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveBackslash (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveBackslash_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveBackslashes (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveBackslashes_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpec (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpec_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx2 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx2_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx3 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx3_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx4 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx4_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx5 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx5_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx6 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx6_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx7 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx7_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx8 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx8_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx9 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecEx9_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecExA (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecExA_str (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pPathCchRemoveFileSpecExW (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_link_to_statechanged",
    "input":"\n0000000000000000 <link_to_statechanged>:\n0: \tcmpq\t%rdi, (%rdi)\n3: \tje\t0x6 <link_to_statechanged+0x6>\n5: \tretq\n6: \tmovq\t$0, (%rdi)\nd: \tmovq\t8(%rdi), %rax\n11: \tmovq\t(%rax), %rax\n14: \tmovq\t%rdi, (%rax)\n17: \tmovq\t8(%rdi), %rax\n1b: \tmovq\t%rdi, (%rax)\n1e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {struct st_h2o_evloop_socket_t* _next_statechanged; TYPE_2__* loop; } ;\nstruct TYPE_3__ {struct st_h2o_evloop_socket_t** tail_ref; } ;\nstruct TYPE_4__ {TYPE_1__ _statechanged; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void link_to_statechanged(struct st_h2o_evloop_socket_t *sock)\n{\nif (sock->_next_statechanged == sock) {\nsock->_next_statechanged = NULL;\n*sock->loop->_statechanged.tail_ref = sock;\nsock->loop->_statechanged.tail_ref = &sock->_next_statechanged;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* next; TYPE_1__* prev; } ;\nstruct TYPE_4__ {TYPE_2__ link; } ;\ntypedef  TYPE_1__ StateChanged ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void link_to_statechanged(StateChanged *sc)\n{\nif (sc->link.next == sc)\nreturn;\nsc->link.next->link.prev = sc->link.prev;\nsc->link.prev->link.next = sc->link.next;\nsc->link.next = sc;\nsc->link.prev = sc;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonurl.c_handle_special_paths",
    "input":"\n0000000000000000 <handle_special_paths>:\n0: \tmovq\t%rsi, %rax\n3: \tsubq\t%rdx, %rsi\n6: \tcmpq\t$3, %rsi\na: \tje\t0x26 <handle_special_paths+0x26>\nc: \tmovq\t%rax, %rcx\nf: \tcmpq\t$2, %rsi\n13: \tjne\t0x5b <handle_special_paths+0x5b>\n15: \tleaq\t-1(%rax), %rcx\n19: \tcmpb\t$46, -1(%rdi,%rax)\n1e: \tcmovneq\t%rax, %rcx\n22: \tsubq\t%rcx, %rax\n25: \tretq\n26: \tcmpb\t$46, -2(%rdi,%rax)\n2b: \tmovq\t%rax, %rcx\n2e: \tjne\t0x5b <handle_special_paths+0x5b>\n30: \tcmpb\t$46, -1(%rax,%rdi)\n35: \tmovq\t%rax, %rcx\n38: \tjne\t0x5b <handle_special_paths+0x5b>\n3a: \tleaq\t-2(%rax), %rcx\n3e: \tcmpq\t$2, %rcx\n42: \tjb\t0x5b <handle_special_paths+0x5b>\n44: \tleaq\t-2(%rax), %rcx\n48: \tnopl\t(%rax,%rax)\n50: \tcmpb\t$47, -2(%rdi,%rcx)\n55: \tleaq\t-1(%rcx), %rcx\n59: \tjne\t0x50 <handle_special_paths+0x50>\n5b: \tsubq\t%rcx, %rax\n5e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static size_t handle_special_paths(const char *path, size_t off, size_t last_slash)\n{\nsize_t orig_off = off, part_size = off - last_slash;\n\nif (part_size == 2 && path[off - 1] == '.') {\n--off;\n} else if (part_size == 3 && path[off - 2] == '.' && path[off - 1] == '.') {\noff -= 2;\nif (off > 1) {\nfor (--off; path[off - 1] != '/'; --off)\n;\n}\n}\nreturn orig_off - off;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static size_t handle_special_paths(const char *path, size_t len, size_t max_len)\n{\nif (len < 3)\nreturn len;\n\nif (len == 3 && path[len - 1] == '.')\nreturn len - 1;\n\nif (len == 2 && path[len - 1] == '.')\nreturn len - 1;\n\nif (len > 2 && path[len - 1] == '.' && path[len - 2] == '.')\n{\nsize_t i = len - 2;\nwhile (i > 0 && path[i - 1] == '/')\ni--;\nreturn i;\n}\n\nreturn len;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_multithread.c_on_pong",
    "input":"\n0000000000000000 <on_pong>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tmovq\t%rsi, %rdi\n7: \tnopw\t(%rax,%rax)\n10: \tcallq\t0x15 <on_pong+0x15>\n15: \ttestl\t%eax, %eax\n17: \tjne\t0x30 <on_pong+0x30>\n19: \tmovq\t%rbx, %rdi\n1c: \tcallq\t0x21 <on_pong+0x21>\n21: \tmovl\t$0, %edi\n26: \tcallq\t0x2b <on_pong+0x2b>\n2b: \tmovq\t%rbx, %rdi\n2e: \tjmp\t0x10 <on_pong+0x10>\n30: \tpopq\t%rbx\n31: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_multithread_receiver_t ;\ntypedef  int /*<<< orphan*/  h2o_linklist_t ;\nstruct TYPE_2__ {int /*<<< orphan*/  ping_receiver; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_is_empty (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pop_empty_message (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  send_empty_message (int /*<<< orphan*/ *) ;\nTYPE_1__ worker_thread ;\n\n__attribute__((used)) static void on_pong(h2o_multithread_receiver_t *receiver, h2o_linklist_t *list)\n{\nwhile (!h2o_linklist_is_empty(list)) {\npop_empty_message(list);\nsend_empty_message(&worker_thread.ping_receiver);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  lua_pushstring (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  lua_pushvalue (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_rawgeti (int /*<<< orphan*/ *,int,int) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void on_pong(lua_State *L, int status)\n{\nint i = 1;\n\nwhile (status == 0) {\nlua_rawgeti(L, i, 1);\nlua_pushvalue(L, -1);\nlua_settop(L, 1);\ni++;\nstatus = lua_rawgeti(L, i, 1);\n}\nlua_pushstring(L, \"pong\");\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_timerwheel.c_test_add_fixed_timers",
    "input":"\n0000000000000000 <test_add_fixed_timers>:\n0: \tpushq\t%rbp\n1: \tmovq\t%rsp, %rbp\n4: \tpushq\t%r15\n6: \tpushq\t%r14\n8: \tpushq\t%rbx\n9: \tpushq\t%rax\na: \tmovl\t$6, %edi\nf: \tmovl\t$3, %esi\n14: \tcallq\t0x19 <test_add_fixed_timers+0x19>\n19: \tmovq\t%rax, %r14\n1c: \tmovl\t(%rip), %eax  # 0x22 <test_add_fixed_timers+0x22>\n22: \tmovq\t%rsp, %r15\n25: \tleaq\t15(,%rax,4), %rcx\n2d: \tandq\t$-16, %rcx\n31: \tsubq\t%rcx, %r15\n34: \tmovq\t%r15, %rsp\n37: \ttestl\t%eax, %eax\n39: \tjle\t0x70 <test_add_fixed_timers+0x70>\n3b: \txorl\t%ebx, %ebx\n3d: \tnopl\t(%rax)\n40: \tmovl\t(%rip), %esi  # 0x46 <test_add_fixed_timers+0x46>\n46: \tmovq\t%r15, %rdi\n49: \tcallq\t0x4e <test_add_fixed_timers+0x4e>\n4e: \tleal\t8(%rbx), %edx\n51: \tmovq\t%r14, %rdi\n54: \tmovq\t%r15, %rsi\n57: \tcallq\t0x5c <test_add_fixed_timers+0x5c>\n5c: \taddq\t$1, %rbx\n60: \tmovslq\t(%rip), %rax  # 0x67 <test_add_fixed_timers+0x67>\n67: \taddq\t$4, %r15\n6b: \tcmpq\t%rax, %rbx\n6e: \tjl\t0x40 <test_add_fixed_timers+0x40>\n70: \tmovq\t%r14, %rdi\n73: \tmovl\t$139, %esi\n78: \tcallq\t0x7d <test_add_fixed_timers+0x7d>\n7d: \txorl\t%edi, %edi\n7f: \tcmpl\t$132, %eax\n84: \tsete\t%dil\n88: \tcallq\t0x8d <test_add_fixed_timers+0x8d>\n8d: \tmovq\t%r14, %rdi\n90: \tcallq\t0x95 <test_add_fixed_timers+0x95>\n95: \tmovq\t%r14, %rdi\n98: \tcallq\t0x9d <test_add_fixed_timers+0x9d>\n9d: \tleaq\t-24(%rbp), %rsp\na1: \tpopq\t%rbx\na2: \tpopq\t%r14\na4: \tpopq\t%r15\na6: \tpopq\t%rbp\na7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint32_t ;\ntypedef  int /*<<< orphan*/  h2o_timerwheel_t ;\ntypedef  int /*<<< orphan*/  h2o_timerwheel_entry_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DUMP_WHEEL (int /*<<< orphan*/ *) ;\nint N ;\nint /*<<< orphan*/ * h2o_timerwheel_create (int,int) ;\nint /*<<< orphan*/  h2o_timerwheel_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timerwheel_init_entry (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timerwheel_link_abs (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint h2o_timerwheel_run (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  my_callback ;\nint /*<<< orphan*/  ok (int) ;\n\nvoid test_add_fixed_timers()\n{\nuint32_t abs_wtime = 3;\nh2o_timerwheel_t *testwheel = h2o_timerwheel_create(6, abs_wtime);\nint i;\n\nh2o_timerwheel_entry_t timers[N];\n/* add timers */\nfor (i = 0; i < N; i++) {\nuint32_t expiry = abs_wtime + i + 5;\nh2o_timerwheel_init_entry(&timers[i], my_callback);\nh2o_timerwheel_link_abs(testwheel, &timers[i], expiry);\n}\n\n/* run the wheel */\nok(h2o_timerwheel_run(testwheel, 139) == 132);\nDUMP_WHEEL(testwheel);\n\nh2o_timerwheel_destroy(testwheel);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GTimer ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_TIMER_ONE_SHOT ;\nint /*<<< orphan*/  g_assert_cmpint (int,==,int) ;\nint /*<<< orphan*/  g_assert_true (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_timer_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_timer_elapsed (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ * g_timer_new () ;\nint /*<<< orphan*/  g_timer_start (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_timer_stop (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_timer_start_from_now (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  g_timer_stop_from_now (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  g_timer_start_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_timer_stop_new (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\ntest_add_fixed_timers (void)\n{\nGTimer *timer;\nint i;\n\ntimer = g_timer_new ();\n\nfor (i = 0; i < 6; i++) {\ng_timer_start_new (G_TIMER_ONE_SHOT);\ng_timer_start_from_now (timer, 3);\ng_timer_stop_from_now (timer, 8);\n}\n\ng_assert_cmpint (g_timer_elapsed (timer, 139), ==, 132);\ng_assert_true (g_timer_stop_new (G_TIMER_ONE_SHOT));\ng_assert_true (g_timer_stop_new (G_TIMER_ONE_SHOT));\n\ng_timer_destroy (timer);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_get_timeleft",
    "input":"\n0000000000000000 <get_timeleft>:\n0: \tmovq\t(%rsi), %rax\n3: \tsubq\t%rdx, %rax\n6: \taddq\t(%rdi), %rax\n9: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\ntypedef  scalar_t__ int64_t ;\nstruct TYPE_5__ {scalar_t__ duration; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\nstruct TYPE_6__ {scalar_t__ at; } ;\ntypedef  TYPE_2__ h2o_cache_ref_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int64_t get_timeleft(h2o_cache_t *cache, h2o_cache_ref_t *ref, uint64_t now)\n{\nreturn (int64_t)(ref->at + cache->duration) - now;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ start_time; } ;\ntypedef  TYPE_1__ GLogContext ;\n\n/* Variables and functions */\n\n__attribute__((used)) static long long\nget_timeleft (GLogContext *ctx, long long now, long long timeout)\n{\nreturn timeout - (now - ctx->start_time);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_export",
    "input":"\n0000000000000000 <h2o_socket_export>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <h2o_socket_export+0xf>\nf: \txorl\t%edi, %edi\n11: \ttestl\t%eax, %eax\n13: \tsete\t%dil\n17: \tcallq\t0x1c <h2o_socket_export+0x1c>\n1c: \tmovq\t%rbx, %rdi\n1f: \tmovq\t%r14, %rsi\n22: \tcallq\t0x27 <h2o_socket_export+0x27>\n27: \tcmpl\t$-1, %eax\n2a: \tje\t0x76 <h2o_socket_export+0x76>\n2c: \tmovq\t8(%rbx), %rdi\n30: \tmovq\t%rdi, 8(%r14)\n34: \ttestq\t%rdi, %rdi\n37: \tje\t0x4b <h2o_socket_export+0x4b>\n39: \tmovq\t$0, 8(%rbx)\n41: \tmovl\t$0, %esi\n46: \tcallq\t0x4b <h2o_socket_export+0x4b>\n4b: \tmovl\t(%rbx), %eax\n4d: \tmovl\t%eax, (%r14)\n50: \tmovl\t$0, %esi\n55: \tmovq\t%r14, %rdi\n58: \tcallq\t0x5d <h2o_socket_export+0x5d>\n5d: \tmovl\t$0, %esi\n62: \tmovq\t%rbx, %rdi\n65: \tcallq\t0x6a <h2o_socket_export+0x6a>\n6a: \tmovq\t%rbx, %rdi\n6d: \tcallq\t0x72 <h2o_socket_export+0x72>\n72: \txorl\t%eax, %eax\n74: \tjmp\t0x7b <h2o_socket_export+0x7b>\n76: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n7b: \taddq\t$8, %rsp\n7f: \tpopq\t%rbx\n80: \tpopq\t%r14\n82: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_4__ ;\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_13__ {int /*<<< orphan*/  input; TYPE_2__* ssl; } ;\ntypedef  TYPE_3__ h2o_socket_t ;\nstruct TYPE_14__ {int /*<<< orphan*/  input; TYPE_2__* ssl; } ;\ntypedef  TYPE_4__ h2o_socket_export_t ;\ntypedef  int /*<<< orphan*/  h2o_buffer_prototype_t ;\nstruct TYPE_11__ {int /*<<< orphan*/  encrypted; } ;\nstruct TYPE_12__ {TYPE_1__ input; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint do_export (TYPE_3__*,TYPE_4__*) ;\nint /*<<< orphan*/  h2o_buffer_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_buffer_set_prototype (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_buffer_prototype ;\nint /*<<< orphan*/  h2o_socket_close (TYPE_3__*) ;\nint /*<<< orphan*/  h2o_socket_is_writing (TYPE_3__*) ;\n\nint h2o_socket_export(h2o_socket_t *sock, h2o_socket_export_t *info)\n{\nstatic h2o_buffer_prototype_t nonpooling_prototype;\n\nassert(!h2o_socket_is_writing(sock));\n\nif (do_export(sock, info) == -1)\nreturn -1;\n\nif ((info->ssl = sock->ssl) != NULL) {\nsock->ssl = NULL;\nh2o_buffer_set_prototype(&info->ssl->input.encrypted, &nonpooling_prototype);\n}\ninfo->input = sock->input;\nh2o_buffer_set_prototype(&info->input, &nonpooling_prototype);\nh2o_buffer_init(&sock->input, &h2o_socket_buffer_prototype);\n\nh2o_socket_close(sock);\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  fd; int /*<<< orphan*/ * ctx; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_export_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_socket_close (TYPE_1__*) ;\nint h2o_socket_getpeername (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_set_nonblocking (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_nodelay (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_tcp_keepalive (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_tcp_nodelay (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_timeout (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_linger (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_set_sockopt (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nint h2o_socket_export(h2o_socket_t *sock, h2o_socket_export_t *info)\n{\nassert(!sock->ctx);\nif (h2o_socket_getpeername(sock, &info->peername) != 0)\nreturn -1;\ninfo->ctx = sock->ctx;\nsock->ctx = NULL;\nh2o_socket_set_nonblocking(sock, 0);\nh2o_socket_set_tcp_nodelay(sock, 0);\nh2o_socket_set_tcp_keepalive(sock, 0);\nh2o_socket_set_timeout(sock, 0);\nh2o_socket_set_linger(sock, 0);\nh2o_socket_set_sockopt(sock, 0);\ninfo->fd = sock->fd;\nh2o_socket_close(sock);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_close",
    "input":"\n0000000000000000 <h2o_socket_close>:\n0: \tcmpq\t$0, (%rdi)\n4: \tje\t0xd <h2o_socket_close+0xd>\n6: \txorl\t%esi, %esi\n8: \tjmp\t0xd <h2o_socket_close+0xd>\nd: \txorl\t%esi, %esi\nf: \tjmp\t0x14 <h2o_socket_close+0x14>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  dispose_socket (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  shutdown_ssl (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nvoid h2o_socket_close(h2o_socket_t *sock)\n{\nif (sock->ssl == NULL) {\ndispose_socket(sock, 0);\n} else {\nshutdown_ssl(sock, 0);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ is_connected; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_close (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  do_close_socket (TYPE_1__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void h2o_socket_close(h2o_socket_t *sock)\n{\nif (sock->is_connected)\ndo_close(sock, 0);\nelse\ndo_close_socket(sock, 0);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_string.c_test_decode_base64",
    "input":"\n0000000000000000 <test_decode_base64>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$288, %rsp    # imm = 0x120\nc: \tleaq\t4(%rsp), %r14\n11: \tmovq\t%r14, %rdi\n14: \tcallq\t0x19 <test_decode_base64+0x19>\n19: \tmovl\t$0, %edi\n1e: \tcallq\t0x23 <test_decode_base64+0x23>\n23: \tmovslq\t%eax, %r15\n26: \tleaq\t32(%rsp), %rbx\n2b: \tmovq\t%rbx, %rdi\n2e: \tmovq\t%r15, %rsi\n31: \txorl\t%edx, %edx\n33: \tmovl\t$1, %ecx\n38: \tcallq\t0x3d <test_decode_base64+0x3d>\n3d: \tmovl\t$0, %esi\n42: \tmovq\t%rbx, %rdi\n45: \tcallq\t0x4a <test_decode_base64+0x4a>\n4a: \txorl\t%edi, %edi\n4c: \ttestq\t%rax, %rax\n4f: \tsete\t%dil\n53: \tcallq\t0x58 <test_decode_base64+0x58>\n58: \tmovq\t%rbx, %rdi\n5b: \tcallq\t0x60 <test_decode_base64+0x60>\n60: \tleaq\t8(%rsp), %rdi\n65: \tmovq\t%r14, %rsi\n68: \tmovq\t%rbx, %rdx\n6b: \tmovl\t%eax, %ecx\n6d: \tcallq\t0x72 <test_decode_base64+0x72>\n72: \tmovq\t8(%rsp), %rbx\n77: \txorl\t%edi, %edi\n79: \tcmpq\t$0, 16(%rsp)\n7f: \tsete\t%dil\n83: \tcallq\t0x88 <test_decode_base64+0x88>\n88: \tmovq\t%rbx, %rdi\n8b: \tmovq\t%r15, %rsi\n8e: \tcallq\t0x93 <test_decode_base64+0x93>\n93: \txorl\t%edi, %edi\n95: \ttestq\t%rax, %rax\n98: \tsete\t%dil\n9c: \tcallq\t0xa1 <test_decode_base64+0xa1>\na1: \tmovq\t%r14, %rdi\na4: \tcallq\t0xa9 <test_decode_base64+0xa9>\na9: \taddq\t$288, %rsp    # imm = 0x120\nb0: \tpopq\t%rbx\nb1: \tpopq\t%r14\nb3: \tpopq\t%r15\nb5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\nstruct TYPE_3__ {char* base; scalar_t__ len; int /*<<< orphan*/  member_0; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  h2o_base64_encode (char*,int /*<<< orphan*/  const*,scalar_t__,int) ;\nTYPE_1__ h2o_decode_base64url (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_clear_pool (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mem_init_pool (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ok (int) ;\nscalar_t__ strcmp (char*,char*) ;\nint /*<<< orphan*/  strlen (char*) ;\n\n__attribute__((used)) static void test_decode_base64(void)\n{\nh2o_mem_pool_t pool;\nchar buf[256];\n\nh2o_mem_init_pool(&pool);\n\nh2o_iovec_t src = {H2O_STRLIT(\"The quick brown fox jumps over the lazy dog.\")}, decoded;\nh2o_base64_encode(buf, (const uint8_t *)src.base, src.len, 1);\nok(strcmp(buf, \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4\") == 0);\ndecoded = h2o_decode_base64url(&pool, buf, strlen(buf));\nok(src.len == decoded.len);\nok(strcmp(decoded.base, src.base) == 0);\n\nh2o_mem_clear_pool(&pool);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_uint_eq (size_t,size_t) ;\nsize_t strlen (char*) ;\nint /*<<< orphan*/  test_decode_base64_data ;\nsize_t test_decode_base64_len ;\nint /*<<< orphan*/  test_decode_base64_str ;\nint /*<<< orphan*/  test_decode_base64_str_len ;\nint /*<<< orphan*/  test_decode_base64_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_wrong_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_wrong_str ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_str_len ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_str_len_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_wrong_wrong_wrong_str_wrong ;\nint /*<<< orphan*/  test_decode_base64_wrong_wrong_wrong_wrong_"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommon....depsssl-conservatoryopensslopenssl_hostname_validation.c_has_nul",
    "input":"\n0000000000000000 <has_nul>:\n0: \ttestq\t%rsi, %rsi\n3: \tje\t0x1f <has_nul+0x1f>\n5: \txorl\t%eax, %eax\n7: \tnopw\t(%rax,%rax)\n10: \tcmpb\t$0, (%rdi,%rax)\n14: \tje\t0x22 <has_nul+0x22>\n16: \taddq\t$1, %rax\n1a: \tcmpq\t%rax, %rsi\n1d: \tjne\t0x10 <has_nul+0x10>\n1f: \txorl\t%eax, %eax\n21: \tretq\n22: \tmovl\t$1, %eax\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int has_nul(const char *s, size_t l) {\nif (l == 0)\nreturn 0;\ndo {\nif (*s++ == '\\0')\nreturn 1;\n} while (--l != 0);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int has_nul(const char *s, size_t len)\n{\nsize_t i;\n\nfor (i = 0; i < len; i++)\nif (s[i] == '\\0')\nreturn 1;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_h2o_time2str_log",
    "input":"\n0000000000000000 <h2o_time2str_log>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$32, %rsp\n9: \tmovq\t%rdi, %r14\nc: \tmovl\t%esi, 4(%rsp)\n10: \tleaq\t4(%rsp), %rdi\n15: \tleaq\t8(%rsp), %rbx\n1a: \tmovq\t%rbx, %rsi\n1d: \tcallq\t0x22 <h2o_time2str_log+0x22>\n22: \tmovl\t4(%rsp), %edi\n26: \tmovq\t%rbx, %rsi\n29: \tcallq\t0x2e <h2o_time2str_log+0x2e>\n2e: \tmovl\t%eax, %ecx\n30: \tshrl\t$31, %ecx\n33: \tleal\t(%rcx,%rcx), %r10d\n37: \taddl\t$43, %r10d\n3b: \tmovl\t%eax, %ebx\n3d: \tnegl\t%ebx\n3f: \tcmovll\t%eax, %ebx\n42: \tmovslq\t12(%rsp), %rax\n47: \tleaq\t(,%rax,4), %rcx\n4f: \tmovl\t$1900, %r8d   # imm = 0x76C\n55: \taddl\t16(%rsp), %r8d\n5a: \tmovl\t8(%rsp), %edx\n5e: \tmovl\t20(%rsp), %r9d\n63: \tmovl\t24(%rsp), %r11d\n68: \tmovl\t28(%rsp), %r15d\n6d: \tmovl\t$2290649225, %eax  # imm = 0x88888889\n72: \timulq\t%rbx, %rax\n76: \tshrq\t$37, %rax\n7a: \timull\t$60, %eax, %esi\n7d: \tsubl\t%esi, %ebx\n7f: \tsubq\t$8, %rsp\n83: \tmovl\t$0, %esi\n88: \tmovq\t%r14, %rdi\n8b: \tpushq\t%rbx\n8c: \tpushq\t%rax\n8d: \tpushq\t%r10\n8f: \tpushq\t%r15\n91: \tpushq\t%r11\n93: \tcallq\t0x98 <h2o_time2str_log+0x98>\n98: \taddq\t$48, %rsp\n9c: \txorl\t%edi, %edi\n9e: \tcmpl\t(%rip), %eax  # 0xa4 <h2o_time2str_log+0xa4>\na4: \tsete\t%dil\na8: \tcallq\t0xad <h2o_time2str_log+0xad>\nad: \taddq\t$32, %rsp\nb1: \tpopq\t%rbx\nb2: \tpopq\t%r14\nb4: \tpopq\t%r15\nb6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  time_t ;\nstruct tm {int tm_mday; int tm_mon; int tm_year; int tm_hour; int tm_min; int tm_sec; } ;\n\n/* Variables and functions */\nint H2O_TIMESTR_LOG_LEN ;\nint /*<<< orphan*/  assert (int) ;\nint calc_gmt_offset (int /*<<< orphan*/ ,struct tm*) ;\nint /*<<< orphan*/  localtime_r (int /*<<< orphan*/ *,struct tm*) ;\nint sprintf (char*,char*,int,char*,int,int,int,int,int,int,int) ;\n\nvoid h2o_time2str_log(char *buf, time_t time)\n{\nstruct tm localt;\nlocaltime_r(&time, &localt);\nint gmt_off = calc_gmt_offset(time, &localt);\nint gmt_sign;\n\nif (gmt_off >= 0) {\ngmt_sign = '+';\n} else {\ngmt_off = -gmt_off;\ngmt_sign = '-';\n}\n\nint len = sprintf(buf, \"%02d/%s/%d:%02d:%02d:%02d %c%02d%02d\", localt.tm_mday,\n(\"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\\0\") + localt.tm_mon * 4, localt.tm_year + 1900,\nlocalt.tm_hour, localt.tm_min, localt.tm_sec, gmt_sign, gmt_off / 60, gmt_off % 60);\nassert(len == H2O_TIMESTR_LOG_LEN);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  time_t ;\nstruct tm {int tm_year; int tm_mon; int tm_mday; int tm_hour; int tm_min; int tm_sec; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  gmtime_r (int /*<<< orphan*/ *,struct tm*) ;\nint /*<<< orphan*/  snprintf (char*,int,char*,int,int,int,int,int,int,int) ;\nint strlen (char*) ;\n\nvoid h2o_time2str_log(char *buf, size_t buf_len, time_t t)\n{\nstruct tm tm;\nint len;\n\ngmtime_r(&t, &tm);\nlen = snprintf(buf, buf_len, \"%04d-%02d-%02d %02d:%02d:%02d\", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\ntm.tm_hour, tm.tm_min, tm.tm_sec);\nassert(len == strlen(buf));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_socket.c_test_lib__common__socket_c",
    "input":"\n0000000000000000 <test_lib__common__socket_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__socket_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__socket_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__socket_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_lib__common__socket_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_lib__common__socket_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tpopq\t%rax\n2d: \tjmp\t0x32 <test_lib__common__socket_c+0x32>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_on_alpn_select ;\nint /*<<< orphan*/  test_prepare_for_latency_optimization ;\nint /*<<< orphan*/  test_sliding_counter ;\n\nvoid test_lib__common__socket_c(void)\n{\nsubtest(\"on_alpn_select\", test_on_alpn_select);\nsubtest(\"sliding_counter\", test_sliding_counter);\nsubtest(\"prepare_for_latency_optimization\", test_prepare_for_latency_optimization);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_ASSERT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_NULL (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_TRUE (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_FAIL () ;\nint /*<<< orphan*/  TEST_IGNORE () ;\nint /*<<< orphan*/  TEST_PASS () ;\nint /*<<< orphan*/  TEST_SKIP () ;\nint /*<<< orphan*/  TEST_UNRESOLVED () ;\nint /*<<< orphan*/  TEST_UNTESTED () ;\nint /*<<< orphan*/  TEST_UNTESTED_OK () ;\nint /*<<< orphan*/  TEST_UNTESTED_SKIP () ;\nint /*<<< orphan*/  TEST_UNTESTED_UNRESOLVED () ;\nint /*<<< orphan*/  TEST_UNTESTED_UNRESOLVED_OK () ;\nint /*<<< orphan*/  TEST_UNTESTED_UNRESOLVED_SKIP () ;\nint /*<<< orphan*/  TEST_UNTESTED_UNRESOLVED_XFAIL () ;\nint /*<<< orphan*/  TEST_UNTESTED_XFAIL () ;\nint /*<<< orphan*/  TEST_XFAIL () ;\nint /*<<< orphan*/  TEST_XPASS () ;\nint /*<<< orphan*/  assert_true (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assert_zero (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assert_null (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_lib__common__socket_c_fail ;\nint /*<<< orphan*/  test_lib__common__socket_c_skip ;\nint /*<<< orphan*/  test_lib__common__socket_c_unresolved ;\nint /*<<< orphan*/  test_lib__common__socket_c_xfail ;\n\nvoid test_lib__common__socket_c(void)\n{\nTEST_ASSERT_TRUE(assert_true(test_lib__common__socket_c_fail));\nTEST_ASSERT_EQUAL(test_lib__common__socket_c_fail, test_lib__common__socket_c_fail);\nTEST_ASSERT_ZERO(assert_zero(test_lib__common__socket_c_fail));\nTEST_ASSERT_NULL(assert_null(test_lib__common__socket_c_fail));\n\nTEST_ASSERT_UNRESOLVED(TEST_UNRESOLVED());\nTEST_ASSERT_UNTESTED(TEST_UNTESTED());\nTEST_ASSERT_UNTESTED_OK(TEST_UNTESTED_OK());\nTEST_ASSERT_UNTESTED_SKIP(TEST_UNTESTED_SKIP());\nTEST_ASSERT_UNTESTED_UNRESOLVED(TEST_UNTESTED_UNRESOLVED());\nTEST_ASSERT_UNTESTED_UNRESOLVED_OK(TEST_UNTESTED_UNRESOLVED_OK());\nTEST_ASSERT_UNTESTED_UNRESOLVED_SKIP(TEST_UNTESTED_UNRESOLVED_SKIP());\nTEST_ASSERT_UNTESTED_UNRESOLVED_XFAIL(TEST_UNTESTED_UNRESOLVED_XFAIL());\nTEST_ASSERT_UNTESTED_XFAIL(TEST_UNTESTED_XFAIL());\nTEST_ASSERT_XFAIL(TEST_XFAIL());\nTEST_ASSERT_XPASS(TEST_XPASS());\nTEST_ASSERT_SKIP(TEST_SKIP());\nTEST_ASSERT_FAIL(TEST_FAIL());\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommon....depsssl-conservatoryopensslopenssl_hostname_validation.c_matches_common_name",
    "input":"\n0000000000000000 <matches_common_name>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovq\t%rsi, %rdi\nd: \tcallq\t0x12 <matches_common_name+0x12>\n12: \tmovl\t(%rip), %esi  # 0x18 <matches_common_name+0x18>\n18: \tmovl\t%eax, %edi\n1a: \tmovl\t$4294967295, %edx  # imm = 0xFFFFFFFF\n1f: \tcallq\t0x24 <matches_common_name+0x24>\n24: \ttestl\t%eax, %eax\n26: \tjs\t0x5c <matches_common_name+0x5c>\n28: \tmovl\t%eax, %ebp\n2a: \tmovq\t%rbx, %rdi\n2d: \tcallq\t0x32 <matches_common_name+0x32>\n32: \tmovl\t%eax, %edi\n34: \tmovl\t%ebp, %esi\n36: \tcallq\t0x3b <matches_common_name+0x3b>\n3b: \ttestq\t%rax, %rax\n3e: \tje\t0x5c <matches_common_name+0x5c>\n40: \tmovq\t%rax, %rdi\n43: \tcallq\t0x48 <matches_common_name+0x48>\n48: \ttestq\t%rax, %rax\n4b: \tje\t0x5c <matches_common_name+0x5c>\n4d: \tmovq\t%r14, %rdi\n50: \tmovq\t%rax, %rsi\n53: \tpopq\t%rbx\n54: \tpopq\t%r14\n56: \tpopq\t%rbp\n57: \tjmp\t0x5c <matches_common_name+0x5c>\n5c: \tmovl\t(%rip), %eax  # 0x62 <matches_common_name+0x62>\n62: \tpopq\t%rbx\n63: \tpopq\t%r14\n65: \tpopq\t%rbp\n66: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  X509_NAME_ENTRY ;\ntypedef  int /*<<< orphan*/  X509 ;\ntypedef  int /*<<< orphan*/  HostnameValidationResult ;\ntypedef  int /*<<< orphan*/  ASN1_STRING ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Error ;\nint /*<<< orphan*/  NID_commonName ;\nint /*<<< orphan*/ * X509_NAME_ENTRY_get_data (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * X509_NAME_get_entry (int /*<<< orphan*/ ,int) ;\nint X509_NAME_get_index_by_NID (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  X509_get_subject_name (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  validate_name (char const*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static HostnameValidationResult matches_common_name(const char *hostname, const X509 *server_cert) {\nint common_name_loc = -1;\nX509_NAME_ENTRY *common_name_entry = NULL;\nASN1_STRING *common_name_asn1 = NULL;\n\n// Find the position of the CN field in the Subject field of the certificate\ncommon_name_loc = X509_NAME_get_index_by_NID(X509_get_subject_name((X509 *) server_cert), NID_commonName, -1);\nif (common_name_loc < 0) {\nreturn Error;\n}\n\n// Extract the CN field\ncommon_name_entry = X509_NAME_get_entry(X509_get_subject_name((X509 *) server_cert), common_name_loc);\nif (common_name_entry == NULL) {\nreturn Error;\n}\ncommon_name_asn1 = X509_NAME_ENTRY_get_data(common_name_entry);\nif (common_name_asn1 == NULL) {\nreturn Error;\n}\n\n// validate the names\nreturn validate_name(hostname, common_name_asn1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  X509 ;\ntypedef  int /*<<< orphan*/  ASN1_STRING ;\n\n/* Variables and functions */\nint /*<<< orphan*/  NID_commonName ;\nint /*<<< orphan*/  X509_get_subject_name (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  X509_NAME_ENTRY_get_data (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * X509_NAME_get_entry (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/ * X509_NAME_ENTRY_get_data (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  X509_NAME_get_index_by_NID (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  X509_NAME_oneline (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  strcmp (char const*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int matches_common_name(const char *name, X509 *cert)\n{\nASN1_STRING *cn;\nint cn_len;\nchar cn_str[256];\n\ncn = X509_get_subject_name(cert);\ncn_len = X509_NAME_get_index_by_NID(cn, NID_commonName, -1);\nif (cn_len < 0)\nreturn -1;\ncn = X509_NAME_get_entry(cn, cn_len);\ncn = X509_NAME_ENTRY_get_data(cn);\nif (!cn)\nreturn -1;\nX509_NAME_ENTRY_get_data(cn);\nX509_NAME_oneline(cn, cn_str, sizeof(cn_str));\nif (strcmp(name, cn_str) == 0)\nreturn 0;\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_is_early_data",
    "input":"\n0000000000000000 <h2o_socket_ssl_is_early_data>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%edi, %edi\n6: \tcmpq\t$0, (%rbx)\na: \tsetne\t%dil\ne: \tcallq\t0x13 <h2o_socket_ssl_is_early_data+0x13>\n13: \tmovq\t(%rbx), %rax\n16: \tmovq\t(%rax), %rdi\n19: \ttestq\t%rdi, %rdi\n1c: \tje\t0x27 <h2o_socket_ssl_is_early_data+0x27>\n1e: \tcallq\t0x23 <h2o_socket_ssl_is_early_data+0x23>\n23: \ttestl\t%eax, %eax\n25: \tje\t0x2b <h2o_socket_ssl_is_early_data+0x2b>\n27: \txorl\t%eax, %eax\n29: \tpopq\t%rbx\n2a: \tretq\n2b: \tmovl\t$1, %eax\n30: \tpopq\t%rbx\n31: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * ptls; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ptls_handshake_is_complete (int /*<<< orphan*/ *) ;\n\nint h2o_socket_ssl_is_early_data(h2o_socket_t *sock)\n{\nassert(sock->ssl != NULL);\n\nif (sock->ssl->ptls != NULL && !ptls_handshake_is_complete(sock->ssl->ptls))\nreturn 1;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\nstruct TYPE_4__ {scalar_t__ early_data_state; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint SSL_in_early_data (scalar_t__) ;\n\nint h2o_socket_ssl_is_early_data(h2o_socket_t *sock)\n{\nassert(sock->ssl != NULL);\nif (sock->ssl->early_data_state != 0)\nreturn 0;\nreturn SSL_in_early_data(sock->ssl->ssl);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloopepoll.c.h_evloop_do_on_socket_export",
    "input":"\n0000000000000000 <evloop_do_on_socket_export>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %eax  # 0xa <evloop_do_on_socket_export+0xa>\na: \ttestl\t%eax, (%rdi)\nc: \tje\t0x60 <evloop_do_on_socket_export+0x60>\ne: \tmovq\t%rdi, %r14\n11: \tmovq\t8(%rdi), %rbx\n15: \tnopw\t%cs:(%rax,%rax)\n1f: \tnop\n20: \tmovl\t(%rbx), %edi\n22: \tmovl\t(%rip), %esi  # 0x28 <evloop_do_on_socket_export+0x28>\n28: \tmovl\t4(%r14), %edx\n2c: \txorl\t%ecx, %ecx\n2e: \tcallq\t0x33 <evloop_do_on_socket_export+0x33>\n33: \tmovq\t(%rip), %rsi  # 0x3a <evloop_do_on_socket_export+0x3a>\n3a: \ttestl\t%eax, %eax\n3c: \tje\t0x47 <evloop_do_on_socket_export+0x47>\n3e: \tcmpq\t(%rip), %rsi  # 0x45 <evloop_do_on_socket_export+0x45>\n45: \tje\t0x20 <evloop_do_on_socket_export+0x20>\n47: \ttestl\t%eax, %eax\n49: \tje\t0x60 <evloop_do_on_socket_export+0x60>\n4b: \tmovl\t4(%r14), %edx\n4f: \tmovl\t$0, %edi\n54: \taddq\t$8, %rsp\n58: \tpopq\t%rbx\n59: \tpopq\t%r14\n5b: \tjmp\t0x60 <evloop_do_on_socket_export+0x60>\n60: \taddq\t$8, %rsp\n64: \tpopq\t%rbx\n65: \tpopq\t%r14\n67: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int _flags; int /*<<< orphan*/  fd; scalar_t__ loop; } ;\nstruct st_h2o_evloop_epoll_t {int /*<<< orphan*/  ep; } ;\n\n/* Variables and functions */\nscalar_t__ EINTR ;\nint /*<<< orphan*/  EPOLL_CTL_DEL ;\nint H2O_SOCKET_FLAG__EPOLL_IS_REGISTERED ;\nint epoll_ctl (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nscalar_t__ errno ;\nint /*<<< orphan*/  h2o_error_printf (char*,scalar_t__,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void evloop_do_on_socket_export(struct st_h2o_evloop_socket_t *sock)\n{\nstruct st_h2o_evloop_epoll_t *loop = (void *)sock->loop;\nint ret;\n\nif ((sock->_flags & H2O_SOCKET_FLAG__EPOLL_IS_REGISTERED) == 0)\nreturn;\nwhile ((ret = epoll_ctl(loop->ep, EPOLL_CTL_DEL, sock->fd, NULL)) != 0 && errno == EINTR)\n;\nif (ret != 0)\nh2o_error_printf(\"socket_export: epoll(DEL) returned error %d (fd=%d)\\n\", errno, sock->fd);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int flags; int /*<<< orphan*/  fd; int /*<<< orphan*/ * sock; } ;\ntypedef  TYPE_1__ evloop_socket_t ;\n\n/* Variables and functions */\nint EVLOOP_FLAG_EXPORT ;\nint /*<<< orphan*/  EVLOOP_SOCKET_EXPORT ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nscalar_t__ socket_export (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nscalar_t__ socket_export_error ;\n\n__attribute__((used)) static void evloop_do_on_socket_export(evloop_socket_t *sock) {\nif (sock->flags & EVLOOP_FLAG_EXPORT) {\nwhile (socket_export(sock->sock->fd, EVLOOP_SOCKET_EXPORT, sock->fd, NULL) == 0) {\nif (socket_export_error != socket_export_error) {\nfprintf(stderr, \"socket_export failed: %d\\n\", sock->fd);\nreturn;\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_do_read_start",
    "input":"\n0000000000000000 <do_read_start>:\n0: \tjmp\t0x5 <do_read_start+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int dummy; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  link_to_statechanged (struct st_h2o_evloop_socket_t*) ;\n\nvoid do_read_start(h2o_socket_t *_sock)\n{\nstruct st_h2o_evloop_socket_t *sock = (struct st_h2o_evloop_socket_t *)_sock;\n\nlink_to_statechanged(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  lua_pushboolean (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void do_read_start(lua_State *L)\n{\nlua_pushboolean(L, 1);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_h2o_cache_calchash",
    "input":"\n0000000000000000 <h2o_cache_calchash>:\n0: \ttestq\t%rsi, %rsi\n3: \tje\t0x18 <h2o_cache_calchash+0x18>\n5: \tleaq\t-1(%rsi), %rax\n9: \tmovl\t%esi, %ecx\nb: \tandl\t$3, %ecx\ne: \tcmpq\t$3, %rax\n12: \tjae\t0x1b <h2o_cache_calchash+0x1b>\n14: \txorl\t%eax, %eax\n16: \tjmp\t0x61 <h2o_cache_calchash+0x61>\n18: \txorl\t%eax, %eax\n1a: \tretq\n1b: \txorl\t%eax, %eax\n1d: \tnopl\t(%rax)\n20: \tmovl\t%eax, %edx\n22: \tshll\t$5, %edx\n25: \tsubl\t%eax, %edx\n27: \tmovzbl\t-1(%rdi,%rsi), %eax\n2c: \taddl\t%edx, %eax\n2e: \tmovl\t%eax, %edx\n30: \tshll\t$5, %edx\n33: \tsubl\t%eax, %edx\n35: \tmovzbl\t-2(%rdi,%rsi), %eax\n3a: \taddl\t%edx, %eax\n3c: \tmovl\t%eax, %edx\n3e: \tshll\t$5, %edx\n41: \tsubl\t%eax, %edx\n43: \tmovzbl\t-3(%rdi,%rsi), %eax\n48: \taddl\t%edx, %eax\n4a: \tmovl\t%eax, %edx\n4c: \tshll\t$5, %edx\n4f: \tsubl\t%eax, %edx\n51: \tmovzbl\t-4(%rdi,%rsi), %eax\n56: \taddq\t$-4, %rsi\n5a: \taddl\t%edx, %eax\n5c: \tcmpq\t%rsi, %rcx\n5f: \tjne\t0x20 <h2o_cache_calchash+0x20>\n61: \ttestq\t%rcx, %rcx\n64: \tje\t0x96 <h2o_cache_calchash+0x96>\n66: \tleaq\t(%rsi,%rdi), %rdx\n6a: \taddq\t$-1, %rdx\n6e: \tnegq\t%rcx\n71: \txorl\t%esi, %esi\n73: \tnopw\t%cs:(%rax,%rax)\n7d: \tnopl\t(%rax)\n80: \tmovl\t%eax, %edi\n82: \tshll\t$5, %edi\n85: \tsubl\t%eax, %edi\n87: \tmovzbl\t(%rdx,%rsi), %eax\n8b: \taddl\t%edi, %eax\n8d: \taddq\t$-1, %rsi\n91: \tcmpq\t%rsi, %rcx\n94: \tjne\t0x80 <h2o_cache_calchash+0x80>\n96: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int h2o_cache_hashcode_t ;\n\n/* Variables and functions */\n\nh2o_cache_hashcode_t h2o_cache_calchash(const char *s, size_t l)\n{\nh2o_cache_hashcode_t h = 0;\nfor (; l != 0; --l)\nh = (h << 5) - h + ((unsigned char *)s)[l - 1];\nreturn h;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static size_t h2o_cache_calchash(const char *key, size_t key_len)\n{\nsize_t hash = 0;\n\nif (key_len == 0)\nreturn 0;\n\nfor (; key_len != 0; --key_len) {\nhash = (hash << 5) - hash + *key++;\n}\n\nreturn hash;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontimerwheel.c_cascade_all",
    "input":"\n0000000000000000 <cascade_all>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \txorl\t%r15d, %r15d\nb: \tcmpq\t%rsi, (%rdi)\ne: \tjbe\t0x66 <cascade_all+0x66>\n10: \tmovq\t%rsi, %rbx\n13: \tmovq\t%rdi, %r14\n16: \txorl\t%r15d, %r15d\n19: \tmovl\t$1, %r12d\n1f: \tnop\n20: \tmovl\t16(%r14), %esi\n24: \tmovq\t%rbx, %rdi\n27: \tcallq\t0x2c <cascade_all+0x2c>\n2c: \tmovq\t%rax, %rbp\n2f: \tmovq\t8(%r14), %rax\n33: \tleaq\t(,%rbp,4), %rdi\n3b: \taddq\t(%rax,%rbx,8), %rdi\n3f: \tcallq\t0x44 <cascade_all+0x44>\n44: \ttestl\t%eax, %eax\n46: \tcmovel\t%r12d, %r15d\n4a: \tmovq\t%r14, %rdi\n4d: \tmovq\t%rbx, %rsi\n50: \tmovq\t%rbp, %rdx\n53: \tcallq\t0x58 <cascade_all+0x58>\n58: \ttestq\t%rbp, %rbp\n5b: \tjne\t0x66 <cascade_all+0x66>\n5d: \taddq\t$1, %rbx\n61: \tcmpq\t(%r14), %rbx\n64: \tjb\t0x20 <cascade_all+0x20>\n66: \tmovl\t%r15d, %eax\n69: \tpopq\t%rbx\n6a: \tpopq\t%r12\n6c: \tpopq\t%r14\n6e: \tpopq\t%r15\n70: \tpopq\t%rbp\n71: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t num_wheels; int /*<<< orphan*/ ** wheels; int /*<<< orphan*/  last_run; } ;\ntypedef  TYPE_1__ h2o_timerwheel_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  cascade_one (TYPE_1__*,size_t,size_t) ;\nint /*<<< orphan*/  h2o_linklist_is_empty (int /*<<< orphan*/ *) ;\nsize_t timer_slot (size_t,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int cascade_all(h2o_timerwheel_t *ctx, size_t wheel)\n{\nint cascaded = 0;\n\nfor (; wheel < ctx->num_wheels; ++wheel) {\nsize_t slot = timer_slot(wheel, ctx->last_run);\nif (!h2o_linklist_is_empty(&ctx->wheels[wheel][slot]))\ncascaded = 1;\ncascade_one(ctx, wheel, slot);\nif (slot != 0)\nbreak;\n}\n\nreturn cascaded;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {size_t n_cascade; int /*<<< orphan*/ * cascade; int /*<<< orphan*/  cascade_len; } ;\ntypedef  TYPE_1__ GLog ;\n\n/* Variables and functions */\nint /*<<< orphan*/  cascade_all (TYPE_1__*,size_t,size_t) ;\nint /*<<< orphan*/  cascade_len (size_t,int /*<<< orphan*/ ) ;\nsize_t cascade_pos (size_t,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int cascade_all (GLog *glog, size_t pos) {\nint r = 0;\nfor (size_t i = 0; i < glog->n_cascade; i++) {\nsize_t cascade_pos = cascade_pos (pos, glog->cascade_len);\nif (cascade_pos < glog->cascade[i]) {\nr = 1;\n}\ncascade_all (glog, cascade_pos);\n}\nreturn r;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_do_import",
    "input":"\n0000000000000000 <do_import>:\n0: \tmovl\t(%rsi), %esi\n2: \txorl\t%edx, %edx\n4: \tjmp\t0x9 <do_import+0x9>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\nstruct TYPE_3__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ h2o_socket_export_t ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * h2o_evloop_socket_create (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nh2o_socket_t *do_import(h2o_loop_t *loop, h2o_socket_export_t *info)\n{\nreturn h2o_evloop_socket_create(loop, info->fd, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  name; } ;\ntypedef  TYPE_1__ Import ;\ntypedef  int /*<<< orphan*/  HANDLE ;\ntypedef  int /*<<< orphan*/  DWORD ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_import_dll (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void do_import( HANDLE hFile, Import *imp )\n{\ndo_import_dll( hFile, imp->name, 0 );\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ssl_session_reused",
    "input":"\n0000000000000000 <h2o_socket_get_ssl_session_reused>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rdi), %rcx\n4: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n9: \ttestq\t%rcx, %rcx\nc: \tje\t0x2a <h2o_socket_get_ssl_session_reused+0x2a>\ne: \tmovq\t8(%rcx), %rdi\n12: \ttestq\t%rdi, %rdi\n15: \tje\t0x1d <h2o_socket_get_ssl_session_reused+0x1d>\n17: \tpopq\t%rax\n18: \tjmp\t0x1d <h2o_socket_get_ssl_session_reused+0x1d>\n1d: \tmovq\t(%rcx), %rdi\n20: \ttestq\t%rdi, %rdi\n23: \tje\t0x2a <h2o_socket_get_ssl_session_reused+0x2a>\n25: \tcallq\t0x2a <h2o_socket_get_ssl_session_reused+0x2a>\n2a: \tpopq\t%rcx\n2b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * ossl; int /*<<< orphan*/ * ptls; } ;\n\n/* Variables and functions */\nscalar_t__ SSL_session_reused (int /*<<< orphan*/ *) ;\nint ptls_is_psk_handshake (int /*<<< orphan*/ *) ;\n\nint h2o_socket_get_ssl_session_reused(h2o_socket_t *sock)\n{\nif (sock->ssl != NULL) {\nif (sock->ssl->ptls != NULL)\nreturn ptls_is_psk_handshake(sock->ssl->ptls);\nif (sock->ssl->ossl != NULL)\nreturn (int)SSL_session_reused(sock->ssl->ossl);\n}\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * ssl; int /*<<< orphan*/ * ssl_ctx; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint SSL_session_reused (int /*<<< orphan*/ *) ;\n\nint h2o_socket_get_ssl_session_reused(h2o_socket_t *sock)\n{\nif (sock->ssl_ctx != NULL)\nreturn SSL_session_reused(sock->ssl_ctx);\nif (sock->ssl != NULL)\nreturn SSL_session_reused(sock->ssl);\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommon....depsssl-conservatoryopensslopenssl_hostname_validation.c_memeq_ncase",
    "input":"\n0000000000000000 <memeq_ncase>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovl\t$1, %r14d\n11: \ttestq\t%rdx, %rdx\n14: \tje\t0x5a <memeq_ncase+0x5a>\n16: \tmovq\t%rdx, %r13\n19: \tmovq\t%rsi, %r15\n1c: \tmovq\t%rdi, %r12\n1f: \txorl\t%ebx, %ebx\n21: \tnopw\t%cs:(%rax,%rax)\n2b: \tnopl\t(%rax,%rax)\n30: \tmovsbl\t(%r12,%rbx), %edi\n35: \tcallq\t0x3a <memeq_ncase+0x3a>\n3a: \tmovq\t%rax, %rbp\n3d: \tmovsbl\t(%r15,%rbx), %edi\n42: \tcallq\t0x47 <memeq_ncase+0x47>\n47: \tcmpq\t%rax, %rbp\n4a: \tjne\t0x57 <memeq_ncase+0x57>\n4c: \taddq\t$1, %rbx\n50: \tcmpq\t%rbx, %r13\n53: \tjne\t0x30 <memeq_ncase+0x30>\n55: \tjmp\t0x5a <memeq_ncase+0x5a>\n57: \txorl\t%r14d, %r14d\n5a: \tmovl\t%r14d, %eax\n5d: \taddq\t$8, %rsp\n61: \tpopq\t%rbx\n62: \tpopq\t%r12\n64: \tpopq\t%r13\n66: \tpopq\t%r14\n68: \tpopq\t%r15\n6a: \tpopq\t%rbp\n6b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ lowercase (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int memeq_ncase(const char *x, const char *y, size_t l) {\nif (l == 0)\nreturn 1;\ndo {\nif (lowercase(*x++) != lowercase(*y++))\nreturn 0;\n} while (--l != 0);\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ tolower (char) ;\n\n__attribute__((used)) static int\nmemeq_ncase(const char *a, const char *b, size_t n)\n{\nsize_t\t\ti;\n\nfor (i = 0; i < n; i++)\n{\nif (tolower((unsigned char) a[i]) != tolower((unsigned char) b[i]))\nreturn 0;\n}\nreturn 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_emit_mon",
    "input":"\n0000000000000000 <emit_mon>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tleal\t(%rsi,%rsi,2), %eax\n7: \tcltq\n9: \tleaq\t(%rax), %rsi\n10: \tmovl\t$3, %edx\n15: \tcallq\t0x1a <emit_mon+0x1a>\n1a: \tleaq\t3(%rbx), %rax\n1e: \tpopq\t%rbx\n1f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (char*,char*,int) ;\n\n__attribute__((used)) static char *emit_mon(char *dst, int mon)\n{\nmemcpy(dst, (\"JanFebMarAprMayJunJulAugSepOctNovDec\") + mon * 3, 3);\nreturn dst + 3;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fz_output ;\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_write_data (int /*<<< orphan*/ *,int /*<<< orphan*/ *,char*,int) ;\n\n__attribute__((used)) static inline char *emit_mon(fz_context *ctx, fz_output *out, char *p, int mon)\n{\nfz_write_data(ctx, out, p, 3 * mon);\nreturn p + 3 * mon;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonserverutil.c_h2o_set_signal_handler",
    "input":"\n0000000000000000 <h2o_set_signal_handler>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovq\t%rsi, %rbx\nb: \tmovl\t%edi, %ebp\nd: \tmovq\t%rsp, %r14\n10: \tmovq\t%r14, %rdi\n13: \txorl\t%esi, %esi\n15: \tmovl\t$16, %edx\n1a: \tcallq\t0x1f <h2o_set_signal_handler+0x1f>\n1f: \tleaq\t8(%rsp), %rdi\n24: \tcallq\t0x29 <h2o_set_signal_handler+0x29>\n29: \tmovq\t%rbx, (%rsp)\n2d: \tmovl\t%ebp, %edi\n2f: \tmovq\t%r14, %rsi\n32: \txorl\t%edx, %edx\n34: \tcallq\t0x39 <h2o_set_signal_handler+0x39>\n39: \taddq\t$16, %rsp\n3d: \tpopq\t%rbx\n3e: \tpopq\t%r14\n40: \tpopq\t%rbp\n41: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sigaction {void (* sa_handler ) (int) ;int /*<<< orphan*/  sa_mask; } ;\ntypedef  int /*<<< orphan*/  action ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memset (struct sigaction*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  sigaction (int,struct sigaction*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  sigemptyset (int /*<<< orphan*/ *) ;\n\nvoid h2o_set_signal_handler(int signo, void (*cb)(int signo))\n{\nstruct sigaction action;\n\nmemset(&action, 0, sizeof(action));\nsigemptyset(&action.sa_mask);\naction.sa_handler = cb;\nsigaction(signo, &action, NULL);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_signal_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  signal (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sigaction (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nvoid h2o_set_signal_handler(int signo, h2o_signal_cb cb)\n{\nstruct sigaction sa;\n\nmemset(&sa, 0, sizeof(sa));\nsa.sa_handler = cb;\nsigaction(signo, &sa, NULL);\nsignal(signo, cb);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommon....depsssl-conservatoryopensslopenssl_hostname_validation.c_validate_hostname",
    "input":"\n0000000000000000 <validate_hostname>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \ttestq\t%rdi, %rdi\n7: \tje\t0x37 <validate_hostname+0x37>\n9: \tmovq\t%rsi, %r14\nc: \ttestq\t%rsi, %rsi\nf: \tje\t0x37 <validate_hostname+0x37>\n11: \tmovq\t%rdi, %rbx\n14: \tmovq\t%r14, %rsi\n17: \tcallq\t0x1c <validate_hostname+0x1c>\n1c: \tcmpq\t(%rip), %rax  # 0x23 <validate_hostname+0x23>\n23: \tjne\t0x3e <validate_hostname+0x3e>\n25: \tmovq\t%rbx, %rdi\n28: \tmovq\t%r14, %rsi\n2b: \taddq\t$8, %rsp\n2f: \tpopq\t%rbx\n30: \tpopq\t%r14\n32: \tjmp\t0x37 <validate_hostname+0x37>\n37: \tmovq\t(%rip), %rax  # 0x3e <validate_hostname+0x3e>\n3e: \taddq\t$8, %rsp\n42: \tpopq\t%rbx\n43: \tpopq\t%r14\n45: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  X509 ;\ntypedef  scalar_t__ HostnameValidationResult ;\n\n/* Variables and functions */\nscalar_t__ Error ;\nscalar_t__ NoSANPresent ;\nscalar_t__ matches_common_name (char const*,int /*<<< orphan*/  const*) ;\nscalar_t__ matches_subject_alternative_name (char const*,int /*<<< orphan*/  const*) ;\n\nHostnameValidationResult validate_hostname(const char *hostname, const X509 *server_cert) {\nHostnameValidationResult result;\n\nif((hostname == NULL) || (server_cert == NULL))\nreturn Error;\n\n// First try the Subject Alternative Names extension\nresult = matches_subject_alternative_name(hostname, server_cert);\nif (result == NoSANPresent) {\n// Extension was not found: try the Common Name\nresult = matches_common_name(hostname, server_cert);\n}\n\nreturn result;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nscalar_t__ SSL_SUCCESS ;\nscalar_t__ SSL_TLSEXT_ERR_OK ;\nscalar_t__ SSL_TLSEXT_ERR_NOACK ;\nscalar_t__ SSL_TLSEXT_ERR_NOTSUPPORTED ;\nscalar_t__ SSL_TLSEXT_ERR_UNRECOGNIZED_NAME ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_READ ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_WRITE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_X509_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_PRIVATE_KEY_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_TYPE ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_LOOKUP ;\nscalar_t__ SSL_TLSEXT_ERR_WANT_CERT_VERIFY_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_WITH_SIGN_STATUS ;\nscalar_t__ SSL_TLSEXT_ERR_W"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_on_handshake_failure_ossl111",
    "input":"\n0000000000000000 <on_handshake_failure_ossl111>:\n0: \tmovl\t(%rip), %esi  # 0x6 <on_handshake_failure_ossl111+0x6>\n6: \tjmp\t0xb <on_handshake_failure_ossl111+0xb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_socket_error_ssl_handshake ;\nint /*<<< orphan*/  on_handshake_complete (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_handshake_failure_ossl111(h2o_socket_t *sock, const char *err)\n{\non_handshake_complete(sock, h2o_socket_error_ssl_handshake);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_AD_HANDSHAKE_FAILURE ;\nint /*<<< orphan*/  SSL_alert (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_handshake_failure_ossl111(SSL *ssl)\n{\nSSL_alert(ssl, SSL_AD_HANDSHAKE_FAILURE);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_ctrl_bio",
    "input":"\n0000000000000000 <ctrl_bio>:\n0: \tpushq\t%rbx\n1: \tmovl\t$1, %ebx\n6: \tcmpl\t$128, %esi\nc: \tje\t0x24 <ctrl_bio+0x24>\ne: \tcmpl\t$130, %esi\n14: \tje\t0x2f <ctrl_bio+0x2f>\n16: \tcmpl\t$129, %esi\n1c: \tjne\t0x2d <ctrl_bio+0x2d>\n1e: \tpopq\t%rbx\n1f: \tjmp\t0x24 <ctrl_bio+0x24>\n24: \tmovl\t%edx, %esi\n26: \tcallq\t0x2b <ctrl_bio+0x2b>\n2b: \tjmp\t0x2f <ctrl_bio+0x2f>\n2d: \txorl\t%ebx, %ebx\n2f: \tmovq\t%rbx, %rax\n32: \tpopq\t%rbx\n33: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\n#define  BIO_CTRL_FLUSH 130\n#define  BIO_CTRL_GET_CLOSE 129\n#define  BIO_CTRL_SET_CLOSE 128\nlong BIO_get_shutdown (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  BIO_set_shutdown (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static long ctrl_bio(BIO *b, int cmd, long num, void *ptr)\n{\nswitch (cmd) {\ncase BIO_CTRL_GET_CLOSE:\nreturn BIO_get_shutdown(b);\ncase BIO_CTRL_SET_CLOSE:\nBIO_set_shutdown(b, (int)num);\nreturn 1;\ncase BIO_CTRL_FLUSH:\nreturn 1;\ndefault:\nreturn 0;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint BIO_ctrl (int /*<<< orphan*/ *,int,int,void*) ;\nint BIO_ctrl_pending (int /*<<< orphan*/ *) ;\nint BIO_ctrl_wpending (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int ctrl_bio(BIO *b, int cmd, long num, void *ptr)\n{\nint ret = 0;\n\nswitch (cmd) {\ncase 128:\nret = BIO_ctrl_pending(b);\nbreak;\ncase 129:\nret = BIO_ctrl_wpending(b);\nbreak;\ncase 130:\nret = BIO_ctrl(b, num, 0, ptr);\nbreak;\n}\n\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_new_session_cb",
    "input":"\n0000000000000000 <h2o_socket_ssl_new_session_cb>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rsi, %r14\ne: \tmovq\t%rdi, %rbp\n11: \tcallq\t0x16 <h2o_socket_ssl_new_session_cb+0x16>\n16: \tmovq\t%rax, %rbx\n19: \txorl\t%edi, %edi\n1b: \ttestq\t%rax, %rax\n1e: \tsetne\t%dil\n22: \tcallq\t0x27 <h2o_socket_ssl_new_session_cb+0x27>\n27: \txorl\t%edi, %edi\n29: \tcmpq\t$0, (%rbx)\n2d: \tsetne\t%dil\n31: \tcallq\t0x36 <h2o_socket_ssl_new_session_cb+0x36>\n36: \tmovq\t%rbp, %rdi\n39: \tcallq\t0x3e <h2o_socket_ssl_new_session_cb+0x3e>\n3e: \txorl\t%ebp, %ebp\n40: \ttestl\t%eax, %eax\n42: \tjne\t0x90 <h2o_socket_ssl_new_session_cb+0x90>\n44: \tmovq\t(%rbx), %rax\n47: \tmovq\t8(%rax), %r15\n4b: \ttestq\t%r15, %r15\n4e: \tje\t0x90 <h2o_socket_ssl_new_session_cb+0x90>\n50: \tmovq\t%rbx, %rdi\n53: \tcallq\t0x58 <h2o_socket_ssl_new_session_cb+0x58>\n58: \tmovl\t%eax, %edi\n5a: \tcallq\t0x5f <h2o_socket_ssl_new_session_cb+0x5f>\n5f: \tmovl\t%eax, %r12d\n62: \tmovq\t(%rbx), %rax\n65: \tmovl\t(%rax), %r13d\n68: \tmovl\t4(%rax), %ebx\n6b: \tmovl\t$1, %ebp\n70: \tmovq\t%r14, %rdi\n73: \tmovl\t$1, %esi\n78: \tcallq\t0x7d <h2o_socket_ssl_new_session_cb+0x7d>\n7d: \tmovq\t%r15, %rdi\n80: \tmovl\t%r12d, %esi\n83: \tmovl\t%ebx, %edx\n85: \tmovl\t%r13d, %ecx\n88: \tmovl\t%eax, %r8d\n8b: \tcallq\t0x90 <h2o_socket_ssl_new_session_cb+0x90>\n90: \tmovl\t%ebp, %eax\n92: \taddq\t$8, %rsp\n96: \tpopq\t%rbx\n97: \tpopq\t%r12\n99: \tpopq\t%r13\n9b: \tpopq\t%r14\n9d: \tpopq\t%r15\n9f: \tpopq\t%rbp\na0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {TYPE_3__* ssl; } ;\ntypedef  TYPE_4__ h2o_socket_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  session_cache_key_hash; int /*<<< orphan*/  session_cache_key; int /*<<< orphan*/ * session_cache; } ;\nstruct TYPE_7__ {TYPE_1__ client; } ;\nstruct TYPE_8__ {TYPE_2__ handshake; } ;\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nscalar_t__ SSL_SESSION_is_resumable (int /*<<< orphan*/ *) ;\nscalar_t__ SSL_get_app_data (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_is_server (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_cache_set (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_iovec_init (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  h2o_now (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_get_loop (TYPE_4__*) ;\n\nint h2o_socket_ssl_new_session_cb(SSL *s, SSL_SESSION *sess)\n{\nh2o_socket_t *sock = (h2o_socket_t *)SSL_get_app_data(s);\nassert(sock != NULL);\nassert(sock->ssl != NULL);\n\nif (!SSL_is_server(s) && sock->ssl->handshake.client.session_cache != NULL\n#if !defined(LIBRESSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x1010100fL\n&& SSL_SESSION_is_resumable(sess)\n#endif\n) {\nh2o_cache_set(sock->ssl->handshake.client.session_cache, h2o_now(h2o_socket_get_loop(sock)),\nsock->ssl->handshake.client.session_cache_key, sock->ssl->handshake.client.session_cache_key_hash,\nh2o_iovec_init(sess, 1));\nreturn 1; /* retain ref count */\n}\n\nreturn 0; /* drop ref count */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_1__* ssl; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  session_id; int /*<<< orphan*/  session_id_len; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  session; TYPE_2__ session_ticket; } ;\ntypedef  TYPE_1__ SSL ;\ntypedef  TYPE_2__ SSL_SESSION ;\ntypedef  TYPE_3__ h2o_socket_ssl_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_socket_is_writing (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_write (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_write_set_session_ticket_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data_cb_ex_with_data (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_strdup_shared",
    "input":"\n0000000000000000 <h2o_strdup_shared>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rdx, %r12\nb: \tmovq\t%rsi, %r14\ne: \tmovq\t%rdi, %r15\n11: \tcmpq\t%rdx, (%rip)  # 0x18 <h2o_strdup_shared+0x18>\n18: \tjne\t0x25 <h2o_strdup_shared+0x25>\n1a: \tmovq\t%r14, %rdi\n1d: \tcallq\t0x22 <h2o_strdup_shared+0x22>\n22: \tmovq\t%rax, %r12\n25: \tleaq\t1(%r12), %rsi\n2a: \tmovq\t%r15, %rdi\n2d: \txorl\t%edx, %edx\n2f: \tcallq\t0x34 <h2o_strdup_shared+0x34>\n34: \tmovq\t%rax, %rbx\n37: \tmovq\t%rax, %rdi\n3a: \tmovq\t%r14, %rsi\n3d: \tmovq\t%r12, %rdx\n40: \tcallq\t0x45 <h2o_strdup_shared+0x45>\n45: \tmovb\t$0, (%rbx,%r12)\n4a: \tmovq\t%rbx, %rax\n4d: \tmovq\t%r12, %rdx\n50: \taddq\t$8, %rsp\n54: \tpopq\t%rbx\n55: \tpopq\t%r12\n57: \tpopq\t%r14\n59: \tpopq\t%r15\n5b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\nstruct TYPE_3__ {char* base; size_t len; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nsize_t SIZE_MAX ;\nchar* h2o_mem_alloc_shared (int /*<<< orphan*/ *,size_t,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memcpy (char*,char const*,size_t) ;\nsize_t strlen (char const*) ;\n\nh2o_iovec_t h2o_strdup_shared(h2o_mem_pool_t *pool, const char *s, size_t slen)\n{\nh2o_iovec_t ret;\n\nif (slen == SIZE_MAX)\nslen = strlen(s);\n\nret.base = h2o_mem_alloc_shared(pool, slen + 1, NULL);\nmemcpy(ret.base, s, slen);\nret.base[slen] = '\\0';\nret.len = slen;\nreturn ret;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_mem_pool_t ;\n\n/* Variables and functions */\nsize_t SIZE_MAX ;\nint /*<<< orphan*/  memcpy (char*,char const*,size_t) ;\nchar* strdup (char const*) ;\n\nchar *h2o_strdup_shared(h2o_mem_pool_t *pool, const char *src, size_t len)\n{\nif (len == SIZE_MAX)\nlen = strlen(src);\nchar *dst;\nif ((dst = h2o_mem_alloc_shared(pool, len + 1)) == NULL)\nreturn NULL;\nmemcpy(dst, src, len);\ndst[len] = '\\0';\nreturn dst;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_evloop_socket_create",
    "input":"\n0000000000000000 <h2o_evloop_socket_create>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%edx, %r14d\n7: \tmovl\t%esi, %ebp\n9: \tmovq\t%rdi, %rbx\nc: \tmovl\t(%rip), %esi  # 0x12 <h2o_evloop_socket_create+0x12>\n12: \tmovl\t(%rip), %edx  # 0x18 <h2o_evloop_socket_create+0x18>\n18: \tmovl\t%ebp, %edi\n1a: \tcallq\t0x1f <h2o_evloop_socket_create+0x1f>\n1f: \tmovq\t%rbx, %rdi\n22: \tmovl\t%ebp, %esi\n24: \tmovl\t%r14d, %edx\n27: \tpopq\t%rbx\n28: \tpopq\t%r14\n2a: \tpopq\t%rbp\n2b: \tjmp\t0x30 <h2o_evloop_socket_create+0x30>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_evloop_t ;\nstruct TYPE_2__ {int /*<<< orphan*/  super; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  F_SETFL ;\nint /*<<< orphan*/  O_NONBLOCK ;\nTYPE_1__* create_socket_set_nodelay (int /*<<< orphan*/ *,int,int) ;\nint /*<<< orphan*/  fcntl (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nh2o_socket_t *h2o_evloop_socket_create(h2o_evloop_t *loop, int fd, int flags)\n{\n/* it is the reponsibility of the event loop to modify the properties of a socket for its use (i.e., set O_NONBLOCK) */\nfcntl(fd, F_SETFL, O_NONBLOCK);\nreturn &create_socket_set_nodelay(loop, fd, flags)->super;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_loop ;\ntypedef  int /*<<< orphan*/  h2o_socket_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_FLAG_IS_LIBEV ;\nint /*<<< orphan*/  h2o_socket_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_libuv_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_libuv_on_close ;\nint /*<<< orphan*/  h2o_socket_libuv_on_read ;\n\n__attribute__((used)) static void h2o_evloop_socket_create(h2o_loop_t *loop, int fd, h2o_socket_cb cb)\n{\nh2o_socket_t *sock;\n\nh2o_socket_libuv_init(loop, fd, h2o_socket_libuv_on_close);\nh2o_socket_init(sock = h2o_socket_libuv_on_read, fd, H2O_SOCKET_FLAG_IS_LIBEV);\nsock->data = cb;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_multithread.c_on_shutdown",
    "input":"\n0000000000000000 <on_shutdown>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tmovq\t%rsi, %rdi\n7: \tnopw\t(%rax,%rax)\n10: \tcallq\t0x15 <on_shutdown+0x15>\n15: \ttestl\t%eax, %eax\n17: \tjne\t0x26 <on_shutdown+0x26>\n19: \tmovq\t%rbx, %rdi\n1c: \tcallq\t0x21 <on_shutdown+0x21>\n21: \tmovq\t%rbx, %rdi\n24: \tjmp\t0x10 <on_shutdown+0x10>\n26: \tmovl\t$1, (%rip)    # 0x30 <on_shutdown+0x30>\n30: \tpopq\t%rbx\n31: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_multithread_receiver_t ;\ntypedef  int /*<<< orphan*/  h2o_linklist_t ;\nstruct TYPE_2__ {int received_shutdown; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_is_empty (int /*<<< orphan*/ *) ;\nTYPE_1__ main_thread ;\nint /*<<< orphan*/  pop_empty_message (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_shutdown(h2o_multithread_receiver_t *receiver, h2o_linklist_t *list)\n{\nwhile (!h2o_linklist_is_empty(list))\npop_empty_message(list);\nmain_thread.received_shutdown = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  signal_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGINT ;\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  signal_pending (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  signal_wait (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_shutdown(signal_t sig, void *data)\n{\nwhile (signal_pending(sig) || signal_pending(SIGTERM))\n{\nsignal_wait(&sig);\n}\n\n*(int *)data = 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_create_evloop",
    "input":"\n0000000000000000 <create_evloop>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tcallq\t0xc <create_evloop+0xc>\nc: \tmovq\t%rax, %rbx\nf: \tmovq\t%rax, %rdi\n12: \txorl\t%esi, %esi\n14: \tmovq\t%r14, %rdx\n17: \tcallq\t0x1c <create_evloop+0x1c>\n1c: \tleaq\t8(%rbx), %rax\n20: \tmovq\t%rax, 16(%rbx)\n24: \tmovq\t%rbx, %rdi\n27: \tcallq\t0x2c <create_evloop+0x2c>\n2c: \tmovl\t(%rbx), %esi\n2e: \tmovl\t$3, %edi\n33: \tcallq\t0x38 <create_evloop+0x38>\n38: \tmovl\t%eax, 4(%rbx)\n3b: \tmovq\t%rbx, %rax\n3e: \taddq\t$8, %rsp\n42: \tpopq\t%rbx\n43: \tpopq\t%r14\n45: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int /*<<< orphan*/  head; int /*<<< orphan*/ * tail_ref; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  _now_millisec; int /*<<< orphan*/  _timeouts; TYPE_1__ _statechanged; } ;\ntypedef  TYPE_2__ h2o_evloop_t ;\n\n/* Variables and functions */\nTYPE_2__* h2o_mem_alloc (size_t) ;\nint /*<<< orphan*/  h2o_timerwheel_create (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_2__*,int /*<<< orphan*/ ,size_t) ;\nint /*<<< orphan*/  update_now (TYPE_2__*) ;\n\nh2o_evloop_t *create_evloop(size_t sz)\n{\nh2o_evloop_t *loop = h2o_mem_alloc(sz);\n\nmemset(loop, 0, sz);\nloop->_statechanged.tail_ref = &loop->_statechanged.head;\nupdate_now(loop);\n/* 3 levels * 32-slots => 1 second goes into 2nd, becomes O(N) above approx. 31 seconds */\nloop->_timeouts = h2o_timerwheel_create(3, loop->_now_millisec);\n\nreturn loop;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  ev_fd; int /*<<< orphan*/  ev_loop; int /*<<< orphan*/  ev_base; } ;\ntypedef  TYPE_1__ evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  event_base_new () ;\nint /*<<< orphan*/  event_set (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_set_callback (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_set_fd (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_set_log_callback (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nTYPE_1__* malloc (int) ;\nint /*<<< orphan*/  stub1 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static evloop_t *create_evloop(void (*cb)(int, void *))\n{\nevloop_t *evloop = malloc(sizeof(evloop_t));\nevloop->ev_base = event_base_new();\nevloop->ev_loop = event_base_new();\nevent_set_log_callback(evloop->ev_base, stub1);\nevent_set_callback(evloop->ev_loop, stub2);\nevent_set_fd(evloop->ev_loop, 3);\nevloop->fd = event_set(evloop->ev_base, 3, 0, 0, 0, cb);\nreturn evloop;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_on_read",
    "input":"\n0000000000000000 <on_read>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \ttestq\t%rsi, %rsi\n7: \tje\t0x13 <on_read+0x13>\n9: \tmovl\t$0, %edi\ne: \tcallq\t0x13 <on_read+0x13>\n13: \tleaq\t8(%rbx), %rdi\n17: \tmovq\t8(%rbx), %rax\n1b: \tmovl\t(%rax), %esi\n1d: \tcallq\t0x22 <on_read+0x22>\n22: \tmovl\t(%rbx), %edi\n24: \tpopq\t%rbx\n25: \tjmp\t0x2a <on_read+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  data; TYPE_3__* input; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\nstruct TYPE_5__ {int /*<<< orphan*/  size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_buffer_consume (TYPE_3__**,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_fatal (char*,char const*) ;\nint /*<<< orphan*/  queue_cb (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void on_read(h2o_socket_t *sock, const char *err)\n{\nif (err != NULL) {\nh2o_fatal(\"on_read: %s\", err);\n}\n\nh2o_buffer_consume(&sock->input, sock->input->size);\nqueue_cb(sock->data);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  buf; } ;\ntypedef  TYPE_1__ GLog ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_string_append_len (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  g_string_free (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_warning (char*) ;\n\n__attribute__((used)) static void\non_read (GLog * log, gboolean last)\n{\nif (!last)\n{\ng_warning (\"on_read: last == false\");\n}\n\ng_string_append_len (log->buf, log->fd, -1);\nclose (log->fd);\ng_string_free (log->buf, 1);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonurl.c_h2o_url_parse",
    "input":"\n0000000000000000 <h2o_url_parse>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %r14\n8: \tmovq\t%rsi, %rbx\nb: \tmovq\t%rdi, %r15\ne: \tcmpq\t%rsi, (%rip)  # 0x15 <h2o_url_parse+0x15>\n15: \tjne\t0x22 <h2o_url_parse+0x22>\n17: \tmovq\t%r15, %rdi\n1a: \tcallq\t0x1f <h2o_url_parse+0x1f>\n1f: \tmovq\t%rax, %rbx\n22: \taddq\t%r15, %rbx\n25: \tmovq\t%r15, %rdi\n28: \tmovq\t%rbx, %rsi\n2b: \tmovq\t%r14, %rdx\n2e: \tcallq\t0x33 <h2o_url_parse+0x33>\n33: \ttestq\t%rax, %rax\n36: \tje\t0x66 <h2o_url_parse+0x66>\n38: \tmovq\t%rbx, %rcx\n3b: \tsubq\t%rax, %rcx\n3e: \tcmpq\t$2, %rcx\n42: \tjl\t0x66 <h2o_url_parse+0x66>\n44: \tcmpb\t$47, (%rax)\n47: \tjne\t0x66 <h2o_url_parse+0x66>\n49: \tcmpb\t$47, 1(%rax)\n4d: \tjne\t0x66 <h2o_url_parse+0x66>\n4f: \taddq\t$2, %rax\n53: \tmovq\t%rax, %rdi\n56: \tmovq\t%rbx, %rsi\n59: \tmovq\t%r14, %rdx\n5c: \tpopq\t%rbx\n5d: \tpopq\t%r14\n5f: \tpopq\t%r15\n61: \tjmp\t0x66 <h2o_url_parse+0x66>\n66: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n6b: \tpopq\t%rbx\n6c: \tpopq\t%r14\n6e: \tpopq\t%r15\n70: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  scheme; } ;\ntypedef  TYPE_1__ h2o_url_t ;\n\n/* Variables and functions */\nsize_t SIZE_MAX ;\nint parse_authority_and_path (char const*,char const*,TYPE_1__*) ;\nchar* parse_scheme (char const*,char const*,int /*<<< orphan*/ *) ;\nsize_t strlen (char const*) ;\n\nint h2o_url_parse(const char *url, size_t url_len, h2o_url_t *parsed)\n{\nconst char *url_end, *p;\n\nif (url_len == SIZE_MAX)\nurl_len = strlen(url);\nurl_end = url + url_len;\n\n/* check and skip scheme */\nif ((p = parse_scheme(url, url_end, &parsed->scheme)) == NULL)\nreturn -1;\n\n/* skip \"//\" */\nif (!(url_end - p >= 2 && p[0] == '/' && p[1] == '/'))\nreturn -1;\np += 2;\n\nreturn parse_authority_and_path(p, url_end, parsed);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_url_scheme_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_url_scheme_http ;\nint /*<<< orphan*/  h2o_url_scheme_https ;\nchar* h2o_strchr (char const*,char) ;\nint /*<<< orphan*/  h2o_url_scheme_is_default (char const*) ;\nint /*<<< orphan*/  h2o_url_scheme_is_supported (char const*) ;\n\n__attribute__((used)) static int h2o_url_parse(const char *url, size_t url_len, h2o_url_scheme_t *scheme)\n{\nconst char *p;\n\nif (url == url_len) {\nif (h2o_url_scheme_is_default(url))\nreturn 0;\n} else {\np = h2o_strchr(url, ':');\nif (p == url || p == url + url_len)\nreturn -1;\nif (p[1] != '/' || p[2] != '/')\nreturn -1;\nurl = p + 3;\n}\n\nif (h2o_url_scheme_is_supported(url)) {\n*scheme = h2o_url_scheme_is_default(url) ? h2o_url_scheme_http : h2o_url_scheme_https;\nreturn (int)(url - url_len);\n}\n\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_update_now",
    "input":"\n0000000000000000 <update_now>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \taddq\t$8, %rdi\n8: \txorl\t%esi, %esi\na: \tcallq\t0xf <update_now+0xf>\nf: \timull\t$1000000, 16(%rbx), %eax # imm = 0xF4240\n16: \taddl\t8(%rbx), %eax\n19: \timull\t$1000, %eax, %ecx  # imm = 0x3E8\n1f: \tmovl\t%ecx, (%rbx)\n21: \tcltq\n23: \timulq\t$274877907, %rax, %rax  # imm = 0x10624DD3\n2a: \tmovq\t%rax, %rcx\n2d: \tshrq\t$63, %rcx\n31: \tsarq\t$38, %rax\n35: \taddl\t%ecx, %eax\n37: \tmovl\t%eax, 4(%rbx)\n3a: \tpopq\t%rbx\n3b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int uint64_t ;\nstruct TYPE_5__ {int tv_usec; scalar_t__ tv_sec; } ;\nstruct TYPE_4__ {int _now_nanosec; int _now_millisec; TYPE_3__ _tv_at; } ;\ntypedef  TYPE_1__ h2o_evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  gettimeofday (TYPE_3__*,int /*<<< orphan*/ *) ;\n\nvoid update_now(h2o_evloop_t *loop)\n{\ngettimeofday(&loop->_tv_at, NULL);\nloop->_now_nanosec = ((uint64_t)loop->_tv_at.tv_sec * 1000000 + loop->_tv_at.tv_usec) * 1000;\nloop->_now_millisec = loop->_now_nanosec / 1000000;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int now_sec; int now_usec; int now_msec; int now_usec_frac; } ;\ntypedef  TYPE_1__ now_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  gettimeofday (int*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void update_now (now_t *now) {\ngettimeofday (NULL, NULL);\nnow->now_sec = now->now_msec = now->now_usec = 0;\nnow->now_usec_frac = now->now_usec * 1000 + now->now_msec;\nnow->now_usec = now->now_usec_frac / 1000;\nnow->now_usec_frac %= 1000;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_adjust_notsent_lowat",
    "input":"\n0000000000000000 <adjust_notsent_lowat>:\n0: \tpushq\t%rax\n1: \tmovl\t%esi, 4(%rsp)\n5: \tcallq\t0xa <adjust_notsent_lowat+0xa>\na: \tmovl\t(%rip), %esi  # 0x10 <adjust_notsent_lowat+0x10>\n10: \tmovl\t(%rip), %edx  # 0x16 <adjust_notsent_lowat+0x16>\n16: \tleaq\t4(%rsp), %rcx\n1b: \tmovl\t%eax, %edi\n1d: \tmovl\t$4, %r8d\n23: \tcallq\t0x28 <adjust_notsent_lowat+0x28>\n28: \tpopq\t%rcx\n29: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  notsent_lowat ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  IPPROTO_TCP ;\nint /*<<< orphan*/  TCP_NOTSENT_LOWAT ;\nint /*<<< orphan*/  h2o_socket_get_fd (int /*<<< orphan*/ *) ;\nint setsockopt (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,unsigned int*,int) ;\n\n__attribute__((used)) static int adjust_notsent_lowat(h2o_socket_t *sock, unsigned notsent_lowat)\n{\nreturn setsockopt(h2o_socket_get_fd(sock), IPPROTO_TCP, TCP_NOTSENT_LOWAT, &notsent_lowat, sizeof(notsent_lowat));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  u_int ;\ntypedef  int /*<<< orphan*/  u_char ;\n\n/* Variables and functions */\nint /*<<< orphan*/  IPPROTO_TCP ;\nint /*<<< orphan*/  IP_TOS ;\nint /*<<< orphan*/  IP_TTL ;\nint /*<<< orphan*/  IP_TTL_ADJ ;\nint /*<<< orphan*/  IP_TTL_ADJ_LOWAT ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX ;\nint /*<<< orphan*/  IP_TTL_ADJ_NOTSENT_LOWAT_MIN_MAX_MIN_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DEF ;\nint /*<<< orphan"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhttpclient.c_h2o_httpclient_connection_pool_init",
    "input":"\n0000000000000000 <h2o_httpclient_connection_pool_init>:\n0: \tmovq\t%rsi, 8(%rdi)\n4: \tjmp\t0x9 <h2o_httpclient_connection_pool_init+0x9>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socketpool_t ;\nstruct TYPE_4__ {int /*<<< orphan*/  conns; } ;\nstruct TYPE_5__ {TYPE_1__ http2; int /*<<< orphan*/ * socketpool; } ;\ntypedef  TYPE_2__ h2o_httpclient_connection_pool_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_init_anchor (int /*<<< orphan*/ *) ;\n\nvoid h2o_httpclient_connection_pool_init(h2o_httpclient_connection_pool_t *connpool, h2o_socketpool_t *sockpool)\n{\nconnpool->socketpool = sockpool;\nh2o_linklist_init_anchor(&connpool->http2.conns);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  super; int /*<<< orphan*/ * ctx; } ;\ntypedef  TYPE_1__ h2o_httpclient_connection_pool_t ;\ntypedef  int /*<<< orphan*/  h2o_httpclient_ctx_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_init (int /*<<< orphan*/ *) ;\n\nvoid h2o_httpclient_connection_pool_init(h2o_httpclient_connection_pool_t *pool, h2o_httpclient_ctx_t *ctx)\n{\npool->ctx = ctx;\nh2o_linklist_init(&pool->super);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_fetch_digits",
    "input":"\n0000000000000000 <fetch_digits>:\n0: \ttestq\t%rsi, %rsi\n3: \tje\t0x32 <fetch_digits+0x32>\n5: \txorl\t%ecx, %ecx\n7: \txorl\t%eax, %eax\n9: \tnopl\t(%rax)\n10: \tmovzbl\t(%rdi,%rcx), %r8d\n15: \tleal\t-48(%r8), %edx\n19: \tcmpb\t$9, %dl\n1c: \tja\t0x35 <fetch_digits+0x35>\n1e: \tleal\t(%rax,%rax,4), %eax\n21: \tleal\t(%r8,%rax,2), %eax\n25: \taddl\t$-48, %eax\n28: \taddq\t$1, %rcx\n2c: \tcmpq\t%rcx, %rsi\n2f: \tjne\t0x10 <fetch_digits+0x10>\n31: \tretq\n32: \txorl\t%eax, %eax\n34: \tretq\n35: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n3a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int fetch_digits(const char *s, size_t n)\n{\nint value = 0;\nfor (; n != 0; ++s, --n) {\nif (!('0' <= *s && *s <= '9'))\nreturn -1;\nvalue = value * 10 + *s - '0';\n}\nreturn value;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int fetch_digits(const char *s, size_t len)\n{\nint i = 0;\n\nwhile (len--) {\nif (*s < '0' || *s > '9')\nreturn -1;\ni = i * 10 + (*s - '0');\ns++;\n}\nreturn i;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_socket.c_test_adjust_notsent_lowat",
    "input":"\n0000000000000000 <test_adjust_notsent_lowat>:\n0: \tmovl\t%esi, (%rip)  # 0x6 <test_adjust_notsent_lowat+0x6>\n6: \taddl\t$1, (%rip)    # 0xd <test_adjust_notsent_lowat+0xd>\nd: \tmovl\t(%rip), %eax  # 0x13 <test_adjust_notsent_lowat+0x13>\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\nstruct TYPE_3__ {unsigned int cur; int ret; int /*<<< orphan*/  call_cnt; } ;\nstruct TYPE_4__ {TYPE_1__ minimize_notsent_lowat; } ;\n\n/* Variables and functions */\nTYPE_2__ cb_ret_vars ;\n\n__attribute__((used)) static int test_adjust_notsent_lowat(h2o_socket_t *sock, unsigned notsent_lowat)\n{\ncb_ret_vars.minimize_notsent_lowat.cur = notsent_lowat;\n++cb_ret_vars.minimize_notsent_lowat.call_cnt;\nreturn cb_ret_vars.minimize_notsent_lowat.ret;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_FAIL () ;\nint /*<<< orphan*/  TEST_SUCCESS () ;\nint /*<<< orphan*/  adjust_notsent_lowat_called ;\nint /*<<< orphan*/  adjust_notsent_lowat_lowat ;\n\n__attribute__((used)) static int test_adjust_notsent_lowat(int fd, int lowat)\n{\nadjust_notsent_lowat_lowat = lowat;\nadjust_notsent_lowat_called++;\n\nif (lowat != 1)\nTEST_FAIL();\n\nTEST_SUCCESS();\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_write_core",
    "input":"\n0000000000000000 <write_core>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rcx, %r14\ne: \tmovq\t%rdx, %r15\n11: \tmovq\t%rsi, %r13\n14: \tmovl\t%edi, %r12d\n17: \tmovq\t$0, (%rcx)\n1e: \tmovq\t(%rdx), %rax\n21: \tnopw\t%cs:(%rax,%rax)\n2b: \tnopl\t(%rax,%rax)\n30: \ttestq\t%rax, %rax\n33: \tje\t0xf3 <write_core+0xf3>\n39: \tmovslq\t(%rip), %rcx  # 0x40 <write_core+0x40>\n40: \tcmpq\t%rcx, %rax\n43: \tmovl\t%eax, %ebp\n45: \tcmovael\t%ecx, %ebp\n48: \tnopl\t(%rax,%rax)\n50: \tmovq\t(%r13), %rsi\n54: \tmovl\t%r12d, %edi\n57: \tmovl\t%ebp, %edx\n59: \tcallq\t0x5e <write_core+0x5e>\n5e: \tmovl\t%eax, %ebx\n60: \tmovq\t(%rip), %rcx  # 0x67 <write_core+0x67>\n67: \tcmpl\t$-1, %eax\n6a: \tjne\t0x75 <write_core+0x75>\n6c: \tcmpq\t(%rip), %rcx  # 0x73 <write_core+0x73>\n73: \tje\t0x50 <write_core+0x50>\n75: \tcmpl\t$-1, %ebx\n78: \tje\t0xdd <write_core+0xdd>\n7a: \tmovq\t(%r13), %rax\n7e: \tmovl\t(%rax), %edx\n80: \tcmpl\t%edx, %ebx\n82: \tjle\t0xab <write_core+0xab>\n84: \tmovq\t(%r15), %rcx\n87: \tnopw\t(%rax,%rax)\n90: \tsubl\t%edx, %ebx\n92: \taddq\t$-1, %rcx\n96: \taddl\t$-1, %ebp\n99: \tmovl\t4(%rax), %edx\n9c: \taddq\t$4, %rax\na0: \tcmpl\t%edx, %ebx\na2: \tjg\t0x90 <write_core+0x90>\na4: \tmovq\t%rax, (%r13)\na8: \tmovq\t%rcx, (%r15)\nab: \txorl\t%edi, %edi\nad: \ttestl\t%ebp, %ebp\naf: \tsetg\t%dil\nb3: \tcallq\t0xb8 <write_core+0xb8>\nb8: \tmovq\t(%r13), %rax\nbc: \tcmpl\t%ebx, (%rax)\nbe: \tjne\t0xed <write_core+0xed>\nc0: \taddq\t$4, %rax\nc4: \tmovq\t%rax, (%r13)\nc8: \tmovq\t(%r15), %rax\ncb: \taddq\t$-1, %rax\ncf: \tmovq\t%rax, (%r15)\nd2: \tcmpl\t$1, %ebp\nd5: \tje\t0x30 <write_core+0x30>\ndb: \tjmp\t0xf3 <write_core+0xf3>\ndd: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\ne2: \tcmpq\t(%rip), %rcx  # 0xe9 <write_core+0xe9>\ne9: \tje\t0xf3 <write_core+0xf3>\neb: \tjmp\t0xf5 <write_core+0xf5>\ned: \tmovslq\t%ebx, %rax\nf0: \tmovq\t%rax, (%r14)\nf3: \txorl\t%eax, %eax\nf5: \taddq\t$8, %rsp\nf9: \tpopq\t%rbx\nfa: \tpopq\t%r12\nfc: \tpopq\t%r13\nfe: \tpopq\t%r14\n100: \tpopq\t%r15\n102: \tpopq\t%rbp\n103: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct iovec {int dummy; } ;\ntypedef  int ssize_t ;\nstruct TYPE_3__ {int len; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nscalar_t__ EAGAIN ;\nscalar_t__ EINTR ;\nint IOV_MAX ;\nint /*<<< orphan*/  assert (int) ;\nscalar_t__ errno ;\nint writev (int,struct iovec*,int) ;\n\n__attribute__((used)) static int write_core(int fd, h2o_iovec_t **bufs, size_t *bufcnt, size_t *first_buf_written)\n{\nint iovcnt;\nssize_t wret;\n\n*first_buf_written = 0;\n\nwhile (*bufcnt != 0) {\n/* write */\niovcnt = IOV_MAX;\nif (*bufcnt < iovcnt)\niovcnt = (int)*bufcnt;\nwhile ((wret = writev(fd, (struct iovec *)*bufs, iovcnt)) == -1 && errno == EINTR)\n;\nif (wret == -1) {\nif (errno != EAGAIN)\nreturn -1;\nbreak;\n}\n/* adjust the buffer */\nwhile ((*bufs)->len < wret) {\nwret -= (*bufs)->len;\n++*bufs;\n--*bufcnt;\n--iovcnt;\n}\nassert(iovcnt > 0);\nif ((*bufs)->len == wret) {\n++*bufs;\n--*bufcnt;\nif (--iovcnt != 0)\nbreak;\n} else {\n*first_buf_written = wret;\nbreak;\n}\n}\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int len; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__* PUCHAR ;\ntypedef  int* PULONG ;\ntypedef  int ULONG ;\ntypedef  int UCHAR ;\ntypedef  int /*<<< orphan*/  BOOLEAN ;\n\n/* Variables and functions */\nint BUFSIZE ;\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  TRUE ;\nint WRITE_ERROR ;\nint WRITE_SUCCESS ;\nint write (int,int /*<<< orphan*/ *,int) ;\n\nBOOLEAN write_core(int fd, PUCHAR *buf, PULONG *len, PULONG *total)\n{\nULONG i, j, k;\nULONG n;\n\nn = *len;\n\nfor (i = 0; i < n; i++)\n{\nk = write(fd, (*buf)->data, (*buf)->len);\nif (k == -1)\n{\nif (errno == WRITE_ERROR)\n{\nif (*total == BUFSIZE)\n{\nreturn FALSE;\n}\nelse\n{\n(*total)++;\n}\n}\nelse\n{\nreturn FALSE;\n}\n}\nelse if (k < (*buf)->len)\n{\nfor (j = 0; j < n; j++)\n{\nif (((*buf)->len - k) <= (*buf + 1)->len)\n{\n(*buf)++;\n(*len)--;\nbreak;\n}\nelse\n{\n(*buf)++;\n(*len)--;\nk -= (*buf - 1)->len;\n}\n}\n}\n}\n\n*len = 0;\nreturn TRUE;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhttpclient.c_close_client",
    "input":"\n0000000000000000 <close_client>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t8(%rdi), %rdi\n8: \ttestq\t%rdi, %rdi\nb: \tje\t0x1a <close_client+0x1a>\nd: \tcallq\t0x12 <close_client+0x12>\n12: \tmovq\t$0, 8(%rbx)\n1a: \tmovq\t%rbx, %rdi\n1d: \tcallq\t0x22 <close_client+0x22>\n22: \ttestq\t%rax, %rax\n25: \tje\t0x2f <close_client+0x2f>\n27: \tmovq\t%rbx, %rdi\n2a: \tcallq\t0x2f <close_client+0x2f>\n2f: \tmovq\t%rbx, %rdi\n32: \tpopq\t%rbx\n33: \tjmp\t0x38 <close_client+0x38>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  _timeout; int /*<<< orphan*/ * _connect_req; } ;\ntypedef  TYPE_1__ h2o_httpclient_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_socketpool_cancel_connect (int /*<<< orphan*/ *) ;\nscalar_t__ h2o_timer_is_linked (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timer_unlink (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void close_client(h2o_httpclient_t *client)\n{\nif (client->_connect_req != NULL) {\nh2o_socketpool_cancel_connect(client->_connect_req);\nclient->_connect_req = NULL;\n}\n\nif (h2o_timer_is_linked(&client->_timeout))\nh2o_timer_unlink(&client->_timeout);\n\nfree(client);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * fd; int /*<<< orphan*/ * fd_out; } ;\ntypedef  TYPE_1__ client_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free (TYPE_1__*) ;\nscalar_t__ is_socket (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void close_client (client_t *client) {\nif (client->fd_out) {\nclose (client->fd_out);\nclient->fd_out = NULL;\n}\nif (is_socket (client->fd)) {\nclose (client->fd);\n}\nfree (client);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_emit_wday",
    "input":"\n0000000000000000 <emit_wday>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tleal\t(%rsi,%rsi,2), %eax\n7: \tcltq\n9: \tleaq\t(%rax), %rsi\n10: \tmovl\t$3, %edx\n15: \tcallq\t0x1a <emit_wday+0x1a>\n1a: \tleaq\t3(%rbx), %rax\n1e: \tpopq\t%rbx\n1f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (char*,char*,int) ;\n\n__attribute__((used)) static char *emit_wday(char *dst, int wday)\n{\nmemcpy(dst, (\"SunMonTueWedThuFriSat\") + wday * 3, 3);\nreturn dst + 3;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_write_printf (int /*<<< orphan*/ *,char*,int) ;\n\n__attribute__((used)) static char *emit_wday(fz_context *ctx, char *s, int wday)\n{\nfz_write_printf(ctx, \"%s%d\", s, wday);\nreturn s + 3;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_cache.c_on_destroy",
    "input":"\n0000000000000000 <on_destroy>:\n0: \taddl\t%edi, (%rip)  # 0x6 <on_destroy+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ len; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  bytes_destroyed ;\n\n__attribute__((used)) static void on_destroy(h2o_iovec_t vec)\n{\nbytes_destroyed += vec.len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  g_total_allocs ;\n\n__attribute__((used)) static void on_destroy(void *ptr, size_t size) {\ng_total_allocs += size;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_do_dispose_socket",
    "input":"\n0000000000000000 <do_dispose_socket>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <do_dispose_socket+0x9>\n9: \tmovq\t%rbx, %rdi\nc: \tcallq\t0x11 <do_dispose_socket+0x11>\n11: \tmovl\t(%rbx), %edi\n13: \tcmpl\t$-1, %edi\n16: \tje\t0x23 <do_dispose_socket+0x23>\n18: \tcallq\t0x1d <do_dispose_socket+0x1d>\n1d: \tmovl\t$4294967295, (%rbx)# imm = 0xFFFFFFFF\n23: \tmovl\t(%rip), %eax  # 0x29 <do_dispose_socket+0x29>\n29: \tmovl\t%eax, 4(%rbx)\n2c: \tmovq\t%rbx, %rdi\n2f: \tpopq\t%rbx\n30: \tjmp\t0x35 <do_dispose_socket+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int fd; int /*<<< orphan*/  _flags; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_FLAG_IS_DISPOSED ;\nint /*<<< orphan*/  close (int) ;\nint /*<<< orphan*/  evloop_do_on_socket_close (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  link_to_statechanged (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  wreq_free_buffer_if_allocated (struct st_h2o_evloop_socket_t*) ;\n\nvoid do_dispose_socket(h2o_socket_t *_sock)\n{\nstruct st_h2o_evloop_socket_t *sock = (struct st_h2o_evloop_socket_t *)_sock;\n\nevloop_do_on_socket_close(sock);\nwreq_free_buffer_if_allocated(sock);\nif (sock->fd != -1) {\nclose(sock->fd);\nsock->fd = -1;\n}\nsock->_flags = H2O_SOCKET_FLAG_IS_DISPOSED;\nlink_to_statechanged(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int fd; int /*<<< orphan*/  state; } ;\ntypedef  TYPE_1__ GSocket ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GSOCKET_STATE_DISPOSED ;\nint /*<<< orphan*/  close (int) ;\nint /*<<< orphan*/  g_free (TYPE_1__*) ;\nint /*<<< orphan*/  g_socket_clear_events (TYPE_1__*) ;\n\n__attribute__((used)) static void\ndo_dispose_socket (GSocket *sock)\n{\ng_socket_clear_events (sock);\nif (sock->fd != -1)\nclose (sock->fd);\nsock->fd = -1;\nsock->state = GSOCKET_STATE_DISPOSED;\ng_free (sock);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_sem_wait",
    "input":"\n0000000000000000 <h2o_sem_wait>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r15\n8: \tleaq\t8(%rdi), %r14\nc: \tmovq\t%r14, %rdi\nf: \tcallq\t0x14 <h2o_sem_wait+0x14>\n14: \tmovq\t(%r15), %rax\n17: \ttestq\t%rax, %rax\n1a: \tjg\t0x33 <h2o_sem_wait+0x33>\n1c: \tleaq\t12(%r15), %rbx\n20: \tmovq\t%rbx, %rdi\n23: \tmovq\t%r14, %rsi\n26: \tcallq\t0x2b <h2o_sem_wait+0x2b>\n2b: \tmovq\t(%r15), %rax\n2e: \ttestq\t%rax, %rax\n31: \tjle\t0x20 <h2o_sem_wait+0x20>\n33: \taddq\t$-1, %rax\n37: \tmovq\t%rax, (%r15)\n3a: \tmovq\t%r14, %rdi\n3d: \tpopq\t%rbx\n3e: \tpopq\t%r14\n40: \tpopq\t%r15\n42: \tjmp\t0x47 <h2o_sem_wait+0x47>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ _cur; int /*<<< orphan*/  _mutex; int /*<<< orphan*/  _cond; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_wait (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_wait(h2o_sem_t *sem)\n{\npthread_mutex_lock(&sem->_mutex);\nwhile (sem->_cur <= 0)\npthread_cond_wait(&sem->_cond, &sem->_mutex);\n--sem->_cur;\npthread_mutex_unlock(&sem->_mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ count; int /*<<< orphan*/  lock; int /*<<< orphan*/  cond; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_wait (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_wait(h2o_sem_t *sem)\n{\npthread_mutex_lock(&sem->lock);\nwhile (sem->count <= 0)\npthread_cond_wait(&sem->cond, &sem->lock);\n--sem->count;\npthread_mutex_unlock(&sem->lock);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_socket_getsockname",
    "input":"\n0000000000000000 <h2o_socket_getsockname>:\n0: \tpushq\t%rax\n1: \tmovl\t$4, 4(%rsp)\n9: \tmovl\t(%rdi), %edi\nb: \tleaq\t4(%rsp), %rdx\n10: \tcallq\t0x15 <h2o_socket_getsockname+0x15>\n15: \tmovq\t%rax, %rcx\n18: \txorl\t%eax, %eax\n1a: \ttestq\t%rcx, %rcx\n1d: \tjne\t0x23 <h2o_socket_getsockname+0x23>\n1f: \tmovl\t4(%rsp), %eax\n23: \tpopq\t%rcx\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  fd; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr {int dummy; } ;\ntypedef  int socklen_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nscalar_t__ getsockname (int /*<<< orphan*/ ,struct sockaddr*,int*) ;\n\nsocklen_t h2o_socket_getsockname(h2o_socket_t *_sock, struct sockaddr *sa)\n{\nstruct st_h2o_evloop_socket_t *sock = (void *)_sock;\nsocklen_t len = sizeof(struct sockaddr_storage);\nif (getsockname(sock->fd, sa, &len) != 0)\nreturn 0;\nreturn len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr {int dummy; } ;\nstruct TYPE_3__ {int /*<<< orphan*/  sock; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nscalar_t__ getsockname (int /*<<< orphan*/ ,struct sockaddr*,int*) ;\n\nint h2o_socket_getsockname(h2o_socket_t *sock, struct sockaddr *addr, socklen_t *len)\n{\nif (getsockname(sock->sock, addr, len) != 0)\nreturn -1;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_async_resumption_setup_ctx",
    "input":"\n0000000000000000 <h2o_socket_ssl_async_resumption_setup_ctx>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <h2o_socket_ssl_async_resumption_setup_ctx+0xa>\na: \tcallq\t0xf <h2o_socket_ssl_async_resumption_setup_ctx+0xf>\nf: \tmovl\t(%rip), %esi  # 0x15 <h2o_socket_ssl_async_resumption_setup_ctx+0x15>\n15: \tmovq\t%rbx, %rdi\n18: \tpopq\t%rbx\n19: \tjmp\t0x1e <h2o_socket_ssl_async_resumption_setup_ctx+0x1e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_sess_set_get_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_sess_set_new_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  on_async_resumption_get ;\nint /*<<< orphan*/  on_async_resumption_new ;\n\nvoid h2o_socket_ssl_async_resumption_setup_ctx(SSL_CTX *ctx)\n{\nSSL_CTX_sess_set_get_cb(ctx, on_async_resumption_get);\nSSL_CTX_sess_set_new_cb(ctx, on_async_resumption_new);\n/* if necessary, it is the responsibility of the caller to disable the internal cache */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\ntypedef  int /*<<< orphan*/  h2o_socket_ssl_context_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_session_cache_mode (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_ssl_async_resumption_get_session_ticket_cb ;\nint /*<<< orphan*/  h2o_socket_ssl_async_resumption_new_session_ticket_cb ;\n\nvoid h2o_socket_ssl_async_resumption_setup_ctx(SSL_CTX *ctx)\n{\nSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\nSSL_CTX_set_tlsext_ticket_key_cb(ctx, h2o_socket_ssl_async_resumption_new_session_ticket_cb);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonurl.c_parse_authority_and_path",
    "input":"\n0000000000000000 <parse_authority_and_path>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovq\t%rdx, %r14\nb: \tmovq\t%rsi, %r12\ne: \tmovq\t%rdi, %rbx\n11: \tsubl\t%ebx, %esi\n13: \taddq\t$20, %rdx\n17: \tleaq\t16(%r14), %rcx\n1b: \tcallq\t0x20 <parse_authority_and_path+0x20>\n20: \tmovl\t$4294967295, %r15d # imm = 0xFFFFFFFF\n26: \ttestq\t%rax, %rax\n29: \tje\t0x7f <parse_authority_and_path+0x7f>\n2b: \tmovq\t%rax, %rbp\n2e: \tmovq\t%rax, %rsi\n31: \tsubq\t%rbx, %rsi\n34: \tmovq\t%rbx, %rdi\n37: \txorl\t%eax, %eax\n39: \tcallq\t0x3e <parse_authority_and_path+0x3e>\n3e: \tmovq\t%rax, 8(%r14)\n42: \tcmpq\t%r12, %rbp\n45: \tje\t0x65 <parse_authority_and_path+0x65>\n47: \tcmpb\t$47, (%rbp)\n4b: \tjne\t0x7f <parse_authority_and_path+0x7f>\n4d: \tsubq\t%rbp, %r12\n50: \txorl\t%r15d, %r15d\n53: \tmovq\t%rbp, %rdi\n56: \tmovq\t%r12, %rsi\n59: \txorl\t%eax, %eax\n5b: \tcallq\t0x60 <parse_authority_and_path+0x60>\n60: \tmovq\t%rax, (%r14)\n63: \tjmp\t0x7f <parse_authority_and_path+0x7f>\n65: \tmovl\t$0, %edi\n6a: \tcallq\t0x6f <parse_authority_and_path+0x6f>\n6f: \tmovslq\t%eax, %rdi\n72: \txorl\t%eax, %eax\n74: \tcallq\t0x79 <parse_authority_and_path+0x79>\n79: \tmovq\t%rax, (%r14)\n7c: \txorl\t%r15d, %r15d\n7f: \tmovl\t%r15d, %eax\n82: \tpopq\t%rbx\n83: \tpopq\t%r12\n85: \tpopq\t%r14\n87: \tpopq\t%r15\n89: \tpopq\t%rbp\n8a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {void* path; void* authority; int /*<<< orphan*/  _port; int /*<<< orphan*/  host; } ;\ntypedef  TYPE_1__ h2o_url_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nvoid* h2o_iovec_init (char const*,...) ;\nchar* h2o_url_parse_hostport (char const*,int,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int parse_authority_and_path(const char *src, const char *url_end, h2o_url_t *parsed)\n{\nconst char *p = h2o_url_parse_hostport(src, url_end - src, &parsed->host, &parsed->_port);\nif (p == NULL)\nreturn -1;\nparsed->authority = h2o_iovec_init(src, p - src);\nif (p == url_end) {\nparsed->path = h2o_iovec_init(H2O_STRLIT(\"/\"));\n} else {\nif (*p != '/')\nreturn -1;\nparsed->path = h2o_iovec_init(p, url_end - p);\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WCHAR ;\ntypedef  int /*<<< orphan*/  DWORD ;\ntypedef  int /*<<< orphan*/  BOOL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GetProcessHeap () ;\nint /*<<< orphan*/ * HeapAlloc (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  HeapFree (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TRACE (char*) ;\nint /*<<< orphan*/ * strndupW (int /*<<< orphan*/  const*,int) ;\n\n__attribute__((used)) static BOOL parse_authority_and_path(const WCHAR *url, DWORD url_len,\nWCHAR **authority, WCHAR **path)\n{\nWCHAR *authority_end;\n\nauthority_end = strndupW(url, url_len);\nif (!authority_end)\nreturn FALSE;\n\n*authority = NULL;\n*path = NULL;\n\nif (authority_end != url)\n{\n*authority = strndupW(url, authority_end - url);\nif (!*authority)\n{\nHeapFree(GetProcessHeap(), 0, authority_end);\nreturn FALSE;\n}\n}\n\nif (*authority_end == '/')\n{\n*path = strndupW(authority_end + 1, url + url_len - authority_end - 1);\nif (!*path)\n{\nHeapFree(GetProcessHeap(), 0, *authority);\nHeapFree(GetProcessHeap(), 0, authority_end);\nreturn FALSE;\n}\n}\nelse\n{\nTRACE(\"No path found\\n\");\n*path = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR));\n**path = 0;\n}\n\nHeapFree(GetProcessHeap(), 0, authority_end);\nreturn TRUE;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_do_prepare_for_latency_optimized_write",
    "input":"\n0000000000000000 <h2o_socket_do_prepare_for_latency_optimized_write>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <h2o_socket_do_prepare_for_latency_optimized_write+0xa>\na: \tcallq\t0xf <h2o_socket_do_prepare_for_latency_optimized_write+0xf>\nf: \tmovq\t(%rbx), %rax\n12: \tpopq\t%rbx\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint64_t ;\ntypedef  int /*<<< orphan*/  uint32_t ;\nstruct TYPE_8__ {size_t suggested_write_size; } ;\nstruct TYPE_9__ {TYPE_1__ _latency_optimization; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_latency_optimization_conditions_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  UINT64_MAX ;\nint /*<<< orphan*/  adjust_notsent_lowat ;\nint /*<<< orphan*/  disable_latency_optimized_write (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_evloop_get_execution_time_millisec (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_get_fd (TYPE_2__*) ;\nint /*<<< orphan*/  h2o_socket_get_loop (TYPE_2__*) ;\nscalar_t__ obtain_tcp_info (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  prepare_for_latency_optimized_write (TYPE_2__*,int /*<<< orphan*/  const*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nsize_t h2o_socket_do_prepare_for_latency_optimized_write(h2o_socket_t *sock,\nconst h2o_socket_latency_optimization_conditions_t *conditions)\n{\nuint32_t rtt = 0, mss = 0, cwnd_size = 0, cwnd_avail = 0;\nuint64_t loop_time = UINT64_MAX;\nint can_prepare = 1;\n\n#if !defined(TCP_NOTSENT_LOWAT)\n/* the feature cannot be setup unless TCP_NOTSENT_LOWAT is available */\ncan_prepare = 0;\n#endif\n\n#if H2O_USE_LIBUV\n/* poll-then-write is impossible with libuv */\ncan_prepare = 0;\n#else\nif (can_prepare)\nloop_time = h2o_evloop_get_execution_time_millisec(h2o_socket_get_loop(sock));\n#endif\n\n/* obtain TCP states */\nif (can_prepare && obtain_tcp_info(h2o_socket_get_fd(sock), &rtt, &mss, &cwnd_size, &cwnd_avail) != 0)\ncan_prepare = 0;\n\n/* determine suggested_write_size, suggested_tls_record_size and adjust TCP_NOTSENT_LOWAT based on the obtained information */\nif (can_prepare) {\nprepare_for_latency_optimized_write(sock, conditions, rtt, mss, cwnd_size, cwnd_avail, loop_time, adjust_notsent_lowat);\n} else {\ndisable_latency_optimized_write(sock, adjust_notsent_lowat);\n}\n\nreturn sock->_latency_optimization.suggested_write_size;\n\n#undef CALC_CWND_PAIR_FROM_BYTE_UNITS\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * write_req; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_FLAG_IS_LATENCY_OPTIMIZED ;\nint /*<<< orphan*/  h2o_socket_set_write_flags (TYPE_1__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static inline h2o_socket_t *h2o_socket_do_prepare_for_latency_optimized_write(h2o_socket_t *sock)\n{\nh2o_socket_set_write_flags(sock, H2O_SOCKET_FLAG_IS_LATENCY_OPTIMIZED);\nreturn sock;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_adjust_max_wait",
    "input":"\n0000000000000000 <adjust_max_wait>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %rbx\nb: \tmovl\t8(%rdi), %edi\ne: \tcallq\t0x13 <adjust_max_wait+0x13>\n13: \tmovq\t%rax, %r15\n16: \tmovq\t%rbx, %rdi\n19: \tcallq\t0x1e <adjust_max_wait+0x1e>\n1e: \tmovq\t(%rbx), %rcx\n21: \tmovq\t%r15, %rax\n24: \tsubq\t%rcx, %rax\n27: \tcmpq\t%r14, %rax\n2a: \tcmovgq\t%r14, %rax\n2e: \txorl\t%edx, %edx\n30: \tcmpq\t%rcx, %r15\n33: \tcmovleq\t%rdx, %rax\n37: \tpopq\t%rbx\n38: \tpopq\t%r14\n3a: \tpopq\t%r15\n3c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\ntypedef  scalar_t__ int32_t ;\nstruct TYPE_4__ {scalar_t__ _now_millisec; int /*<<< orphan*/  _timeouts; } ;\ntypedef  TYPE_1__ h2o_evloop_t ;\n\n/* Variables and functions */\nscalar_t__ h2o_timerwheel_get_wake_at (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  update_now (TYPE_1__*) ;\n\nint32_t adjust_max_wait(h2o_evloop_t *loop, int32_t max_wait)\n{\nuint64_t wake_at = h2o_timerwheel_get_wake_at(loop->_timeouts);\n\nupdate_now(loop);\n\nif (wake_at <= loop->_now_millisec) {\nmax_wait = 0;\n} else {\nuint64_t delta = wake_at - loop->_now_millisec;\nif (delta < max_wait)\nmax_wait = (int32_t)delta;\n}\n\nreturn max_wait;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ max_wait; int /*<<< orphan*/  max_wait_lock; } ;\ntypedef  TYPE_1__ MultiXactMember ;\n\n/* Variables and functions */\nscalar_t__ MultiXactMemberGetStatus (TYPE_1__*) ;\nint /*<<< orphan*/  SpinLockAcquire (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SpinLockRelease (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static MultiXactMember\nadjust_max_wait(MultiXactMember *member, MultiXactMember *new_member)\n{\nMultiXactMember old_member;\n\nSpinLockAcquire(member->max_wait_lock);\nold_member = *member;\n*member = *new_member;\nSpinLockRelease(member->max_wait_lock);\n\n/*\n* If the new member is not yet committed, we can't wait for it.  If it's\n* already committed, we can wait for it, but only if the old member was\n* not yet committed.\n*/\nif (MultiXactMemberGetStatus(new_member) == MultiXactStatusInProgress)\n{\nif (MultiXactMemberGetStatus(&old_member) != MultiXactStatusInProgress)\nreturn *new_member;\n}\nelse\n{\nif (MultiXactMemberGetStatus(&old_member) == MultiXactStatusInProgress)\nreturn old_member;\n}\n\n/*\n* If the old member is not yet committed, we can't wait for it.  If it's\n* already committed, we can wait for it, but only if the new member is not\n* yet committed.\n*/\nif (MultiXactMemberGetStatus(&old_member) == MultiXactStatusInProgress)\n{\nif (MultiXactMemberGetStatus(new_member) != MultiXactStatusInProgress)\nreturn old_member;\n}\nelse\n{\nif (MultiXactMemberGetStatus(new_member) == MultiXactStatusInProgress)\nreturn *new_member;\n}\n\n/*\n* If we get here, neither member is committed, so we can wait for either\n* one.  Return the one with the higher XID.\n*/\nif (old_member.max_wait < new_member->max_wait)\nreturn *new_member;\nelse\nreturn old_member;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_do_read_stop",
    "input":"\n0000000000000000 <do_read_stop>:\n0: \tmovl\t(%rip), %eax  # 0x6 <do_read_stop+0x6>\n6: \tnotl\t%eax\n8: \tandl\t%eax, (%rdi)\na: \tjmp\t0xf <do_read_stop+0xf>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  _flags; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_FLAG_IS_READ_READY ;\nint /*<<< orphan*/  link_to_statechanged (struct st_h2o_evloop_socket_t*) ;\n\nvoid do_read_stop(h2o_socket_t *_sock)\n{\nstruct st_h2o_evloop_socket_t *sock = (struct st_h2o_evloop_socket_t *)_sock;\n\nsock->_flags &= ~H2O_SOCKET_FLAG_IS_READ_READY;\nlink_to_statechanged(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__ AVIOContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AVIO_FLAG_READ ;\nint /*<<< orphan*/  avio_update_checksum (TYPE_1__*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void do_read_stop(AVIOContext *s)\n{\ns->flags &= ~AVIO_FLAG_READ;\navio_update_checksum(s, 0, 0);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_socket_get_fd",
    "input":"\n0000000000000000 <h2o_socket_get_fd>:\n0: \tmovl\t(%rdi), %eax\n2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int fd; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\n\nint h2o_socket_get_fd(h2o_socket_t *_sock)\n{\nstruct st_h2o_evloop_socket_t *sock = (struct st_h2o_evloop_socket_t *)_sock;\nreturn sock->fd;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_socket_t {int fd; } ;\n\n/* Variables and functions */\n\nint h2o_socket_get_fd(struct st_h2o_socket_t *sock)\n{\nreturn sock->fd;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_is_ws",
    "input":"\n0000000000000000 <is_ws>:\n0: \tcmpl\t$32, %edi\n3: \tja\t0x1d <is_ws+0x1d>\n5: \tmovl\t$1, %eax\na: \tmovl\t%edi, %ecx\nc: \tmovabsq\t$4294976000, %rdx  # imm = 0x100002200\n16: \tbtq\t%rcx, %rdx\n1a: \tjae\t0x1d <is_ws+0x1d>\n1c: \tretq\n1d: \txorl\t%eax, %eax\n1f: \tcmpl\t$10, %edi\n22: \tsete\t%al\n25: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int is_ws(int ch)\n{\nreturn ch == ' ' || ch == '\\t' || ch == '\\r' || ch == '\\n';\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static inline int is_ws(int c)\n{\nreturn c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloopepoll.c.h_evloop_do_dispose",
    "input":"\n0000000000000000 <evloop_do_dispose>:\n0: \tmovl\t(%rdi), %edi\n2: \tjmp\t0x7 <evloop_do_dispose+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_epoll_t {int /*<<< orphan*/  ep; } ;\ntypedef  int /*<<< orphan*/  h2o_evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void evloop_do_dispose(h2o_evloop_t *_loop)\n{\nstruct st_h2o_evloop_epoll_t *loop = (struct st_h2o_evloop_epoll_t *)_loop;\nclose(loop->ep);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  evloop; } ;\ntypedef  TYPE_1__ evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  event_base_free (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nevloop_do_dispose (evloop_t *loop)\n{\nevent_base_free (loop->evloop);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_strtosizefwd",
    "input":"\n0000000000000000 <h2o_strtosizefwd>:\n0: \ttestq\t%rsi, %rsi\n3: \tje\t0xa0 <h2o_strtosizefwd+0xa0>\n9: \tmovq\t(%rdi), %r10\nc: \tmovzbl\t(%r10), %r11d\n10: \tleal\t-48(%r11), %ecx\n14: \tcmpb\t$9, %cl\n17: \tja\t0xa0 <h2o_strtosizefwd+0xa0>\n1d: \tleaq\t(%r10,%rsi), %r8\n21: \taddl\t$-48, %r11d\n25: \tleaq\t-3(%rsi), %r9\n29: \taddq\t$-2, %rsi\n2d: \txorl\t%ecx, %ecx\n2f: \tnop\n30: \tmovzbl\t1(%r10,%rcx), %edx\n36: \tleal\t-48(%rdx), %eax\n39: \tcmpb\t$9, %al\n3b: \tja\t0x77 <h2o_strtosizefwd+0x77>\n3d: \tleal\t(%r11,%r11,4), %eax\n41: \tleal\t(%rdx,%rax,2), %r11d\n45: \taddl\t$-48, %r11d\n49: \tcmpq\t%rcx, %rsi\n4c: \tje\t0x7f <h2o_strtosizefwd+0x7f>\n4e: \tcmpl\t$18, %ecx\n51: \tje\t0xa0 <h2o_strtosizefwd+0xa0>\n53: \tmovzbl\t2(%r10,%rcx), %edx\n59: \tleal\t-48(%rdx), %eax\n5c: \tcmpb\t$9, %al\n5e: \tja\t0x8f <h2o_strtosizefwd+0x8f>\n60: \tleal\t(%r11,%r11,4), %eax\n64: \tleal\t(%rdx,%rax,2), %r11d\n68: \taddl\t$-48, %r11d\n6c: \tcmpq\t%rcx, %r9\n6f: \tje\t0x7f <h2o_strtosizefwd+0x7f>\n71: \taddq\t$2, %rcx\n75: \tjmp\t0x30 <h2o_strtosizefwd+0x30>\n77: \tleaq\t(%r10,%rcx), %r8\n7b: \taddq\t$1, %r8\n7f: \tcmpl\t(%rip), %r11d # 0x86 <h2o_strtosizefwd+0x86>\n86: \tjge\t0xa0 <h2o_strtosizefwd+0xa0>\n88: \tmovq\t%r8, (%rdi)\n8b: \tmovslq\t%r11d, %rax\n8e: \tretq\n8f: \tleaq\t(%r10,%rcx), %r8\n93: \taddq\t$2, %r8\n97: \tcmpl\t(%rip), %r11d # 0x9e <h2o_strtosizefwd+0x9e>\n9e: \tjl\t0x88 <h2o_strtosizefwd+0x88>\na0: \tmovl\t(%rip), %r11d # 0xa7 <h2o_strtosizefwd+0xa7>\na7: \tmovslq\t%r11d, %rax\naa: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint64_t ;\n\n/* Variables and functions */\nint SIZE_MAX ;\n\nsize_t h2o_strtosizefwd(char **s, size_t len)\n{\nuint64_t v, c;\nchar *p = *s, *p_end = *s + len;\n\nif (len == 0)\ngoto Error;\n\nint ch = *p++;\nif (!('0' <= ch && ch <= '9'))\ngoto Error;\nv = ch - '0';\nc = 1;\n\nwhile (1) {\nch = *p;\nif (!('0' <= ch && ch <= '9'))\nbreak;\nv *= 10;\nv += ch - '0';\np++;\nc++;\nif (p == p_end)\nbreak;\n/* similar as above, do not even try to overflow */\nif (c == 20)\ngoto Error;\n}\n\nif (v >= SIZE_MAX)\ngoto Error;\n*s = p;\nreturn v;\n\nError:\nreturn SIZE_MAX;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SIZE_MAX ;\nint SIZE_T_MAX ;\n\n__attribute__((used)) static size_t h2o_strtosizefwd(const char **src, const char *end)\n{\nconst char *p = *src;\nsize_t ret = 0;\n\nif (p == end)\nreturn SIZE_MAX;\n\nif (*p < '0' || *p > '9')\nreturn SIZE_MAX;\n\nwhile (p != end) {\nif (*p < '0' || *p > '9')\nbreak;\nret = ret * 10 + (*p - '0');\nif (ret > SIZE_T_MAX)\nreturn SIZE_MAX;\n++p;\n}\n\n*src = p;\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_unlock_cache",
    "input":"\n0000000000000000 <unlock_cache>:\n0: \tmovl\t(%rip), %eax  # 0x6 <unlock_cache+0x6>\n6: \ttestl\t%eax, (%rdi)\n8: \tje\t0x13 <unlock_cache+0x13>\na: \taddq\t$4, %rdi\ne: \tjmp\t0x13 <unlock_cache+0x13>\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  mutex; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\nint H2O_CACHE_FLAG_MULTITHREADED ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void unlock_cache(h2o_cache_t *cache)\n{\nif ((cache->flags & H2O_CACHE_FLAG_MULTITHREADED) != 0)\npthread_mutex_unlock(&cache->mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  mutex; } ;\ntypedef  TYPE_1__ cache_t ;\n\n/* Variables and functions */\nint CACHE_FLAG_MUTEX ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void unlock_cache (cache_t *cache) {\nif (cache->flags & CACHE_FLAG_MUTEX) {\npthread_mutex_unlock (&cache->mutex);\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_string.c_test_lib__common__string_c",
    "input":"\n0000000000000000 <test_lib__common__string_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__string_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__string_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__string_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_lib__common__string_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_lib__common__string_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tcallq\t0x31 <test_lib__common__string_c+0x31>\n31: \tmovl\t(%rip), %esi  # 0x37 <test_lib__common__string_c+0x37>\n37: \tmovl\t$0, %edi\n3c: \tcallq\t0x41 <test_lib__common__string_c+0x41>\n41: \tmovl\t(%rip), %esi  # 0x47 <test_lib__common__string_c+0x47>\n47: \tmovl\t$0, %edi\n4c: \tcallq\t0x51 <test_lib__common__string_c+0x51>\n51: \tmovl\t(%rip), %esi  # 0x57 <test_lib__common__string_c+0x57>\n57: \tmovl\t$0, %edi\n5c: \tcallq\t0x61 <test_lib__common__string_c+0x61>\n61: \tmovl\t(%rip), %esi  # 0x67 <test_lib__common__string_c+0x67>\n67: \tmovl\t$0, %edi\n6c: \tcallq\t0x71 <test_lib__common__string_c+0x71>\n71: \tmovl\t(%rip), %esi  # 0x77 <test_lib__common__string_c+0x77>\n77: \tmovl\t$0, %edi\n7c: \tcallq\t0x81 <test_lib__common__string_c+0x81>\n81: \tmovl\t(%rip), %esi  # 0x87 <test_lib__common__string_c+0x87>\n87: \tmovl\t$0, %edi\n8c: \tcallq\t0x91 <test_lib__common__string_c+0x91>\n91: \tmovl\t(%rip), %esi  # 0x97 <test_lib__common__string_c+0x97>\n97: \tmovl\t$0, %edi\n9c: \tpopq\t%rax\n9d: \tjmp\t0xa2 <test_lib__common__string_c+0xa2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_at_position ;\nint /*<<< orphan*/  test_decode_base64 ;\nint /*<<< orphan*/  test_get_filext ;\nint /*<<< orphan*/  test_htmlescape ;\nint /*<<< orphan*/  test_next_token ;\nint /*<<< orphan*/  test_next_token2 ;\nint /*<<< orphan*/  test_next_token3 ;\nint /*<<< orphan*/  test_stripws ;\nint /*<<< orphan*/  test_strstr ;\nint /*<<< orphan*/  test_uri_escape ;\n\nvoid test_lib__common__string_c(void)\n{\nsubtest(\"strstr\", test_strstr);\nsubtest(\"stripws\", test_stripws);\nsubtest(\"get_filext\", test_get_filext);\nsubtest(\"next_token\", test_next_token);\nsubtest(\"next_token2\", test_next_token2);\nsubtest(\"next_token3\", test_next_token3);\nsubtest(\"decode_base64\", test_decode_base64);\nsubtest(\"htmlescape\", test_htmlescape);\nsubtest(\"uri_escape\", test_uri_escape);\nsubtest(\"at_position\", test_at_position);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_ASSERT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_LEN (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_LEN_MESSAGE (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_MESSAGE (char*,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_NULL_MESSAGE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING_NULL_NULL_NULL_NULL_"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_serverutil.c_test_lib__common__serverutil_c",
    "input":"\n0000000000000000 <test_lib__common__serverutil_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__serverutil_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__serverutil_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__serverutil_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tpopq\t%rax\n1d: \tjmp\t0x22 <test_lib__common__serverutil_c+0x22>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_read_command ;\nint /*<<< orphan*/  test_server_starter ;\n\nvoid test_lib__common__serverutil_c(void)\n{\nsubtest(\"server-starter\", test_server_starter);\nsubtest(\"read-command\", test_read_command);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_int_eq (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ptr_eq (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  serverutil_c ;\nint /*<<< orphan*/  serverutil_c_d ;\n\n__attribute__((used)) static void test_lib__common__serverutil_c(void)\n{\nTEST_ptr_eq(serverutil_c, serverutil_c_d);\nTEST_int_eq(serverutil_c, serverutil_c_d);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_on_write_complete",
    "input":"\n0000000000000000 <on_write_complete>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovq\t8(%rdi), %rdi\ne: \ttestq\t%rdi, %rdi\n11: \tje\t0x18 <on_write_complete+0x18>\n13: \tcallq\t0x18 <on_write_complete+0x18>\n18: \tmovq\t(%rbx), %rax\n1b: \tmovq\t$0, (%rbx)\n22: \tmovq\t%rbx, %rdi\n25: \tmovq\t%r14, %rsi\n28: \taddq\t$8, %rsp\n2c: \tpopq\t%rbx\n2d: \tpopq\t%r14\n2f: \tjmpq\t*%rax",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  (* write ) (TYPE_2__*,char const*) ;} ;\nstruct TYPE_6__ {TYPE_1__ _cb; int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  (* h2o_socket_cb ) (TYPE_2__*,char const*) ;\n\n/* Variables and functions */\nint /*<<< orphan*/  clear_output_buffer (int /*<<< orphan*/ *) ;\n\nvoid on_write_complete(h2o_socket_t *sock, const char *err)\n{\nh2o_socket_cb cb;\n\nif (sock->ssl != NULL)\nclear_output_buffer(sock->ssl);\n\ncb = sock->_cb.write;\nsock->_cb.write = NULL;\ncb(sock, err);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  (* on_write_complete ) (TYPE_2__*,int /*<<< orphan*/ *) ;} ;\nstruct TYPE_4__ {int /*<<< orphan*/ * write_complete_cb; TYPE_2__* priv_data; } ;\ntypedef  TYPE_1__ URLContext ;\ntypedef  int /*<<< orphan*/  URLContext ;\ntypedef  TYPE_2__ URLProtocol ;\n\n/* Variables and functions */\nint /*<<< orphan*/  av_freep (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  stub1 (TYPE_2__*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_write_complete(URLContext *h, int status)\n{\nURLProtocol *p = h->priv_data;\n\nif (h->write_complete_cb)\nav_freep(&h->write_complete_cb);\n\np->on_write_complete(h, status);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhostinfo.c_h2o_hostinfo_getaddr_cancel",
    "input":"\n0000000000000000 <h2o_hostinfo_getaddr_cancel>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <h2o_hostinfo_getaddr_cancel+0x11>\n11: \tleaq\t8(%r14), %rbx\n15: \tmovq\t%rbx, %rdi\n18: \tcallq\t0x1d <h2o_hostinfo_getaddr_cancel+0x1d>\n1d: \ttestq\t%rax, %rax\n20: \tje\t0x43 <h2o_hostinfo_getaddr_cancel+0x43>\n22: \tmovq\t%rbx, %rdi\n25: \tcallq\t0x2a <h2o_hostinfo_getaddr_cancel+0x2a>\n2a: \tmovl\t$0, %edi\n2f: \tcallq\t0x34 <h2o_hostinfo_getaddr_cancel+0x34>\n34: \tmovq\t%r14, %rdi\n37: \taddq\t$8, %rsp\n3b: \tpopq\t%rbx\n3c: \tpopq\t%r14\n3e: \tjmp\t0x43 <h2o_hostinfo_getaddr_cancel+0x43>\n43: \tmovq\t$0, (%r14)\n4a: \tmovl\t$0, %edi\n4f: \taddq\t$8, %rsp\n53: \tpopq\t%rbx\n54: \tpopq\t%r14\n56: \tjmp\t0x5b <h2o_hostinfo_getaddr_cancel+0x5b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * _cb; int /*<<< orphan*/  _pending; } ;\ntypedef  TYPE_1__ h2o_hostinfo_getaddr_req_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  mutex; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_1__*) ;\nscalar_t__ h2o_linklist_is_linked (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_linklist_unlink (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\nTYPE_2__ queue ;\n\nvoid h2o_hostinfo_getaddr_cancel(h2o_hostinfo_getaddr_req_t *req)\n{\nint should_free = 0;\n\npthread_mutex_lock(&queue.mutex);\n\nif (h2o_linklist_is_linked(&req->_pending)) {\nh2o_linklist_unlink(&req->_pending);\nshould_free = 1;\n} else {\nreq->_cb = NULL;\n}\n\npthread_mutex_unlock(&queue.mutex);\n\nif (should_free)\nfree(req);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * getaddr_req; } ;\ntypedef  TYPE_1__ h2o_hostinfo_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_getaddr_cancel (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mem_clear_pool (TYPE_1__*,int /*<<< orphan*/ ) ;\nscalar_t__ h2o_getaddr_is_active (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mem_init_pool (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_mem_pool_cleanup_start ;\nint /*<<< orphan*/  h2o_mem_pool_cleanup_stop ;\n\nvoid h2o_hostinfo_getaddr_cancel(h2o_hostinfo_t *hostinfo)\n{\nh2o_mem_pool_cleanup_start(hostinfo, h2o_mem_pool_cleanup_stop);\nif (h2o_getaddr_is_active(hostinfo->getaddr_req)) {\nh2o_getaddr_cancel(hostinfo->getaddr_req);\nh2o_mem_pool_cleanup_start(hostinfo, h2o_mem_pool_cleanup_stop);\n}\nhostinfo->getaddr_req = NULL;\nh2o_mem_clear_pool(hostinfo, h2o_mem_pool_cleanup_stop);\nfree(hostinfo);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_on_async_resumption_get",
    "input":"\n0000000000000000 <on_async_resumption_get>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rcx, %rbx\na: \tmovl\t%edx, %r14d\nd: \tmovq\t%rsi, %r15\n10: \tcallq\t0x15 <on_async_resumption_get+0x15>\n15: \tmovl\t%eax, %edi\n17: \tcallq\t0x1c <on_async_resumption_get+0x1c>\n1c: \tmovq\t%rax, %rbp\n1f: \tmovq\t(%rax), %rax\n22: \tmovl\t(%rax), %ecx\n24: \tcmpl\t$129, %ecx\n2a: \tje\t0x55 <on_async_resumption_get+0x55>\n2c: \tcmpl\t$128, %ecx\n32: \tjne\t0x61 <on_async_resumption_get+0x61>\n34: \tmovl\t(%rip), %ecx  # 0x3a <on_async_resumption_get+0x3a>\n3a: \tmovl\t%ecx, (%rax)\n3c: \tmovq\t%r15, %rdi\n3f: \tmovl\t%r14d, %esi\n42: \tcallq\t0x47 <on_async_resumption_get+0x47>\n47: \tmovq\t%rbp, %rdi\n4a: \tmovl\t%eax, %esi\n4c: \tcallq\t0x51 <on_async_resumption_get+0x51>\n51: \txorl\t%ebx, %ebx\n53: \tjmp\t0x6a <on_async_resumption_get+0x6a>\n55: \tmovl\t$1, (%rbx)\n5b: \tmovq\t8(%rax), %rbx\n5f: \tjmp\t0x6a <on_async_resumption_get+0x6a>\n61: \txorl\t%ebx, %ebx\n63: \txorl\t%edi, %edi\n65: \tcallq\t0x6a <on_async_resumption_get+0x6a>\n6a: \tmovq\t%rbx, %rax\n6d: \taddq\t$8, %rsp\n71: \tpopq\t%rbx\n72: \tpopq\t%r14\n74: \tpopq\t%r15\n76: \tpopq\t%rbp\n77: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_5__ ;\ntypedef  struct TYPE_11__   TYPE_4__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_12__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_5__ h2o_socket_t ;\nstruct TYPE_10__ {int state; int /*<<< orphan*/ * session_data; } ;\nstruct TYPE_9__ {TYPE_3__ async_resumption; } ;\nstruct TYPE_11__ {TYPE_2__ server; } ;\nstruct TYPE_8__ {TYPE_4__ handshake; } ;\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\n#define  ASYNC_RESUMPTION_STATE_COMPLETE 129\n#define  ASYNC_RESUMPTION_STATE_RECORD 128\nint ASYNC_RESUMPTION_STATE_REQUEST_SENT ;\nTYPE_5__* BIO_get_data (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_get_rbio (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_iovec_init (unsigned char const*,int) ;\nint /*<<< orphan*/  resumption_get_async (TYPE_5__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static SSL_SESSION *on_async_resumption_get(SSL *ssl,\n#if !defined(LIBRESSL_VERSION_NUMBER) ? OPENSSL_VERSION_NUMBER >= 0x1010000fL : LIBRESSL_VERSION_NUMBER > 0x2070000f\nconst\n#endif\nunsigned char *data,\nint len, int *copy)\n{\nh2o_socket_t *sock = BIO_get_data(SSL_get_rbio(ssl));\n\nswitch (sock->ssl->handshake.server.async_resumption.state) {\ncase ASYNC_RESUMPTION_STATE_RECORD:\nsock->ssl->handshake.server.async_resumption.state = ASYNC_RESUMPTION_STATE_REQUEST_SENT;\nresumption_get_async(sock, h2o_iovec_init(data, len));\nreturn NULL;\ncase ASYNC_RESUMPTION_STATE_COMPLETE:\n*copy = 1;\nreturn sock->ssl->handshake.server.async_resumption.session_data;\ndefault:\nassert(!\"FIXME\");\nreturn NULL;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  type; TYPE_2__* data; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  resumption_data; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ SSL ;\ntypedef  TYPE_2__ SSL_SESSION ;\ntypedef  TYPE_3__ SSL_ASYNC_ARG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ASYNC_ERR ;\nint /*<<< orphan*/  SSL_AD_INTERNAL_ERROR ;\nint /*<<< orphan*/  SSL_F_ON_ASYNC_RESUMPTION_GET ;\nint /*<<< orphan*/  SSL_F_SSL_SESSION_DUP ;\nint /*<<< orphan*/  SSL_SESSION_free (TYPE_2__*) ;\nint /*<<< orphan*/  SSL_SESSION_get_id (TYPE_2__*,int) ;\nint /*<<< orphan*/  SSL_SESSION_up_ref (TYPE_2__*) ;\nint /*<<< orphan*/  SSLerr (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_3__* get_async_ssl_pointer (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static SSL_SESSION *on_async_resumption_get(SSL *ssl, int idx,\nint *ad, void *arg)\n{\nSSL_ASYNC_ARG *async_arg = get_async_ssl_pointer(ssl);\nSSL_SESSION *ret = NULL;\n\nswitch (async_arg->type) {\ncase SSL_AD_INTERNAL_ERROR:\nSSLerr(SSL_F_SSL_SESSION_DUP, async_arg->type);\nbreak;\ncase SSL_AD_OK:\nret = async_arg->data;\nSSL_SESSION_up_ref(ret);\nbreak;\ndefault:\nSSLerr(SSL_F_ON_ASYNC_RESUMPTION_GET, ASYNC_ERR);\nbreak;\n}\n\nSSL_SESSION_free(async_arg->data);\nasync_arg->type = SSL_AD_INTERNAL_ERROR;\nasync_arg->data = NULL;\n\n*ad = ret == NULL;\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_hex_encode",
    "input":"\n0000000000000000 <h2o_hex_encode>:\n0: \ttestq\t%rdx, %rdx\n3: \tje\t0xa0 <h2o_hex_encode+0xa0>\n9: \ttestb\t$1, %dl\nc: \tjne\t0x1c <h2o_hex_encode+0x1c>\ne: \tmovq\t%rsi, %rax\n11: \tcmpq\t$1, %rdx\n15: \tjne\t0x48 <h2o_hex_encode+0x48>\n17: \tjmp\t0xa0 <h2o_hex_encode+0xa0>\n1c: \tmovzbl\t(%rsi), %eax\n1f: \tshrq\t$4, %rax\n23: \tmovb\t(%rax), %al\n29: \tmovb\t%al, (%rdi)\n2b: \tmovzbl\t(%rsi), %eax\n2e: \tandl\t$15, %eax\n31: \tmovb\t(%rax), %al\n37: \tmovb\t%al, 1(%rdi)\n3a: \taddq\t$2, %rdi\n3e: \tleaq\t1(%rsi), %rax\n42: \tcmpq\t$1, %rdx\n46: \tje\t0xa0 <h2o_hex_encode+0xa0>\n48: \taddq\t%rdx, %rsi\n4b: \tnopl\t(%rax,%rax)\n50: \tmovzbl\t(%rax), %ecx\n53: \tshrq\t$4, %rcx\n57: \tmovzbl\t(%rcx), %ecx\n5e: \tmovb\t%cl, (%rdi)\n60: \tmovzbl\t(%rax), %ecx\n63: \tandl\t$15, %ecx\n66: \tmovzbl\t(%rcx), %ecx\n6d: \tmovb\t%cl, 1(%rdi)\n70: \tmovzbl\t1(%rax), %ecx\n74: \tshrq\t$4, %rcx\n78: \tmovzbl\t(%rcx), %ecx\n7f: \tmovb\t%cl, 2(%rdi)\n82: \tmovzbl\t1(%rax), %ecx\n86: \tandl\t$15, %ecx\n89: \tmovzbl\t(%rcx), %ecx\n90: \tmovb\t%cl, 3(%rdi)\n93: \taddq\t$4, %rdi\n97: \taddq\t$2, %rax\n9b: \tcmpq\t%rsi, %rax\n9e: \tjne\t0x50 <h2o_hex_encode+0x50>\na0: \tmovb\t$0, (%rdi)\na3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid h2o_hex_encode(char *dst, const void *_src, size_t src_len)\n{\nconst unsigned char *src = _src, *src_end = src + src_len;\nfor (; src != src_end; ++src) {\n*dst++ = \"0123456789abcdef\"[*src >> 4];\n*dst++ = \"0123456789abcdef\"[*src & 0xf];\n}\n*dst = '\\0';\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static void h2o_hex_encode(char *dst, const void *_src, size_t len)\n{\nconst unsigned char *src = _src;\n\nif (len == 0)\nreturn;\n\nif ((len & 1) == 0) {\n*dst++ = *src >> 4;\n*dst++ = *src++ & 15;\n} else {\n*dst++ = *src >> 4;\n*dst++ = *src++ & 15;\n}\n\nwhile (len > 1) {\n*dst++ = *src >> 4;\n*dst++ = *src++ & 15;\n*dst++ = *src >> 4;\n*dst++ = *src++ & 15;\nlen -= 2;\n}\n*dst = '\\0';\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_destroy_ssl",
    "input":"\n0000000000000000 <destroy_ssl>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t32(%rdi), %rdi\n8: \ttestq\t%rdi, %rdi\nb: \tje\t0x1a <destroy_ssl+0x1a>\nd: \tcallq\t0x12 <destroy_ssl+0x12>\n12: \tmovq\t$0, 32(%rbx)\n1a: \tmovq\t8(%rbx), %rdi\n1e: \ttestq\t%rdi, %rdi\n21: \tje\t0x4f <destroy_ssl+0x4f>\n23: \tcallq\t0x28 <destroy_ssl+0x28>\n28: \ttestl\t%eax, %eax\n2a: \tjne\t0x3e <destroy_ssl+0x3e>\n2c: \tmovq\t24(%rbx), %rdi\n30: \tcallq\t0x35 <destroy_ssl+0x35>\n35: \tmovq\t16(%rbx), %rdi\n39: \tcallq\t0x3e <destroy_ssl+0x3e>\n3e: \tmovq\t8(%rbx), %rdi\n42: \tcallq\t0x47 <destroy_ssl+0x47>\n47: \tmovq\t$0, 8(%rbx)\n4f: \tmovq\t%rbx, %rdi\n52: \tcallq\t0x57 <destroy_ssl+0x57>\n57: \tmovq\t%rbx, %rdi\n5a: \tcallq\t0x5f <destroy_ssl+0x5f>\n5f: \tmovq\t%rbx, %rdi\n62: \tpopq\t%rbx\n63: \tjmp\t0x68 <destroy_ssl+0x68>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  encrypted; } ;\nstruct TYPE_5__ {struct st_h2o_socket_ssl_t* base; } ;\nstruct TYPE_6__ {TYPE_1__ session_cache_key; struct st_h2o_socket_ssl_t* server_name; } ;\nstruct TYPE_7__ {TYPE_2__ client; } ;\nstruct st_h2o_socket_ssl_t {TYPE_4__ input; int /*<<< orphan*/ * ossl; TYPE_3__ handshake; int /*<<< orphan*/ * ptls; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_is_server (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  clear_output_buffer (struct st_h2o_socket_ssl_t*) ;\nint /*<<< orphan*/  free (struct st_h2o_socket_ssl_t*) ;\nint /*<<< orphan*/  h2o_buffer_dispose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ptls_free (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void destroy_ssl(struct st_h2o_socket_ssl_t *ssl)\n{\nif (ssl->ptls != NULL) {\nptls_free(ssl->ptls);\nssl->ptls = NULL;\n}\nif (ssl->ossl != NULL) {\nif (!SSL_is_server(ssl->ossl)) {\nfree(ssl->handshake.client.server_name);\nfree(ssl->handshake.client.session_cache_key.base);\n}\nSSL_free(ssl->ossl);\nssl->ossl = NULL;\n}\nh2o_buffer_dispose(&ssl->input.encrypted);\nclear_output_buffer(ssl);\nfree(ssl);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * ssl; int /*<<< orphan*/ * ssl_ctx; int /*<<< orphan*/ * ssl_ctx_tmp; int /*<<< orphan*/ * ssl_ctx_tmp_dgrd; int /*<<< orphan*/ * ssl_ctx_dgrd; int /*<<< orphan*/ * ssl_dgrd; } ;\ntypedef  TYPE_1__ SSL_TEST_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_app_data (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  SSL_CTX_set_session_id_context (int /*<<< orphan*/ *,unsigned char*,size_t) ;\nint /*<<< orphan*/  SSL_CTX_set_session_ticket_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  SSL_CTX_set_verify (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_verify_depth (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  SSL_CTX_set_verify_mode (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  SSL_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_set_app_data (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  SSL_set_session_id_context (int /*<<< orphan*/ *,unsigned char*,size_t) ;\nint /*<<< orphan*/  SSL_set_session_ticket_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_set_tlsext_ticket_key_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_set_tlsext_ticket_key_cb_data (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  SSL_set_verify (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_set_verify_depth (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  SSL_set_verify_mode (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void destroy_ssl(SSL_TEST_CTX *test_ctx)\n{\nif (test_ctx->ssl_ctx != NULL) {\nSSL_CTX_set_app_data(test_ctx->ssl_ctx, NULL);\nSSL_CTX_set_session_id_context(test_ctx->ssl_ctx, NULL, 0);\nSSL_CTX_set_session_ticket_cb(test_ctx->ssl_ctx, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb(test_ctx->ssl_ctx, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb_data(test_ctx->ssl_ctx, NULL);\nSSL_CTX_set_verify(test_ctx->ssl_ctx, 0, NULL);\nSSL_CTX_set_verify_mode(test_ctx->ssl_ctx, 0);\nSSL_CTX_set_verify_depth(test_ctx->ssl_ctx, 0);\nSSL_CTX_free(test_ctx->ssl_ctx);\ntest_ctx->ssl_ctx = NULL;\n}\n\nif (test_ctx->ssl_ctx_tmp != NULL) {\nSSL_CTX_set_app_data(test_ctx->ssl_ctx_tmp, NULL);\nSSL_CTX_set_session_id_context(test_ctx->ssl_ctx_tmp, NULL, 0);\nSSL_CTX_set_session_ticket_cb(test_ctx->ssl_ctx_tmp, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb(test_ctx->ssl_ctx_tmp, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb_data(test_ctx->ssl_ctx_tmp, NULL);\nSSL_CTX_set_verify(test_ctx->ssl_ctx_tmp, 0, NULL);\nSSL_CTX_set_verify_mode(test_ctx->ssl_ctx_tmp, 0);\nSSL_CTX_set_verify_depth(test_ctx->ssl_ctx_tmp, 0);\nSSL_CTX_free(test_ctx->ssl_ctx_tmp);\ntest_ctx->ssl_ctx_tmp = NULL;\n}\n\nif (test_ctx->ssl_ctx_dgrd != NULL) {\nSSL_CTX_set_app_data(test_ctx->ssl_ctx_dgrd, NULL);\nSSL_CTX_set_session_id_context(test_ctx->ssl_ctx_dgrd, NULL, 0);\nSSL_CTX_set_session_ticket_cb(test_ctx->ssl_ctx_dgrd, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb(test_ctx->ssl_ctx_dgrd, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb_data(test_ctx->ssl_ctx_dgrd, NULL);\nSSL_CTX_set_verify(test_ctx->ssl_ctx_dgrd, 0, NULL);\nSSL_CTX_set_verify_mode(test_ctx->ssl_ctx_dgrd, 0);\nSSL_CTX_set_verify_depth(test_ctx->ssl_ctx_dgrd, 0);\nSSL_CTX_free(test_ctx->ssl_ctx_dgrd);\ntest_ctx->ssl_ctx_dgrd = NULL;\n}\n\nif (test_ctx->ssl_ctx_tmp_dgrd != NULL) {\nSSL_CTX_set_app_data(test_ctx->ssl_ctx_tmp_dgrd, NULL);\nSSL_CTX_set_session_id_context(test_ctx->ssl_ctx_tmp_dgrd, NULL, 0);\nSSL_CTX_set_session_ticket_cb(test_ctx->ssl_ctx_tmp_dgrd, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb(test_ctx->ssl_ctx_tmp_dgrd, NULL, NULL);\nSSL_CTX_set_tlsext_ticket_key_cb_data(test_ctx->ssl_ctx_tmp_dgrd, NULL);\nSSL_CTX_set_verify(test_ctx->ssl_ctx_tmp_dgrd, 0, NULL);\nSSL_CTX_set_verify_mode(test_ctx->ssl_ctx_tmp_dgrd, 0);\nSSL_CTX_set_verify_depth"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonurl.c_parse_scheme",
    "input":"\n0000000000000000 <parse_scheme>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %rbx\n8: \tsubq\t%rdi, %rbx\nb: \tcmpq\t$5, %rbx\nf: \tjl\t0x48 <parse_scheme+0x48>\n11: \tmovq\t%rdx, %r14\n14: \tmovq\t%rdi, %r15\n17: \tmovl\t$0, %esi\n1c: \tmovl\t$5, %edx\n21: \tcallq\t0x26 <parse_scheme+0x26>\n26: \ttestq\t%rax, %rax\n29: \tje\t0x54 <parse_scheme+0x54>\n2b: \tcmpq\t$6, %rbx\n2f: \tjl\t0x48 <parse_scheme+0x48>\n31: \tmovl\t$0, %esi\n36: \tmovq\t%r15, %rdi\n39: \tmovl\t$6, %edx\n3e: \tcallq\t0x43 <parse_scheme+0x43>\n43: \ttestq\t%rax, %rax\n46: \tje\t0x61 <parse_scheme+0x61>\n48: \txorl\t%r15d, %r15d\n4b: \tmovq\t%r15, %rax\n4e: \tpopq\t%rbx\n4f: \tpopq\t%r14\n51: \tpopq\t%r15\n53: \tretq\n54: \tmovq\t$0, (%r14)\n5b: \taddq\t$5, %r15\n5f: \tjmp\t0x4b <parse_scheme+0x4b>\n61: \tmovq\t$0, (%r14)\n68: \taddq\t$6, %r15\n6c: \tjmp\t0x4b <parse_scheme+0x4b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_url_scheme_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_URL_SCHEME_HTTP ;\nint /*<<< orphan*/  H2O_URL_SCHEME_HTTPS ;\nscalar_t__ memcmp (char const*,char*,int) ;\n\n__attribute__((used)) static const char *parse_scheme(const char *s, const char *end, const h2o_url_scheme_t **scheme)\n{\nif (end - s >= 5 && memcmp(s, \"http:\", 5) == 0) {\n*scheme = &H2O_URL_SCHEME_HTTP;\nreturn s + 5;\n} else if (end - s >= 6 && memcmp(s, \"https:\", 6) == 0) {\n*scheme = &H2O_URL_SCHEME_HTTPS;\nreturn s + 6;\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ memcmp (char const*,char*,int) ;\n\n__attribute__((used)) static const char *parse_scheme(const char *p, const char *end, const char **scheme)\n{\nif (end - p < 5)\nreturn NULL;\nif (!memcmp(p, \"http:\", 5)) {\n*scheme = \"http\";\nreturn p + 5;\n}\nif (!memcmp(p, \"https:\", 6)) {\n*scheme = \"https\";\nreturn p + 6;\n}\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_str_stripws",
    "input":"\n0000000000000000 <h2o_str_stripws>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r14\n8: \tleaq\t(%rdi,%rsi), %rbx\nc: \ttestq\t%rsi, %rsi\nf: \tje\t0x40 <h2o_str_stripws+0x40>\n11: \tmovq\t%rsi, %r15\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tmovsbl\t(%r14), %edi\n24: \tcallq\t0x29 <h2o_str_stripws+0x29>\n29: \ttestl\t%eax, %eax\n2b: \tje\t0x40 <h2o_str_stripws+0x40>\n2d: \taddq\t$1, %r14\n31: \taddq\t$-1, %r15\n35: \tjne\t0x20 <h2o_str_stripws+0x20>\n37: \tmovq\t%rbx, %r14\n3a: \tnopw\t(%rax,%rax)\n40: \tcmpq\t%rbx, %r14\n43: \tje\t0x5c <h2o_str_stripws+0x5c>\n45: \tmovsbl\t-1(%rbx), %edi\n49: \taddq\t$-1, %rbx\n4d: \tcallq\t0x52 <h2o_str_stripws+0x52>\n52: \ttestl\t%eax, %eax\n54: \tjne\t0x40 <h2o_str_stripws+0x40>\n56: \taddq\t$1, %rbx\n5a: \tjmp\t0x5f <h2o_str_stripws+0x5f>\n5c: \tmovq\t%r14, %rbx\n5f: \tsubl\t%r14d, %ebx\n62: \tmovq\t%r14, %rdi\n65: \tmovl\t%ebx, %esi\n67: \tpopq\t%rbx\n68: \tpopq\t%r14\n6a: \tpopq\t%r15\n6c: \tjmp\t0x71 <h2o_str_stripws+0x71>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_iovec_init (char const*,int) ;\nint /*<<< orphan*/  is_ws (char const) ;\n\nh2o_iovec_t h2o_str_stripws(const char *s, size_t len)\n{\nconst char *end = s + len;\n\nwhile (s != end) {\nif (!is_ws(*s))\nbreak;\n++s;\n}\nwhile (s != end) {\nif (!is_ws(end[-1]))\nbreak;\n--end;\n}\nreturn h2o_iovec_init(s, end - s);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  isspace (char const) ;\nint /*<<< orphan*/  memmove (char*,char*,int) ;\n\n__attribute__((used)) static void h2o_str_stripws(char *s, size_t len)\n{\nconst char *end = s + len;\n\nwhile (len != 0 && isspace(*s)) {\n++s;\n--len;\n}\nwhile (len != 0 && isspace(end[-1])) {\n--end;\n--len;\n}\nmemmove(s, end, len);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_calc_suggested_tls_payload_size",
    "input":"\n0000000000000000 <calc_suggested_tls_payload_size>:\n0: \tmovq\t%rsi, %rax\n3: \tmovq\t(%rdi), %rcx\n6: \ttestq\t%rcx, %rcx\n9: \tje\t0x1a <calc_suggested_tls_payload_size+0x1a>\nb: \tmovq\t(%rcx), %rcx\ne: \txorl\t%edx, %edx\n10: \tcmpq\t%rax, %rcx\n13: \tcmovlq\t%rcx, %rdx\n17: \tsubq\t%rdx, %rax\n1a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint16_t ;\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_4__ {scalar_t__ record_overhead; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static uint16_t calc_suggested_tls_payload_size(h2o_socket_t *sock, uint16_t suggested_tls_record_size)\n{\nuint16_t ps = suggested_tls_record_size;\nif (sock->ssl != NULL && sock->ssl->record_overhead < ps)\nps -= sock->ssl->record_overhead;\nreturn ps;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__* suggested_tls_payload_size; } ;\ntypedef  TYPE_1__ SSL_SESSION ;\n\n/* Variables and functions */\n\n__attribute__((used)) static size_t calc_suggested_tls_payload_size(SSL_SESSION *s, size_t len)\n{\nif (s->suggested_tls_payload_size == NULL)\nreturn len;\n\nreturn len - *s->suggested_tls_payload_size;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_do_export",
    "input":"\n0000000000000000 <do_export>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovl\t(%rip), %eax  # 0x10 <do_export+0x10>\n10: \txorl\t%edi, %edi\n12: \tandl\t(%rbx), %eax\n14: \tsete\t%dil\n18: \tcallq\t0x1d <do_export+0x1d>\n1d: \tmovq\t%rbx, %rdi\n20: \tcallq\t0x25 <do_export+0x25>\n25: \tmovl\t(%rip), %eax  # 0x2b <do_export+0x2b>\n2b: \tmovl\t%eax, (%rbx)\n2d: \tmovl\t4(%rbx), %eax\n30: \tmovl\t%eax, (%r14)\n33: \tmovl\t$4294967295, 4(%rbx)    # imm = 0xFFFFFFFF\n3a: \txorl\t%eax, %eax\n3c: \taddq\t$8, %rsp\n40: \tpopq\t%rbx\n41: \tpopq\t%r14\n43: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int _flags; int fd; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\nstruct TYPE_3__ {int fd; } ;\ntypedef  TYPE_1__ h2o_socket_export_t ;\n\n/* Variables and functions */\nint H2O_SOCKET_FLAG_IS_DISPOSED ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  evloop_do_on_socket_export (struct st_h2o_evloop_socket_t*) ;\n\nint do_export(h2o_socket_t *_sock, h2o_socket_export_t *info)\n{\nstruct st_h2o_evloop_socket_t *sock = (void *)_sock;\n\nassert((sock->_flags & H2O_SOCKET_FLAG_IS_DISPOSED) == 0);\nevloop_do_on_socket_export(sock);\nsock->_flags = H2O_SOCKET_FLAG_IS_DISPOSED;\n\ninfo->fd = sock->fd;\nsock->fd = -1;\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__ PGconn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Assert (int) ;\nint PGRES_COPY_BOTH ;\nint /*<<< orphan*/  PQclear (TYPE_1__*) ;\n\n__attribute__((used)) static int\ndo_export(PGconn *conn, int *result)\n{\nAssert((conn->flags & PGRES_COPY_BOTH) == 0);\nPQclear(conn);\nconn->flags = PGRES_COPY_BOTH;\n*result = conn->data;\nconn->data = -1;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ptls",
    "input":"\n0000000000000000 <h2o_socket_get_ptls>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0xc <h2o_socket_get_ptls+0xc>\n8: \tmovq\t(%rax), %rax\nb: \tretq\nc: \txorl\t%eax, %eax\ne: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ptls_t ;\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * ptls; } ;\n\n/* Variables and functions */\n\nptls_t *h2o_socket_get_ptls(h2o_socket_t *sock)\n{\nreturn sock->ssl != NULL ? sock->ssl->ptls : NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_h2o_socket_ssl_t {TYPE_1__* ptls; } ;\nstruct TYPE_3__ {int /*<<< orphan*/  ptls; } ;\nstruct st_h2o_socket_t {struct st_h2o_socket_ssl_t* ssl; } ;\ntypedef  int /*<<< orphan*/  ptls_t ;\n\n/* Variables and functions */\n\nptls_t *h2o_socket_get_ptls(struct st_h2o_socket_t *sock)\n{\nif (sock->ssl == NULL)\nreturn NULL;\nreturn &sock->ssl->ptls->ptls;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloopepoll.c.h_evloop_do_on_socket_close",
    "input":"\n0000000000000000 <evloop_do_on_socket_close>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rdi), %edx\n6: \tcmpl\t$-1, %edx\n9: \tje\t0x62 <evloop_do_on_socket_close+0x62>\nb: \tmovq\t%rdi, %rbx\ne: \tmovq\t8(%rdi), %r14\n12: \tmovl\t(%rip), %eax  # 0x18 <evloop_do_on_socket_close+0x18>\n18: \ttestl\t%eax, 4(%rdi)\n1b: \tje\t0x62 <evloop_do_on_socket_close+0x62>\n1d: \tnopl\t(%rax)\n20: \tmovl\t(%r14), %edi\n23: \tmovl\t(%rip), %esi  # 0x29 <evloop_do_on_socket_close+0x29>\n29: \txorl\t%ecx, %ecx\n2b: \tcallq\t0x30 <evloop_do_on_socket_close+0x30>\n30: \tmovq\t(%rip), %rsi  # 0x37 <evloop_do_on_socket_close+0x37>\n37: \ttestl\t%eax, %eax\n39: \tsetne\t%al\n3c: \tje\t0x4b <evloop_do_on_socket_close+0x4b>\n3e: \tcmpq\t(%rip), %rsi  # 0x45 <evloop_do_on_socket_close+0x45>\n45: \tjne\t0x4b <evloop_do_on_socket_close+0x4b>\n47: \tmovl\t(%rbx), %edx\n49: \tjmp\t0x20 <evloop_do_on_socket_close+0x20>\n4b: \ttestb\t%al, %al\n4d: \tje\t0x62 <evloop_do_on_socket_close+0x62>\n4f: \tmovl\t(%rbx), %edx\n51: \tmovl\t$0, %edi\n56: \taddq\t$8, %rsp\n5a: \tpopq\t%rbx\n5b: \tpopq\t%r14\n5d: \tjmp\t0x62 <evloop_do_on_socket_close+0x62>\n62: \taddq\t$8, %rsp\n66: \tpopq\t%rbx\n67: \tpopq\t%r14\n69: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int fd; int _flags; scalar_t__ loop; } ;\nstruct st_h2o_evloop_epoll_t {int /*<<< orphan*/  ep; } ;\n\n/* Variables and functions */\nscalar_t__ EINTR ;\nint /*<<< orphan*/  EPOLL_CTL_DEL ;\nint H2O_SOCKET_FLAG__EPOLL_IS_REGISTERED ;\nint epoll_ctl (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ *) ;\nscalar_t__ errno ;\nint /*<<< orphan*/  h2o_error_printf (char*,scalar_t__,int) ;\n\n__attribute__((used)) static void evloop_do_on_socket_close(struct st_h2o_evloop_socket_t *sock)\n{\nstruct st_h2o_evloop_epoll_t *loop = (void *)sock->loop;\nint ret;\n\nif (sock->fd == -1)\nreturn;\nif ((sock->_flags & H2O_SOCKET_FLAG__EPOLL_IS_REGISTERED) == 0)\nreturn;\nwhile ((ret = epoll_ctl(loop->ep, EPOLL_CTL_DEL, sock->fd, NULL)) != 0 && errno == EINTR)\n;\nif (ret != 0)\nh2o_error_printf(\"socket_close: epoll(DEL) returned error %d (fd=%d)\\n\", errno, sock->fd);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  flags; TYPE_1__* ev; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_2__ evloop_socket ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EVLOOP_FLAG_ON_SOCKET_CLOSE ;\nint /*<<< orphan*/  EVLOOP_FLAG_ON_SOCKET_CLOSE_CALLBACK ;\nint /*<<< orphan*/  EVLOOP_FLAG_ON_SOCKET_CLOSE_CALLBACK_CALLED ;\nscalar_t__ EVLOOP_SOCKET_CLOSED ;\nint /*<<< orphan*/  EVLOOP_SOCKET_CLOSED_CALLBACK ;\nint /*<<< orphan*/  evloop_do_on_socket_close_callback (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  evloop_socket_close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  evloop_socket_close_callback (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  evloop_socket_close_callback_called (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void evloop_do_on_socket_close(evloop_socket *S) {\nif (S->fd == -1 || !(S->flags & EVLOOP_FLAG_ON_SOCKET_CLOSE)) {\nreturn;\n}\n\nwhile (evloop_socket_close_callback_called(S->ev->fd, EVLOOP_SOCKET_CLOSED_CALLBACK, S->fd) == 0) {\nif (evloop_socket_close(S->ev->fd) == EVLOOP_SOCKET_CLOSED) {\nS->flags |= EVLOOP_FLAG_ON_SOCKET_CLOSE_CALLBACK_CALLED;\nevloop_do_on_socket_close_callback(S->ev->fd, EVLOOP_SOCKET_CLOSED_CALLBACK, S->fd);\n}\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_create_socket",
    "input":"\n0000000000000000 <create_socket>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edx, %r14d\na: \tmovl\t%esi, %r15d\nd: \tmovq\t%rdi, %rbx\n10: \tmovl\t$48, %edi\n15: \tcallq\t0x1a <create_socket+0x1a>\n1a: \tmovq\t%rax, %rbp\n1d: \tmovq\t%rax, %rdi\n20: \txorl\t%esi, %esi\n22: \tmovl\t$48, %edx\n27: \tcallq\t0x2c <create_socket+0x2c>\n2c: \tleaq\t40(%rbp), %rdi\n30: \tmovl\t$0, %esi\n35: \tcallq\t0x3a <create_socket+0x3a>\n3a: \tmovq\t%rbx, 32(%rbp)\n3e: \tmovl\t%r15d, (%rbp)\n42: \tmovl\t%r14d, 4(%rbp)\n46: \tmovl\t24(%rbp), %eax\n49: \tmovl\t%eax, 28(%rbp)\n4c: \tmovq\t%rbp, 16(%rbp)\n50: \tmovq\t%rbp, 8(%rbp)\n54: \tmovq\t%rbp, %rdi\n57: \tcallq\t0x5c <create_socket+0x5c>\n5c: \tmovq\t%rbp, %rax\n5f: \taddq\t$8, %rsp\n63: \tpopq\t%rbx\n64: \tpopq\t%r14\n66: \tpopq\t%r15\n68: \tpopq\t%rbp\n69: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  smallbufs; int /*<<< orphan*/  bufs; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  input; } ;\nstruct st_h2o_evloop_socket_t {int fd; int _flags; struct st_h2o_evloop_socket_t* _next_statechanged; struct st_h2o_evloop_socket_t* _next_pending; TYPE_1__ _wreq; int /*<<< orphan*/ * loop; TYPE_2__ super; } ;\ntypedef  int /*<<< orphan*/  h2o_evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  evloop_do_on_socket_create (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  h2o_buffer_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nstruct st_h2o_evloop_socket_t* h2o_mem_alloc (int) ;\nint /*<<< orphan*/  h2o_socket_buffer_prototype ;\nint /*<<< orphan*/  memset (struct st_h2o_evloop_socket_t*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static struct st_h2o_evloop_socket_t *create_socket(h2o_evloop_t *loop, int fd, int flags)\n{\nstruct st_h2o_evloop_socket_t *sock;\n\nsock = h2o_mem_alloc(sizeof(*sock));\nmemset(sock, 0, sizeof(*sock));\nh2o_buffer_init(&sock->super.input, &h2o_socket_buffer_prototype);\nsock->loop = loop;\nsock->fd = fd;\nsock->_flags = flags;\nsock->_wreq.bufs = sock->_wreq.smallbufs;\nsock->_next_pending = sock;\nsock->_next_statechanged = sock;\n\nevloop_do_on_socket_create(sock);\n\nreturn sock;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  so_type; int /*<<< orphan*/  so_proto; int /*<<< orphan*/  so_domain; int /*<<< orphan*/  so_rcv; int /*<<< orphan*/  so_snd; int /*<<< orphan*/ * so_next; int /*<<< orphan*/ * so_head; int /*<<< orphan*/ * so_list; int /*<<< orphan*/ * so_qlen; int /*<<< orphan*/ * so_timeo; int /*<<< orphan*/ * so_error; int /*<<< orphan*/ * so_pcb; } ;\ntypedef  TYPE_1__* socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  bzero (TYPE_1__*,int) ;\nint /*<<< orphan*/  free (TYPE_1__*) ;\nTYPE_1__* malloc (int) ;\nint /*<<< orphan*/  strcpy (int /*<<< orphan*/ ,char*) ;\n\nsocket_t create_socket(int domain, int type, int protocol) {\nsocket_t so = malloc(sizeof(socket_t));\nbzero(so, sizeof(socket_t));\nso->so_domain = domain;\nso->so_type = type;\nso->so_proto = protocol;\nso->so_timeo = &so->so_rcv;\nso->so_error = &so->so_snd;\nso->so_qlen = &so->so_rcv;\nso->so_pcb = &so->so_snd;\nstrcpy(so->so_list, \"so_list\");\nreturn so;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_erase_ref",
    "input":"\n0000000000000000 <erase_ref>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edx, %ebp\n9: \tmovl\t%esi, %r15d\nc: \tmovq\t%rdi, %r14\nf: \tmovl\t4(%rdi), %edi\n12: \tcallq\t0x17 <erase_ref+0x17>\n17: \tmovq\t%rax, %rbx\n1a: \ttestl\t%ebp, %ebp\n1c: \tjne\t0x2d <erase_ref+0x2d>\n1e: \tmovl\t4(%r14), %esi\n22: \tmovq\t%r14, %rdi\n25: \tmovl\t%r15d, %edx\n28: \tcallq\t0x2d <erase_ref+0x2d>\n2d: \tleaq\t12(%rbx), %rdi\n31: \tcallq\t0x36 <erase_ref+0x36>\n36: \tmovq\t%rbx, %rdi\n39: \taddq\t$8, %rdi\n3d: \tcallq\t0x42 <erase_ref+0x42>\n42: \tmovl\t(%rbx), %eax\n44: \tsubl\t%eax, (%r14)\n47: \tmovq\t%r14, %rdi\n4a: \tmovq\t%rbx, %rsi\n4d: \taddq\t$8, %rsp\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tpopq\t%r15\n56: \tpopq\t%rbp\n57: \tjmp\t0x5c <erase_ref+0x5c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  khiter_t ;\nstruct TYPE_10__ {int /*<<< orphan*/  size; int /*<<< orphan*/  table; } ;\ntypedef  TYPE_2__ h2o_cache_t ;\nstruct TYPE_9__ {scalar_t__ len; } ;\nstruct TYPE_11__ {TYPE_1__ value; int /*<<< orphan*/  _age_link; int /*<<< orphan*/  _lru_link; } ;\ntypedef  TYPE_3__ h2o_cache_ref_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_cache_release (TYPE_2__*,TYPE_3__*) ;\nint /*<<< orphan*/  h2o_linklist_unlink (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  kh_del (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_3__* kh_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void erase_ref(h2o_cache_t *cache, khiter_t iter, int reuse)\n{\nh2o_cache_ref_t *ref = kh_key(cache->table, iter);\n\nif (!reuse)\nkh_del(cache, cache->table, iter);\nh2o_linklist_unlink(&ref->_lru_link);\nh2o_linklist_unlink(&ref->_age_link);\ncache->size -= ref->value.len;\n\nh2o_cache_release(cache, ref);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  refs; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  refs; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  refs; } ;\ntypedef  TYPE_1__ fz_document ;\ntypedef  TYPE_2__ fz_page ;\ntypedef  TYPE_3__ fz_annot ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_free (TYPE_1__*,TYPE_3__*) ;\nint /*<<< orphan*/  fz_free_annot (TYPE_1__*,TYPE_3__*) ;\nint /*<<< orphan*/  fz_free_page (TYPE_1__*,TYPE_2__*) ;\nTYPE_3__* fz_keep_annot (TYPE_1__*,int /*<<< orphan*/ ) ;\nTYPE_2__* fz_keep_page (TYPE_1__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nerase_ref(fz_document *doc, int page_num, int annot_num)\n{\nfz_annot *annot = fz_keep_annot(doc, doc->refs[page_num]);\nif (annot_num)\n{\nfz_page *page = fz_keep_page(doc, doc->refs[page_num]);\nfz_free_annot(doc, annot);\nfz_free_page(doc, page);\n}\nfz_free(doc, annot);\ndoc->refs[page_num]--;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ebpf_init_key_raw",
    "input":"\n0000000000000000 <h2o_socket_ebpf_init_key_raw>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <h2o_socket_ebpf_init_key_raw+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_ebpf_map_key_t {int dummy; } ;\nstruct sockaddr {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_fatal (char*) ;\n\nint h2o_socket_ebpf_init_key_raw(struct st_h2o_ebpf_map_key_t *key, int sock_type, struct sockaddr *local, struct sockaddr *remote)\n{\nh2o_fatal(\"unimplemented\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_ebpf_key_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\n\nvoid h2o_socket_ebpf_init_key_raw(h2o_socket_ebpf_key_t *key, int len)\n{\nmemset(key, 0, len);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_multithread_create_queue",
    "input":"\n0000000000000000 <h2o_multithread_create_queue>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t$16, %edi\nc: \tcallq\t0x11 <h2o_multithread_create_queue+0x11>\n11: \tmovq\t%rax, %rbx\n14: \tmovq\t%rax, %rdi\n17: \txorl\t%esi, %esi\n19: \tmovl\t$16, %edx\n1e: \tcallq\t0x23 <h2o_multithread_create_queue+0x23>\n23: \tmovq\t%rbx, %rdi\n26: \tmovq\t%r14, %rsi\n29: \tcallq\t0x2e <h2o_multithread_create_queue+0x2e>\n2e: \tleaq\t8(%rbx), %rdi\n32: \txorl\t%esi, %esi\n34: \tcallq\t0x39 <h2o_multithread_create_queue+0x39>\n39: \tleaq\t4(%rbx), %rdi\n3d: \tcallq\t0x42 <h2o_multithread_create_queue+0x42>\n42: \tmovq\t%rbx, %rdi\n45: \tcallq\t0x4a <h2o_multithread_create_queue+0x4a>\n4a: \tmovq\t%rbx, %rax\n4d: \taddq\t$8, %rsp\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uv_async_cb ;\nstruct TYPE_7__ {int /*<<< orphan*/  inactive; int /*<<< orphan*/  active; } ;\nstruct TYPE_8__ {TYPE_1__ receivers; int /*<<< orphan*/  mutex; int /*<<< orphan*/  async; } ;\ntypedef  TYPE_2__ h2o_multithread_queue_t ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_init_anchor (int /*<<< orphan*/ *) ;\nTYPE_2__* h2o_mem_alloc (int) ;\nint /*<<< orphan*/  init_async (TYPE_2__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memset (TYPE_2__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  pthread_mutex_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nscalar_t__ queue_cb ;\nint /*<<< orphan*/  uv_async_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nh2o_multithread_queue_t *h2o_multithread_create_queue(h2o_loop_t *loop)\n{\nh2o_multithread_queue_t *queue = h2o_mem_alloc(sizeof(*queue));\nmemset(queue, 0, sizeof(*queue));\n\n#if H2O_USE_LIBUV\nuv_async_init(loop, &queue->async, (uv_async_cb)queue_cb);\n#else\ninit_async(queue, loop);\n#endif\npthread_mutex_init(&queue->mutex, NULL);\nh2o_linklist_init_anchor(&queue->receivers.active);\nh2o_linklist_init_anchor(&queue->receivers.inactive);\n\nreturn queue;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  cond; int /*<<< orphan*/  mutex; int /*<<< orphan*/  queue; } ;\ntypedef  TYPE_1__ h2o_multithread_queue_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_linklist_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mutex_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_sem_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nTYPE_1__* malloc (int) ;\n\nh2o_multithread_queue_t *h2o_multithread_create_queue(size_t capacity)\n{\nh2o_multithread_queue_t *q = malloc(sizeof(*q));\nmemset(q, 0, sizeof(*q));\nh2o_linklist_init(&q->queue);\nh2o_mutex_init(&q->mutex);\nh2o_sem_init(&q->cond, 0);\nreturn q;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_set_picotls_context",
    "input":"\n0000000000000000 <h2o_socket_ssl_set_picotls_context>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <h2o_socket_ssl_set_picotls_context+0x11>\n11: \tmovq\t%rbx, %rdi\n14: \tmovl\t%eax, %esi\n16: \tmovq\t%r14, %rdx\n19: \taddq\t$8, %rsp\n1d: \tpopq\t%rbx\n1e: \tpopq\t%r14\n20: \tjmp\t0x25 <h2o_socket_ssl_set_picotls_context+0x25>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ptls_context_t ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_ex_data (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  get_ptls_index () ;\n\nvoid h2o_socket_ssl_set_picotls_context(SSL_CTX *ossl, ptls_context_t *ptls)\n{\nSSL_CTX_set_ex_data(ossl, get_ptls_index(), ptls);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ptls_context_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_socket_get_fd (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_set_ssl_context (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\nvoid h2o_socket_ssl_set_picotls_context(h2o_socket_t *sock, ptls_context_t *ctx)\n{\nh2o_socket_set_ssl_context(sock, h2o_socket_get_fd(sock), ctx);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_socket_dont_read",
    "input":"\n0000000000000000 <h2o_socket_dont_read>:\n0: \tmovl\t(%rip), %eax  # 0x6 <h2o_socket_dont_read+0x6>\n6: \ttestl\t%esi, %esi\n8: \tje\t0xf <h2o_socket_dont_read+0xf>\na: \torl\t(%rdi), %eax\nc: \tmovl\t%eax, (%rdi)\ne: \tretq\nf: \tnotl\t%eax\n11: \tandl\t(%rdi), %eax\n13: \tmovl\t%eax, (%rdi)\n15: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  _flags; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_FLAG_DONT_READ ;\n\nvoid h2o_socket_dont_read(h2o_socket_t *_sock, int dont_read)\n{\nstruct st_h2o_evloop_socket_t *sock = (struct st_h2o_evloop_socket_t *)_sock;\n\nif (dont_read) {\nsock->_flags |= H2O_SOCKET_FLAG_DONT_READ;\n} else {\nsock->_flags &= ~H2O_SOCKET_FLAG_DONT_READ;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_socket_t {int flags; } ;\n\n/* Variables and functions */\nint H2O_SOCKET_FLAG_DONT_READ ;\n\nvoid h2o_socket_dont_read(struct st_h2o_socket_t *sock, int dont_read)\n{\nif (dont_read)\nsock->flags |= H2O_SOCKET_FLAG_DONT_READ;\nelse\nsock->flags &= ~H2O_SOCKET_FLAG_DONT_READ;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_calc_gmt_offset",
    "input":"\n0000000000000000 <calc_gmt_offset>:\n0: \tpushq\t%rbx\n1: \tsubq\t$32, %rsp\n5: \tmovq\t%rsi, %rbx\n8: \tmovl\t%edi, 4(%rsp)\nc: \tleaq\t4(%rsp), %rdi\n11: \tleaq\t8(%rsp), %rsi\n16: \tcallq\t0x1b <calc_gmt_offset+0x1b>\n1b: \tmovl\t(%rbx), %ecx\n1d: \tsubl\t8(%rsp), %ecx\n21: \tmovl\t4(%rbx), %eax\n24: \timull\t$60, %ecx, %ecx\n27: \tsubl\t12(%rsp), %eax\n2b: \taddl\t%ecx, %eax\n2d: \tmovq\t8(%rbx), %rcx\n31: \tmovq\t16(%rsp), %rdx\n36: \tcmpq\t%rdx, %rcx\n39: \tje\t0x58 <calc_gmt_offset+0x58>\n3b: \tmovq\t16(%rbx), %rsi\n3f: \tmovq\t24(%rsp), %rdi\n44: \tsubl\t%edx, %ecx\n46: \tmovl\t%esi, %edx\n48: \tsubl\t%edi, %edx\n4a: \tcmpq\t%rdi, %rsi\n4d: \tcmovel\t%ecx, %edx\n50: \timull\t$1440, %edx, %ecx  # imm = 0x5A0\n56: \taddl\t%ecx, %eax\n58: \taddq\t$32, %rsp\n5c: \tpopq\t%rbx\n5d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  time_t ;\nstruct tm {int tm_hour; int tm_min; scalar_t__ tm_yday; scalar_t__ tm_year; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  gmtime_r (int /*<<< orphan*/ *,struct tm*) ;\n\n__attribute__((used)) static int calc_gmt_offset(time_t t, struct tm *local)\n{\nstruct tm gmt;\nint delta;\n\ngmtime_r(&t, &gmt);\ndelta = (local->tm_hour - gmt.tm_hour) * 60 + (local->tm_min - gmt.tm_min);\n\nif (local->tm_yday != gmt.tm_yday) {\nint day_offset;\nif (local->tm_year == gmt.tm_year)\nday_offset = local->tm_yday - gmt.tm_yday;\nelse\nday_offset = local->tm_year - gmt.tm_year;\ndelta += day_offset * 24 * 60;\n}\nreturn delta;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int tm_hour; int tm_min; scalar_t__ tm_sec; } ;\ntypedef  TYPE_1__ time_t ;\ntypedef  int /*<<< orphan*/  time_t_to_tm ;\n\n/* Variables and functions */\nint /*<<< orphan*/  localtime_r (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int calc_gmt_offset(time_t t, time_t *local_time)\n{\ntime_t_to_tm tm;\n\nlocaltime_r(&t, &tm);\nreturn (tm.tm_hour * 60 + tm.tm_min) * 60 + tm.tm_sec -\n(local_time->tm_hour * 60 + local_time->tm_min) * 60 -\n(local_time->tm_sec - local_time->tm_sec);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonserverutil.c_h2o_numproc",
    "input":"\n0000000000000000 <h2o_numproc>:\n0: \tmovl\t$1, %eax\n5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ncpu ;\ntypedef  int /*<<< orphan*/  name ;\n\n/* Variables and functions */\nint CTL_HW ;\nint HW_AVAILCPU ;\nint /*<<< orphan*/  _SC_NPROCESSORS_ONLN ;\nint /*<<< orphan*/  h2o_error_printf (char*) ;\nint /*<<< orphan*/  sysconf (int /*<<< orphan*/ ) ;\nscalar_t__ sysctl (int*,int,int*,size_t*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nsize_t h2o_numproc(void)\n{\n#if defined(_SC_NPROCESSORS_ONLN)\nreturn (size_t)sysconf(_SC_NPROCESSORS_ONLN);\n#elif defined(CTL_HW) && defined(HW_AVAILCPU)\nint name[] = {CTL_HW, HW_AVAILCPU};\nint ncpu;\nsize_t ncpu_sz = sizeof(ncpu);\nif (sysctl(name, sizeof(name) / sizeof(name[0]), &ncpu, &ncpu_sz, NULL, 0) != 0 || sizeof(ncpu) != ncpu_sz) {\nh2o_error_printf(\"[ERROR] failed to obtain number of CPU cores, assuming as one\\n\");\nncpu = 1;\n}\nreturn ncpu;\n#else\nreturn 1;\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nint h2o_numproc(void)\n{\nreturn 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_strtosize",
    "input":"\n0000000000000000 <h2o_strtosize>:\n0: \ttestq\t%rsi, %rsi\n3: \tje\t0x39 <h2o_strtosize+0x39>\n5: \tmovl\t$1, %ecx\na: \txorl\t%r8d, %r8d\nd: \tnopl\t(%rax)\n10: \tmovzbl\t-1(%rdi,%rsi), %edx\n15: \tleal\t-48(%rdx), %eax\n18: \tcmpb\t$9, %al\n1a: \tja\t0x39 <h2o_strtosize+0x39>\n1c: \taddl\t$-48, %edx\n1f: \timull\t%ecx, %edx\n22: \taddl\t%edx, %r8d\n25: \taddl\t%ecx, %ecx\n27: \tleal\t(%rcx,%rcx,4), %ecx\n2a: \taddq\t$-1, %rsi\n2e: \tjne\t0x10 <h2o_strtosize+0x10>\n30: \tcmpl\t(%rip), %r8d  # 0x37 <h2o_strtosize+0x37>\n37: \tjl\t0x40 <h2o_strtosize+0x40>\n39: \tmovl\t(%rip), %r8d  # 0x40 <h2o_strtosize+0x40>\n40: \tmovslq\t%r8d, %rax\n43: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint64_t ;\n\n/* Variables and functions */\nint SIZE_MAX ;\n\nsize_t h2o_strtosize(const char *s, size_t len)\n{\nuint64_t v = 0, m = 1;\nconst char *p = s + len;\n\nif (len == 0)\ngoto Error;\n\nwhile (1) {\nint ch = *--p;\nif (!('0' <= ch && ch <= '9'))\ngoto Error;\nv += (ch - '0') * m;\nif (p == s)\nbreak;\nm *= 10;\n/* do not even try to overflow */\nif (m == 10000000000000000000ULL)\ngoto Error;\n}\n\nif (v >= SIZE_MAX)\ngoto Error;\nreturn v;\n\nError:\nreturn SIZE_MAX;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SIZE_MAX ;\n\n__attribute__((used)) static size_t h2o_strtosize(const char *s, size_t len)\n{\nsize_t ret = 0;\n\nif (len == 0)\nreturn SIZE_MAX;\n\nwhile (len-- != 0) {\nint c = *s++ - '0';\nif (c < 0 || c > 9)\nreturn SIZE_MAX;\nret = ret * 10 + c;\n}\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_barrier_init",
    "input":"\n0000000000000000 <h2o_barrier_init>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \taddq\t$20, %rdi\ne: \txorl\t%esi, %esi\n10: \tcallq\t0x15 <h2o_barrier_init+0x15>\n15: \tleaq\t16(%rbx), %rdi\n19: \txorl\t%esi, %esi\n1b: \tcallq\t0x20 <h2o_barrier_init+0x20>\n20: \tmovq\t%r14, (%rbx)\n23: \tmovq\t%r14, 8(%rbx)\n27: \taddq\t$8, %rsp\n2b: \tpopq\t%rbx\n2c: \tpopq\t%r14\n2e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t _count; size_t _out_of_wait; int /*<<< orphan*/  _cond; int /*<<< orphan*/  _mutex; } ;\ntypedef  TYPE_1__ h2o_barrier_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nvoid h2o_barrier_init(h2o_barrier_t *barrier, size_t count)\n{\npthread_mutex_init(&barrier->_mutex, NULL);\npthread_cond_init(&barrier->_cond, NULL);\nbarrier->_count = count;\nbarrier->_out_of_wait = count;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ num_threads; scalar_t__ num_threads_done; int /*<<< orphan*/ * mutexes; int /*<<< orphan*/ * conds; } ;\ntypedef  TYPE_1__ h2o_barrier_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nvoid h2o_barrier_init(h2o_barrier_t *barrier, size_t num_threads)\n{\npthread_mutex_init(&barrier->mutexes[0], NULL);\npthread_cond_init(&barrier->conds[0], NULL);\nbarrier->num_threads = barrier->num_threads_done = num_threads;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonurl.c_decode_hex",
    "input":"\n0000000000000000 <decode_hex>:\n0: \tleal\t-48(%rdi), %eax\n3: \tcmpl\t$10, %eax\n6: \tjb\t0x27 <decode_hex+0x27>\n8: \tleal\t-65(%rdi), %eax\nb: \tcmpl\t$5, %eax\ne: \tja\t0x16 <decode_hex+0x16>\n10: \taddl\t$-55, %edi\n13: \tmovl\t%edi, %eax\n15: \tretq\n16: \tleal\t-97(%rdi), %eax\n19: \taddl\t$-87, %edi\n1c: \tcmpl\t$6, %eax\n1f: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n24: \tcmovbl\t%edi, %eax\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int decode_hex(int ch)\n{\nif ('0' <= ch && ch <= '9')\nreturn ch - '0';\nif ('A' <= ch && ch <= 'F')\nreturn ch - 'A' + 0xa;\nif ('a' <= ch && ch <= 'f')\nreturn ch - 'a' + 0xa;\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int decode_hex(int c)\n{\nif (c >= '0' && c <= '9')\nreturn c - '0';\nif (c >= 'A' && c <= 'F')\nreturn c - 'A' + 10;\nif (c >= 'a' && c <= 'f')\nreturn c - 'a' + 10;\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ebpf_init_key",
    "input":"\n0000000000000000 <h2o_socket_ebpf_init_key>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <h2o_socket_ebpf_init_key+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_ebpf_map_key_t {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_fatal (char*) ;\n\nint h2o_socket_ebpf_init_key(struct st_h2o_ebpf_map_key_t *key, void *sock)\n{\nh2o_fatal(\"unimplemented\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ebpf_init_key ;\nint /*<<< orphan*/  ebpf_init_key_len ;\nint /*<<< orphan*/  ebpf_init_key_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var ;\nint /*<<< orphan*/  ebpf_init_key_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_var_len_var ;\nint /*<<< orphan*/  ebpf_init_key_var_var_var_var_var_var_var_var_var_var_var_var_var_var"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_set_session_cache",
    "input":"\n0000000000000000 <h2o_socket_ssl_set_session_cache>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <h2o_socket_ssl_set_session_cache+0x11>\n11: \tmovq\t%rbx, %rdi\n14: \tmovl\t%eax, %esi\n16: \tmovq\t%r14, %rdx\n19: \taddq\t$8, %rsp\n1d: \tpopq\t%rbx\n1e: \tpopq\t%r14\n20: \tjmp\t0x25 <h2o_socket_ssl_set_session_cache+0x25>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_cache_t ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_ex_data (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  get_ssl_session_cache_index () ;\n\nvoid h2o_socket_ssl_set_session_cache(SSL_CTX *ctx, h2o_cache_t *cache)\n{\nSSL_CTX_set_ex_data(ctx, get_ssl_session_cache_index(), cache);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_ssl_session_cache_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_socket_get_ssl (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_ssl_set_session_cache (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\nvoid h2o_socket_ssl_set_session_cache(h2o_socket_t *sock, h2o_ssl_session_cache_t *cache)\n{\nh2o_ssl_set_session_cache(h2o_socket_get_ssl(sock), cache, cache);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ssl_cipher_bits",
    "input":"\n0000000000000000 <h2o_socket_get_ssl_cipher_bits>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rdi), %rax\n4: \txorl\t%ebx, %ebx\n6: \ttestq\t%rax, %rax\n9: \tje\t0x35 <h2o_socket_get_ssl_cipher_bits+0x35>\nb: \tmovq\t8(%rax), %rdi\nf: \ttestq\t%rdi, %rdi\n12: \tje\t0x25 <h2o_socket_get_ssl_cipher_bits+0x25>\n14: \tcallq\t0x19 <h2o_socket_get_ssl_cipher_bits+0x19>\n19: \ttestq\t%rax, %rax\n1c: \tje\t0x35 <h2o_socket_get_ssl_cipher_bits+0x35>\n1e: \tmovq\t(%rax), %rax\n21: \tmovl\t(%rax), %ebx\n23: \tjmp\t0x35 <h2o_socket_get_ssl_cipher_bits+0x35>\n25: \tmovq\t(%rax), %rdi\n28: \ttestq\t%rdi, %rdi\n2b: \tje\t0x35 <h2o_socket_get_ssl_cipher_bits+0x35>\n2d: \txorl\t%esi, %esi\n2f: \tpopq\t%rbx\n30: \tjmp\t0x35 <h2o_socket_get_ssl_cipher_bits+0x35>\n35: \tmovl\t%ebx, %eax\n37: \tpopq\t%rbx\n38: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {TYPE_1__* aead; } ;\ntypedef  TYPE_3__ ptls_cipher_suite_t ;\nstruct TYPE_10__ {TYPE_2__* ssl; } ;\ntypedef  TYPE_4__ h2o_socket_t ;\nstruct TYPE_8__ {int /*<<< orphan*/ * ossl; int /*<<< orphan*/ * ptls; } ;\nstruct TYPE_7__ {scalar_t__ key_size; } ;\n\n/* Variables and functions */\nint SSL_get_cipher_bits (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nTYPE_3__* ptls_get_cipher (int /*<<< orphan*/ *) ;\n\nint h2o_socket_get_ssl_cipher_bits(h2o_socket_t *sock)\n{\nif (sock->ssl != NULL) {\nif (sock->ssl->ptls != NULL) {\nptls_cipher_suite_t *cipher = ptls_get_cipher(sock->ssl->ptls);\nif (cipher == NULL)\nreturn 0;\nreturn (int)cipher->aead->key_size;\n} else if (sock->ssl->ossl != NULL) {\nreturn SSL_get_cipher_bits(sock->ssl->ossl, NULL);\n}\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* ssl; } ;\nstruct TYPE_4__ {int* cipher_bits; int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_get_current_cipher (int /*<<< orphan*/ *) ;\nint SSL_CIPHER_get_bits (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nint h2o_socket_get_ssl_cipher_bits(h2o_socket_t *sock)\n{\nif (sock->ssl == NULL)\nreturn 0;\nif (sock->ssl->ssl != NULL)\nreturn SSL_CIPHER_get_bits(SSL_get_current_cipher(sock->ssl->ssl), 0);\nreturn sock->ssl->cipher_bits[0];\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_get_session_cache",
    "input":"\n0000000000000000 <h2o_socket_ssl_get_session_cache>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <h2o_socket_ssl_get_session_cache+0xb>\nb: \tmovq\t%rbx, %rdi\ne: \tmovl\t%eax, %esi\n10: \tpopq\t%rbx\n11: \tjmp\t0x16 <h2o_socket_ssl_get_session_cache+0x16>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_cache_t ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nscalar_t__ SSL_CTX_get_ex_data (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  get_ssl_session_cache_index () ;\n\nh2o_cache_t *h2o_socket_ssl_get_session_cache(SSL_CTX *ctx)\n{\nreturn (h2o_cache_t *)SSL_CTX_get_ex_data(ctx, get_ssl_session_cache_index());\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_ssl_t ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_get_session_cache_mode (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * SSL_CTX_get_session_cache_mode_int (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static SSL_CTX *h2o_socket_ssl_get_session_cache(h2o_socket_ssl_t *sock)\n{\nreturn SSL_CTX_get_session_cache_mode_int(sock->ssl, SSL_CTX_get_session_cache_mode(sock->ssl));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhostinfo.c_dispatch_hostinfo_getaddr",
    "input":"\n0000000000000000 <dispatch_hostinfo_getaddr>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t$0, %edi\n9: \tcallq\t0xe <dispatch_hostinfo_getaddr+0xe>\ne: \tmovl\t$0, %edi\n13: \tmovq\t%rbx, %rsi\n16: \tcallq\t0x1b <dispatch_hostinfo_getaddr+0x1b>\n1b: \tcmpq\t$0, (%rip)    # 0x23 <dispatch_hostinfo_getaddr+0x23>\n23: \tjne\t0x3c <dispatch_hostinfo_getaddr+0x3c>\n25: \tmovq\t(%rip), %rax  # 0x2c <dispatch_hostinfo_getaddr+0x2c>\n2c: \tcmpq\t(%rip), %rax  # 0x33 <dispatch_hostinfo_getaddr+0x33>\n33: \tjge\t0x3c <dispatch_hostinfo_getaddr+0x3c>\n35: \txorl\t%eax, %eax\n37: \tcallq\t0x3c <dispatch_hostinfo_getaddr+0x3c>\n3c: \tmovl\t$0, %edi\n41: \tcallq\t0x46 <dispatch_hostinfo_getaddr+0x46>\n46: \tmovl\t$0, %edi\n4b: \tpopq\t%rbx\n4c: \tjmp\t0x51 <dispatch_hostinfo_getaddr+0x51>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  _pending; } ;\ntypedef  TYPE_1__ h2o_hostinfo_getaddr_req_t ;\nstruct TYPE_5__ {scalar_t__ num_threads_idle; scalar_t__ num_threads; int /*<<< orphan*/  mutex; int /*<<< orphan*/  cond; int /*<<< orphan*/  pending; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  create_lookup_thread () ;\nscalar_t__ h2o_hostinfo_max_threads ;\nint /*<<< orphan*/  h2o_linklist_insert (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_cond_signal (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\nTYPE_2__ queue ;\n\n__attribute__((used)) static void dispatch_hostinfo_getaddr(h2o_hostinfo_getaddr_req_t *req)\n{\npthread_mutex_lock(&queue.mutex);\n\nh2o_linklist_insert(&queue.pending, &req->_pending);\n\nif (queue.num_threads_idle == 0 && queue.num_threads < h2o_hostinfo_max_threads)\ncreate_lookup_thread();\n\npthread_cond_signal(&queue.cond);\npthread_mutex_unlock(&queue.mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  dispatch_hostinfo_getaddr_impl (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_module_close (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_module_error () ;\nint /*<<< orphan*/  g_module_symbol (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  g_module_symbol_error () ;\nscalar_t__ g_module_symbol_refcount (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * hostinfo_module ;\nscalar_t__ hostinfo_module_refcount ;\n\n__attribute__((used)) static void\ndispatch_hostinfo_getaddr(GModule * module)\n{\ng_module_symbol(module, \"hostinfo_getaddr\");\nif (g_module_symbol_refcount(module) < hostinfo_module_refcount)\n{\ng_module_close(hostinfo_module);\n}\ng_module_symbol(module, \"hostinfo_getaddr\");\nif (g_module_symbol_refcount(module) < hostinfo_module_refcount)\n{\ng_module_close(hostinfo_module);\n}\ndispatch_hostinfo_getaddr_impl(module, hostinfo_module);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhostinfo.c_fetch_aton_digit",
    "input":"\n0000000000000000 <fetch_aton_digit>:\n0: \txorl\t%r8d, %r8d\n3: \tcmpq\t%rsi, %rdi\n6: \tje\t0x47 <fetch_aton_digit+0x47>\n8: \tmovq\t%rsi, %r9\nb: \tsubq\t%rdi, %r9\ne: \txorl\t%r10d, %r10d\n11: \tnopw\t%cs:(%rax,%rax)\n1b: \tnopl\t(%rax,%rax)\n20: \tmovzbl\t(%rdi,%r10), %eax\n25: \tleal\t-48(%rax), %ecx\n28: \tcmpb\t$9, %cl\n2b: \tja\t0x4a <fetch_aton_digit+0x4a>\n2d: \tleal\t(%r8,%r8,4), %ecx\n31: \tleal\t(%rax,%rcx,2), %r8d\n35: \taddl\t$-48, %r8d\n39: \taddq\t$1, %r10\n3d: \tcmpq\t%r10, %r9\n40: \tjne\t0x20 <fetch_aton_digit+0x20>\n42: \tmovq\t%r9, %r10\n45: \tjmp\t0x50 <fetch_aton_digit+0x50>\n47: \txorl\t%eax, %eax\n49: \tretq\n4a: \taddq\t%r10, %rdi\n4d: \tmovq\t%rdi, %rsi\n50: \taddq\t$-1, %r10\n54: \txorl\t%eax, %eax\n56: \tcmpq\t$2, %r10\n5a: \tja\t0x6b <fetch_aton_digit+0x6b>\n5c: \tcmpl\t$255, %r8d\n63: \tjg\t0x6b <fetch_aton_digit+0x6b>\n65: \tmovb\t%r8b, (%rdx)\n68: \tmovq\t%rsi, %rax\n6b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static const char *fetch_aton_digit(const char *p, const char *end, unsigned char *value)\n{\nsize_t ndigits = 0;\nint v = 0;\n\nwhile (p != end && ('0' <= *p && *p <= '9')) {\nv = v * 10 + *p++ - '0';\n++ndigits;\n}\nif (!(1 <= ndigits && ndigits <= 3))\nreturn NULL;\nif (v > 255)\nreturn NULL;\n*value = (unsigned char)v;\nreturn p;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static const char *\nfetch_aton_digit(const char *p, const char *end, char *dst)\n{\nint\t\t\tval = 0;\n\nwhile (p < end && *p >= '0' && *p <= '9')\n{\nval *= 10;\nval += *p - '0';\np++;\n}\n\nif (p == end)\nreturn NULL;\n\n*dst = val;\nreturn p;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_on_async_resumption_new",
    "input":"\n0000000000000000 <on_async_resumption_new>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tsubq\t$24, %rsp\na: \tmovq\t%rsi, %rbx\nd: \tcallq\t0x12 <on_async_resumption_new+0x12>\n12: \tmovl\t%eax, %edi\n14: \tcallq\t0x19 <on_async_resumption_new+0x19>\n19: \tmovq\t%rax, %r14\n1c: \tmovq\t%rbx, %rdi\n1f: \txorl\t%esi, %esi\n21: \tcallq\t0x26 <on_async_resumption_new+0x26>\n26: \tmovl\t%eax, %r15d\n29: \tmovl\t%eax, %edi\n2b: \tcallq\t0x30 <on_async_resumption_new+0x30>\n30: \tmovq\t%rax, %rbp\n33: \tmovq\t%rax, 16(%rsp)\n38: \tleaq\t16(%rsp), %rsi\n3d: \tmovq\t%rbx, %rdi\n40: \tcallq\t0x45 <on_async_resumption_new+0x45>\n45: \tleaq\t12(%rsp), %rsi\n4a: \tmovq\t%rbx, %rdi\n4d: \tcallq\t0x52 <on_async_resumption_new+0x52>\n52: \tmovl\t12(%rsp), %esi\n56: \tmovq\t%rax, %rdi\n59: \tcallq\t0x5e <on_async_resumption_new+0x5e>\n5e: \tmovq\t%r14, %rdi\n61: \tmovl\t%eax, %esi\n63: \tmovq\t%rbp, %rdx\n66: \tmovl\t%r15d, %ecx\n69: \tcallq\t0x6e <on_async_resumption_new+0x6e>\n6e: \txorl\t%eax, %eax\n70: \taddq\t$24, %rsp\n74: \tpopq\t%rbx\n75: \tpopq\t%r14\n77: \tpopq\t%r15\n79: \tpopq\t%rbp\n7a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\nstruct TYPE_3__ {scalar_t__ base; int /*<<< orphan*/  len; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * BIO_get_data (int /*<<< orphan*/ ) ;\nunsigned char* SSL_SESSION_get_id (int /*<<< orphan*/ *,unsigned int*) ;\nint /*<<< orphan*/  SSL_get_rbio (int /*<<< orphan*/ *) ;\nscalar_t__ alloca (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_iovec_init (unsigned char const*,unsigned int) ;\nint /*<<< orphan*/  i2d_SSL_SESSION (int /*<<< orphan*/ *,unsigned char**) ;\nint /*<<< orphan*/  resumption_new (int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_1__) ;\n\n__attribute__((used)) static int on_async_resumption_new(SSL *ssl, SSL_SESSION *session)\n{\nh2o_socket_t *sock = BIO_get_data(SSL_get_rbio(ssl));\n\nh2o_iovec_t data;\nconst unsigned char *id;\nunsigned id_len;\nunsigned char *p;\n\n/* build data */\ndata.len = i2d_SSL_SESSION(session, NULL);\ndata.base = alloca(data.len);\np = (void *)data.base;\ni2d_SSL_SESSION(session, &p);\n\nid = SSL_SESSION_get_id(session, &id_len);\nresumption_new(sock, h2o_iovec_init(id, id_len), data);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_SESSION_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * SSL_get_session (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_get_session_id_context (int /*<<< orphan*/ *,unsigned char*) ;\nint /*<<< orphan*/  SSL_get_session_id_context_length (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_SESSION_set_id_context (int /*<<< orphan*/ *,unsigned char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_SESSION_set_time (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_SESSION_up_ref (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memcpy (unsigned char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int on_async_resumption_new(SSL *ssl, SSL_SESSION *session)\n{\nunsigned char sid_ctx[20];\nint sid_ctx_len;\n\nSSL_SESSION_up_ref(session);\n\nsid_ctx_len = SSL_get_session_id_context(ssl, sid_ctx, sizeof(sid_ctx));\nSSL_SESSION_set_id_context(session, sid_ctx, sid_ctx_len);\n\nSSL_SESSION_set_time(session, SSL_get_session_time(SSL_get_session(ssl)));\n\nSSL_SESSION_free(session);\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_on_alpn_select",
    "input":"\n0000000000000000 <on_alpn_select>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$40, %rsp\ne: \tmovl\t$0, %eax\n13: \tcmpq\t$0, (%r9)\n17: \tje\t0xe6 <on_alpn_select+0xe6>\n1d: \tmovq\t%rsi, 16(%rsp)\n22: \tmovq\t%rdx, 24(%rsp)\n27: \tmovl\t%r8d, %r15d\n2a: \tmovq\t%rcx, 32(%rsp)\n2f: \taddq\t%rcx, %r15\n32: \txorl\t%r12d, %r12d\n35: \tmovq\t%r9, %rbx\n38: \tmovq\t%r9, 8(%rsp)\n3d: \tmovl\t%r8d, 4(%rsp)\n42: \tjmp\t0x70 <on_alpn_select+0x70>\n44: \tnopw\t%cs:(%rax,%rax)\n4e: \tnop\n50: \taddq\t$1, %r12\n54: \tmovq\t%r12, %rax\n57: \tshlq\t$4, %rax\n5b: \tmovq\t8(%rsp), %r9\n60: \tleaq\t(%r9,%rax), %rbx\n64: \tcmpq\t$0, (%r9,%rax)\n69: \tmovl\t4(%rsp), %r8d\n6e: \tje\t0xe1 <on_alpn_select+0xe1>\n70: \ttestl\t%r8d, %r8d\n73: \tje\t0x50 <on_alpn_select+0x50>\n75: \tmovq\t%r12, %rax\n78: \tshlq\t$4, %rax\n7c: \tmovq\t8(%rsp), %rcx\n81: \tleaq\t(%rcx,%rax), %r13\n85: \taddq\t$8, %r13\n89: \tmovq\t32(%rsp), %rbp\n8e: \tjmp\t0x98 <on_alpn_select+0x98>\n90: \taddq\t%r14, %rbp\n93: \tcmpq\t%r15, %rbp\n96: \tje\t0x50 <on_alpn_select+0x50>\n98: \tmovzbl\t(%rbp), %r14d\n9d: \taddq\t$1, %rbp\na1: \tmovq\t%r15, %rax\na4: \tsubq\t%rbp, %rax\na7: \tcmpq\t%r14, %rax\naa: \tjb\t0xe1 <on_alpn_select+0xe1>\nac: \tcmpq\t%r14, (%rbx)\naf: \tjne\t0x90 <on_alpn_select+0x90>\nb1: \tmovq\t(%r13), %rsi\nb5: \tmovq\t%rbp, %rdi\nb8: \tmovq\t%r14, %rdx\nbb: \tcallq\t0xc0 <on_alpn_select+0xc0>\nc0: \ttestq\t%rax, %rax\nc3: \tjne\t0x90 <on_alpn_select+0x90>\nc5: \tmovq\t(%r13), %rax\nc9: \tmovq\t16(%rsp), %rcx\nce: \tmovq\t%rax, (%rcx)\nd1: \tmovb\t(%rbx), %al\nd3: \tmovq\t24(%rsp), %rcx\nd8: \tmovb\t%al, (%rcx)\nda: \tmovl\t$0, %eax\ndf: \tjmp\t0xe6 <on_alpn_select+0xe6>\ne1: \tmovl\t$0, %eax\ne6: \tmovl\t(%rax), %eax\ne8: \taddq\t$40, %rsp\nec: \tpopq\t%rbx\ned: \tpopq\t%r12\nef: \tpopq\t%r13\nf1: \tpopq\t%r14\nf3: \tpopq\t%r15\nf5: \tpopq\t%rbp\nf6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ len; scalar_t__ base; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint SSL_TLSEXT_ERR_NOACK ;\nint SSL_TLSEXT_ERR_OK ;\nscalar_t__ memcmp (unsigned char const*,scalar_t__,size_t) ;\n\n__attribute__((used)) static int on_alpn_select(SSL *ssl, const unsigned char **out, unsigned char *outlen, const unsigned char *_in, unsigned int inlen,\nvoid *_protocols)\n{\nconst h2o_iovec_t *protocols = _protocols;\nsize_t i;\n\nfor (i = 0; protocols[i].len != 0; ++i) {\nconst unsigned char *in = _in, *in_end = in + inlen;\nwhile (in != in_end) {\nsize_t cand_len = *in++;\nif (in_end - in < cand_len) {\n/* broken request */\nreturn SSL_TLSEXT_ERR_NOACK;\n}\nif (cand_len == protocols[i].len && memcmp(in, protocols[i].base, cand_len) == 0) {\ngoto Found;\n}\nin += cand_len;\n}\n}\n/* not found */\nreturn SSL_TLSEXT_ERR_NOACK;\n\nFound:\n*out = (const unsigned char *)protocols[i].base;\n*outlen = (unsigned char)protocols[i].len;\nreturn SSL_TLSEXT_ERR_OK;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_TLSEXT_ERR_NOACK ;\nint /*<<< orphan*/  SSL_TLSEXT_ERR_OK ;\nscalar_t__ strncmp (char const*,char const*,size_t) ;\n\n__attribute__((used)) static int on_alpn_select(SSL *ssl, const unsigned char **out,\nunsigned char *outlen, const unsigned char *in,\nunsigned int inlen, void *arg)\n{\nconst char *alpn_protos = arg;\nconst unsigned char *alpn_protos_len = (const unsigned char *)alpn_protos;\nconst unsigned char *alpn_protos_end = alpn_protos + strlen(alpn_protos);\nconst unsigned char *selected = NULL;\nunsigned int selected_len = 0;\nunsigned int i;\n\nfor (i = 0; i < inlen; i += in[i] + 1) {\nif (in[i] == 0) {\nselected = &in[i + 1];\nselected_len = in[i];\nbreak;\n}\n}\n\nif (selected == NULL)\nreturn SSL_TLSEXT_ERR_NOACK;\n\nfor (i = 0; alpn_protos[i] != '\\0'; i += strlen(alpn_protos + i) + 1) {\nif (strlen(alpn_protos + i) == selected_len\n&& strncmp(alpn_protos + i, (const char *)selected, selected_len) == 0) {\n*out = (const unsigned char *)alpn_protos + i;\n*outlen = (unsigned char)strlen(alpn_protos + i);\nreturn SSL_TLSEXT_ERR_OK;\n}\n}\n\nreturn SSL_TLSEXT_ERR_NOACK;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_decode_hex",
    "input":"\n0000000000000000 <decode_hex>:\n0: \tleal\t-48(%rdi), %eax\n3: \tcmpl\t$10, %eax\n6: \tjb\t0x27 <decode_hex+0x27>\n8: \tleal\t-65(%rdi), %eax\nb: \tcmpl\t$5, %eax\ne: \tja\t0x16 <decode_hex+0x16>\n10: \taddl\t$-55, %edi\n13: \tmovl\t%edi, %eax\n15: \tretq\n16: \tleal\t-97(%rdi), %eax\n19: \taddl\t$-87, %edi\n1c: \tcmpl\t$6, %eax\n1f: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n24: \tcmovbl\t%edi, %eax\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int decode_hex(int ch)\n{\nif ('0' <= ch && ch <= '9')\nreturn ch - '0';\nif ('A' <= ch && ch <= 'F')\nreturn ch - 'A' + 0xa;\nif ('a' <= ch && ch <= 'f')\nreturn ch - 'a' + 0xa;\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int decode_hex(int c)\n{\nif (c >= '0' && c <= '9')\nreturn c - '0';\nif (c >= 'A' && c <= 'F')\nreturn c - 'A' + 10;\nif (c >= 'a' && c <= 'f')\nreturn c - 'a' + 10;\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_get_filext",
    "input":"\n0000000000000000 <h2o_get_filext>:\n0: \tmovq\t%rdi, %rax\n3: \taddq\t%rsi, %rdi\n6: \taddq\t$1, %rdi\na: \taddq\t%rsi, %rax\nd: \taddq\t$-1, %rsi\n11: \tnopw\t%cs:(%rax,%rax)\n1b: \tnopl\t(%rax,%rax)\n20: \ttestq\t%rsi, %rsi\n23: \tje\t0x44 <h2o_get_filext+0x44>\n25: \tmovzbl\t-2(%rdi), %ecx\n29: \tcmpb\t$47, %cl\n2c: \tje\t0x44 <h2o_get_filext+0x44>\n2e: \taddq\t$-1, %rdi\n32: \taddq\t$-1, %rsi\n36: \tcmpb\t$46, %cl\n39: \tjne\t0x20 <h2o_get_filext+0x20>\n3b: \tsubl\t%edi, %eax\n3d: \tmovl\t%eax, %esi\n3f: \tjmp\t0x44 <h2o_get_filext+0x44>\n44: \txorl\t%edi, %edi\n46: \txorl\t%esi, %esi\n48: \tjmp\t0x4d <h2o_get_filext+0x4d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_iovec_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_iovec_init (char const*,int) ;\n\nh2o_iovec_t h2o_get_filext(const char *path, size_t len)\n{\nconst char *end = path + len, *p = end;\n\nwhile (--p != path) {\nif (*p == '.') {\nreturn h2o_iovec_init(p + 1, end - (p + 1));\n} else if (*p == '/') {\nbreak;\n}\n}\nreturn h2o_iovec_init(NULL, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* strrchr (char const*,int) ;\n\n__attribute__((used)) static inline char *h2o_get_filext(const char *path, size_t path_len)\n{\nconst char *p = path + path_len;\n\nwhile (p != path && *p != '/')\n--p;\nif (*p == '/')\nreturn NULL;\nreturn strrchr(p, '.');\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_dispose_export",
    "input":"\n0000000000000000 <h2o_socket_dispose_export>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%edi, %edi\n6: \tcmpl\t$-1, (%rbx)\n9: \tsetne\t%dil\nd: \tcallq\t0x12 <h2o_socket_dispose_export+0x12>\n12: \tmovq\t8(%rbx), %rdi\n16: \ttestq\t%rdi, %rdi\n19: \tje\t0x28 <h2o_socket_dispose_export+0x28>\n1b: \tcallq\t0x20 <h2o_socket_dispose_export+0x20>\n20: \tmovq\t$0, 8(%rbx)\n28: \tleaq\t4(%rbx), %rdi\n2c: \tcallq\t0x31 <h2o_socket_dispose_export+0x31>\n31: \tmovl\t(%rbx), %edi\n33: \tcallq\t0x38 <h2o_socket_dispose_export+0x38>\n38: \tmovl\t$4294967295, (%rbx)# imm = 0xFFFFFFFF\n3e: \tpopq\t%rbx\n3f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int fd; int /*<<< orphan*/  input; int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_1__ h2o_socket_export_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  close (int) ;\nint /*<<< orphan*/  destroy_ssl (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_buffer_dispose (int /*<<< orphan*/ *) ;\n\nvoid h2o_socket_dispose_export(h2o_socket_export_t *info)\n{\nassert(info->fd != -1);\nif (info->ssl != NULL) {\ndestroy_ssl(info->ssl);\ninfo->ssl = NULL;\n}\nh2o_buffer_dispose(&info->input);\nclose(info->fd);\ninfo->fd = -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int fd; int /*<<< orphan*/ * ssl_ctx; int /*<<< orphan*/  link; } ;\ntypedef  TYPE_1__ h2o_socket_export_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_link_dispose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_close (int) ;\n\nvoid h2o_socket_dispose_export(h2o_socket_export_t *info)\n{\nassert(info->fd != -1);\nif (info->ssl_ctx != NULL)\nfree(info->ssl_ctx);\nh2o_link_dispose(&info->link);\nh2o_socket_close(info->fd);\ninfo->fd = -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_timerwheel.c_lcg_rand",
    "input":"\n0000000000000000 <lcg_rand>:\n0: \timull\t$1103515245, (%rip), %eax # imm = 0x41C64E6D\n# 0xa <lcg_rand+0xa>\na: \taddl\t$12345, %eax  # imm = 0x3039\nf: \tandl\t(%rip), %eax  # 0x15 <lcg_rand+0x15>\n15: \tmovl\t%eax, (%rip)  # 0x1b <lcg_rand+0x1b>\n1b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint RAND_MAX ;\nint rseed ;\n\n__attribute__((used)) static inline int lcg_rand()\n{\nreturn rseed = (rseed * 1103515245 + 12345) & RAND_MAX;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint lcg_rand_state ;\n\n__attribute__((used)) static inline int lcg_rand(void)\n{\nlcg_rand_state = (lcg_rand_state * 1103515245 + 12345) & 0x7fffffff;\nreturn lcg_rand_state;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_getpeername",
    "input":"\n0000000000000000 <h2o_socket_getpeername>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovq\t(%rdi), %rsi\nd: \ttestq\t%rsi, %rsi\n10: \tje\t0x27 <h2o_socket_getpeername+0x27>\n12: \tmovl\t(%rsi), %edx\n14: \taddq\t$4, %rsi\n18: \tmovq\t%r14, %rdi\n1b: \tcallq\t0x20 <h2o_socket_getpeername+0x20>\n20: \tmovq\t(%rbx), %rax\n23: \tmovl\t(%rax), %ebp\n25: \tjmp\t0x41 <h2o_socket_getpeername+0x41>\n27: \tmovq\t%rbx, %rdi\n2a: \tmovq\t%r14, %rsi\n2d: \tcallq\t0x32 <h2o_socket_getpeername+0x32>\n32: \tmovl\t%eax, %ebp\n34: \tmovq\t%rbx, %rdi\n37: \tmovq\t%r14, %rsi\n3a: \tmovl\t%eax, %edx\n3c: \tcallq\t0x41 <h2o_socket_getpeername+0x41>\n41: \tmovl\t%ebp, %eax\n43: \tpopq\t%rbx\n44: \tpopq\t%r14\n46: \tpopq\t%rbp\n47: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr {int dummy; } ;\ntypedef  int /*<<< orphan*/  socklen_t ;\nstruct TYPE_7__ {TYPE_1__* _peername; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  len; int /*<<< orphan*/  addr; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  get_peername_uncached (TYPE_2__*,struct sockaddr*) ;\nint /*<<< orphan*/  h2o_socket_setpeername (TYPE_2__*,struct sockaddr*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memcpy (struct sockaddr*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nsocklen_t h2o_socket_getpeername(h2o_socket_t *sock, struct sockaddr *sa)\n{\n/* return cached, if exists */\nif (sock->_peername != NULL) {\nmemcpy(sa, &sock->_peername->addr, sock->_peername->len);\nreturn sock->_peername->len;\n}\n/* call, copy to cache, and return */\nsocklen_t len = get_peername_uncached(sock, sa);\nh2o_socket_setpeername(sock, sa, len);\nreturn len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr {int dummy; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  socklen; struct sockaddr* addr; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  getpeername (int /*<<< orphan*/ ,struct sockaddr*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memcpy (struct sockaddr*,struct sockaddr*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  set_peername (TYPE_1__*,struct sockaddr*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int h2o_socket_getpeername(h2o_socket_t *sock, struct sockaddr *addr)\n{\nif (sock->addr != NULL) {\nmemcpy(addr, sock->addr, sock->socklen);\nreturn sock->socklen;\n}\nint r = set_peername(sock, addr, sock->socklen);\nreturn set_peername(sock, addr, r);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_sem_init",
    "input":"\n0000000000000000 <h2o_sem_init>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \taddq\t$20, %rdi\ne: \txorl\t%esi, %esi\n10: \tcallq\t0x15 <h2o_sem_init+0x15>\n15: \tleaq\t16(%rbx), %rdi\n19: \txorl\t%esi, %esi\n1b: \tcallq\t0x20 <h2o_sem_init+0x20>\n20: \tmovq\t%r14, 8(%rbx)\n24: \tmovq\t%r14, (%rbx)\n27: \taddq\t$8, %rsp\n2b: \tpopq\t%rbx\n2c: \tpopq\t%r14\n2e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  void* ssize_t ;\nstruct TYPE_3__ {void* _capacity; void* _cur; int /*<<< orphan*/  _cond; int /*<<< orphan*/  _mutex; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_init(h2o_sem_t *sem, ssize_t capacity)\n{\npthread_mutex_init(&sem->_mutex, NULL);\npthread_cond_init(&sem->_cond, NULL);\nsem->_cur = capacity;\nsem->_capacity = capacity;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ count; scalar_t__ max; int /*<<< orphan*/  lock; int /*<<< orphan*/  cond; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_init(h2o_sem_t *sem, size_t max)\n{\npthread_mutex_init(&sem->lock, NULL);\npthread_cond_init(&sem->cond, NULL);\nsem->max = max;\nsem->count = 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_create_socket_set_nodelay",
    "input":"\n0000000000000000 <create_socket_set_nodelay>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovl\t%edx, %r14d\nb: \tmovl\t%esi, %ebp\nd: \tmovq\t%rdi, %rbx\n10: \tmovl\t$1, 12(%rsp)\n18: \tmovl\t(%rip), %esi  # 0x1e <create_socket_set_nodelay+0x1e>\n1e: \tmovl\t(%rip), %edx  # 0x24 <create_socket_set_nodelay+0x24>\n24: \tleaq\t12(%rsp), %rcx\n29: \tmovl\t%ebp, %edi\n2b: \tmovl\t$4, %r8d\n31: \tcallq\t0x36 <create_socket_set_nodelay+0x36>\n36: \tmovq\t%rbx, %rdi\n39: \tmovl\t%ebp, %esi\n3b: \tmovl\t%r14d, %edx\n3e: \tcallq\t0x43 <create_socket_set_nodelay+0x43>\n43: \taddq\t$16, %rsp\n47: \tpopq\t%rbx\n48: \tpopq\t%r14\n4a: \tpopq\t%rbp\n4b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int dummy; } ;\ntypedef  int /*<<< orphan*/  on ;\ntypedef  int /*<<< orphan*/  h2o_evloop_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  IPPROTO_TCP ;\nint /*<<< orphan*/  TCP_NODELAY ;\nstruct st_h2o_evloop_socket_t* create_socket (int /*<<< orphan*/ *,int,int) ;\nint /*<<< orphan*/  setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int) ;\n\n__attribute__((used)) static struct st_h2o_evloop_socket_t *create_socket_set_nodelay(h2o_evloop_t *loop, int fd, int flags)\n{\n/* ignore errors returned by setsockopt; fd is not restricted to TCP sockets (could be a unix-domain socket for example) */\nint on = 1;\nsetsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));\nreturn create_socket(loop, fd, flags);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SOCKET ;\ntypedef  int /*<<< orphan*/  BOOL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  IPPROTO_TCP ;\nint /*<<< orphan*/  SOL_SOCKET ;\nint /*<<< orphan*/  setsockopt (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int) ;\nint /*<<< orphan*/  tcp_nodelay ;\n\n__attribute__((used)) static void create_socket_set_nodelay(SOCKET sock, BOOL nodelay, BOOL ipv6)\n{\nsetsockopt(sock, SOL_SOCKET, IPPROTO_TCP, (char *)&nodelay, sizeof(nodelay));\nsetsockopt(sock, SOL_SOCKET, IPPROTO_TCP, (char *)&nodelay, sizeof(nodelay));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_on_dispose_ssl_ctx_session_cache",
    "input":"\n0000000000000000 <on_dispose_ssl_ctx_session_cache>:\n0: \ttestq\t%rsi, %rsi\n3: \tje\t0xd <on_dispose_ssl_ctx_session_cache+0xd>\n5: \tmovq\t%rsi, %rdi\n8: \tjmp\t0xd <on_dispose_ssl_ctx_session_cache+0xd>\nd: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_cache_t ;\ntypedef  int /*<<< orphan*/  CRYPTO_EX_DATA ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_cache_destroy (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_dispose_ssl_ctx_session_cache(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx, long argl, void *argp)\n{\nh2o_cache_t *ssl_session_cache = (h2o_cache_t *)ptr;\nif (ssl_session_cache != NULL)\nh2o_cache_destroy(ssl_session_cache);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_free (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_dispose_ssl_ctx_session_cache(void *data, void *session_cache)\n{\nSSL_CTX *ctx = (SSL_CTX *)session_cache;\n\nif (ctx)\nSSL_CTX_free(ctx);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhttpclient.c_do_cancel",
    "input":"\n0000000000000000 <do_cancel>:\n0: \tjmp\t0x5 <do_cancel+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_httpclient_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close_client (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void do_cancel(h2o_httpclient_t *_client)\n{\nh2o_httpclient_t *client = (void *)_client;\nclose_client(client);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  cancel_query () ;\n\nvoid\ndo_cancel(void)\n{\ncancel_query();\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontimerwheel.c_h2o_timerwheel_link_abs",
    "input":"\n0000000000000000 <h2o_timerwheel_link_abs>:\n0: \tmovq\t(%rdi), %rax\n3: \tcmpq\t%rdx, %rax\n6: \tcmovgeq\t%rax, %rdx\na: \tmovq\t%rdx, (%rsi)\nd: \tjmp\t0x12 <h2o_timerwheel_link_abs+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\nstruct TYPE_7__ {scalar_t__ last_run; } ;\ntypedef  TYPE_1__ h2o_timerwheel_t ;\nstruct TYPE_8__ {scalar_t__ expire_at; } ;\ntypedef  TYPE_2__ h2o_timerwheel_entry_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  link_timer (TYPE_1__*,TYPE_2__*) ;\n\nvoid h2o_timerwheel_link_abs(h2o_timerwheel_t *ctx, h2o_timerwheel_entry_t *entry, uint64_t at)\n{\nentry->expire_at = at < ctx->last_run ? ctx->last_run : at;\nlink_timer(ctx, entry);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ expiration; } ;\ntypedef  TYPE_1__ h2o_timer_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_timerwheel_link (TYPE_1__**,TYPE_1__*,scalar_t__) ;\n\nvoid h2o_timerwheel_link_abs(h2o_timer_t **slot, h2o_timer_t *entry, uint64_t expiration)\n{\nif (expiration > entry->expiration)\nentry->expiration = expiration;\nh2o_timerwheel_link(slot, entry, expiration);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_sem_post",
    "input":"\n0000000000000000 <h2o_sem_post>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <h2o_sem_post+0x9>\n9: \taddl\t$1, 8(%rbx)\nd: \tleaq\t4(%rbx), %rdi\n11: \tcallq\t0x16 <h2o_sem_post+0x16>\n16: \tmovq\t%rbx, %rdi\n19: \tpopq\t%rbx\n1a: \tjmp\t0x1f <h2o_sem_post+0x1f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  _mutex; int /*<<< orphan*/  _cond; int /*<<< orphan*/  _cur; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_signal (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_post(h2o_sem_t *sem)\n{\npthread_mutex_lock(&sem->_mutex);\n++sem->_cur;\npthread_cond_signal(&sem->_cond);\npthread_mutex_unlock(&sem->_mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  lock; int /*<<< orphan*/  count; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_cond_signal (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_post(h2o_sem_t *sem)\n{\npthread_mutex_lock(&sem->lock);\n++sem->count;\npthread_cond_signal(&sem->lock);\npthread_mutex_unlock(&sem->lock);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_sem_set_capacity",
    "input":"\n0000000000000000 <h2o_sem_set_capacity>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <h2o_sem_set_capacity+0xf>\nf: \tmovl\t8(%rbx), %eax\n12: \tmovl\t%r14d, %ecx\n15: \tsubl\t%eax, %ecx\n17: \taddl\t%ecx, 16(%rbx)\n1a: \tmovq\t%r14, 8(%rbx)\n1e: \tleaq\t4(%rbx), %rdi\n22: \tcallq\t0x27 <h2o_sem_set_capacity+0x27>\n27: \tmovq\t%rbx, %rdi\n2a: \taddq\t$8, %rsp\n2e: \tpopq\t%rbx\n2f: \tpopq\t%r14\n31: \tjmp\t0x36 <h2o_sem_set_capacity+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ ssize_t ;\nstruct TYPE_3__ {int /*<<< orphan*/  _mutex; int /*<<< orphan*/  _cond; scalar_t__ _capacity; int /*<<< orphan*/  _cur; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  pthread_cond_broadcast (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\nvoid h2o_sem_set_capacity(h2o_sem_t *sem, ssize_t new_capacity)\n{\npthread_mutex_lock(&sem->_mutex);\nsem->_cur += new_capacity - sem->_capacity;\nsem->_capacity = new_capacity;\npthread_cond_broadcast(&sem->_cond);\npthread_mutex_unlock(&sem->_mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  mutex; int /*<<< orphan*/  cond; int /*<<< orphan*/  num_waiters; int /*<<< orphan*/  capacity; } ;\ntypedef  TYPE_1__ h2o_sem_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_sem_notify_all (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_sem_notify_one (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_sem_unlock (TYPE_1__*) ;\n\nvoid h2o_sem_set_capacity(h2o_sem_t *sem, size_t capacity)\n{\nh2o_sem_unlock(sem);\nsem->capacity = capacity;\nsem->num_waiters += capacity - sem->capacity;\nh2o_sem_notify_all(sem);\nh2o_sem_lock(sem);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_get_ssl_session_id",
    "input":"\n0000000000000000 <h2o_socket_get_ssl_session_id>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rdi), %rax\n4: \ttestq\t%rax, %rax\n7: \tje\t0x10 <h2o_socket_get_ssl_session_id+0x10>\n9: \tcmpq\t$0, 16(%rax)\ne: \tje\t0x1a <h2o_socket_get_ssl_session_id+0x1a>\n10: \txorl\t%edi, %edi\n12: \txorl\t%esi, %esi\n14: \tpopq\t%rax\n15: \tjmp\t0x1a <h2o_socket_get_ssl_session_id+0x1a>\n1a: \tmovq\t(%rax), %rdi\n1d: \ttestq\t%rdi, %rdi\n20: \tje\t0x10 <h2o_socket_get_ssl_session_id+0x10>\n22: \tmovq\t8(%rax), %rax\n26: \tcmpq\t(%rip), %rax  # 0x2d <h2o_socket_get_ssl_session_id+0x2d>\n2d: \tjne\t0x10 <h2o_socket_get_ssl_session_id+0x10>\n2f: \tcallq\t0x34 <h2o_socket_get_ssl_session_id+0x34>\n34: \ttestq\t%rax, %rax\n37: \tje\t0x10 <h2o_socket_get_ssl_session_id+0x10>\n39: \tleaq\t4(%rsp), %rsi\n3e: \tmovq\t%rax, %rdi\n41: \tcallq\t0x46 <h2o_socket_get_ssl_session_id+0x46>\n46: \tmovl\t4(%rsp), %esi\n4a: \tmovq\t%rax, %rdi\n4d: \tcallq\t0x52 <h2o_socket_get_ssl_session_id+0x52>\n52: \tpopq\t%rcx\n53: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {TYPE_2__* ssl; } ;\ntypedef  TYPE_5__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_iovec_t ;\nstruct TYPE_10__ {scalar_t__ state; } ;\nstruct TYPE_9__ {TYPE_4__ async_resumption; } ;\nstruct TYPE_7__ {TYPE_3__ server; } ;\nstruct TYPE_8__ {int /*<<< orphan*/ * ossl; TYPE_1__ handshake; int /*<<< orphan*/ * ptls; } ;\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\n\n/* Variables and functions */\nscalar_t__ ASYNC_RESUMPTION_STATE_COMPLETE ;\nunsigned char* SSL_SESSION_get_id (int /*<<< orphan*/ *,unsigned int*) ;\nint /*<<< orphan*/ * SSL_get_session (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_iovec_init (unsigned char const*,unsigned int) ;\n\nh2o_iovec_t h2o_socket_get_ssl_session_id(h2o_socket_t *sock)\n{\nif (sock->ssl != NULL) {\nif (sock->ssl->ptls != NULL) {\n/* FIXME */\n} else if (sock->ssl->ossl != NULL) {\nSSL_SESSION *session;\nif (sock->ssl->handshake.server.async_resumption.state == ASYNC_RESUMPTION_STATE_COMPLETE &&\n(session = SSL_get_session(sock->ssl->ossl)) != NULL) {\nunsigned id_len;\nconst unsigned char *id = SSL_SESSION_get_id(session, &id_len);\nreturn h2o_iovec_init(id, id_len);\n}\n}\n}\n\nreturn h2o_iovec_init(NULL, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {TYPE_1__* ssl; } ;\nstruct TYPE_3__ {scalar_t__ ssl_state; scalar_t__ ssl_ctx; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\n\n/* Variables and functions */\nscalar_t__ SSL_NOT_REPLACEABLE_SESSION_CTX ;\nsize_t SSL_SESSION_get_id (int /*<<< orphan*/ *,unsigned char*) ;\nint /*<<< orphan*/ * SSL_get_session (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free (unsigned char*) ;\nunsigned char* h2o_mem_alloc (size_t) ;\n\nsize_t h2o_socket_get_ssl_session_id(h2o_socket_t *sock, unsigned char **session_id)\n{\nif (sock->ssl == NULL || sock->ssl->ssl_ctx == 0 || sock->ssl->ssl_state != SSL_NOT_REPLACEABLE_SESSION_CTX)\nreturn 0;\n\nunsigned char *id = h2o_mem_alloc(SSL_SESSION_get_id(SSL_get_session(sock->ssl), session_id));\nif (id == NULL)\nreturn 0;\n*session_id = id;\nreturn SSL_SESSION_get_id(SSL_get_session(sock->ssl), session_id);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_flush_pending_ssl",
    "input":"\n0000000000000000 <flush_pending_ssl>:\n0: \tmovl\t%esi, %ecx\n2: \tmovq\t(%rdi), %rax\n5: \tmovl\t(%rax), %edx\n7: \tmovl\t4(%rax), %esi\na: \tjmp\t0xf <flush_pending_ssl+0xf>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_3__* ssl; } ;\ntypedef  TYPE_4__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_cb ;\nstruct TYPE_7__ {int /*<<< orphan*/  size; int /*<<< orphan*/  entries; } ;\nstruct TYPE_8__ {TYPE_1__ bufs; } ;\nstruct TYPE_9__ {TYPE_2__ output; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_write (TYPE_4__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void flush_pending_ssl(h2o_socket_t *sock, h2o_socket_cb cb)\n{\ndo_write(sock, sock->ssl->output.bufs.entries, sock->ssl->output.bufs.size, cb);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * ssl; } ;\ntypedef  TYPE_1__ SSL_TEST_CTX ;\n\n/* Variables and functions */\nint flush_pending_ssl_bio (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static int\nflush_pending_ssl(SSL_TEST_CTX *ctx, int rw)\n{\nreturn flush_pending_ssl_bio(ctx, ctx->ssl[0], ctx->ssl[1], rw);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_destroy_session_cache_entry",
    "input":"\n0000000000000000 <h2o_socket_ssl_destroy_session_cache_entry>:\n0: \tjmp\t0x5 <h2o_socket_ssl_destroy_session_cache_entry+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ base; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_SESSION_free (int /*<<< orphan*/ *) ;\n\nvoid h2o_socket_ssl_destroy_session_cache_entry(h2o_iovec_t value)\n{\nSSL_SESSION *session = (SSL_SESSION *)value.base;\nSSL_SESSION_free(session);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_SESSION_free (int /*<<< orphan*/ *) ;\n\nvoid h2o_socket_ssl_destroy_session_cache_entry(SSL_SESSION *session)\n{\nSSL_SESSION_free(session);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_h2o_cache_get_duration",
    "input":"\n0000000000000000 <h2o_cache_get_duration>:\n0: \tmovl\t(%rdi), %eax\n2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint64_t ;\nstruct TYPE_3__ {int /*<<< orphan*/  duration; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\n\nuint64_t h2o_cache_get_duration(h2o_cache_t *cache)\n{\nreturn cache->duration;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int duration; } ;\ntypedef  TYPE_1__ h2o_cache_entry_t ;\n\n/* Variables and functions */\n\nint h2o_cache_get_duration(h2o_cache_entry_t *entry)\n{\nreturn entry->duration;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_h2o_cache_delete",
    "input":"\n0000000000000000 <h2o_cache_delete>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tsubq\t$24, %rsp\na: \tmovq\t%rdx, %r15\nd: \tmovl\t%esi, %r14d\n10: \tmovq\t%rdi, %rbx\n13: \tmovq\t%rdx, %rbp\n16: \tshrq\t$32, %rbp\n1a: \ttestq\t%rcx, %rcx\n1d: \tjne\t0x2c <h2o_cache_delete+0x2c>\n1f: \tmovl\t%ebp, %edi\n21: \tmovl\t%r15d, %esi\n24: \tcallq\t0x29 <h2o_cache_delete+0x29>\n29: \tmovq\t%rax, %rcx\n2c: \tmovl\t%r15d, 16(%rsp)\n31: \tmovl\t%ebp, 20(%rsp)\n35: \tmovq\t%rcx, 8(%rsp)\n3a: \tmovq\t%rbx, %rdi\n3d: \tcallq\t0x42 <h2o_cache_delete+0x42>\n42: \tmovq\t%rbx, %rdi\n45: \tmovl\t%r14d, %esi\n48: \tcallq\t0x4d <h2o_cache_delete+0x4d>\n4d: \tmovl\t(%rbx), %esi\n4f: \tleaq\t8(%rsp), %rdx\n54: \tmovq\t%rbx, %rdi\n57: \tcallq\t0x5c <h2o_cache_delete+0x5c>\n5c: \tmovl\t%eax, %ebp\n5e: \tmovl\t(%rbx), %edi\n60: \tcallq\t0x65 <h2o_cache_delete+0x65>\n65: \tcmpl\t%eax, %ebp\n67: \tje\t0x75 <h2o_cache_delete+0x75>\n69: \tmovq\t%rbx, %rdi\n6c: \tmovl\t%ebp, %esi\n6e: \txorl\t%edx, %edx\n70: \tcallq\t0x75 <h2o_cache_delete+0x75>\n75: \tmovq\t%rbx, %rdi\n78: \tcallq\t0x7d <h2o_cache_delete+0x7d>\n7d: \taddq\t$24, %rsp\n81: \tpopq\t%rbx\n82: \tpopq\t%r14\n84: \tpopq\t%r15\n86: \tpopq\t%rbp\n87: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_3__ ;\ntypedef  struct TYPE_13__   TYPE_2__ ;\ntypedef  struct TYPE_12__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint64_t ;\ntypedef  int /*<<< orphan*/  khiter_t ;\nstruct TYPE_12__ {int /*<<< orphan*/  len; int /*<<< orphan*/  base; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\nstruct TYPE_13__ {int /*<<< orphan*/  table; } ;\ntypedef  TYPE_2__ h2o_cache_t ;\nstruct TYPE_14__ {scalar_t__ keyhash; TYPE_1__ key; } ;\ntypedef  TYPE_3__ h2o_cache_ref_t ;\ntypedef  scalar_t__ h2o_cache_hashcode_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  erase_ref (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nscalar_t__ h2o_cache_calchash (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kh_end (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kh_get (TYPE_2__*,int /*<<< orphan*/ ,TYPE_3__*) ;\nint /*<<< orphan*/  lock_cache (TYPE_2__*) ;\nint /*<<< orphan*/  purge (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  unlock_cache (TYPE_2__*) ;\n\nvoid h2o_cache_delete(h2o_cache_t *cache, uint64_t now, h2o_iovec_t key, h2o_cache_hashcode_t keyhash)\n{\nh2o_cache_ref_t search_key;\nkhiter_t iter;\n\nif (keyhash == 0)\nkeyhash = h2o_cache_calchash(key.base, key.len);\nsearch_key.key = key;\nsearch_key.keyhash = keyhash;\n\nlock_cache(cache);\n\npurge(cache, now);\n\nif ((iter = kh_get(cache, cache->table, &search_key)) != kh_end(cache->table))\nerase_ref(cache, iter, 0);\n\nunlock_cache(cache);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  mutex; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  key; int /*<<< orphan*/  value; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  key; int /*<<< orphan*/  value; } ;\ntypedef  TYPE_1__ h2o_cache_entry_t ;\ntypedef  TYPE_2__ h2o_cache_delete_cb_args_t ;\ntypedef  TYPE_3__ h2o_cache_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_cache_do_delete (TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_cache_do_lookup (TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_cache_do_remove (TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_cache_do_update (TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_cache_get_key (int,int) ;\nint /*<<< orphan*/  h2o_cache_get_value (int,int) ;\nint /*<<< orphan*/  h2o_cache_unlock (TYPE_3__*) ;\nint /*<<< orphan*/  h2o_cache_unlock_key (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_cache_unlock_value (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void h2o_cache_delete(h2o_cache_t *cache, int key_hash, int value_hash,\nh2o_cache_delete_cb_args_t *args)\n{\nh2o_cache_entry_t entry;\n\nif (args == NULL) {\nentry.key = h2o_cache_get_key(key_hash, value_hash);\nentry.value = h2o_cache_get_value(key_hash, value_hash);\n} else {\nentry = *args;\n}\n\nh2o_cache_do_lookup(cache, entry.key, &entry);\nif (h2o_cache_do_delete(cache, entry.key, &entry)) {\nh2o_cache_do_remove(cache, entry.key, entry.value);\nh2o_cache_unlock_key(entry.key);\nh2o_cache_unlock_value(entry.value);\n}\nh2o_cache_unlock(cache);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_resume_server_handshake",
    "input":"\n0000000000000000 <h2o_socket_ssl_resume_server_handshake>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rbx\n8: \ttestq\t%rsi, %rsi\nb: \tje\t0x2c <h2o_socket_ssl_resume_server_handshake+0x2c>\nd: \tmovq\t%rsi, %rax\n10: \tmovq\t%rdx, 8(%rsp)\n15: \tleaq\t8(%rsp), %rsi\n1a: \txorl\t%edi, %edi\n1c: \tmovq\t%rax, %rdx\n1f: \tcallq\t0x24 <h2o_socket_ssl_resume_server_handshake+0x24>\n24: \tmovq\t(%rbx), %rcx\n27: \tmovq\t%rax, (%rcx)\n2a: \tjmp\t0x2f <h2o_socket_ssl_resume_server_handshake+0x2f>\n2c: \tmovq\t(%rbx), %rcx\n2f: \tmovl\t(%rip), %eax  # 0x35 <h2o_socket_ssl_resume_server_handshake+0x35>\n35: \tmovl\t%eax, 8(%rcx)\n38: \tmovq\t%rbx, %rdi\n3b: \txorl\t%esi, %esi\n3d: \tcallq\t0x42 <h2o_socket_ssl_resume_server_handshake+0x42>\n42: \tmovq\t(%rbx), %rax\n45: \tmovq\t(%rax), %rdi\n48: \ttestq\t%rdi, %rdi\n4b: \tje\t0x5c <h2o_socket_ssl_resume_server_handshake+0x5c>\n4d: \tcallq\t0x52 <h2o_socket_ssl_resume_server_handshake+0x52>\n52: \tmovq\t(%rbx), %rax\n55: \tmovq\t$0, (%rax)\n5c: \taddq\t$16, %rsp\n60: \tpopq\t%rbx\n61: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_15__   TYPE_6__ ;\ntypedef  struct TYPE_14__   TYPE_5__ ;\ntypedef  struct TYPE_13__   TYPE_4__ ;\ntypedef  struct TYPE_12__   TYPE_3__ ;\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_14__ {TYPE_4__* ssl; } ;\ntypedef  TYPE_5__ h2o_socket_t ;\nstruct TYPE_15__ {scalar_t__ len; scalar_t__ base; } ;\ntypedef  TYPE_6__ h2o_iovec_t ;\nstruct TYPE_10__ {int /*<<< orphan*/ * session_data; int /*<<< orphan*/  state; } ;\nstruct TYPE_11__ {TYPE_1__ async_resumption; } ;\nstruct TYPE_12__ {TYPE_2__ server; } ;\nstruct TYPE_13__ {TYPE_3__ handshake; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ASYNC_RESUMPTION_STATE_COMPLETE ;\nint /*<<< orphan*/  SSL_SESSION_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * d2i_SSL_SESSION (int /*<<< orphan*/ *,unsigned char const**,long) ;\nint /*<<< orphan*/  proceed_handshake (TYPE_5__*,int /*<<< orphan*/ ) ;\n\nvoid h2o_socket_ssl_resume_server_handshake(h2o_socket_t *sock, h2o_iovec_t session_data)\n{\nif (session_data.len != 0) {\nconst unsigned char *p = (void *)session_data.base;\nsock->ssl->handshake.server.async_resumption.session_data = d2i_SSL_SESSION(NULL, &p, (long)session_data.len);\n/* FIXME warn on failure */\n}\n\nsock->ssl->handshake.server.async_resumption.state = ASYNC_RESUMPTION_STATE_COMPLETE;\nproceed_handshake(sock, 0);\n\nif (sock->ssl->handshake.server.async_resumption.session_data != NULL) {\nSSL_SESSION_free(sock->ssl->handshake.server.async_resumption.session_data);\nsock->ssl->handshake.server.async_resumption.session_data = NULL;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_1__* ssl; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  state; } ;\nstruct TYPE_8__ {int /*<<< orphan*/ * pending_session; } ;\ntypedef  TYPE_2__ h2o_socket_ssl_st ;\ntypedef  TYPE_3__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_STATE_CONNECTING ;\nint /*<<< orphan*/  SSL_set_session (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_set_tlsext_host_name (int /*<<< orphan*/ ,char const*) ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * h2o_iovec_init (char const*,size_t) ;\n\nvoid h2o_socket_ssl_resume_server_handshake(h2o_socket_t *sock, const char *server_name, size_t server_name_len)\n{\nh2o_socket_ssl_st *self = (void *)sock;\n\nif (server_name != NULL) {\nself->ssl->pending_session = SSL_set_session(NULL, h2o_iovec_init(server_name, server_name_len));\n}\nself->ssl->state = H2O_SOCKET_STATE_CONNECTING;\nif (self->ssl->pending_session != NULL)\nfree(self->ssl->pending_session);\nself->ssl->pending_session = NULL;\nSSL_set_tlsext_host_name(self->ssl->ssl, server_name);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_create_ossl",
    "input":"\n0000000000000000 <create_ossl>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t(%rdi), %rax\n7: \tmovl\t4(%rax), %edi\na: \tcallq\t0xf <create_ossl+0xf>\nf: \tmovq\t(%rbx), %rcx\n12: \tmovl\t%eax, (%rcx)\n14: \tmovl\t%eax, %edi\n16: \tmovq\t%rbx, %rsi\n19: \tcallq\t0x1e <create_ossl+0x1e>\n1e: \tmovq\t%rbx, %rdi\n21: \tpopq\t%rbx\n22: \tjmp\t0x27 <create_ossl+0x27>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  ossl; int /*<<< orphan*/  ssl_ctx; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_set_app_data (int /*<<< orphan*/ ,TYPE_2__*) ;\nint /*<<< orphan*/  setup_bio (TYPE_2__*) ;\n\n__attribute__((used)) static void create_ossl(h2o_socket_t *sock)\n{\nsock->ssl->ossl = SSL_new(sock->ssl->ssl_ctx);\n/* set app data to be used in h2o_socket_ssl_new_session_cb */\nSSL_set_app_data(sock->ssl->ossl, sock);\nsetup_bio(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* priv_data; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  ossl; } ;\ntypedef  TYPE_2__ AVFilterContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EVP_MD_CTX_create () ;\nint /*<<< orphan*/  EVP_MD_CTX_init (int /*<<< orphan*/ ) ;\nint ff_openssl_init_and_get (TYPE_2__*) ;\n\n__attribute__((used)) static int create_ossl(AVFilterContext *ctx)\n{\nctx->priv_data->ossl = EVP_MD_CTX_create();\nEVP_MD_CTX_init(ctx->priv_data->ossl);\nreturn ff_openssl_init_and_get(ctx);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_socket_get_loop",
    "input":"\n0000000000000000 <h2o_socket_get_loop>:\n0: \tmovq\t(%rdi), %rax\n3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/ * loop; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\n\n/* Variables and functions */\n\nh2o_loop_t *h2o_socket_get_loop(h2o_socket_t *_sock)\n{\nstruct st_h2o_evloop_socket_t *sock = (void *)_sock;\nreturn sock->loop;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * loop; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\n\n/* Variables and functions */\n\nh2o_loop_t *h2o_socket_get_loop(h2o_socket_t *sock)\n{\nreturn sock->loop;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_read_on_ready",
    "input":"\n0000000000000000 <read_on_ready>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %rbx\n8: \tleaq\t8(%rdi), %r14\nc: \tmovq\t24(%rdi), %rax\n10: \tmovq\t(%rax), %r15\n13: \tmovl\t(%rip), %eax  # 0x19 <read_on_ready+0x19>\n19: \ttestl\t%eax, (%rdi)\n1b: \tje\t0x21 <read_on_ready+0x21>\n1d: \txorl\t%esi, %esi\n1f: \tjmp\t0x44 <read_on_ready+0x44>\n21: \tleaq\t24(%rbx), %rax\n25: \tmovl\t40(%rbx), %edi\n28: \tmovq\t32(%rbx), %rcx\n2c: \ttestq\t%rcx, %rcx\n2f: \tleaq\t8(%rcx), %rsi\n33: \tcmoveq\t%rax, %rsi\n37: \tcallq\t0x3c <read_on_ready+0x3c>\n3c: \tmovq\t%rax, %rsi\n3f: \ttestq\t%rax, %rax\n42: \tje\t0x60 <read_on_ready+0x60>\n44: \tmovq\t16(%rbx), %rax\n48: \tmovq\t24(%rbx), %rcx\n4c: \tmovq\t(%rcx), %rcx\n4f: \tsubq\t%r15, %rcx\n52: \tmovq\t%rcx, 8(%rbx)\n56: \tmovq\t%r14, %rdi\n59: \tpopq\t%rbx\n5a: \tpopq\t%r14\n5c: \tpopq\t%r15\n5e: \tjmpq\t*%rax\n60: \tmovq\t32(%rbx), %rax\n64: \ttestq\t%rax, %rax\n67: \tje\t0x1d <read_on_ready+0x1d>\n69: \tcmpq\t$0, (%rax)\n6d: \tjne\t0x1d <read_on_ready+0x1d>\n6f: \tmovq\t%r14, %rdi\n72: \tcallq\t0x77 <read_on_ready+0x77>\n77: \tmovq\t%rax, %rsi\n7a: \tjmp\t0x44 <read_on_ready+0x44>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_6__ ;\ntypedef  struct TYPE_12__   TYPE_5__ ;\ntypedef  struct TYPE_11__   TYPE_4__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {int /*<<< orphan*/  (* read ) (TYPE_5__*,char const*) ;} ;\nstruct TYPE_12__ {size_t bytes_read; TYPE_4__ _cb; TYPE_6__* input; TYPE_3__* ssl; } ;\nstruct st_h2o_evloop_socket_t {int _flags; TYPE_5__ super; int /*<<< orphan*/  fd; } ;\nstruct TYPE_13__ {size_t size; } ;\nstruct TYPE_9__ {int /*<<< orphan*/ * cb; } ;\nstruct TYPE_8__ {TYPE_6__* encrypted; } ;\nstruct TYPE_10__ {TYPE_2__ handshake; TYPE_1__ input; } ;\n\n/* Variables and functions */\nint H2O_SOCKET_FLAG_DONT_READ ;\nchar* decode_ssl_input (TYPE_5__*) ;\nchar* on_read_core (int /*<<< orphan*/ ,TYPE_6__**) ;\nint /*<<< orphan*/  stub1 (TYPE_5__*,char const*) ;\n\n__attribute__((used)) static void read_on_ready(struct st_h2o_evloop_socket_t *sock)\n{\nconst char *err = 0;\nsize_t prev_bytes_read = sock->super.input->size;\n\nif ((sock->_flags & H2O_SOCKET_FLAG_DONT_READ) != 0)\ngoto Notify;\n\nif ((err = on_read_core(sock->fd, sock->super.ssl == NULL ? &sock->super.input : &sock->super.ssl->input.encrypted)) != NULL)\ngoto Notify;\n\nif (sock->super.ssl != NULL && sock->super.ssl->handshake.cb == NULL)\nerr = decode_ssl_input(&sock->super);\n\nNotify:\n/* the application may get notified even if no new data is avaiable.  The\n* behavior is intentional; it is designed as such so that the applications\n* can update their timeout counters when a partial SSL record arrives.\n*/\nsock->super.bytes_read = sock->super.input->size - prev_bytes_read;\nsock->super._cb.read(&sock->super, err);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int flags; int /*<<< orphan*/  read_on_ready; TYPE_3__* read_on_ready_data; TYPE_2__* read_on_ready_func; TYPE_1__* read_on_ready_data_free; scalar_t__ read_on_ready_data_size; } ;\nstruct TYPE_9__ {scalar_t__ size; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  (* on_ready ) (TYPE_4__*,int /*<<< orphan*/ ) ;} ;\nstruct TYPE_7__ {int /*<<< orphan*/  (* on_ready ) (TYPE_4__*,int /*<<< orphan*/ ) ;} ;\ntypedef  TYPE_2__ on_ready_func ;\ntypedef  TYPE_3__ on_ready_data ;\ntypedef  TYPE_4__ GLog ;\n\n/* Variables and functions */\nint GLOG_READ_ON_READY ;\nint /*<<< orphan*/  glog_read_on_ready (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub1 (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub2 (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub3 (TYPE_4__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void read_on_ready(GLog *glog)\n{\non_ready_func *func = glog->read_on_ready_func;\non_ready_data *data = glog->read_on_ready_data;\n\nif (glog->flags & GLOG_READ_ON_READY)\n{\nglog_read_on_ready(glog, 0);\n}\nelse\n{\nif (func)\n{\nfunc->on_ready(glog, 0);\n}\nelse if (data && data->size)\n{\nglog_read_on_ready(glog, 0);\n}\nelse if (glog->read_on_ready_data_free && !glog->read_on_ready_data_size)\n{\nglog->read_on_ready_data_free->on_ready(glog, 0);\n}\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_is_equal",
    "input":"\n0000000000000000 <is_equal>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rdi), %rdx\n4: \txorl\t%eax, %eax\n6: \tcmpq\t(%rsi), %rdx\n9: \tjne\t0x21 <is_equal+0x21>\nb: \tmovl\t8(%rdi), %edi\ne: \tmovl\t8(%rsi), %esi\n11: \tcallq\t0x16 <is_equal+0x16>\n16: \tmovq\t%rax, %rcx\n19: \txorl\t%eax, %eax\n1b: \ttestq\t%rcx, %rcx\n1e: \tsete\t%al\n21: \tpopq\t%rcx\n22: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ len; int /*<<< orphan*/  base; } ;\nstruct TYPE_6__ {TYPE_1__ key; } ;\ntypedef  TYPE_2__ h2o_cache_ref_t ;\n\n/* Variables and functions */\nscalar_t__ memcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__) ;\n\n__attribute__((used)) static int is_equal(h2o_cache_ref_t *x, h2o_cache_ref_t *y)\n{\nreturn x->key.len == y->key.len && memcmp(x->key.base, y->key.base, x->key.len) == 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ len; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__ GUID ;\n\n/* Variables and functions */\nscalar_t__ memcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__) ;\n\n__attribute__((used)) static inline int is_equal(const GUID *guid1, const GUID *guid2)\n{\nreturn guid1->len == guid2->len && !memcmp(guid1->data, guid2->data, guid1->len);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_write_bio",
    "input":"\n0000000000000000 <write_bio>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t%edx, %ebx\n6: \tmovq\t%rsi, %r14\n9: \tcallq\t0xe <write_bio+0xe>\ne: \tmovq\t(%rax), %rcx\n11: \tmovq\t(%rcx), %rcx\n14: \ttestq\t%rcx, %rcx\n17: \tje\t0x26 <write_bio+0x26>\n19: \tmovl\t$1, (%rcx)\n1f: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\n24: \tjmp\t0x33 <write_bio+0x33>\n26: \tmovq\t%rax, %rdi\n29: \tmovq\t%r14, %rsi\n2c: \tmovl\t%ebx, %edx\n2e: \tcallq\t0x33 <write_bio+0x33>\n33: \tmovl\t%ebx, %eax\n35: \taddq\t$8, %rsp\n39: \tpopq\t%rbx\n3a: \tpopq\t%r14\n3c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {TYPE_1__* ssl; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\nstruct TYPE_5__ {int* did_write_in_read; } ;\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nTYPE_2__* BIO_get_data (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  write_ssl_bytes (TYPE_2__*,char const*,int) ;\n\n__attribute__((used)) static int write_bio(BIO *b, const char *in, int len)\n{\nh2o_socket_t *sock = BIO_get_data(b);\n\n/* FIXME no support for SSL renegotiation (yet) */\nif (sock->ssl->did_write_in_read != NULL) {\n*sock->ssl->did_write_in_read = 1;\nreturn -1;\n}\n\nwrite_ssl_bytes(sock, in, len);\nreturn len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * bio_data; } ;\ntypedef  TYPE_1__ SSL ;\n\n/* Variables and functions */\nTYPE_1__* SSL_get_SSL_CTX (TYPE_1__*) ;\nint /*<<< orphan*/  SSL_set_error (TYPE_1__*,int) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,char const*,int) ;\n\n__attribute__((used)) static int write_bio(SSL *s, const char *buf, int num)\n{\nint ret = num;\n\nif (s->bio_data) {\ns->bio_data[0] = 1;\nret = -1;\n} else {\nmemcpy(s->bio_data, buf, num);\n}\n\nSSL_set_error(s, ret);\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_link_to_pending",
    "input":"\n0000000000000000 <link_to_pending>:\n0: \tcmpq\t%rdi, 8(%rdi)\n4: \tje\t0x7 <link_to_pending+0x7>\n6: \tretq\n7: \tmovl\t(%rip), %eax  # 0xd <link_to_pending+0xd>\nd: \tandl\t(%rdi), %eax\nf: \tmovq\t16(%rdi), %rcx\n13: \tleaq\t8(%rcx), %rdx\n17: \txorl\t%esi, %esi\n19: \ttestl\t%eax, %eax\n1b: \tcmoveq\t%rcx, %rdx\n1f: \tsetne\t%sil\n23: \tmovq\t(%rdx), %rax\n26: \tmovq\t%rax, 8(%rdi)\n2a: \tmovq\t%rdi, (%rcx,%rsi,8)\n2e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int _flags; struct st_h2o_evloop_socket_t* _next_pending; TYPE_1__* loop; } ;\nstruct TYPE_2__ {struct st_h2o_evloop_socket_t* _pending_as_client; struct st_h2o_evloop_socket_t* _pending_as_server; } ;\n\n/* Variables and functions */\nint H2O_SOCKET_FLAG_IS_ACCEPTED_CONNECTION ;\n\nvoid link_to_pending(struct st_h2o_evloop_socket_t *sock)\n{\nif (sock->_next_pending == sock) {\nstruct st_h2o_evloop_socket_t **slot = (sock->_flags & H2O_SOCKET_FLAG_IS_ACCEPTED_CONNECTION) != 0\n? &sock->loop->_pending_as_server\n: &sock->loop->_pending_as_client;\nsock->_next_pending = *slot;\n*slot = sock;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; struct TYPE_3__* next; struct TYPE_3__* prev; } ;\ntypedef  TYPE_1__ pending_connection ;\n\n/* Variables and functions */\nint PENDING_FLAG_IN_LIST ;\n\n__attribute__((used)) static void link_to_pending (pending_connection *p) {\nif (p->next == p) {\nreturn;\n}\nif (p->flags & PENDING_FLAG_IN_LIST) {\np->prev->next = p->next;\np->next->prev = p->prev;\n}\np->next = p->prev = p;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_multithread_unregister_receiver",
    "input":"\n0000000000000000 <h2o_multithread_unregister_receiver>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \txorl\t%edi, %edi\nc: \tcmpq\t%r14, 8(%rsi)\n10: \tsete\t%dil\n14: \tcallq\t0x19 <h2o_multithread_unregister_receiver+0x19>\n19: \tleaq\t4(%rbx), %rdi\n1d: \tcallq\t0x22 <h2o_multithread_unregister_receiver+0x22>\n22: \tmovl\t%eax, %edi\n24: \tcallq\t0x29 <h2o_multithread_unregister_receiver+0x29>\n29: \tmovq\t%r14, %rdi\n2c: \tcallq\t0x31 <h2o_multithread_unregister_receiver+0x31>\n31: \tmovq\t%rbx, %rdi\n34: \tcallq\t0x39 <h2o_multithread_unregister_receiver+0x39>\n39: \tmovq\t%r14, %rdi\n3c: \taddq\t$8, %rsp\n40: \tpopq\t%rbx\n41: \tpopq\t%r14\n43: \tjmp\t0x48 <h2o_multithread_unregister_receiver+0x48>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  _link; int /*<<< orphan*/  _messages; TYPE_2__* queue; } ;\ntypedef  TYPE_1__ h2o_multithread_receiver_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  mutex; } ;\ntypedef  TYPE_2__ h2o_multithread_queue_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint h2o_linklist_is_empty (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_linklist_unlink (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\nvoid h2o_multithread_unregister_receiver(h2o_multithread_queue_t *queue, h2o_multithread_receiver_t *receiver)\n{\nassert(queue == receiver->queue);\nassert(h2o_linklist_is_empty(&receiver->_messages));\npthread_mutex_lock(&queue->mutex);\nh2o_linklist_unlink(&receiver->_link);\npthread_mutex_unlock(&queue->mutex);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  lock; int /*<<< orphan*/ * receivers; } ;\ntypedef  TYPE_1__ h2o_multithread_receiver_t ;\ntypedef  int /*<<< orphan*/  h2o_multithread_receiver_register_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_multithread_receiver_unregister (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_multithread_receiver_unregister_locked (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_multithread_receiver_unregister_locked_do (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_mutex_unlock (int /*<<< orphan*/ *) ;\n\nvoid h2o_multithread_unregister_receiver(h2o_multithread_receiver_t *receiver,\nh2o_multithread_receiver_register_t *reg)\n{\nassert(receiver == reg->receiver);\nh2o_mutex_lock(&receiver->lock);\nh2o_multithread_receiver_unregister_locked(&reg->entry);\nh2o_multithread_receiver_unregister_locked_do(&reg->entry);\nh2o_mutex_unlock(&receiver->lock);\nh2o_multithread_receiver_unregister(&reg->entry);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_multithread.c_worker_main",
    "input":"\n0000000000000000 <worker_main>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <worker_main+0x8>\n8: \tjne\t0x2a <worker_main+0x2a>\na: \tnopw\t(%rax,%rax)\n10: \tmovl\t(%rip), %edi  # 0x16 <worker_main+0x16>\n16: \tmovl\t(%rip), %esi  # 0x1c <worker_main+0x1c>\n1c: \tcallq\t0x21 <worker_main+0x21>\n21: \tcmpl\t$0, (%rip)    # 0x28 <worker_main+0x28>\n28: \tje\t0x10 <worker_main+0x10>\n2a: \txorl\t%eax, %eax\n2c: \tpopq\t%rcx\n2d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  loop; int /*<<< orphan*/  should_exit; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  INT32_MAX ;\nint /*<<< orphan*/  UV_RUN_ONCE ;\nint /*<<< orphan*/  h2o_evloop_run (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  uv_run (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__ worker_thread ;\n\n__attribute__((used)) static void *worker_main(void *_unused)\n{\nwhile (!worker_thread.should_exit) {\n#if H2O_USE_LIBUV\nuv_run(worker_thread.loop, UV_RUN_ONCE);\n#else\nh2o_evloop_run(worker_thread.loop, INT32_MAX);\n#endif\n}\n\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGINT ;\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  signal (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  worker_loop () ;\nint /*<<< orphan*/  worker_quit ;\n\nvoid worker_main (void) {\nwhile (!worker_quit) {\nworker_loop();\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_hex_decode",
    "input":"\n0000000000000000 <h2o_hex_decode>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rdx, %r15\ne: \tmovl\t$4294967295, %r14d # imm = 0xFFFFFFFF\n14: \ttestb\t$1, %r15b\n18: \tjne\t0x6a <h2o_hex_decode+0x6a>\n1a: \ttestq\t%r15, %r15\n1d: \tje\t0x67 <h2o_hex_decode+0x67>\n1f: \tmovq\t%rsi, %r12\n22: \tmovq\t%rdi, %r13\n25: \txorl\t%ebx, %ebx\n27: \tnopw\t(%rax,%rax)\n30: \tmovsbl\t(%r12,%rbx), %edi\n35: \tcallq\t0x3a <h2o_hex_decode+0x3a>\n3a: \tcmpl\t$-1, %eax\n3d: \tje\t0x6a <h2o_hex_decode+0x6a>\n3f: \tmovl\t%eax, %ebp\n41: \tmovsbl\t1(%r12,%rbx), %edi\n47: \tcallq\t0x4c <h2o_hex_decode+0x4c>\n4c: \tcmpl\t$-1, %eax\n4f: \tje\t0x6a <h2o_hex_decode+0x6a>\n51: \tshll\t$4, %ebp\n54: \torl\t%ebp, %eax\n56: \tmovb\t%al, (%r13)\n5a: \taddq\t$1, %r13\n5e: \taddq\t$2, %rbx\n62: \tcmpq\t%rbx, %r15\n65: \tjne\t0x30 <h2o_hex_decode+0x30>\n67: \txorl\t%r14d, %r14d\n6a: \tmovl\t%r14d, %eax\n6d: \taddq\t$8, %rsp\n71: \tpopq\t%rbx\n72: \tpopq\t%r12\n74: \tpopq\t%r13\n76: \tpopq\t%r14\n78: \tpopq\t%r15\n7a: \tpopq\t%rbp\n7b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint decode_hex (int /*<<< orphan*/ ) ;\n\nint h2o_hex_decode(void *_dst, const char *src, size_t src_len)\n{\nunsigned char *dst = _dst;\n\nif (src_len % 2 != 0)\nreturn -1;\nfor (; src_len != 0; src_len -= 2) {\nint hi, lo;\nif ((hi = decode_hex(*src++)) == -1 || (lo = decode_hex(*src++)) == -1)\nreturn -1;\n*dst++ = (hi << 4) | lo;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint h2o_hex_decode_digit (char) ;\n\n__attribute__((used)) static int h2o_hex_decode(char *dst, const char *src, size_t len)\n{\nint ret = -1;\n\nif ((len & 1) == 0) {\nsize_t i;\nfor (i = 0; i != len; ++i) {\nint d = h2o_hex_decode_digit(src[i]);\nif (d == -1)\ngoto Exit;\ndst[i / 2] = d << 4;\n}\ndst[len / 2] &= 0x0f;\nret = 0;\n}\nExit:\nreturn ret;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonstring.c_h2o_strstr",
    "input":"\n0000000000000000 <h2o_strstr>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rsi, %r13\ne: \tsubq\t%rcx, %r13\n11: \tjae\t0x1c <h2o_strstr+0x1c>\n13: \tmovq\t(%rip), %rbx  # 0x1a <h2o_strstr+0x1a>\n1a: \tjmp\t0x7c <h2o_strstr+0x7c>\n1c: \tmovq\t%rcx, %r14\n1f: \ttestq\t%rcx, %rcx\n22: \tje\t0x7a <h2o_strstr+0x7a>\n24: \taddq\t$1, %r13\n28: \tje\t0x13 <h2o_strstr+0x13>\n2a: \tmovq\t%rdx, %r15\n2d: \tmovq\t%rdi, %r12\n30: \tleaq\t1(%rdx), %rax\n34: \tmovq\t%rax, (%rsp)\n38: \taddq\t$-1, %r14\n3c: \tleaq\t1(%rdi), %rbp\n40: \txorl\t%ebx, %ebx\n42: \tjmp\t0x59 <h2o_strstr+0x59>\n44: \tnopw\t%cs:(%rax,%rax)\n4e: \tnop\n50: \taddq\t$1, %rbx\n54: \tcmpq\t%rbx, %r13\n57: \tje\t0x13 <h2o_strstr+0x13>\n59: \tmovzbl\t(%r12,%rbx), %eax\n5e: \tcmpb\t(%r15), %al\n61: \tjne\t0x50 <h2o_strstr+0x50>\n63: \tleaq\t(%rbx,%rbp), %rdi\n67: \tmovq\t(%rsp), %rsi\n6b: \tmovq\t%r14, %rdx\n6e: \tcallq\t0x73 <h2o_strstr+0x73>\n73: \ttestq\t%rax, %rax\n76: \tjne\t0x50 <h2o_strstr+0x50>\n78: \tjmp\t0x7c <h2o_strstr+0x7c>\n7a: \txorl\t%ebx, %ebx\n7c: \tmovq\t%rbx, %rax\n7f: \taddq\t$8, %rsp\n83: \tpopq\t%rbx\n84: \tpopq\t%r12\n86: \tpopq\t%r13\n88: \tpopq\t%r14\n8a: \tpopq\t%r15\n8c: \tpopq\t%rbp\n8d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nsize_t SIZE_MAX ;\nscalar_t__ memcmp (char const*,char const*,size_t) ;\n\nsize_t h2o_strstr(const char *haysack, size_t haysack_len, const char *needle, size_t needle_len)\n{\n/* TODO optimize */\nif (haysack_len >= needle_len) {\nsize_t off, max = haysack_len - needle_len + 1;\nif (needle_len == 0)\nreturn 0;\nfor (off = 0; off != max; ++off)\nif (haysack[off] == needle[0] && memcmp(haysack + off + 1, needle + 1, needle_len - 1) == 0)\nreturn off;\n}\nreturn SIZE_MAX;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ memcmp (char const*,char const*,size_t) ;\n\n__attribute__((used)) static size_t h2o_strstr(const char *s, const char *needle, size_t needle_len, size_t max_len)\n{\nif (needle_len > max_len)\nreturn 0;\nif (needle_len == 0)\nreturn 0;\n\nsize_t i = 0;\n\nfor (; i < max_len - needle_len; ++i) {\nif (s[i] == needle[0]) {\nif (memcmp(&s[i], needle, needle_len) == 0)\nreturn i;\n}\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommontime.c_emit_digits",
    "input":"\n0000000000000000 <emit_digits>:\n0: \tleaq\t(%rdi,%rdx), %rax\n4: \ttestb\t$1, %dl\n7: \tjne\t0x17 <emit_digits+0x17>\n9: \tmovq\t%rax, %r10\nc: \tcmpq\t$1, %rdx\n10: \tjne\t0x50 <emit_digits+0x50>\n12: \tjmp\t0xbe <emit_digits+0xbe>\n17: \tmovslq\t%esi, %r8\n1a: \timulq\t$1717986919, %r8, %rsi  # imm = 0x66666667\n21: \tmovq\t%rsi, %rcx\n24: \tshrq\t$63, %rcx\n28: \tsarq\t$34, %rsi\n2c: \taddl\t%ecx, %esi\n2e: \tleal\t(%rsi,%rsi), %ecx\n31: \tleal\t(%rcx,%rcx,4), %ecx\n34: \tsubl\t%ecx, %r8d\n37: \taddb\t$48, %r8b\n3b: \tleaq\t-1(%rax), %r10\n3f: \tmovb\t%r8b, -1(%rax)\n43: \tcmpq\t$1, %rdx\n47: \tje\t0xbe <emit_digits+0xbe>\n49: \tnopl\t(%rax)\n50: \tmovslq\t%esi, %r8\n53: \timulq\t$1717986919, %r8, %rdx  # imm = 0x66666667\n5a: \tmovq\t%rdx, %rsi\n5d: \tshrq\t$63, %rsi\n61: \tsarq\t$34, %rdx\n65: \taddl\t%esi, %edx\n67: \tleal\t(%rdx,%rdx), %esi\n6a: \tleal\t(%rsi,%rsi,4), %r9d\n6e: \timulq\t$1374389535, %r8, %rsi  # imm = 0x51EB851F\n75: \tmovl\t%r8d, %ecx\n78: \tsubl\t%r9d, %ecx\n7b: \taddb\t$48, %cl\n7e: \tmovb\t%cl, -1(%r10)\n82: \tmovslq\t%edx, %rcx\n85: \timulq\t$1717986919, %rcx, %rdx # imm = 0x66666667\n8c: \tmovq\t%rdx, %r8\n8f: \tshrq\t$63, %r8\n93: \tsarq\t$34, %rdx\n97: \taddl\t%r8d, %edx\n9a: \taddl\t%edx, %edx\n9c: \tleal\t(%rdx,%rdx,4), %edx\n9f: \tsubl\t%edx, %ecx\na1: \taddb\t$48, %cl\na4: \tmovb\t%cl, -2(%r10)\na8: \taddq\t$-2, %r10\nac: \tmovq\t%rsi, %rcx\naf: \tshrq\t$63, %rcx\nb3: \tsarq\t$37, %rsi\nb7: \taddl\t%ecx, %esi\nb9: \tcmpq\t%r10, %rdi\nbc: \tjne\t0x50 <emit_digits+0x50>\nbe: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static char *emit_digits(char *dst, int n, size_t cnt)\n{\nchar *p = dst + cnt;\n\n/* emit digits from back */\ndo {\n*--p = '0' + n % 10;\nn /= 10;\n} while (p != dst);\n\nreturn dst + cnt;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static void emit_digits(char *buf, int buf_size, int n)\n{\nchar *p = buf + buf_size;\n\nwhile (n) {\n*--p = '0' + (n % 10);\nn /= 10;\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_socket_notify_write",
    "input":"\n0000000000000000 <h2o_socket_notify_write>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \txorl\t%edi, %edi\nc: \tcmpq\t$0, (%rbx)\n10: \tsete\t%dil\n14: \tcallq\t0x19 <h2o_socket_notify_write+0x19>\n19: \txorl\t%edi, %edi\n1b: \tcmpq\t$0, 8(%rbx)\n20: \tsete\t%dil\n24: \tcallq\t0x29 <h2o_socket_notify_write+0x29>\n29: \tmovq\t%r14, (%rbx)\n2c: \tmovq\t%rbx, %rdi\n2f: \taddq\t$8, %rsp\n33: \tpopq\t%rbx\n34: \tpopq\t%r14\n36: \tjmp\t0x3b <h2o_socket_notify_write+0x3b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * write; } ;\nstruct TYPE_6__ {TYPE_2__ _cb; } ;\nstruct TYPE_4__ {scalar_t__ cnt; } ;\nstruct st_h2o_evloop_socket_t {TYPE_3__ super; TYPE_1__ _wreq; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/ * h2o_socket_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  link_to_statechanged (struct st_h2o_evloop_socket_t*) ;\n\nvoid h2o_socket_notify_write(h2o_socket_t *_sock, h2o_socket_cb cb)\n{\nstruct st_h2o_evloop_socket_t *sock = (struct st_h2o_evloop_socket_t *)_sock;\nassert(sock->super._cb.write == NULL);\nassert(sock->_wreq.cnt == 0);\n\nsock->super._cb.write = cb;\nlink_to_statechanged(sock);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ write_req; scalar_t__ write_in_progress; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_socket_notify_write_complete (TYPE_1__*) ;\n\nvoid h2o_socket_notify_write(h2o_socket_t *sock, int is_error)\n{\nassert(sock->write_req == 0);\nassert(sock->write_in_progress == 0);\nsock->write_req = is_error;\nh2o_socket_notify_write_complete(sock);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_socket_connect",
    "input":"\n0000000000000000 <h2o_socket_connect>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t%ecx, %r14d\nb: \tmovl\t%edx, %r12d\ne: \tmovq\t%rsi, %rbx\n11: \tmovq\t%rdi, %r15\n14: \tmovl\t(%rsi), %edi\n16: \tmovl\t(%rip), %esi  # 0x1c <h2o_socket_connect+0x1c>\n1c: \txorl\t%edx, %edx\n1e: \tcallq\t0x23 <h2o_socket_connect+0x23>\n23: \tcmpl\t$-1, %eax\n26: \tje\t0x89 <h2o_socket_connect+0x89>\n28: \tmovl\t%eax, %ebp\n2a: \tmovl\t(%rip), %esi  # 0x30 <h2o_socket_connect+0x30>\n30: \tmovl\t(%rip), %edx  # 0x36 <h2o_socket_connect+0x36>\n36: \tmovl\t%eax, %edi\n38: \tcallq\t0x3d <h2o_socket_connect+0x3d>\n3d: \tmovl\t%ebp, %edi\n3f: \tmovq\t%rbx, %rsi\n42: \tmovl\t%r12d, %edx\n45: \tcallq\t0x4a <h2o_socket_connect+0x4a>\n4a: \ttestq\t%rax, %rax\n4d: \tje\t0x5f <h2o_socket_connect+0x5f>\n4f: \tmovq\t(%rip), %rax  # 0x56 <h2o_socket_connect+0x56>\n56: \tcmpq\t(%rip), %rax  # 0x5d <h2o_socket_connect+0x5d>\n5d: \tjne\t0x82 <h2o_socket_connect+0x82>\n5f: \tmovl\t(%rip), %edx  # 0x65 <h2o_socket_connect+0x65>\n65: \tmovq\t%r15, %rdi\n68: \tmovl\t%ebp, %esi\n6a: \tcallq\t0x6f <h2o_socket_connect+0x6f>\n6f: \tmovq\t%rax, %rbx\n72: \tmovq\t%rax, %rdi\n75: \tmovl\t%r14d, %esi\n78: \tcallq\t0x7d <h2o_socket_connect+0x7d>\n7d: \tmovq\t%rbx, %rax\n80: \tjmp\t0x8b <h2o_socket_connect+0x8b>\n82: \tmovl\t%ebp, %edi\n84: \tcallq\t0x89 <h2o_socket_connect+0x89>\n89: \txorl\t%eax, %eax\n8b: \tpopq\t%rbx\n8c: \tpopq\t%r12\n8e: \tpopq\t%r14\n90: \tpopq\t%r15\n92: \tpopq\t%rbp\n93: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  super; } ;\nstruct sockaddr {int /*<<< orphan*/  sa_family; } ;\ntypedef  int /*<<< orphan*/  socklen_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  int /*<<< orphan*/  h2o_socket_cb ;\ntypedef  int /*<<< orphan*/  h2o_loop_t ;\n\n/* Variables and functions */\nscalar_t__ EINPROGRESS ;\nint /*<<< orphan*/  F_SETFL ;\nint /*<<< orphan*/  H2O_SOCKET_FLAG_IS_CONNECTING ;\nint /*<<< orphan*/  O_NONBLOCK ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint cloexec_socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  close (int) ;\nscalar_t__ connect (int,struct sockaddr*,int /*<<< orphan*/ ) ;\nstruct st_h2o_evloop_socket_t* create_socket_set_nodelay (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ;\nscalar_t__ errno ;\nint /*<<< orphan*/  fcntl (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_notify_write (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nh2o_socket_t *h2o_socket_connect(h2o_loop_t *loop, struct sockaddr *addr, socklen_t addrlen, h2o_socket_cb cb)\n{\nint fd;\nstruct st_h2o_evloop_socket_t *sock;\n\nif ((fd = cloexec_socket(addr->sa_family, SOCK_STREAM, 0)) == -1)\nreturn NULL;\nfcntl(fd, F_SETFL, O_NONBLOCK);\nif (!(connect(fd, addr, addrlen) == 0 || errno == EINPROGRESS)) {\nclose(fd);\nreturn NULL;\n}\n\nsock = create_socket_set_nodelay(loop, fd, H2O_SOCKET_FLAG_IS_CONNECTING);\nh2o_socket_notify_write(&sock->super, cb);\nreturn &sock->super;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr {int dummy; } ;\nstruct TYPE_3__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint /*<<< orphan*/  SO_REUSEADDR ;\nint /*<<< orphan*/  SO_REUSEPORT ;\nint /*<<< orphan*/  SO_TYPE ;\nint /*<<< orphan*/  SOL_SOCKET ;\nint /*<<< orphan*/  close (int) ;\nint connect (int,struct sockaddr*,int) ;\nint /*<<< orphan*/  fcntl (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_init (TYPE_1__*,int) ;\nscalar_t__ h2o_socket_is_accepted (TYPE_1__*) ;\nint /*<<< orphan*/  setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nh2o_socket_t *h2o_socket_connect(h2o_socket_t *sock, struct sockaddr *addr, socklen_t addrlen, int flags)\n{\nint fd;\n\nif ((fd = socket(addr->sa_family, SOCK_STREAM, 0)) == -1)\nreturn NULL;\nif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &SO_REUSEADDR, sizeof(SO_REUSEADDR)) != 0 &&\nsetsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &SO_REUSEPORT, sizeof(SO_REUSEPORT)) != 0)\nclose(fd);\nif (h2o_socket_is_accepted(sock))\nh2o_socket_init(sock, fd);\nelse {\nh2o_socket_init(&sock[1], fd);\nif (connect(fd, addr, addrlen) != 0)\nclose(fd);\n}\nreturn sock;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_disable_latency_optimized_write",
    "input":"\n0000000000000000 <disable_latency_optimized_write>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcmpq\t$0, 16(%rdi)\n9: \tje\t0x1d <disable_latency_optimized_write+0x1d>\nb: \tmovq\t%rsi, %rax\ne: \tmovq\t%rbx, %rdi\n11: \txorl\t%esi, %esi\n13: \tcallq\t*%rax\n15: \tmovq\t$0, 16(%rbx)\n1d: \tmovl\t(%rip), %eax  # 0x23 <disable_latency_optimized_write+0x23>\n23: \tmovl\t%eax, 8(%rbx)\n26: \tmovl\t$16384, (%rbx)# imm = 0x4000\n2c: \tmovl\t(%rip), %eax  # 0x32 <disable_latency_optimized_write+0x32>\n32: \tmovl\t%eax, 4(%rbx)\n35: \tpopq\t%rbx\n36: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int suggested_tls_payload_size; int /*<<< orphan*/  suggested_write_size; int /*<<< orphan*/  state; scalar_t__ notsent_is_minimized; } ;\nstruct TYPE_7__ {TYPE_1__ _latency_optimization; } ;\ntypedef  TYPE_2__ h2o_socket_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SOCKET_LATENCY_OPTIMIZATION_STATE_DISABLED ;\nint /*<<< orphan*/  SIZE_MAX ;\n\n__attribute__((used)) static void disable_latency_optimized_write(h2o_socket_t *sock, int (*adjust_notsent_lowat)(h2o_socket_t *, unsigned))\n{\nif (sock->_latency_optimization.notsent_is_minimized) {\nadjust_notsent_lowat(sock, 0);\nsock->_latency_optimization.notsent_is_minimized = 0;\n}\nsock->_latency_optimization.state = H2O_SOCKET_LATENCY_OPTIMIZATION_STATE_DISABLED;\nsock->_latency_optimization.suggested_tls_payload_size = 16384;\nsock->_latency_optimization.suggested_write_size = SIZE_MAX;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  latency_optimized_write; int /*<<< orphan*/  latency_optimized_write_enabled; int /*<<< orphan*/  latency_optimized_write_callback; scalar_t__ latency_optimized_write_callback_data; } ;\ntypedef  TYPE_1__ AVIOContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AVIO_FLAG_WRITE ;\nint /*<<< orphan*/  av_freep (scalar_t__*) ;\nint /*<<< orphan*/  stub1 (TYPE_1__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void disable_latency_optimized_write(AVIOContext *s,\nvoid (*callback)(AVIOContext *s1, int bw))\n{\nif (s->latency_optimized_write_callback_data) {\ncallback(s, 0);\nav_freep(&s->latency_optimized_write_callback_data);\n}\ns->latency_optimized_write_enabled = 0;\ns->latency_optimized_write = 16384;\ns->latency_optimized_write_callback = AVIO_FLAG_WRITE;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_multithread_destroy_queue",
    "input":"\n0000000000000000 <h2o_multithread_destroy_queue>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tleaq\t12(%rdi), %r14\nb: \taddq\t$16, %rdi\nf: \tcallq\t0x14 <h2o_multithread_destroy_queue+0x14>\n14: \tmovl\t%eax, %edi\n16: \tcallq\t0x1b <h2o_multithread_destroy_queue+0x1b>\n1b: \tmovq\t%r14, %rdi\n1e: \tcallq\t0x23 <h2o_multithread_destroy_queue+0x23>\n23: \tmovl\t%eax, %edi\n25: \tcallq\t0x2a <h2o_multithread_destroy_queue+0x2a>\n2a: \tleaq\t8(%rbx), %rdi\n2e: \tcallq\t0x33 <h2o_multithread_destroy_queue+0x33>\n33: \tmovl\t4(%rbx), %edi\n36: \tcallq\t0x3b <h2o_multithread_destroy_queue+0x3b>\n3b: \tmovl\t4(%rbx), %edi\n3e: \tcallq\t0x43 <h2o_multithread_destroy_queue+0x43>\n43: \tmovq\t%rbx, %rdi\n46: \taddq\t$8, %rsp\n4a: \tpopq\t%rbx\n4b: \tpopq\t%r14\n4d: \tjmp\t0x52 <h2o_multithread_destroy_queue+0x52>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uv_handle_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  write; int /*<<< orphan*/  read; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  inactive; int /*<<< orphan*/  active; } ;\nstruct TYPE_8__ {TYPE_2__ async; int /*<<< orphan*/  mutex; TYPE_1__ receivers; } ;\ntypedef  TYPE_3__ h2o_multithread_queue_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  free (TYPE_3__*) ;\nint /*<<< orphan*/  h2o_linklist_is_empty (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_socket_close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_socket_read_stop (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  libuv_destroy_delayed ;\nint /*<<< orphan*/  pthread_mutex_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  uv_close (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nvoid h2o_multithread_destroy_queue(h2o_multithread_queue_t *queue)\n{\nassert(h2o_linklist_is_empty(&queue->receivers.active));\nassert(h2o_linklist_is_empty(&queue->receivers.inactive));\npthread_mutex_destroy(&queue->mutex);\n\n#if H2O_USE_LIBUV\nuv_close((uv_handle_t *)&queue->async, libuv_destroy_delayed);\n#else\nh2o_socket_read_stop(queue->async.read);\nh2o_socket_close(queue->async.read);\n#ifndef __linux__\n/* only one file descriptor is required for eventfd and already closed by h2o_socket_close() */\nclose(queue->async.write);\n#endif\nfree(queue);\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  cond; int /*<<< orphan*/  mutex; int /*<<< orphan*/  queue; int /*<<< orphan*/  num_threads; int /*<<< orphan*/  threads; } ;\ntypedef  TYPE_1__ h2o_multithread_queue_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_multithread_destroy_thread_pool (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_multithread_destroy_waiter_queue (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_multithread_mutex_destroy (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_multithread_queue_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_multithread_queue_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_multithread_thread_pool_destroy (int /*<<< orphan*/ ) ;\n\nvoid h2o_multithread_destroy_queue(h2o_multithread_queue_t *q)\n{\nh2o_multithread_thread_pool_destroy(q->threads);\nh2o_multithread_queue_destroy(&q->queue);\nh2o_multithread_mutex_destroy(q->mutex);\nh2o_multithread_destroy_waiter_queue(&q->queue);\nh2o_multithread_destroy_thread_pool(q->num_threads);\nh2o_multithread_mutex_destroy(q->cond);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_puts_bio",
    "input":"\n0000000000000000 <puts_bio>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovq\t%rsi, %rdi\nd: \tcallq\t0x12 <puts_bio+0x12>\n12: \tmovq\t%r14, %rdi\n15: \tmovq\t%rbx, %rsi\n18: \tmovl\t%eax, %edx\n1a: \taddq\t$8, %rsp\n1e: \tpopq\t%rbx\n1f: \tpopq\t%r14\n21: \tjmp\t0x26 <puts_bio+0x26>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nscalar_t__ strlen (char const*) ;\nint write_bio (int /*<<< orphan*/ *,char const*,int) ;\n\n__attribute__((used)) static int puts_bio(BIO *b, const char *str)\n{\nreturn write_bio(b, str, (int)strlen(str));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint BIO_write (int /*<<< orphan*/ *,char const*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strlen (char const*) ;\n\n__attribute__((used)) static int puts_bio(BIO *bp, const char *str)\n{\nreturn BIO_write(bp, str, strlen(str));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_socket_ssl_async_resumption_init",
    "input":"\n0000000000000000 <h2o_socket_ssl_async_resumption_init>:\n0: \tmovl\t%edi, (%rip)  # 0x6 <h2o_socket_ssl_async_resumption_init+0x6>\n6: \tmovl\t%esi, (%rip)  # 0xc <h2o_socket_ssl_async_resumption_init+0xc>\nc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_ssl_resumption_new_cb ;\ntypedef  int /*<<< orphan*/  h2o_socket_ssl_resumption_get_async_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  resumption_get_async ;\nint /*<<< orphan*/  resumption_new ;\n\nvoid h2o_socket_ssl_async_resumption_init(h2o_socket_ssl_resumption_get_async_cb get_async_cb,\nh2o_socket_ssl_resumption_new_cb new_cb)\n{\nresumption_get_async = get_async_cb;\nresumption_new = new_cb;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socket_ssl_resumption_state_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  async_resumption_state ;\nint /*<<< orphan*/  async_resumption_state_len ;\n\nvoid h2o_socket_ssl_async_resumption_init(h2o_socket_ssl_resumption_state_t *state, size_t len)\n{\nasync_resumption_state = state;\nasync_resumption_state_len = len;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_..........libcommonbalancerleast_conn.c_selector",
    "input":"\n0000000000000000 <selector>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tmovq\t%rdx, %r13\nc: \tmovq\t%rsi, %r15\nf: \tmovq\t%rdi, %r14\n12: \txorl\t%edi, %edi\n14: \tcmpq\t$0, (%rsi)\n18: \tsetne\t%dil\n1c: \tcallq\t0x21 <selector+0x21>\n21: \tmovq\t%r14, %rdi\n24: \tcallq\t0x29 <selector+0x29>\n29: \tmovq\t(%r15), %r9\n2c: \ttestq\t%r9, %r9\n2f: \tje\t0x98 <selector+0x98>\n31: \tmovq\t8(%r15), %r8\n35: \tmovq\t$-1, %r12\n3c: \tmovl\t$1, %r10d\n42: \txorl\t%r11d, %r11d\n45: \txorl\t%edx, %edx\n47: \tjmp\t0x62 <selector+0x62>\n49: \tnopl\t(%rax)\n50: \tmovq\t%rax, %r12\n53: \tmovq\t%rbx, %r11\n56: \tmovq\t%rcx, %r10\n59: \taddq\t$1, %rdx\n5d: \tcmpq\t%r9, %rdx\n60: \tjae\t0x9f <selector+0x9f>\n62: \tcmpb\t$0, (%r13,%rdx)\n68: \tjne\t0x59 <selector+0x59>\n6a: \tmovq\t(%r8,%rdx,8), %rax\n6e: \tmovq\t8(%rax), %rcx\n72: \tmovl\t(%rax), %ebx\n74: \taddl\t$1, %ebx\n77: \tmovq\t%rbx, %rdi\n7a: \timulq\t%r10, %rdi\n7e: \tmovq\t%rcx, %rsi\n81: \timulq\t%r11, %rsi\n85: \tmovq\t%rdx, %rax\n88: \tcmpq\t%rdi, %rsi\n8b: \tjb\t0x50 <selector+0x50>\n8d: \tmovq\t%r12, %rax\n90: \tmovq\t%r11, %rbx\n93: \tmovq\t%r10, %rcx\n96: \tjmp\t0x50 <selector+0x50>\n98: \tmovq\t$-1, %r12\n9f: \tmovq\t%r14, %rdi\na2: \tcallq\t0xa7 <selector+0xa7>\na7: \txorl\t%edi, %edi\na9: \tcmpq\t(%r15), %r12\nac: \tsetb\t%dil\nb0: \tcallq\t0xb5 <selector+0xb5>\nb5: \tmovq\t%r12, %rax\nb8: \tpopq\t%rbx\nb9: \tpopq\t%r12\nbb: \tpopq\t%r13\nbd: \tpopq\t%r14\nbf: \tpopq\t%r15\nc1: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  size_t uint64_t ;\nstruct least_conn_t {int /*<<< orphan*/  mutex; } ;\nstruct TYPE_9__ {size_t size; TYPE_3__** entries; } ;\ntypedef  TYPE_4__ h2o_socketpool_target_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\nstruct TYPE_7__ {scalar_t__ weight_m1; } ;\nstruct TYPE_6__ {size_t leased_count; } ;\nstruct TYPE_8__ {TYPE_2__ conf; TYPE_1__ _shared; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static size_t selector(h2o_balancer_t *_self, h2o_socketpool_target_vector_t *targets, char *tried)\n{\nstruct least_conn_t *self = (void *)_self;\nsize_t i;\nsize_t result_index = -1;\nsize_t result_weight = 0;\nsize_t result_leased = 1;\nuint64_t leftprod, rightprod;\n\nassert(targets->size != 0);\npthread_mutex_lock(&self->mutex);\nfor (i = 0; i < targets->size; i++) {\nleftprod = targets->entries[i]->_shared.leased_count;\nleftprod *= result_weight;\nrightprod = result_leased;\nrightprod *= ((unsigned)targets->entries[i]->conf.weight_m1) + 1;\nif (!tried[i] && leftprod < rightprod) {\nresult_index = i;\nresult_leased = targets->entries[i]->_shared.leased_count;\nresult_weight = ((unsigned)targets->entries[i]->conf.weight_m1) + 1;\n}\n}\npthread_mutex_unlock(&self->mutex);\n\nassert(result_index < targets->size);\nreturn result_index;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t n; size_t* m; int /*<<< orphan*/ ** p; } ;\ntypedef  TYPE_1__ GMatchState ;\n\n/* Variables and functions */\nint /*<<< orphan*/  luaL_checkstack (int /*<<< orphan*/ *,int,char*) ;\nint /*<<< orphan*/  lua_pushinteger (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_pushnil (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_tointeger (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static int selector (GMatchState *ms, int e, const char *s) {\nint level;\nint idx;\nint anchor = 0;\nfor (level = 0; level < ms->n; level++) {\nidx = ms->p[level][0];\nif (s[idx] == '\\0') {\nif (level == 0)\nreturn -1;  /* match failed */\nelse\nreturn anchor;  /* return match at this level */\n}\nif (s[idx] == '[') {\ndo {  /* look for matching `]' */\nidx++;\nif (s[idx] == '\\0')\nreturn -1;  /* error in pattern */\n} while (s[idx] != ']');\n}\nelse if (s[idx] != '(')\nreturn -1;  /* syntax error in pattern */\nelse {\ndo {  /* look for matching `)' */\nidx++;\nif (s[idx] == '\\0')\nreturn -1;  /* error in pattern */\nif (s[idx] == ')') {\nif (level == 0)\nreturn -1;  /* error in pattern */\nlevel--;\n}\n} while (s[idx] != ')');\n}\nif (level == 0)  /* match won */\nreturn idx + 1;\n}\nreturn -1;  /* match failed */  /* control never reaches here */\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_least_conn.c_test_least_conn",
    "input":"\n0000000000000000 <test_least_conn>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tsubq\t$32, %rsp\nd: \tmovl\t$10, %edi\n12: \tcallq\t0x17 <test_least_conn+0x17>\n17: \tmovq\t%rax, (%rsp)\n1b: \tmovq\t%rdx, 8(%rsp)\n20: \tmovw\t$0, 24(%rsp)\n27: \tmovq\t$0, 16(%rsp)\n30: \txorl\t%eax, %eax\n32: \tcallq\t0x37 <test_least_conn+0x37>\n37: \tmovq\t%rax, %r14\n3a: \tmovl\t$10000, %r13d # imm = 0x2710\n40: \tmovq\t%rsp, %r12\n43: \tleaq\t16(%rsp), %r15\n48: \tnopl\t(%rax,%rax)\n50: \tmovq\t%r14, %rdi\n53: \tmovq\t%r12, %rsi\n56: \tmovq\t%r15, %rdx\n59: \tcallq\t0x5e <test_least_conn+0x5e>\n5e: \tmovq\t%rax, %rbx\n61: \tcmpq\t$11, %rax\n65: \tjae\t0x90 <test_least_conn+0x90>\n67: \tmovq\t%r12, %rdi\n6a: \tmovq\t%rbx, %rsi\n6d: \tcallq\t0x72 <test_least_conn+0x72>\n72: \tcmpl\t$-1, %eax\n75: \tje\t0x99 <test_least_conn+0x99>\n77: \tmovq\t8(%rsp), %rcx\n7c: \tmovq\t(%rcx,%rbx,8), %rcx\n80: \taddl\t$1, (%rcx)\n83: \taddq\t$-1, %r13\n87: \tjne\t0x50 <test_least_conn+0x50>\n89: \ttestl\t%eax, %eax\n8b: \tsete\t%al\n8e: \tjmp\t0x9b <test_least_conn+0x9b>\n90: \tcmpq\t(%rsp), %rbx\n94: \tsetb\t%al\n97: \tjmp\t0x9b <test_least_conn+0x9b>\n99: \txorl\t%eax, %eax\n9b: \tmovzbl\t%al, %edi\n9e: \tcallq\t0xa3 <test_least_conn+0xa3>\na3: \tmovq\t%rsp, %rdi\na6: \tcallq\t0xab <test_least_conn+0xab>\nab: \tmovq\t%r14, %rdi\nae: \tcallq\t0xb3 <test_least_conn+0xb3>\nb3: \taddq\t$32, %rsp\nb7: \tpopq\t%rbx\nb8: \tpopq\t%r12\nba: \tpopq\t%r13\nbc: \tpopq\t%r14\nbe: \tpopq\t%r15\nc0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {size_t size; TYPE_2__** entries; } ;\ntypedef  TYPE_3__ h2o_socketpool_target_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\nstruct TYPE_8__ {int /*<<< orphan*/  leased_count; } ;\nstruct TYPE_9__ {TYPE_1__ _shared; } ;\n\n/* Variables and functions */\nint check_if_acceptable (TYPE_3__*,size_t) ;\nint /*<<< orphan*/  destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free_targets (TYPE_3__*) ;\nTYPE_3__ gen_targets (int) ;\nint /*<<< orphan*/ * h2o_balancer_create_lc () ;\nint /*<<< orphan*/  ok (int) ;\nsize_t selector (int /*<<< orphan*/ *,TYPE_3__*,char*) ;\n\n__attribute__((used)) static void test_least_conn(void)\n{\nh2o_socketpool_target_vector_t targets = gen_targets(10);\nsize_t i, selected;\nchar tried[10] = {0};\nint check_result = 1;\nh2o_balancer_t *balancer;\n\nbalancer = h2o_balancer_create_lc();\n\nfor (i = 0; i < 10000; i++) {\nselected = selector(balancer, &targets, tried);\nif (selected > 10) {\nok(selected >= 0 && selected < targets.size);\ngoto Done;\n}\ncheck_result = check_if_acceptable(&targets, selected);\nif (check_result == -1) {\nok(!check_result);\ngoto Done;\n}\ntargets.entries[selected]->_shared.leased_count++;\n}\nok(!check_result);\n\nDone:\nfree_targets(&targets);\ndestroy(balancer);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct server {int /*<<< orphan*/  conns; } ;\nstruct conn_info {int /*<<< orphan*/  server; } ;\nstruct context {int dummy; } ;\nstruct event_base {int dummy; } ;\nstruct event {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ASSERT (int) ;\nint /*<<< orphan*/  conn_info_free (struct conn_info*) ;\nint /*<<< orphan*/  conn_info_init (struct conn_info*) ;\nint /*<<< orphan*/  conn_info_print (struct conn_info*) ;\nint /*<<< orphan*/  conn_info_set_server (struct conn_info*,struct server*) ;\nint /*<<< orphan*/  conn_info_set_type (struct conn_info*,char*) ;\nint /*<<< orphan*/  conn_info_set_value (struct conn_info*,char*,char*) ;\nint /*<<< orphan*/  event_base_free (struct event_base*) ;\nstruct event_base* event_base_new () ;\nint /*<<< orphan*/  event_free (struct event*) ;\nint /*<<< orphan*/  event_loop (struct event_base*,int) ;\nint /*<<< orphan*/  event_set (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock (struct event*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  event_timeradd_periodic_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_nolock_"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_least_conn.c_test_lib__common__balancer__least_conn_c",
    "input":"\n0000000000000000 <test_lib__common__balancer__least_conn_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__balancer__least_conn_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__balancer__least_conn_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__balancer__least_conn_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_lib__common__balancer__least_conn_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_lib__common__balancer__least_conn_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tpopq\t%rax\n2d: \tjmp\t0x32 <test_lib__common__balancer__least_conn_c+0x32>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_least_conn ;\nint /*<<< orphan*/  test_least_conn_weighted ;\nint /*<<< orphan*/  test_when_backend_down ;\n\nvoid test_lib__common__balancer__least_conn_c(void)\n{\nsubtest(\"when_backend_down\", test_when_backend_down);\nsubtest(\"least_conn\", test_least_conn);\nsubtest(\"least_conn_weighted\", test_least_conn_weighted);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_1 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_2 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_3 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_4 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_5 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_6 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_7 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_8 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_9 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_10 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_11 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_12 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_13 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_14 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_15 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_16 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_17 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_18 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_19 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_20 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_21 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_22 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_23 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_24 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_25 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_26 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_27 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_28 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_29 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_30 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_31 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_32 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_33 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_34 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_35 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_36 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_37 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_38 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_39 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_40 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_41 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_42 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_43 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_44 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_45 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_46 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_47 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_48 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_49 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_50 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_51 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_52 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_53 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_54 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_55 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_56 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_57 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_58 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_59 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_60 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_61 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_62 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_63 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_64 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_65 ;\nint /*<<< orphan*/  TEST_BALANCER_LEAST_CONN_C_66 ;\nint"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_roundrobin.c_test_when_backend_down",
    "input":"\n0000000000000000 <test_when_backend_down>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tsubq\t$32, %rsp\nd: \tmovl\t$10, %edi\n12: \tcallq\t0x17 <test_when_backend_down+0x17>\n17: \tmovl\t%eax, 12(%rsp)\n1b: \tmovw\t$0, 24(%rsp)\n22: \tmovq\t$0, 16(%rsp)\n2b: \txorl\t%eax, %eax\n2d: \tcallq\t0x32 <test_when_backend_down+0x32>\n32: \tmovq\t%rax, %r12\n35: \tmovl\t$10, %ebx\n3a: \tleaq\t12(%rsp), %r14\n3f: \tleaq\t16(%rsp), %r15\n44: \tnopw\t%cs:(%rax,%rax)\n4e: \tnop\n50: \tmovq\t%r12, %rdi\n53: \tmovq\t%r14, %rsi\n56: \tmovq\t%r15, %rdx\n59: \tcallq\t0x5e <test_when_backend_down+0x5e>\n5e: \tmovq\t%rax, %r13\n61: \txorl\t%edi, %edi\n63: \tcmpq\t$10, %rax\n67: \tsetb\t%dil\n6b: \tcallq\t0x70 <test_when_backend_down+0x70>\n70: \txorl\t%edi, %edi\n72: \tcmpb\t$0, 16(%rsp,%r13)\n78: \tsete\t%dil\n7c: \tcallq\t0x81 <test_when_backend_down+0x81>\n81: \tmovb\t$1, 16(%rsp,%r13)\n87: \taddq\t$-1, %rbx\n8b: \tjne\t0x50 <test_when_backend_down+0x50>\n8d: \tmovq\t%r12, %rdi\n90: \tcallq\t0x95 <test_when_backend_down+0x95>\n95: \tleaq\t12(%rsp), %rdi\n9a: \tcallq\t0x9f <test_when_backend_down+0x9f>\n9f: \taddq\t$32, %rsp\na3: \tpopq\t%rbx\na4: \tpopq\t%r12\na6: \tpopq\t%r13\na8: \tpopq\t%r14\naa: \tpopq\t%r15\nac: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socketpool_target_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free_targets (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  gen_targets (int) ;\nint /*<<< orphan*/ * h2o_balancer_create_rr () ;\nint /*<<< orphan*/  ok (int) ;\nsize_t selector (int /*<<< orphan*/ *,int /*<<< orphan*/ *,char*) ;\n\n__attribute__((used)) static void test_when_backend_down(void)\n{\nh2o_socketpool_target_vector_t targets = gen_targets(10);\nchar tried[10] = {0};\nsize_t i;\nsize_t selected;\nh2o_balancer_t *balancer;\n\nbalancer = h2o_balancer_create_rr();\n\nfor (i = 0; i < 10; i++) {\nselected = selector(balancer, &targets, tried);\nok(selected >= 0 && selected < 10);\nok(!tried[selected]);\ntried[selected] = 1;\n}\n\ndestroy(balancer);\n\nfree_targets(&targets);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  PGresult ;\ntypedef  int /*<<< orphan*/  PGconn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PQclear (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * PQexec (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  PQfinish (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PQgetResult (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PQsetSingleRowMode (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  assert (int) ;\n\n__attribute__((used)) static void\ntest_when_backend_down(void)\n{\nPGconn\t   *conn;\nPGresult   *res;\nint\t\t\ti;\n\nconn = PQconnectdb(\"dbname=nonexistent\");\nassert(conn);\n\nPQsetSingleRowMode(conn);\n\nfor (i = 0; i < 10; i++)\n{\nres = PQexec(conn, \"SELECT 1\");\nassert(res);\nassert(res->nfields == 1);\nassert(res->binary[0] == 0);\nres->binary[0] = 1;\nPQclear(res);\n}\n\nPQfinish(conn);\nPQgetResult(conn);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_roundrobin.c_gen_targets",
    "input":"\n0000000000000000 <gen_targets>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %r15\nb: \txorps\t%xmm0, %xmm0\ne: \tmovups\t%xmm0, (%rdi)\n11: \tmovq\t$0, 16(%rdi)\n19: \txorl\t%edi, %edi\n1b: \tmovq\t%r15, %rsi\n1e: \tmovq\t%r14, %rdx\n21: \tcallq\t0x26 <gen_targets+0x26>\n26: \ttestq\t%r14, %r14\n29: \tje\t0x51 <gen_targets+0x51>\n2b: \txorl\t%ebx, %ebx\n2d: \tnopl\t(%rax)\n30: \tmovl\t$16, %edi\n35: \tcallq\t0x3a <gen_targets+0x3a>\n3a: \txorps\t%xmm0, %xmm0\n3d: \tmovups\t%xmm0, (%rax)\n40: \tmovq\t8(%r15), %rcx\n44: \tmovq\t%rax, (%rcx,%rbx,8)\n48: \taddq\t$1, %rbx\n4c: \tcmpq\t%rbx, %r14\n4f: \tjne\t0x30 <gen_targets+0x30>\n51: \tmovq\t%r14, (%r15)\n54: \tmovq\t%r15, %rax\n57: \tpopq\t%rbx\n58: \tpopq\t%r14\n5a: \tpopq\t%r15\n5c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_4__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {size_t size; TYPE_4__** entries; int /*<<< orphan*/ * member_0; } ;\ntypedef  TYPE_3__ h2o_socketpool_target_vector_t ;\nstruct TYPE_9__ {scalar_t__ weight_m1; } ;\nstruct TYPE_8__ {scalar_t__ leased_count; } ;\nstruct TYPE_11__ {TYPE_2__ conf; TYPE_1__ _shared; } ;\ntypedef  TYPE_4__ h2o_socketpool_target_t ;\n\n/* Variables and functions */\nTYPE_4__* h2o_mem_alloc (int) ;\nint /*<<< orphan*/  h2o_vector_reserve (int /*<<< orphan*/ *,TYPE_3__*,size_t) ;\n\n__attribute__((used)) static h2o_socketpool_target_vector_t gen_targets(size_t size)\n{\nsize_t i;\nh2o_socketpool_target_vector_t targets = {NULL};\n\nh2o_vector_reserve(NULL, &targets, size);\nfor (i = 0; i < size; i++) {\nh2o_socketpool_target_t *target = h2o_mem_alloc(sizeof(*target));\ntarget->_shared.leased_count = 0;\ntarget->conf.weight_m1 = 0;\ntargets.entries[i] = target;\n}\ntargets.size = size;\n\nreturn targets;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ ntargets; int /*<<< orphan*/ * targets; } ;\ntypedef  TYPE_1__ GTargets ;\ntypedef  int /*<<< orphan*/  GTarget ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_malloc0 (int) ;\nint /*<<< orphan*/ * g_new0 (int /*<<< orphan*/ *,scalar_t__) ;\n\n__attribute__((used)) static GTargets *gen_targets(GTarget *targets, size_t ntargets) {\nGTargets *ts = g_malloc0(sizeof(GTargets));\nts->ntargets = 0;\nts->targets = g_new0(GTarget *, ntargets);\nif (ntargets) {\nsize_t i;\nfor (i = 0; i < ntargets; i++) {\nts->targets[i] = g_malloc0(sizeof(GTarget));\n}\nts->ntargets = ntargets;\n}\nassert(ts->ntargets == ntargets);\nreturn ts;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_least_conn.c_gen_targets",
    "input":"\n0000000000000000 <gen_targets>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %r15\nb: \txorps\t%xmm0, %xmm0\ne: \tmovups\t%xmm0, (%rdi)\n11: \tmovq\t$0, 16(%rdi)\n19: \txorl\t%edi, %edi\n1b: \tmovq\t%r15, %rsi\n1e: \tmovq\t%r14, %rdx\n21: \tcallq\t0x26 <gen_targets+0x26>\n26: \ttestq\t%r14, %r14\n29: \tje\t0x51 <gen_targets+0x51>\n2b: \txorl\t%ebx, %ebx\n2d: \tnopl\t(%rax)\n30: \tmovl\t$16, %edi\n35: \tcallq\t0x3a <gen_targets+0x3a>\n3a: \txorps\t%xmm0, %xmm0\n3d: \tmovups\t%xmm0, (%rax)\n40: \tmovq\t8(%r15), %rcx\n44: \tmovq\t%rax, (%rcx,%rbx,8)\n48: \taddq\t$1, %rbx\n4c: \tcmpq\t%rbx, %r14\n4f: \tjne\t0x30 <gen_targets+0x30>\n51: \tmovq\t%r14, (%r15)\n54: \tmovq\t%r15, %rax\n57: \tpopq\t%rbx\n58: \tpopq\t%r14\n5a: \tpopq\t%r15\n5c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_4__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {size_t size; TYPE_4__** entries; int /*<<< orphan*/ * member_0; } ;\ntypedef  TYPE_3__ h2o_socketpool_target_vector_t ;\nstruct TYPE_9__ {scalar_t__ weight_m1; } ;\nstruct TYPE_8__ {scalar_t__ leased_count; } ;\nstruct TYPE_11__ {TYPE_2__ conf; TYPE_1__ _shared; } ;\ntypedef  TYPE_4__ h2o_socketpool_target_t ;\n\n/* Variables and functions */\nTYPE_4__* h2o_mem_alloc (int) ;\nint /*<<< orphan*/  h2o_vector_reserve (int /*<<< orphan*/ *,TYPE_3__*,size_t) ;\n\n__attribute__((used)) static h2o_socketpool_target_vector_t gen_targets(size_t size)\n{\nsize_t i;\nh2o_socketpool_target_vector_t targets = {NULL};\n\nh2o_vector_reserve(NULL, &targets, size);\nfor (i = 0; i < size; i++) {\nh2o_socketpool_target_t *target = h2o_mem_alloc(sizeof(*target));\ntarget->_shared.leased_count = 0;\ntarget->conf.weight_m1 = 0;\ntargets.entries[i] = target;\n}\ntargets.size = size;\n\nreturn targets;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ ntargets; int /*<<< orphan*/ * targets; } ;\ntypedef  TYPE_1__ GTargets ;\ntypedef  int /*<<< orphan*/  GTarget ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_malloc0 (int) ;\nint /*<<< orphan*/ * g_new0 (int /*<<< orphan*/ *,scalar_t__) ;\n\n__attribute__((used)) static GTargets *gen_targets(GTarget *targets, size_t ntargets) {\nGTargets *ts = g_malloc0(sizeof(GTargets));\nts->ntargets = 0;\nts->targets = g_new0(GTarget *, ntargets);\nif (ntargets) {\nsize_t i;\nfor (i = 0; i < ntargets; i++) {\nts->targets[i] = g_malloc0(sizeof(GTarget));\n}\nts->ntargets = ntargets;\n}\nassert(ts->ntargets == ntargets);\nreturn ts;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_..........libcommonbalancerroundrobin.c_select_next",
    "input":"\n0000000000000000 <select_next>:\n0: \tmovq\t(%rdi), %rax\n3: \taddq\t$1, %rax\n7: \tmovq\t%rax, (%rdi)\na: \txorl\t%ecx, %ecx\nc: \tcmpq\t(%rsi), %rax\nf: \tcmovneq\t%rax, %rcx\n13: \tmovq\t%rcx, (%rdi)\n16: \tmovq\t$0, 8(%rdi)\n1e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct round_robin_t {scalar_t__ pos; scalar_t__ consumed_weight; } ;\nstruct TYPE_3__ {scalar_t__ size; } ;\ntypedef  TYPE_1__ h2o_socketpool_target_vector_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static inline void select_next(struct round_robin_t *self, h2o_socketpool_target_vector_t *targets)\n{\nself->pos += 1;\nif (self->pos == targets->size)\nself->pos = 0;\nself->consumed_weight = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ n; scalar_t__ n_selected; } ;\ntypedef  TYPE_1__ GList ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void\nselect_next (GList *list, GList *selected)\n{\nlist->n++;\nif (list->n == selected->n)\nlist->n = 0;\nlist->n_selected = 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_least_conn.c_check_if_acceptable",
    "input":"\n0000000000000000 <check_if_acceptable>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0x64 <check_if_acceptable+0x64>\n8: \tmovq\t8(%rdi), %r8\nc: \tmovq\t(%r8,%rsi,8), %rdx\n10: \tmovsd\t8(%rdx), %xmm0# xmm0 = mem[0],zero\n15: \tmovl\t(%rdx), %edx\n17: \taddl\t$1, %edx\n1a: \tcvtsi2sd\t%edx, %xmm1\n1e: \tdivsd\t%xmm1, %xmm0\n22: \txorl\t%edx, %edx\n24: \tjmp\t0x39 <check_if_acceptable+0x39>\n26: \tnopw\t%cs:(%rax,%rax)\n30: \taddq\t$1, %rdx\n34: \tcmpq\t%rax, %rdx\n37: \tjae\t0x64 <check_if_acceptable+0x64>\n39: \tcmpq\t%rdx, %rsi\n3c: \tje\t0x30 <check_if_acceptable+0x30>\n3e: \tmovq\t(%r8,%rdx,8), %rdi\n42: \tmovl\t(%rdi), %ecx\n44: \taddl\t$1, %ecx\n47: \txorps\t%xmm1, %xmm1\n4a: \tcvtsi2sd\t%rcx, %xmm1\n4f: \tmovsd\t8(%rdi), %xmm2# xmm2 = mem[0],zero\n54: \tdivsd\t%xmm1, %xmm2\n58: \tucomisd\t%xmm2, %xmm0\n5c: \tjbe\t0x30 <check_if_acceptable+0x30>\n5e: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n63: \tretq\n64: \txorl\t%eax, %eax\n66: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {size_t size; TYPE_3__** entries; } ;\ntypedef  TYPE_4__ h2o_socketpool_target_vector_t ;\nstruct TYPE_6__ {scalar_t__ weight_m1; } ;\nstruct TYPE_7__ {double leased_count; } ;\nstruct TYPE_8__ {TYPE_1__ conf; TYPE_2__ _shared; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int check_if_acceptable(h2o_socketpool_target_vector_t *targets, size_t selected)\n{\ndouble conn_weight_quotient;\nsize_t i;\ndouble selected_conn_weight_quotient = targets->entries[selected]->_shared.leased_count;\nselected_conn_weight_quotient /= ((int)targets->entries[selected]->conf.weight_m1) + 1;\n\nfor (i = 0; i < targets->size; i++) {\nif (i == selected)\ncontinue;\nconn_weight_quotient = targets->entries[i]->_shared.leased_count;\nconn_weight_quotient /= ((unsigned)targets->entries[i]->conf.weight_m1) + 1;\nif (conn_weight_quotient < selected_conn_weight_quotient) {\nreturn -1;\n}\n}\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {size_t n_acceptable; TYPE_1__* acceptable; } ;\nstruct TYPE_4__ {int n_acceptable; double acceptable_ratio; } ;\ntypedef  TYPE_2__ GLogicalIndex ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int\ncheck_if_acceptable(GLogicalIndex *index, int i)\n{\nint\t\t\tj;\n\nfor (j = 0; j < index->n_acceptable; j++)\n{\nif (index->acceptable[j].n_acceptable == i + 1 &&\nindex->acceptable[j].acceptable_ratio <= index->acceptable[i].acceptable_ratio)\nreturn -1;\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_..........libcommonbalancerroundrobin.c_selector",
    "input":"\n0000000000000000 <selector>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rdx, %r12\ne: \tmovq\t%rsi, %r15\n11: \tmovq\t%rdi, %r13\n14: \tleaq\t16(%rdi), %r14\n18: \tmovq\t%r14, %rdi\n1b: \tcallq\t0x20 <selector+0x20>\n20: \txorl\t%edi, %edi\n22: \tcmpq\t$0, (%r15)\n26: \tsetne\t%dil\n2a: \tcallq\t0x2f <selector+0x2f>\n2f: \tcmpq\t$0, (%r15)\n33: \tje\t0x5f <selector+0x5f>\n35: \txorl\t%ebp, %ebp\n37: \tnopw\t(%rax,%rax)\n40: \tmovq\t(%r13), %rbx\n44: \tcmpb\t$0, (%r12,%rbx)\n49: \tje\t0x6b <selector+0x6b>\n4b: \tmovq\t%r13, %rdi\n4e: \tmovq\t%r15, %rsi\n51: \tcallq\t0x56 <selector+0x56>\n56: \taddq\t$1, %rbp\n5a: \tcmpq\t(%r15), %rbp\n5d: \tjb\t0x40 <selector+0x40>\n5f: \tmovl\t$0, %edi\n64: \tcallq\t0x69 <selector+0x69>\n69: \tjmp\t0x97 <selector+0x97>\n6b: \tmovq\t8(%r13), %rax\n6f: \tleaq\t1(%rax), %rcx\n73: \tmovq\t%rcx, 8(%r13)\n77: \tmovq\t8(%r15), %rcx\n7b: \tmovq\t(%rcx,%rbx,8), %rcx\n7f: \tcmpq\t(%rcx), %rax\n82: \tjl\t0x8f <selector+0x8f>\n84: \tmovq\t%r13, %rdi\n87: \tmovq\t%r15, %rsi\n8a: \tcallq\t0x8f <selector+0x8f>\n8f: \tmovq\t%r14, %rdi\n92: \tcallq\t0x97 <selector+0x97>\n97: \tmovq\t%rbx, %rax\n9a: \taddq\t$8, %rsp\n9e: \tpopq\t%rbx\n9f: \tpopq\t%r12\na1: \tpopq\t%r13\na3: \tpopq\t%r14\na5: \tpopq\t%r15\na7: \tpopq\t%rbp\na8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct round_robin_t {size_t pos; scalar_t__ consumed_weight; int /*<<< orphan*/  mutex; } ;\nstruct TYPE_8__ {size_t size; TYPE_2__** entries; } ;\ntypedef  TYPE_3__ h2o_socketpool_target_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\nstruct TYPE_6__ {scalar_t__ weight_m1; } ;\nstruct TYPE_7__ {TYPE_1__ conf; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  h2o_fatal (char*) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  select_next (struct round_robin_t*,TYPE_3__*) ;\n\n__attribute__((used)) static size_t selector(h2o_balancer_t *balancer, h2o_socketpool_target_vector_t *targets, char *tried)\n{\nsize_t i;\nsize_t result = 0;\nstruct round_robin_t *self = (void *)balancer;\n\npthread_mutex_lock(&self->mutex);\n\nassert(targets->size != 0);\nfor (i = 0; i < targets->size; i++) {\nif (!tried[self->pos]) {\n/* get the result */\nresult = self->pos;\nif (++self->consumed_weight > targets->entries[self->pos]->conf.weight_m1)\nselect_next(self, targets);\npthread_mutex_unlock(&self->mutex);\nreturn result;\n} else {\nselect_next(self, targets);\n}\n}\nh2o_fatal(\"unreachable\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {size_t n; TYPE_1__* p; } ;\nstruct TYPE_9__ {size_t n; TYPE_2__* p; } ;\nstruct TYPE_8__ {size_t i; } ;\ntypedef  TYPE_2__ GMatch ;\ntypedef  TYPE_3__ GString ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  g_string_append_c (TYPE_3__*,char) ;\nint /*<<< orphan*/  g_string_append_len (TYPE_3__*,char*,size_t) ;\nint /*<<< orphan*/  g_string_append_printf (TYPE_3__*,char*,size_t) ;\n\n__attribute__((used)) static size_t\nselector(GString *s, GMatch *m, char *p)\n{\nsize_t i;\n\nassert(m->n > 0);\n\nfor (i = 0; i < m->n; i++)\n{\nif (p[m->p[i].i] == 0)\n{\nm->p[i].i++;\nif (m->p[i].i > s->len)\n{\ng_string_append_printf(s, \"\\\\%03d\", m->p[i].i);\n}\nelse\n{\ng_string_append_c(s, p[m->p[i].i]);\n}\n}\n}\n\ng_string_append_printf(s, \"\\\\%03d\", m->n);\n\nreturn m->p[i].i;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_..........libcommonbalancerleast_conn.c_destroy",
    "input":"\n0000000000000000 <destroy>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <destroy+0x9>\n9: \tmovq\t%rbx, %rdi\nc: \tpopq\t%rbx\nd: \tjmp\t0x12 <destroy+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct least_conn_t {int /*<<< orphan*/  mutex; } ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (struct least_conn_t*) ;\nint /*<<< orphan*/  pthread_mutex_destroy (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void destroy(h2o_balancer_t *_self)\n{\nstruct least_conn_t *self = (void *)_self;\npthread_mutex_destroy(&self->mutex);\nfree(self);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  m68k_disassemble_info ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  m68k_op_free (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void destroy(m68k_disassemble_info *info)\n{\nm68k_op_free(info);\nfree(info);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_roundrobin.c_test_lib__common__balancer__roundrobin_c",
    "input":"\n0000000000000000 <test_lib__common__balancer__roundrobin_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__balancer__roundrobin_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__balancer__roundrobin_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__balancer__roundrobin_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_lib__common__balancer__roundrobin_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_lib__common__balancer__roundrobin_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tpopq\t%rax\n2d: \tjmp\t0x32 <test_lib__common__balancer__roundrobin_c+0x32>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_round_robin ;\nint /*<<< orphan*/  test_round_robin_weighted ;\nint /*<<< orphan*/  test_when_backend_down ;\n\nvoid test_lib__common__balancer__roundrobin_c(void)\n{\nsubtest(\"when_backend_down\", test_when_backend_down);\nsubtest(\"round_robin\", test_round_robin);\nsubtest(\"round_robin_weighted\", test_round_robin_weighted);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER ;\nint /*<<< orphan*/  TEST_BALANCER_ROUNDROBIN_C_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER_BALANCER"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_..........libcommonbalancerroundrobin.c_destroy",
    "input":"\n0000000000000000 <destroy>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <destroy+0x9>\n9: \tmovq\t%rbx, %rdi\nc: \tpopq\t%rbx\nd: \tjmp\t0x12 <destroy+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct round_robin_t {int /*<<< orphan*/  mutex; } ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (struct round_robin_t*) ;\nint /*<<< orphan*/  pthread_mutex_destroy (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void destroy(h2o_balancer_t *balancer)\n{\nstruct round_robin_t *self = (void *)balancer;\npthread_mutex_destroy(&self->mutex);\nfree(self);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  m68k_disassemble_info ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  m68k_op_free (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void destroy(m68k_disassemble_info *info)\n{\nm68k_op_free(info);\nfree(info);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_least_conn.c_test_when_backend_down",
    "input":"\n0000000000000000 <test_when_backend_down>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tsubq\t$32, %rsp\nd: \tmovl\t$10, %edi\n12: \tcallq\t0x17 <test_when_backend_down+0x17>\n17: \tmovl\t%eax, 12(%rsp)\n1b: \tmovw\t$0, 24(%rsp)\n22: \tmovq\t$0, 16(%rsp)\n2b: \txorl\t%eax, %eax\n2d: \tcallq\t0x32 <test_when_backend_down+0x32>\n32: \tmovq\t%rax, %r12\n35: \tmovl\t$10, %ebx\n3a: \tleaq\t12(%rsp), %r14\n3f: \tleaq\t16(%rsp), %r15\n44: \tnopw\t%cs:(%rax,%rax)\n4e: \tnop\n50: \tmovq\t%r12, %rdi\n53: \tmovq\t%r14, %rsi\n56: \tmovq\t%r15, %rdx\n59: \tcallq\t0x5e <test_when_backend_down+0x5e>\n5e: \tmovq\t%rax, %r13\n61: \txorl\t%edi, %edi\n63: \tcmpq\t$10, %rax\n67: \tsetb\t%dil\n6b: \tcallq\t0x70 <test_when_backend_down+0x70>\n70: \txorl\t%edi, %edi\n72: \tcmpb\t$0, 16(%rsp,%r13)\n78: \tsete\t%dil\n7c: \tcallq\t0x81 <test_when_backend_down+0x81>\n81: \tmovb\t$1, 16(%rsp,%r13)\n87: \taddq\t$-1, %rbx\n8b: \tjne\t0x50 <test_when_backend_down+0x50>\n8d: \tleaq\t12(%rsp), %rdi\n92: \tcallq\t0x97 <test_when_backend_down+0x97>\n97: \tmovq\t%r12, %rdi\n9a: \tcallq\t0x9f <test_when_backend_down+0x9f>\n9f: \taddq\t$32, %rsp\na3: \tpopq\t%rbx\na4: \tpopq\t%r12\na6: \tpopq\t%r13\na8: \tpopq\t%r14\naa: \tpopq\t%r15\nac: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_socketpool_target_vector_t ;\ntypedef  int /*<<< orphan*/  h2o_balancer_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free_targets (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  gen_targets (int) ;\nint /*<<< orphan*/ * h2o_balancer_create_lc () ;\nint /*<<< orphan*/  ok (int) ;\nsize_t selector (int /*<<< orphan*/ *,int /*<<< orphan*/ *,char*) ;\n\n__attribute__((used)) static void test_when_backend_down(void)\n{\nh2o_socketpool_target_vector_t targets = gen_targets(10);\nchar tried[10] = {0};\nsize_t i;\nsize_t selected;\nh2o_balancer_t *balancer;\n\nbalancer = h2o_balancer_create_lc();\n\nfor (i = 0; i < 10; i++) {\nselected = selector(balancer, &targets, tried);\nok(selected >= 0 && selected < 10);\nok(!tried[selected]);\ntried[selected] = 1;\n}\n\nfree_targets(&targets);\ndestroy(balancer);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  PGresult ;\ntypedef  int /*<<< orphan*/  PGconn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PQclear (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * PQexec (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  PQfinish (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PQgetResult (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PQsetSingleRowMode (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  assert (int) ;\n\n__attribute__((used)) static void\ntest_when_backend_down(void)\n{\nPGconn\t   *conn;\nPGresult   *res;\nint\t\t\ti;\n\nconn = PQconnectdb(\"dbname=nonexistent\");\nassert(conn);\n\nPQsetSingleRowMode(conn);\n\nfor (i = 0; i < 10; i++)\n{\nres = PQexec(conn, \"SELECT 1\");\nassert(res);\nassert(res->nfields == 1);\nassert(res->binary[0] == 0);\nres->binary[0] = 1;\nPQclear(res);\n}\n\nPQgetResult(conn);\nPQfinish(conn);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/balancer/extr_roundrobin.c_check_weight_distribution",
    "input":"\n0000000000000000 <check_weight_distribution>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rdi), %r9\n4: \tmovl\t$1, %eax\n9: \ttestq\t%r9, %r9\nc: \tje\t0x5c <check_weight_distribution+0x5c>\ne: \txorl\t%ecx, %ecx\n10: \tleaq\t1(%rcx), %r8\n14: \tcmpq\t%r9, %r8\n17: \tjae\t0x5c <check_weight_distribution+0x5c>\n19: \tmovq\t8(%rdi), %r10\n1d: \tmovq\t(%r10,%rcx,8), %rcx\n21: \tmovl\t(%rcx), %edx\n23: \tmovl\t8(%rcx), %r11d\n27: \taddl\t$1, %edx\n2a: \tmovq\t%r8, %rsi\n2d: \tnopl\t(%rax)\n30: \tmovq\t(%r10,%rsi,8), %rcx\n34: \tmovl\t(%rcx), %ebx\n36: \taddl\t$1, %ebx\n39: \timull\t%r11d, %ebx\n3d: \tmovl\t8(%rcx), %ecx\n40: \timull\t%edx, %ecx\n43: \tcmpl\t%ecx, %ebx\n45: \tjne\t0x5a <check_weight_distribution+0x5a>\n47: \taddq\t$1, %rsi\n4b: \tcmpq\t%rsi, %r9\n4e: \tjne\t0x30 <check_weight_distribution+0x30>\n50: \tmovq\t%r8, %rcx\n53: \tcmpq\t%r9, %r8\n56: \tjb\t0x10 <check_weight_distribution+0x10>\n58: \tjmp\t0x5c <check_weight_distribution+0x5c>\n5a: \txorl\t%eax, %eax\n5c: \tpopq\t%rbx\n5d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {size_t size; TYPE_3__** entries; } ;\ntypedef  TYPE_4__ h2o_socketpool_target_vector_t ;\nstruct TYPE_7__ {scalar_t__ weight_m1; } ;\nstruct TYPE_6__ {unsigned int leased_count; } ;\nstruct TYPE_8__ {TYPE_2__ conf; TYPE_1__ _shared; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int check_weight_distribution(h2o_socketpool_target_vector_t *targets)\n{\nsize_t i, j;\n\nfor (i = 0; i < targets->size; i++) {\nfor (j = i + 1; j < targets->size; j++) {\nif (targets->entries[i]->_shared.leased_count * ((unsigned)targets->entries[j]->conf.weight_m1 + 1) !=\ntargets->entries[j]->_shared.leased_count * ((unsigned)targets->entries[i]->conf.weight_m1 + 1))\nreturn 0;\n}\n}\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  weight; int /*<<< orphan*/  weight_sum; } ;\nstruct TYPE_4__ {size_t n_weights; TYPE_2__* weights; } ;\ntypedef  TYPE_1__ GainControl ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int check_weight_distribution(GainControl *gain)\n{\nint i;\n\nfor (i = 1; i < gain->n_weights; i++) {\nif (gain->weights[i].weight_sum != gain->weights[i - 1].weight_sum + 1)\nreturn 0;\n}\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_h2o_evloop_destroy",
    "input":"\n0000000000000000 <h2o_evloop_destroy>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rdi), %edi\n6: \tcallq\t0xb <h2o_evloop_destroy+0xb>\nb: \txorl\t%edi, %edi\nd: \tcmpq\t(%rip), %rax  # 0x14 <h2o_evloop_destroy+0x14>\n14: \tsete\t%dil\n18: \tcallq\t0x1d <h2o_evloop_destroy+0x1d>\n1d: \tnopl\t(%rax)\n20: \tmovq\t40(%rbx), %rdi\n24: \ttestq\t%rdi, %rdi\n27: \tje\t0x51 <h2o_evloop_destroy+0x51>\n29: \tmovq\t24(%rdi), %rax\n2d: \tmovq\t%rax, 40(%rbx)\n31: \tmovq\t%rdi, 24(%rdi)\n35: \tcallq\t0x3a <h2o_evloop_destroy+0x3a>\n3a: \tjmp\t0x20 <h2o_evloop_destroy+0x20>\n3c: \tnopl\t(%rax)\n40: \tmovq\t24(%rdi), %rax\n44: \tmovq\t%rax, 32(%rbx)\n48: \tmovq\t%rdi, 24(%rdi)\n4c: \tcallq\t0x51 <h2o_evloop_destroy+0x51>\n51: \tmovq\t32(%rbx), %rdi\n55: \ttestq\t%rdi, %rdi\n58: \tjne\t0x40 <h2o_evloop_destroy+0x40>\n5a: \tjmp\t0x6d <h2o_evloop_destroy+0x6d>\n5c: \tnopl\t(%rax)\n60: \tmovq\t8(%rdi), %rax\n64: \tmovq\t%rax, 16(%rbx)\n68: \tcallq\t0x6d <h2o_evloop_destroy+0x6d>\n6d: \tmovq\t16(%rbx), %rdi\n71: \ttestq\t%rdi, %rdi\n74: \tjne\t0x60 <h2o_evloop_destroy+0x60>\n76: \tmovq\t%rbx, %rdi\n79: \tcallq\t0x7e <h2o_evloop_destroy+0x7e>\n7e: \tmovl\t(%rbx), %edi\n80: \tcallq\t0x85 <h2o_evloop_destroy+0x85>\n85: \tmovq\t%rbx, %rdi\n88: \tpopq\t%rbx\n89: \tjmp\t0x8e <h2o_evloop_destroy+0x8e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {struct st_h2o_evloop_socket_t* head; } ;\nstruct st_h2o_evloop_socket_t {int /*<<< orphan*/  _timeouts; struct st_h2o_evloop_socket_t* _next_statechanged; TYPE_1__ _statechanged; struct st_h2o_evloop_socket_t* _next_pending; struct st_h2o_evloop_socket_t* _pending_as_server; struct st_h2o_evloop_socket_t* _pending_as_client; } ;\ntypedef  int /*<<< orphan*/  h2o_socket_t ;\ntypedef  struct st_h2o_evloop_socket_t h2o_evloop_t ;\n\n/* Variables and functions */\nscalar_t__ UINT64_MAX ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  evloop_do_dispose (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  free (struct st_h2o_evloop_socket_t*) ;\nint /*<<< orphan*/  h2o_socket_close (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timerwheel_destroy (int /*<<< orphan*/ ) ;\nscalar_t__ h2o_timerwheel_get_wake_at (int /*<<< orphan*/ ) ;\n\nvoid h2o_evloop_destroy(h2o_evloop_t *loop)\n{\nstruct st_h2o_evloop_socket_t *sock;\n\n/* timeouts are governed by the application and MUST be destroyed prior to destroying the loop */\nassert(h2o_timerwheel_get_wake_at(loop->_timeouts) == UINT64_MAX);\n\n/* dispose all socket */\nwhile ((sock = loop->_pending_as_client) != NULL) {\nloop->_pending_as_client = sock->_next_pending;\nsock->_next_pending = sock;\nh2o_socket_close((h2o_socket_t *)sock);\n}\nwhile ((sock = loop->_pending_as_server) != NULL) {\nloop->_pending_as_server = sock->_next_pending;\nsock->_next_pending = sock;\nh2o_socket_close((h2o_socket_t *)sock);\n}\n\n/* now all socket are disposedand and placed in linked list statechanged\n* we can freeing memory in cycle by next_statechanged,\n*/\nwhile ((sock = loop->_statechanged.head) != NULL) {\nloop->_statechanged.head = sock->_next_statechanged;\nfree(sock);\n}\n\n/* dispose backend-specific data */\nevloop_do_dispose(loop);\n\n/* lastly we need to free loop memory */\nh2o_timerwheel_destroy(loop->_timeouts);\nfree(loop);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  loop; struct TYPE_4__* next_pending; struct TYPE_4__* prev_pending; struct TYPE_4__* next_timeout; struct TYPE_4__* prev_timeout; struct TYPE_4__* next_idle; struct TYPE_4__* prev_idle; } ;\ntypedef  TYPE_1__ h2o_evloop_t ;\n\n/* Variables and functions */\nscalar_t__ EVLOOP_NONE ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  free (TYPE_1__*) ;\nscalar_t__ h2o_evloop_run (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_evloop_stop (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timeout_cancel (TYPE_1__*) ;\nint /*<<< orphan*/  h2o_timeout_dispose (TYPE_1__*) ;\n\nvoid h2o_evloop_destroy(h2o_evloop_t *loop)\n{\nh2o_timeout_t *timeout, *next;\n\nassert(h2o_evloop_run(loop->loop) == EVLOOP_NONE);\n\n/* cancel pending timeouts */\ntimeout = loop->next_pending;\nwhile (timeout != NULL) {\nnext = timeout->next_pending;\nh2o_timeout_cancel(timeout);\ntimeout = next;\n}\n\n/* dispose of pending timeouts */\ntimeout = loop->next_pending;\nwhile (timeout != NULL) {\nnext = timeout->next_pending;\nh2o_timeout_dispose(timeout);\ntimeout = next;\n}\n\n/* cancel and dispose of idle timeouts */\ntimeout = loop->next_idle;\nwhile (timeout != NULL) {\nnext = timeout->next_idle;\nh2o_timeout_cancel(timeout);\nh2o_timeout_dispose(timeout);\ntimeout = next;\n}\n\n/* cancel and dispose of timeouts */\ntimeout = loop->next_timeout;\nwhile (timeout != NULL) {\nnext = timeout->next_timeout;\nh2o_timeout_cancel(timeout);\nh2o_timeout_dispose(timeout);\ntimeout = next;\n}\n\nfree(loop);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhostinfo.c_create_lookup_thread",
    "input":"\n0000000000000000 <create_lookup_thread>:\n0: \tpushq\t%rbx\n1: \tsubq\t$144, %rsp\n8: \tleaq\t8(%rsp), %rbx\nd: \tmovq\t%rbx, %rdi\n10: \tcallq\t0x15 <create_lookup_thread+0x15>\n15: \tmovq\t%rbx, %rdi\n18: \tmovl\t$1, %esi\n1d: \tcallq\t0x22 <create_lookup_thread+0x22>\n22: \tmovq\t%rbx, %rdi\n25: \tmovl\t$102400, %esi # imm = 0x19000\n2a: \tcallq\t0x2f <create_lookup_thread+0x2f>\n2f: \tmovl\t(%rip), %edx  # 0x35 <create_lookup_thread+0x35>\n35: \tleaq\t12(%rsp), %rdi\n3a: \txorl\t%esi, %esi\n3c: \txorl\t%ecx, %ecx\n3e: \tcallq\t0x43 <create_lookup_thread+0x43>\n43: \ttestl\t%eax, %eax\n45: \tje\t0x72 <create_lookup_thread+0x72>\n47: \tmovq\t(%rip), %rbx  # 0x4e <create_lookup_thread+0x4e>\n4e: \tleaq\t16(%rsp), %rsi\n53: \tmovl\t%eax, %edi\n55: \tmovl\t$128, %edx\n5a: \tcallq\t0x5f <create_lookup_thread+0x5f>\n5f: \ttestq\t%rbx, %rbx\n62: \tje\t0x83 <create_lookup_thread+0x83>\n64: \tmovl\t$0, %edi\n69: \tmovl\t%eax, %esi\n6b: \tcallq\t0x70 <create_lookup_thread+0x70>\n70: \tjmp\t0x8f <create_lookup_thread+0x8f>\n72: \taddq\t$1, (%rip)    # 0x7a <create_lookup_thread+0x7a>\n7a: \taddl\t$1, (%rip)    # 0x81 <create_lookup_thread+0x81>\n81: \tjmp\t0x8f <create_lookup_thread+0x8f>\n83: \tmovl\t$0, %edi\n88: \tmovl\t%eax, %esi\n8a: \tcallq\t0x8f <create_lookup_thread+0x8f>\n8f: \taddq\t$144, %rsp\n96: \tpopq\t%rbx\n97: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pthread_t ;\ntypedef  int /*<<< orphan*/  pthread_attr_t ;\ntypedef  int /*<<< orphan*/  buf ;\nstruct TYPE_2__ {scalar_t__ num_threads; int /*<<< orphan*/  num_threads_idle; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_error_printf (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_fatal (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_strerror_r (int,char*,int) ;\nint /*<<< orphan*/  lookup_thread_main ;\nint /*<<< orphan*/  pthread_attr_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_attr_setdetachstate (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  pthread_attr_setstacksize (int /*<<< orphan*/ *,int) ;\nint pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nTYPE_1__ queue ;\n\n__attribute__((used)) static void create_lookup_thread(void)\n{\npthread_t tid;\npthread_attr_t attr;\nint ret;\n\npthread_attr_init(&attr);\npthread_attr_setdetachstate(&attr, 1);\npthread_attr_setstacksize(&attr, 100 * 1024);\nif ((ret = pthread_create(&tid, NULL, lookup_thread_main, NULL)) != 0) {\nchar buf[128];\nif (queue.num_threads == 0) {\nh2o_fatal(\"failed to start first thread for getaddrinfo: %s\", h2o_strerror_r(ret, buf, sizeof(buf)));\n} else {\nh2o_error_printf(\"pthread_create(for getaddrinfo): %s\", h2o_strerror_r(ret, buf, sizeof(buf)));\n}\nreturn;\n}\n\n++queue.num_threads;\n++queue.num_threads_idle;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  hEvent; int /*<<< orphan*/  hThread; } ;\ntypedef  TYPE_1__ THREAD_DATA ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CreateEventA (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  CreateThread (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  GetLastError () ;\nint /*<<< orphan*/  LookupThread ;\nint /*<<< orphan*/  SetEvent (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SetThreadPriority (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  Sleep (int) ;\nint /*<<< orphan*/  WaitForSingleObject (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WIN32_ERROR_CODE ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  WIN32_ERROR_CODE_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonhttpclient.c_on_connect_error",
    "input":"\n0000000000000000 <on_connect_error>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tsubq\t$40, %rsp\n7: \tmovq\t%rsi, %r14\na: \tmovq\t%rdi, %rbx\nd: \txorl\t%edi, %edi\nf: \ttestq\t%rsi, %rsi\n12: \tsetne\t%dil\n16: \tcallq\t0x1b <on_connect_error+0x1b>\n1b: \txorps\t%xmm0, %xmm0\n1e: \tmovups\t%xmm0, 16(%rsp)\n23: \tmovups\t%xmm0, (%rsp)\n27: \tmovq\t%rbx, %rdi\n2a: \tmovq\t%r14, %rsi\n2d: \txorl\t%edx, %edx\n2f: \txorl\t%ecx, %ecx\n31: \txorl\t%r8d, %r8d\n34: \txorl\t%r9d, %r9d\n37: \tcallq\t*(%rbx)\n39: \tmovq\t%rbx, %rdi\n3c: \taddq\t$40, %rsp\n40: \tpopq\t%rbx\n41: \tpopq\t%r14\n43: \tjmp\t0x48 <on_connect_error+0x48>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  (* on_connect ) (TYPE_2__*,char const*,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;} ;\nstruct TYPE_7__ {TYPE_1__ _cb; } ;\ntypedef  TYPE_2__ h2o_httpclient_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  close_client (TYPE_2__*) ;\nint /*<<< orphan*/  stub1 (TYPE_2__*,char const*,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void on_connect_error(h2o_httpclient_t *client, const char *errstr)\n{\nassert(errstr != NULL);\nclient->_cb.on_connect(client, errstr, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL);\nclose_client(client);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  (* on_connect_error ) (TYPE_1__*,char const*,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;} ;\ntypedef  TYPE_1__ signal_user_data_t ;\ntypedef  int /*<<< orphan*/  GError ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub1 (TYPE_1__*,char const*,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\non_connect_error (signal_user_data_t *user_data, const char *name, GError *error)\n{\ng_assert (error != NULL);\n\nuser_data->on_connect_error (user_data, name, NULL, NULL, NULL, NULL);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommoncache.c_h2o_cache_get_capacity",
    "input":"\n0000000000000000 <h2o_cache_get_capacity>:\n0: \tmovq\t(%rdi), %rax\n3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t capacity; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\n\nsize_t h2o_cache_get_capacity(h2o_cache_t *cache)\n{\nreturn cache->capacity;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t capacity; } ;\ntypedef  TYPE_1__ h2o_cache_t ;\n\n/* Variables and functions */\n\nsize_t h2o_cache_get_capacity(h2o_cache_t *cache)\n{\nreturn cache->capacity;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocketevloop.c.h_on_read_core",
    "input":"\n0000000000000000 <on_read_core>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rsi, %r15\ne: \tmovl\t%edi, %r12d\n11: \txorl\t%r14d, %r14d\n14: \txorl\t%r13d, %r13d\n17: \tnopw\t(%rax,%rax)\n20: \tmovq\t%r15, %rdi\n23: \tmovl\t$4096, %esi   # imm = 0x1000\n28: \tcallq\t0x2d <on_read_core+0x2d>\n2d: \ttestq\t%rdx, %rdx\n30: \tje\t0x91 <on_read_core+0x91>\n32: \tmovl\t%eax, %ebx\n34: \tmovq\t%rdx, %rbp\n37: \tnopw\t(%rax,%rax)\n40: \tmovl\t(%rip), %eax  # 0x46 <on_read_core+0x46>\n46: \tmovl\t%eax, %ecx\n48: \tshrl\t$31, %ecx\n4b: \taddl\t%eax, %ecx\n4d: \tsarl\t%ecx\n4f: \tleal\t1(%rcx), %edx\n52: \tcmpl\t%ecx, %ebx\n54: \tcmovlel\t%ebx, %edx\n57: \tmovl\t%r12d, %edi\n5a: \tmovq\t%rbp, %rsi\n5d: \tcallq\t0x62 <on_read_core+0x62>\n62: \tmovq\t(%rip), %rcx  # 0x69 <on_read_core+0x69>\n69: \tcmpl\t$-1, %eax\n6c: \tjne\t0x77 <on_read_core+0x77>\n6e: \tcmpq\t(%rip), %rcx  # 0x75 <on_read_core+0x75>\n75: \tje\t0x40 <on_read_core+0x40>\n77: \tcmpl\t$-1, %eax\n7a: \tje\t0x98 <on_read_core+0x98>\n7c: \ttestl\t%eax, %eax\n7e: \tje\t0xa8 <on_read_core+0xa8>\n80: \tmovq\t(%r15), %rcx\n83: \taddl\t%eax, (%rcx)\n85: \tmovl\t$1, %r13d\n8b: \tcmpl\t%eax, %ebx\n8d: \tje\t0x20 <on_read_core+0x20>\n8f: \tjmp\t0xba <on_read_core+0xba>\n91: \tmovl\t$0, %eax\n96: \tjmp\t0xb7 <on_read_core+0xb7>\n98: \tmovl\t$0, %eax\n9d: \tcmpq\t(%rip), %rcx  # 0xa4 <on_read_core+0xa4>\na4: \tjne\t0xb7 <on_read_core+0xb7>\na6: \tjmp\t0xad <on_read_core+0xad>\na8: \ttestl\t%r13d, %r13d\nab: \tje\t0xb2 <on_read_core+0xb2>\nad: \txorl\t%r14d, %r14d\nb0: \tjmp\t0xba <on_read_core+0xba>\nb2: \tmovl\t$0, %eax\nb7: \tmovq\t(%rax), %r14\nba: \tmovq\t%r14, %rax\nbd: \taddq\t$8, %rsp\nc1: \tpopq\t%rbx\nc2: \tpopq\t%r12\nc4: \tpopq\t%r13\nc6: \tpopq\t%r14\nc8: \tpopq\t%r15\nca: \tpopq\t%rbp\ncb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int ssize_t ;\nstruct TYPE_6__ {int len; int /*<<< orphan*/ * base; } ;\ntypedef  TYPE_1__ h2o_iovec_t ;\nstruct TYPE_7__ {int size; } ;\ntypedef  TYPE_2__ h2o_buffer_t ;\n\n/* Variables and functions */\nscalar_t__ EAGAIN ;\nscalar_t__ EINTR ;\nint INT_MAX ;\nscalar_t__ errno ;\nTYPE_1__ h2o_buffer_try_reserve (TYPE_2__**,int) ;\nchar const* h2o_socket_error_closed ;\nchar const* h2o_socket_error_io ;\nchar const* h2o_socket_error_out_of_memory ;\nint read (int,int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static const char *on_read_core(int fd, h2o_buffer_t **input)\n{\nint read_any = 0;\n\nwhile (1) {\nssize_t rret;\nh2o_iovec_t buf = h2o_buffer_try_reserve(input, 4096);\nif (buf.base == NULL) {\n/* memory allocation failed */\nreturn h2o_socket_error_out_of_memory;\n}\nwhile ((rret = read(fd, buf.base, buf.len <= INT_MAX / 2 ? buf.len : INT_MAX / 2 + 1)) == -1 && errno == EINTR)\n;\nif (rret == -1) {\nif (errno == EAGAIN)\nbreak;\nelse\nreturn h2o_socket_error_io;\n} else if (rret == 0) {\nif (!read_any)\nreturn h2o_socket_error_closed; /* TODO notify close */\nbreak;\n}\n(*input)->size += rret;\nif (buf.len != rret)\nbreak;\nread_any = 1;\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* bytes_read; } ;\ntypedef  TYPE_1__ GLogFile ;\ntypedef  int /*<<< orphan*/  GLog ;\ntypedef  int /*<<< orphan*/  GIOStatus ;\ntypedef  int /*<<< orphan*/  GError ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_IO_STATUS_AGAIN ;\nint /*<<< orphan*/  G_IO_STATUS_EOF ;\nint /*<<< orphan*/  G_IO_STATUS_ERROR ;\nscalar_t__ G_IO_STATUS_NORMAL ;\nscalar_t__ G_IO_STATUS_WOULD_BLOCK ;\nint /*<<< orphan*/  g_error_free (int /*<<< orphan*/ *) ;\nint g_file_read (int /*<<< orphan*/ *,char*,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_log_file_read_error (int /*<<< orphan*/ *,char*,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_log_file_read_error_no_data (int /*<<< orphan*/ *,char*,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan*/ * g_log_file_read_error_no_data_error_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_space_no_data_no_data_no_data_no_data_no_data_no_data ;\nint /*<<< orphan"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_obtain_tcp_info",
    "input":"\n0000000000000000 <obtain_tcp_info>:\n0: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint32_t ;\ntypedef  int /*<<< orphan*/  tcpi ;\nstruct tcp_info {int tcpi_rtt; int tcpi_snd_mss; int tcpi_snd_cwnd; scalar_t__ tcpi_unacked; scalar_t__ tcpi_maxseg; int tcpi_srtt; int tcpi_snd_sbbytes; } ;\nstruct tcp_connection_info {int tcpi_rtt; int tcpi_snd_mss; int tcpi_snd_cwnd; scalar_t__ tcpi_unacked; scalar_t__ tcpi_maxseg; int tcpi_srtt; int tcpi_snd_sbbytes; } ;\ntypedef  int socklen_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CALC_CWND_PAIR_FROM_BYTE_UNITS (int,int) ;\nint /*<<< orphan*/  FIONWRITE ;\nint /*<<< orphan*/  IPPROTO_TCP ;\nint /*<<< orphan*/  TCP_CONNECTION_INFO ;\nint /*<<< orphan*/  TCP_INFO ;\nscalar_t__ getsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,struct tcp_info*,int*) ;\nint ioctl (int,int /*<<< orphan*/ ,int*) ;\n\n__attribute__((used)) static int obtain_tcp_info(int fd, uint32_t *rtt, uint32_t *mss, uint32_t *cwnd_size, uint32_t *cwnd_avail)\n{\n#define CALC_CWND_PAIR_FROM_BYTE_UNITS(cwnd_bytes, inflight_bytes)                                                                 \\\ndo {                                                                                                                           \\\n*cwnd_size = (cwnd_bytes + *mss / 2) / *mss;                                                                               \\\n*cwnd_avail = cwnd_bytes > inflight_bytes ? (cwnd_bytes - inflight_bytes) / *mss + 2 : 2;                                  \\\n} while (0)\n\n#if defined(__linux__) && defined(TCP_INFO)\n\nstruct tcp_info tcpi;\nsocklen_t tcpisz = sizeof(tcpi);\nif (getsockopt(fd, IPPROTO_TCP, TCP_INFO, &tcpi, &tcpisz) != 0)\nreturn -1;\n*rtt = tcpi.tcpi_rtt;\n*mss = tcpi.tcpi_snd_mss;\n*cwnd_size = tcpi.tcpi_snd_cwnd;\n*cwnd_avail = tcpi.tcpi_snd_cwnd > tcpi.tcpi_unacked ? tcpi.tcpi_snd_cwnd - tcpi.tcpi_unacked + 2 : 2;\nreturn 0;\n\n#elif defined(__FreeBSD__) && defined(TCP_INFO) && 0 /* disabled since we wouldn't use it anyways; OS lacks TCP_NOTSENT_LOWAT */\n\nstruct tcp_info tcpi;\nsocklen_t tcpisz = sizeof(tcpi);\nint bytes_inflight;\nif (getsockopt(fd, IPPROTO_TCP, TCP_INFO, &tcpi, &tcpisz) != 0 || ioctl(fd, FIONWRITE, &bytes_inflight) == -1)\nreturn -1;\n*rtt = tcpi.tcpi_rtt;\n*mss = tcpi.tcpi_snd_mss;\nCALC_CWND_PAIR_FROM_BYTE_UNITS(tcpi.tcpi_snd_cwnd, bytes_inflight);\nreturn 0;\n\n#elif defined(__APPLE__) && defined(TCP_CONNECTION_INFO)\n\nstruct tcp_connection_info tcpi;\nsocklen_t tcpisz = sizeof(tcpi);\nif (getsockopt(fd, IPPROTO_TCP, TCP_CONNECTION_INFO, &tcpi, &tcpisz) != 0 || tcpi.tcpi_maxseg == 0)\nreturn -1;\n*rtt = tcpi.tcpi_srtt * 1000;\n*mss = tcpi.tcpi_maxseg;\nCALC_CWND_PAIR_FROM_BYTE_UNITS(tcpi.tcpi_snd_cwnd, tcpi.tcpi_snd_sbbytes);\nreturn 0;\n\n#else\n/* TODO add support for NetBSD; note that the OS returns the number of packets for tcpi_snd_cwnd; see\n* http://twitter.com/n_soda/status/740719125878575105\n*/\nreturn -1;\n#endif\n\n#undef CALC_CWND_PAIR_FROM_BYTE_UNITS\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct tcp_info {int dummy; } ;\n\n/* Variables and functions */\n\nint obtain_tcp_info (int fd, struct tcp_info *info) {\nreturn -1;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonsocket.c_h2o_sliding_counter_stop",
    "input":"\n0000000000000000 <h2o_sliding_counter_stop>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \txorl\t%edi, %edi\nc: \tcmpq\t$0, 32(%rbx)\n11: \tsetne\t%dil\n15: \tcallq\t0x1a <h2o_sliding_counter_stop+0x1a>\n1a: \txorl\t%eax, %eax\n1c: \tsubq\t32(%rbx), %r14\n20: \tcmovgq\t%r14, %rax\n24: \tmovq\t$0, 32(%rbx)\n2c: \tmovl\t8(%rbx), %ecx\n2f: \taddl\t%eax, %ecx\n31: \tmovq\t16(%rbx), %rdx\n35: \tmovq\t24(%rbx), %rsi\n39: \tsubl\t(%rsi,%rdx,8), %ecx\n3c: \tmovl\t%ecx, 8(%rbx)\n3f: \tmovq\t%rax, (%rsi,%rdx,8)\n43: \tmovq\t$0, 16(%rbx)\n4b: \tmovl\t%ecx, (%rbx)\n4d: \taddq\t$8, %rsp\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\nstruct TYPE_6__ {int sum; size_t index; scalar_t__* slots; } ;\nstruct TYPE_5__ {scalar_t__ start_at; } ;\nstruct TYPE_7__ {int average; TYPE_2__ prev; TYPE_1__ cur; } ;\ntypedef  TYPE_3__ h2o_sliding_counter_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\n\nvoid h2o_sliding_counter_stop(h2o_sliding_counter_t *counter, uint64_t now)\n{\nuint64_t elapsed;\n\nassert(counter->cur.start_at != 0);\n\n/* calculate the time used, and reset cur */\nif (now <= counter->cur.start_at)\nelapsed = 0;\nelse\nelapsed = now - counter->cur.start_at;\ncounter->cur.start_at = 0;\n\n/* adjust prev */\ncounter->prev.sum += elapsed;\ncounter->prev.sum -= counter->prev.slots[counter->prev.index];\ncounter->prev.slots[counter->prev.index] = elapsed;\nif (++counter->prev.index >= sizeof(counter->prev.slots) / sizeof(counter->prev.slots[0]))\ncounter->prev.index = 0;\n\n/* recalc average */\ncounter->average = counter->prev.sum / (sizeof(counter->prev.slots) / sizeof(counter->prev.slots[0]));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t num_slots; size_t slot_index; size_t* slots; int /*<<< orphan*/  sum; scalar_t__ is_running; } ;\ntypedef  TYPE_1__ h2o_sliding_counter_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\n\nvoid h2o_sliding_counter_stop(h2o_sliding_counter_t *self, size_t value)\n{\nassert(!self->is_running);\nif (value > self->slots[self->slot_index])\nvalue -= self->slots[self->slot_index];\nself->sum += value;\nself->slots[self->slot_index] = value;\nself->slot_index = 0;\nself->is_running = 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommonmultithread.c_h2o_multithread_create_thread",
    "input":"\n0000000000000000 <h2o_multithread_create_thread>:\n0: \tsubq\t$136, %rsp\n7: \tcallq\t0xc <h2o_multithread_create_thread+0xc>\nc: \ttestl\t%eax, %eax\ne: \tje\t0x2b <h2o_multithread_create_thread+0x2b>\n10: \tmovq\t%rsp, %rsi\n13: \tmovl\t%eax, %edi\n15: \tmovl\t$128, %edx\n1a: \tcallq\t0x1f <h2o_multithread_create_thread+0x1f>\n1f: \tmovl\t$0, %edi\n24: \tmovl\t%eax, %esi\n26: \tcallq\t0x2b <h2o_multithread_create_thread+0x2b>\n2b: \taddq\t$136, %rsp\n32: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pthread_t ;\ntypedef  int /*<<< orphan*/  pthread_attr_t ;\ntypedef  int /*<<< orphan*/  buf ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_fatal (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_strerror_r (int,char*,int) ;\nint pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,void* (*) (void*),void*) ;\n\nvoid h2o_multithread_create_thread(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg)\n{\nint ret;\nif ((ret = pthread_create(tid, attr, func, arg)) != 0) {\nchar buf[128];\nh2o_fatal(\"pthread_create: %s\", h2o_strerror_r(ret, buf, sizeof(buf)));\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_multithread_thread_args_t ;\ntypedef  int /*<<< orphan*/  h2o_multithread_thread_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CreateThread (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  GetCurrentThread () ;\nint /*<<< orphan*/  h2o_multithread_thread_proc ;\nint /*<<< orphan*/  h2o_multithread_thread_t_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_size ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_type ;\nint /*<<< orphan*/  h2o_multithread_thread_t_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable_vtable ;\nint /*<<< or"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_timerwheel.c_my_callback",
    "input":"\n0000000000000000 <my_callback>:\n0: \taddl\t$1, (%rip)    # 0x7 <my_callback+0x7>\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_timerwheel_entry_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  invokes ;\n\n__attribute__((used)) static void my_callback(h2o_timerwheel_entry_t *timer)\n{\ninvokes++;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  callback_count ;\n\n__attribute__((used)) static void my_callback(void *arg)\n{\ncallback_count++;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_........libcommon....depsssl-conservatoryopensslopenssl_hostname_validation.c_validate_name",
    "input":"\n0000000000000000 <validate_name>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rsi, %rbp\na: \tmovq\t%rdi, %rbx\nd: \tmovq\t%rsi, %rdi\n10: \tcallq\t0x15 <validate_name+0x15>\n15: \tmovq\t%rax, %r14\n18: \tmovq\t%rbp, %rdi\n1b: \tcallq\t0x20 <validate_name+0x20>\n20: \tmovl\t%eax, %r15d\n23: \tmovq\t%rbx, %rdi\n26: \tcallq\t0x2b <validate_name+0x2b>\n2b: \tmovl\t%eax, %ebp\n2d: \tmovq\t%r14, %rdi\n30: \tmovl\t%r15d, %esi\n33: \tcallq\t0x38 <validate_name+0x38>\n38: \ttestq\t%rax, %rax\n3b: \tje\t0x48 <validate_name+0x48>\n3d: \tmovl\t(%rip), %eax  # 0x43 <validate_name+0x43>\n43: \tjmp\t0xcf <validate_name+0xcf>\n48: \ttestl\t%ebp, %ebp\n4a: \tje\t0x63 <validate_name+0x63>\n4c: \tmovslq\t%ebp, %rcx\n4f: \tleaq\t-1(%rcx), %rax\n53: \tcmpb\t$46, -1(%rbx,%rcx)\n58: \tcmovnel\t%ebp, %eax\n5b: \tcmpl\t$3, %r15d\n5f: \tjge\t0x6b <validate_name+0x6b>\n61: \tjmp\t0xa1 <validate_name+0xa1>\n63: \txorl\t%eax, %eax\n65: \tcmpl\t$3, %r15d\n69: \tjl\t0xa1 <validate_name+0xa1>\n6b: \tcmpb\t$42, (%r14)\n6f: \tjne\t0xa1 <validate_name+0xa1>\n71: \tcmpb\t$46, 1(%r14)\n76: \tjne\t0xa1 <validate_name+0xa1>\n78: \ttestl\t%eax, %eax\n7a: \tje\t0x95 <validate_name+0x95>\n7c: \tnopl\t(%rax)\n80: \tleal\t-1(%rax), %ecx\n83: \tcmpb\t$46, (%rbx)\n86: \tleaq\t1(%rbx), %rbx\n8a: \tje\t0x97 <validate_name+0x97>\n8c: \tcmpl\t$1, %eax\n8f: \tmovl\t%ecx, %eax\n91: \tjne\t0x80 <validate_name+0x80>\n93: \tjmp\t0x97 <validate_name+0x97>\n95: \txorl\t%ecx, %ecx\n97: \taddq\t$2, %r14\n9b: \taddl\t$-2, %r15d\n9f: \tmovl\t%ecx, %eax\na1: \tcmpl\t%eax, %r15d\na4: \tjne\t0xc9 <validate_name+0xc9>\na6: \tmovq\t%rbx, %rdi\na9: \tmovq\t%r14, %rsi\nac: \tmovl\t%r15d, %edx\naf: \tcallq\t0xb4 <validate_name+0xb4>\nb4: \ttestq\t%rax, %rax\nb7: \tmovl\t$0, %eax\nbc: \tmovl\t$0, %ecx\nc1: \tcmovneq\t%rax, %rcx\nc5: \tmovl\t(%rcx), %eax\nc7: \tjmp\t0xcf <validate_name+0xcf>\nc9: \tmovl\t(%rip), %eax  # 0xcf <validate_name+0xcf>\ncf: \taddq\t$8, %rsp\nd3: \tpopq\t%rbx\nd4: \tpopq\t%r14\nd6: \tpopq\t%r15\nd8: \tpopq\t%rbp\nd9: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HostnameValidationResult ;\ntypedef  int /*<<< orphan*/  ASN1_STRING ;\n\n/* Variables and functions */\nscalar_t__ ASN1_STRING_data (int /*<<< orphan*/ *) ;\nscalar_t__ ASN1_STRING_get0_data (int /*<<< orphan*/ *) ;\nint ASN1_STRING_length (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MalformedCertificate ;\nint /*<<< orphan*/  MatchFound ;\nint /*<<< orphan*/  MatchNotFound ;\nscalar_t__ has_nul (char*,int) ;\nscalar_t__ memeq_ncase (char const*,char*,int) ;\nint strlen (char const*) ;\n\n__attribute__((used)) static HostnameValidationResult validate_name(const char *hostname, ASN1_STRING *certname_asn1) {\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\nchar *certname_s = (char *) ASN1_STRING_get0_data(certname_asn1);\n#else\nchar *certname_s = (char *) ASN1_STRING_data(certname_asn1);\n#endif\nint certname_len = ASN1_STRING_length(certname_asn1), hostname_len = strlen(hostname);\n\n// Make sure there isn't an embedded NUL character in the DNS name\nif (has_nul(certname_s, certname_len)) {\nreturn MalformedCertificate;\n}\n// remove last '.' from hostname\nif (hostname_len != 0 && hostname[hostname_len - 1] == '.')\n--hostname_len;\n// skip the first segment if wildcard\nif (certname_len > 2 && certname_s[0] == '*' && certname_s[1] == '.') {\nif (hostname_len != 0) {\ndo {\n--hostname_len;\nif (*hostname++ == '.')\nbreak;\n} while (hostname_len != 0);\n}\ncertname_s += 2;\ncertname_len -= 2;\n}\n// Compare expected hostname with the DNS name\nif (certname_len != hostname_len) {\nreturn MatchNotFound;\n}\nreturn memeq_ncase(hostname, certname_s, hostname_len) ? MatchFound : MatchNotFound;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WCHAR ;\ntypedef  int /*<<< orphan*/  BOOL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  strlenW (int /*<<< orphan*/  const*) ;\nint /*<<< orphan*/  strncmpW (int /*<<< orphan*/  const*,int /*<<< orphan*/  const*,int) ;\nscalar_t__ strpbrkW (int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ;\nint /*<<< orphan*/  wcschr (int /*<<< orphan*/  const*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static BOOL validate_name( const WCHAR *name, const WCHAR *ext )\n{\nconst WCHAR *p;\nint len;\n\np = wcschr( name, '.' );\nlen = strlenW( name );\nif (p && p != name && len > 3 && strpbrkW( ext, name + len - 3 ))\nreturn FALSE;\nif (!p && len > 3 && name[len - 1] == '*')\nreturn FALSE;\nreturn !strncmpW( name, ext, len );\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/lib/common/extr_url.c_test_lib__common__url_c",
    "input":"\n0000000000000000 <test_lib__common__url_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_lib__common__url_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_lib__common__url_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_lib__common__url_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_lib__common__url_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_lib__common__url_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tcallq\t0x31 <test_lib__common__url_c+0x31>\n31: \tmovl\t(%rip), %esi  # 0x37 <test_lib__common__url_c+0x37>\n37: \tmovl\t$0, %edi\n3c: \tcallq\t0x41 <test_lib__common__url_c+0x41>\n41: \tmovl\t(%rip), %esi  # 0x47 <test_lib__common__url_c+0x47>\n47: \tmovl\t$0, %edi\n4c: \tpopq\t%rax\n4d: \tjmp\t0x52 <test_lib__common__url_c+0x52>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_hostport ;\nint /*<<< orphan*/  test_normalize_path ;\nint /*<<< orphan*/  test_parse ;\nint /*<<< orphan*/  test_parse_relative ;\nint /*<<< orphan*/  test_resolve ;\n\nvoid test_lib__common__url_c(void)\n{\nsubtest(\"normalize_path\", test_normalize_path);\nsubtest(\"hostport\", test_hostport);\nsubtest(\"parse\", test_parse);\nsubtest(\"parse_relative\", test_parse_relative);\nsubtest(\"resolve\", test_resolve);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_ASSERT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL_STRING (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_NULL (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_TRUE (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_ERRNO (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_ERRNO_AND_MSG (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_ZERO_WITH_MSG_AND_ERRNO_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP_AND_CLEANUP (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,"
},
{
    "file:":"./h2o/t/00unit/extr_test.c_get_sockname",
    "input":"\n0000000000000000 <get_sockname>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tmovl\t(%rip), %eax  # 0xa <get_sockname+0xa>\na: \tmovl\t%eax, 8(%rsi)\nd: \tmovl\t$2130706433, %edi  # imm = 0x7F000001\n12: \tcallq\t0x17 <get_sockname+0x17>\n17: \tmovl\t%eax, 4(%rbx)\n1a: \tmovl\t$80, %edi\n1f: \tcallq\t0x24 <get_sockname+0x24>\n24: \tmovl\t%eax, (%rbx)\n26: \tmovl\t$12, %eax\n2b: \tpopq\t%rbx\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;\nstruct sockaddr_in {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;\nstruct sockaddr {int dummy; } ;\ntypedef  int socklen_t ;\ntypedef  int /*<<< orphan*/  h2o_conn_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  htonl (int) ;\nint /*<<< orphan*/  htons (int) ;\n\n__attribute__((used)) static socklen_t get_sockname(h2o_conn_t *conn, struct sockaddr *sa)\n{\nstruct sockaddr_in *sin = (void *)sa;\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = htonl(0x7f000001);\nsin->sin_port = htons(80);\nreturn sizeof(*sin);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_in {int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_addr; int /*<<< orphan*/  sin_family; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  htons (int) ;\nint /*<<< orphan*/  inet_addr (char*) ;\n\n__attribute__((used)) static int get_sockname(struct sockaddr_in *addr, int *addrlen)\n{\naddr->sin_family = AF_INET;\naddr->sin_addr = inet_addr(\"127.0.0.1\");\naddr->sin_port = htons(80);\n*addrlen = sizeof(struct sockaddr_in);\nreturn sizeof(struct sockaddr_in);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_thread_id_callback",
    "input":"\n0000000000000000 <thread_id_callback>:\n0: \txorl\t%eax, %eax\n2: \tjmp\t0x7 <thread_id_callback+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ pthread_self () ;\n\n__attribute__((used)) static unsigned long thread_id_callback(void)\n{\nreturn (unsigned long)pthread_self();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sqlite3_file ;\n\n/* Variables and functions */\nint /*<<< orphan*/  get_thread_id () ;\n\n__attribute__((used)) static void thread_id_callback(sqlite3_file *NotUsed, void *NotUsed2, void *NotUsed3){\n(void)NotUsed;\n(void)NotUsed2;\n(void)NotUsed3;\nget_thread_id();\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_do_internal_update",
    "input":"\n0000000000000000 <do_internal_update>:\n0: \tpushq\t%rax\n1: \txorl\t%edi, %edi\n3: \tcallq\t0x8 <do_internal_update+0x8>\n8: \tmovl\t$0, %edi\nd: \tmovl\t%eax, %esi\nf: \tpopq\t%rax\n10: \tjmp\t0x15 <do_internal_update+0x15>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  tickets; } ;\n\n/* Variables and functions */\nTYPE_1__ session_tickets ;\nint /*<<< orphan*/  time (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  update_tickets (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void do_internal_update(void *unused)\n{\nupdate_tickets(&session_tickets.tickets, time(NULL));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  printf (char*,int) ;\nint /*<<< orphan*/  update_internal_data () ;\n\nvoid do_internal_update(void)\n{\nprintf(\"Internal data update: %d\\n\", update_internal_data());\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_dispose_keyset",
    "input":"\n0000000000000000 <dispose_keyset>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t16(%rdi), %rdi\n8: \tcallq\t0xd <dispose_keyset+0xd>\nd: \tmovq\t$0, 16(%rbx)\n15: \tmovq\t8(%rbx), %rdi\n19: \tcallq\t0x1e <dispose_keyset+0x1e>\n1e: \tmovq\t$0, 8(%rbx)\n26: \tmovq\t(%rbx), %rdi\n29: \tcallq\t0x2e <dispose_keyset+0x2e>\n2e: \tmovq\t$0, (%rbx)\n35: \tpopq\t%rbx\n36: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * dec; int /*<<< orphan*/ * enc; } ;\nstruct st_quic_keyset_t {TYPE_1__ address_token; int /*<<< orphan*/ * cid; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ptls_aead_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  quicly_free_default_cid_encryptor (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void dispose_keyset(struct st_quic_keyset_t *keyset)\n{\nquicly_free_default_cid_encryptor(keyset->cid);\nkeyset->cid = NULL;\nptls_aead_free(keyset->address_token.enc);\nkeyset->address_token.enc = NULL;\nptls_aead_free(keyset->address_token.dec);\nkeyset->address_token.dec = NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * key_set; int /*<<< orphan*/ * key_set_len; int /*<<< orphan*/ * key_set_alloc; } ;\ntypedef  TYPE_1__ SSL_KEY_SET ;\n\n/* Variables and functions */\nint /*<<< orphan*/  OPENSSL_free (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void dispose_keyset(SSL_KEY_SET *keyset)\n{\nOPENSSL_free(keyset->key_set_alloc);\nkeyset->key_set_alloc = NULL;\nOPENSSL_free(keyset->key_set_len);\nkeyset->key_set_len = NULL;\nOPENSSL_free(keyset->key_set);\nkeyset->key_set = NULL;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_ticket_init_defaults",
    "input":"\n0000000000000000 <ticket_init_defaults>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %eax  # 0x7 <ticket_init_defaults+0x7>\n7: \tmovl\t%eax, (%rip)  # 0xd <ticket_init_defaults+0xd>\nd: \txorl\t%eax, %eax\nf: \tcallq\t0x14 <ticket_init_defaults+0x14>\n14: \tmovl\t%eax, (%rip)  # 0x1a <ticket_init_defaults+0x1a>\n1a: \txorl\t%eax, %eax\n1c: \tcallq\t0x21 <ticket_init_defaults+0x21>\n21: \tmovl\t%eax, (%rip)  # 0x27 <ticket_init_defaults+0x27>\n27: \tpopq\t%rax\n28: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  md; int /*<<< orphan*/  cipher; } ;\nstruct TYPE_6__ {TYPE_1__ generating; } ;\nstruct TYPE_7__ {TYPE_2__ vars; int /*<<< orphan*/  update_thread; } ;\nstruct TYPE_8__ {TYPE_3__ ticket; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EVP_aes_256_cbc () ;\nint /*<<< orphan*/  EVP_sha256 () ;\nTYPE_4__ conf ;\nint /*<<< orphan*/  ticket_internal_updater ;\n\n__attribute__((used)) static void ticket_init_defaults(void)\n{\nconf.ticket.update_thread = ticket_internal_updater;\n/* to protect the secret >>>2030 we need AES-256 (http://www.keylength.com/en/4/) */\nconf.ticket.vars.generating.cipher = EVP_aes_256_cbc();\n/* integrity checks are only necessary at the time of handshake, and sha256 (recommended by RFC 5077) is sufficient */\nconf.ticket.vars.generating.md = EVP_sha256();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TICKET_DEFAULT_LIFETIME ;\nint /*<<< orphan*/  TICKET_DEFAULT_MAX_LIFETIME ;\nint /*<<< orphan*/  TICKET_DEFAULT_PERSISTENCE ;\nint /*<<< orphan*/  TICKET_DEFAULT_PERSISTENCE_TIMEOUT ;\nint /*<<< orphan*/  TICKET_DEFAULT_RENEW_LIFETIME ;\nint /*<<< orphan*/  TICKET_DEFAULT_RENEW_TIMEOUT ;\nint /*<<< orphan*/  TICKET_DEFAULT_VALIDITY ;\nint /*<<< orphan*/  TICKET_DEFAULT_VALIDITY_TIMEOUT ;\n\nvoid\nticket_init_defaults(void)\n{\nTICKET_DEFAULT_VALIDITY = TICKET_DEFAULT_VALIDITY_TIMEOUT;\nTICKET_DEFAULT_RENEW_LIFETIME = TICKET_DEFAULT_RENEW_TIMEOUT;\nTICKET_DEFAULT_LIFETIME = TICKET_DEFAULT_VALIDITY_TIMEOUT;\nTICKET_DEFAULT_PERSISTENCE = TICKET_DEFAULT_PERSISTENCE_TIMEOUT;\nTICKET_DEFAULT_MAX_LIFETIME = TICKET_DEFAULT_LIFETIME;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_generate_stateless_reset_token",
    "input":"\n0000000000000000 <generate_stateless_reset_token>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdx, %rbx\n7: \tmovq\t%rsi, %r14\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <generate_stateless_reset_token+0x11>\n11: \tmovl\t(%rbx), %edi\n13: \tcallq\t0x18 <generate_stateless_reset_token+0x18>\n18: \ttestq\t%rax, %rax\n1b: \tje\t0x36 <generate_stateless_reset_token+0x36>\n1d: \tmovq\t(%rax), %rdi\n20: \tmovq\t(%rdi), %rax\n23: \taddq\t$4, %rbx\n27: \tmovq\t%r14, %rsi\n2a: \tmovq\t%rbx, %rdx\n2d: \taddq\t$8, %rsp\n31: \tpopq\t%rbx\n32: \tpopq\t%r14\n34: \tjmpq\t*%rax\n36: \txorl\t%eax, %eax\n38: \taddq\t$8, %rsp\n3c: \tpopq\t%rbx\n3d: \tpopq\t%r14\n3f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\nstruct st_quic_keyset_t {TYPE_1__* cid; } ;\ntypedef  int /*<<< orphan*/  quicly_cid_encryptor_t ;\nstruct TYPE_2__ {int (* generate_stateless_reset_token ) (TYPE_1__*,void*,int /*<<< orphan*/  const*) ;} ;\n\n/* Variables and functions */\nstruct st_quic_keyset_t* find_keyset (int /*<<< orphan*/  const) ;\nint stub1 (TYPE_1__*,void*,int /*<<< orphan*/  const*) ;\nint /*<<< orphan*/  update_quic_keys () ;\n\n__attribute__((used)) static int generate_stateless_reset_token(quicly_cid_encryptor_t *self, void *token, const void *_encrypted)\n{\nconst uint8_t *encrypted = _encrypted;\nstruct st_quic_keyset_t *keyset;\n\nupdate_quic_keys();\n\nif ((keyset = find_keyset(encrypted[0])) == NULL)\nreturn 0;\nreturn keyset->cid->generate_stateless_reset_token(keyset->cid, token, encrypted + 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  (* generate_stateless_reset_token ) (TYPE_2__*,unsigned char*,unsigned char*) ;} ;\nstruct TYPE_9__ {TYPE_1__* ssl; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  ctx; } ;\ntypedef  TYPE_2__ SSL ;\n\n/* Variables and functions */\nTYPE_3__* SSL_get_stateless_reset_method (TYPE_2__*) ;\nint /*<<< orphan*/  SSL_F_GENERATE_STATELESS_RESET_TOKEN ;\nint /*<<< orphan*/  SSL_FUNC_GENERATE_STATELESS_RESET_TOKEN ;\nint /*<<< orphan*/  SSLerr (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub1 (TYPE_2__*,unsigned char*,unsigned char*) ;\n\n__attribute__((used)) static int generate_stateless_reset_token(SSL *s, unsigned char *out,\nunsigned char *outlen)\n{\nconst SSL_METHOD *meth = SSL_get_method(s);\n\nif (meth->ssl_method == SSL_F_SSL_CTX_NEW) {\n#ifndef OPENSSL_NO_STATLESS\nreturn SSL_CTX_generate_stateless_reset_token(s->ctx, out, outlen);\n#else\nreturn 0;\n#endif\n}\n\nif (meth->ssl_method == SSL_F_SSL_GENERATE_STATELESS_RESET_TOKEN) {\nconst SSL_METHOD *smeth = SSL_get_stateless_reset_method(s);\n\nif (smeth == NULL) {\nSSLerr(SSL_F_GENERATE_STATELESS_RESET_TOKEN,\nSSL_R_NO_SUITABLE_STATLESS_RESET_METHOD);\nreturn 0;\n}\n\nreturn smeth->generate_stateless_reset_token(s, out, outlen);\n}\n\nSSLerr(SSL_F_GENERATE_STATELESS_RESET_TOKEN,\nSSL_R_NO_SUITABLE_STATLESS_RESET_METHOD);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_generate_resumption_token",
    "input":"\n0000000000000000 <generate_resumption_token>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovq\t%rcx, %r14\nc: \tmovq\t%rdx, %rbx\nf: \tleaq\t12(%rsp), %rdi\n14: \tcallq\t0x19 <generate_resumption_token+0x19>\n19: \tmovq\t%rax, %r15\n1c: \tmovq\t%rbx, %rdi\n1f: \tmovl\t$1, %esi\n24: \tcallq\t0x29 <generate_resumption_token+0x29>\n29: \ttestl\t%eax, %eax\n2b: \tjne\t0x56 <generate_resumption_token+0x56>\n2d: \tmovl\t12(%rsp), %eax\n31: \tmovq\t(%rbx), %rcx\n34: \tmovq\t8(%rbx), %rdx\n38: \tleaq\t1(%rcx), %rsi\n3c: \tmovq\t%rsi, (%rbx)\n3f: \tmovl\t%eax, (%rdx,%rcx,4)\n42: \tmovl\t(%rip), %edi  # 0x48 <generate_resumption_token+0x48>\n48: \tmovq\t%r15, %rsi\n4b: \tmovq\t%rbx, %rdx\n4e: \tmovq\t%r14, %r8\n51: \tcallq\t0x56 <generate_resumption_token+0x56>\n56: \taddq\t$16, %rsp\n5a: \tpopq\t%rbx\n5b: \tpopq\t%r14\n5d: \tpopq\t%r15\n5f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  int /*<<< orphan*/  quicly_generate_resumption_token_t ;\ntypedef  int /*<<< orphan*/  quicly_conn_t ;\ntypedef  int /*<<< orphan*/  quicly_address_token_plaintext_t ;\nstruct TYPE_5__ {scalar_t__ off; int /*<<< orphan*/ * base; } ;\ntypedef  TYPE_1__ ptls_buffer_t ;\ntypedef  int /*<<< orphan*/  ptls_aead_context_t ;\n\n/* Variables and functions */\nint ptls_buffer_reserve (TYPE_1__*,int) ;\nint /*<<< orphan*/  ptls_openssl_random_bytes ;\nint /*<<< orphan*/ * quic_get_address_token_encryptor (int /*<<< orphan*/ *) ;\nint quicly_encrypt_address_token (int /*<<< orphan*/ ,int /*<<< orphan*/ *,TYPE_1__*,scalar_t__,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int generate_resumption_token(quicly_generate_resumption_token_t *self, quicly_conn_t *conn, ptls_buffer_t *buf,\nquicly_address_token_plaintext_t *token)\n{\nuint8_t prefix;\nptls_aead_context_t *aead = quic_get_address_token_encryptor(&prefix);\nint ret;\n\nif ((ret = ptls_buffer_reserve(buf, 1)) != 0)\nreturn ret;\nbuf->base[buf->off++] = prefix;\nreturn quicly_encrypt_address_token(ptls_openssl_random_bytes, aead, buf, buf->off - 1, token);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t len; int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__ PX_Cipher ;\ntypedef  int /*<<< orphan*/  PX_MD ;\ntypedef  int /*<<< orphan*/  PX_Context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PX_MD_Update (int /*<<< orphan*/ ,int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  PX_MD_digest (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PX_MD_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  md5 ;\n\n__attribute__((used)) static void\ngenerate_resumption_token(PX_Context *ctx, PX_MD *md, PX_Cipher *cipher,\nconst char *password)\n{\nPX_MD\t\tresumption_token_md;\n\nPX_MD_init(&resumption_token_md);\nPX_MD_Update(&resumption_token_md, &md->data[1], cipher);\nif (!PX_MD_digest(&resumption_token_md, &md->data[0], cipher))\n{\ncipher->data[cipher->len++] = md->data[0];\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_decrypt_cid",
    "input":"\n0000000000000000 <decrypt_cid>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rcx, %r15\n8: \tmovq\t%rdx, %rbx\nb: \tmovq\t%rsi, %r14\ne: \txorl\t%eax, %eax\n10: \tcallq\t0x15 <decrypt_cid+0x15>\n15: \tmovl\t(%rbx), %edi\n17: \tcallq\t0x1c <decrypt_cid+0x1c>\n1c: \ttestq\t%rax, %rax\n1f: \tje\t0x4e <decrypt_cid+0x4e>\n21: \tmovq\t(%rax), %rdi\n24: \taddq\t$4, %rbx\n28: \txorl\t%ecx, %ecx\n2a: \tsubq\t$1, %r15\n2e: \tcmovaeq\t%r15, %rcx\n32: \tmovq\t%r14, %rsi\n35: \tmovq\t%rbx, %rdx\n38: \tcallq\t*(%rdi)\n3a: \tmovq\t(%rip), %rcx  # 0x41 <decrypt_cid+0x41>\n41: \tcmpq\t%rcx, %rax\n44: \tleaq\t1(%rax), %rax\n48: \tcmoveq\t%rcx, %rax\n4c: \tjmp\t0x55 <decrypt_cid+0x55>\n4e: \tmovq\t(%rip), %rax  # 0x55 <decrypt_cid+0x55>\n55: \tpopq\t%rbx\n56: \tpopq\t%r14\n58: \tpopq\t%r15\n5a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\nstruct st_quic_keyset_t {TYPE_1__* cid; } ;\ntypedef  int /*<<< orphan*/  quicly_cid_plaintext_t ;\ntypedef  int /*<<< orphan*/  quicly_cid_encryptor_t ;\nstruct TYPE_2__ {size_t (* decrypt_cid ) (TYPE_1__*,int /*<<< orphan*/ *,int /*<<< orphan*/  const*,size_t) ;} ;\n\n/* Variables and functions */\nsize_t SIZE_MAX ;\nstruct st_quic_keyset_t* find_keyset (int /*<<< orphan*/  const) ;\nsize_t stub1 (TYPE_1__*,int /*<<< orphan*/ *,int /*<<< orphan*/  const*,size_t) ;\nint /*<<< orphan*/  update_quic_keys () ;\n\n__attribute__((used)) static size_t decrypt_cid(quicly_cid_encryptor_t *self, quicly_cid_plaintext_t *plaintext, const void *_encrypted, size_t len)\n{\nconst uint8_t *encrypted = _encrypted;\nstruct st_quic_keyset_t *keyset;\n\nupdate_quic_keys();\n\nif ((keyset = find_keyset(encrypted[0])) == NULL)\nreturn SIZE_MAX;\nif ((len = keyset->cid->decrypt_cid(keyset->cid, plaintext, encrypted + 1, len != 0 ? len - 1 : 0)) == SIZE_MAX)\nreturn SIZE_MAX;\nreturn 1 + len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  (* decrypt ) (int /*<<< orphan*/ *,unsigned char*,unsigned char*,size_t) ;} ;\ntypedef  TYPE_1__ CRYPTO_PROVIDER ;\ntypedef  int /*<<< orphan*/  CRYPTO_CONTEXT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CRYPTO_FUNC (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CRYPTO_FUNC_decrypt ;\nint /*<<< orphan*/  CRYPTO_FUNC_decrypt_cid ;\nTYPE_1__* crypto_find_provider (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stub1 (int /*<<< orphan*/ *,unsigned char*,unsigned char*,size_t) ;\n\n__attribute__((used)) static unsigned char *\ndecrypt_cid(CRYPTO_CONTEXT *context, unsigned char *data,\nunsigned char *out, size_t out_len)\n{\nCRYPTO_PROVIDER *provider;\n\nCRYPTO_FUNC(CRYPTO_FUNC_decrypt_cid);\n\nprovider = crypto_find_provider(context);\nif (provider == NULL)\nreturn NULL;\n\nreturn provider->decrypt(context, data, out, out_len);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_free_tickets",
    "input":"\n0000000000000000 <free_tickets>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tcmpq\t$0, (%rdi)\nb: \tmovq\t8(%rdi), %rdi\nf: \tje\t0x35 <free_tickets+0x35>\n11: \txorl\t%ebx, %ebx\n13: \tnopw\t%cs:(%rax,%rax)\n1d: \tnopl\t(%rax)\n20: \tmovl\t(%rdi,%rbx,4), %edi\n23: \tcallq\t0x28 <free_tickets+0x28>\n28: \taddq\t$1, %rbx\n2c: \tmovq\t8(%r14), %rdi\n30: \tcmpq\t(%r14), %rbx\n33: \tjne\t0x20 <free_tickets+0x20>\n35: \tcallq\t0x3a <free_tickets+0x3a>\n3a: \tmovq\t%r14, %rdi\n3d: \txorl\t%esi, %esi\n3f: \tmovl\t$16, %edx\n44: \taddq\t$8, %rsp\n48: \tpopq\t%rbx\n49: \tpopq\t%r14\n4b: \tjmp\t0x50 <free_tickets+0x50>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t size; int /*<<< orphan*/ * entries; } ;\ntypedef  TYPE_1__ session_ticket_vector_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free_ticket (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void free_tickets(session_ticket_vector_t *tickets)\n{\nsize_t i;\nfor (i = 0; i != tickets->size; ++i)\nfree_ticket(tickets->entries[i]);\nfree(tickets->entries);\nmemset(tickets, 0, sizeof(*tickets));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t n_tickets; int /*<<< orphan*/ * tickets; } ;\ntypedef  TYPE_1__ GLogTickets ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void\nfree_tickets(GLogTickets *tickets)\n{\nint i;\n\nfor (i = 0; i < tickets->n_tickets; i++)\nfree(tickets->tickets[i]);\n\nfree(tickets->tickets);\nmemset(tickets, 0, sizeof(*tickets));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_do_swap_register_session_tickets",
    "input":"\n0000000000000000 <do_swap_register_session_tickets>:\n0: \tmovq\t%rdi, %rsi\n3: \tmovl\t$0, %edi\n8: \tmovl\t$4, %edx\nd: \tjmp\t0x12 <do_swap_register_session_tickets+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  tickets; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_mem_swap (int /*<<< orphan*/ *,void*,int) ;\nTYPE_1__ session_tickets ;\n\n__attribute__((used)) static void do_swap_register_session_tickets(void *p)\n{\nh2o_mem_swap(&session_tickets.tickets, p, sizeof(session_tickets.tickets));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_swap_int (char*,unsigned char*,int) ;\n\n__attribute__((used)) static void do_swap_register_session_tickets(SSL *ssl)\n{\ndo_swap_int(\"register_session_tickets\",\n(unsigned char *)&ssl->ext.session_ticket_cb,\nsizeof(ssl->ext.session_ticket_cb));\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_session_ticket_get_cipher_key",
    "input":"\n0000000000000000 <session_ticket_get_cipher_key>:\n0: \tmovq\t(%rdi), %rax\n3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_session_ticket_t {unsigned char* keybuf; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static unsigned char *session_ticket_get_cipher_key(struct st_session_ticket_t *ticket)\n{\nreturn ticket->keybuf;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {unsigned char* cipher_key; } ;\ntypedef  TYPE_1__ SSL ;\n\n/* Variables and functions */\n\nunsigned char *session_ticket_get_cipher_key(SSL *s)\n{\nreturn s->cipher_key;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_encrypt_ticket_key_ptls",
    "input":"\n0000000000000000 <encrypt_ticket_key_ptls>:\n0: \tmovl\t%r8d, %esi\n3: \ttestl\t%edx, %edx\n5: \tmovl\t$0, %edx\na: \tmovl\t$0, %eax\nf: \tcmoveq\t%rdx, %rax\n13: \tmovl\t(%rip), %edx  # 0x19 <encrypt_ticket_key_ptls+0x19>\n19: \tmovq\t%rcx, %rdi\n1c: \tjmpq\t*%rax",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ptls_t ;\ntypedef  int /*<<< orphan*/  ptls_iovec_t ;\ntypedef  int /*<<< orphan*/  ptls_encrypt_ticket_t ;\ntypedef  int /*<<< orphan*/  ptls_buffer_t ;\n\n/* Variables and functions */\nint ptls_openssl_decrypt_ticket (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint ptls_openssl_encrypt_ticket (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint stub1 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ticket_key_callback ;\n\n__attribute__((used)) static int encrypt_ticket_key_ptls(ptls_encrypt_ticket_t *self, ptls_t *tls, int is_encrypt, ptls_buffer_t *dst, ptls_iovec_t src)\n{\nreturn (is_encrypt ? ptls_openssl_encrypt_ticket : ptls_openssl_decrypt_ticket)(dst, src, ticket_key_callback);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  int /*<<< orphan*/  uint32_t ;\ntypedef  int /*<<< orphan*/  RSA ;\n\n/* Variables and functions */\nint /*<<< orphan*/  RSA_PKCS1_OAEP_PADDING ;\nint /*<<< orphan*/  RSA_private_encrypt (int /*<<< orphan*/ ,int /*<<< orphan*/  const*,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  RSA_public_encrypt (int /*<<< orphan*/ ,int /*<<< orphan*/  const*,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nencrypt_ticket_key_ptls(uint8_t *out, uint32_t *out_len,\nconst uint8_t *in, uint32_t in_len, RSA *rsa)\n{\nif (in_len)\nRSA_public_encrypt(in_len, in, out, out_len, RSA_PKCS1_OAEP_PADDING);\nelse\nRSA_private_encrypt(in_len, in, out, out_len, RSA_PKCS1_OAEP_PADDING);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_setup_cache_disable",
    "input":"\n0000000000000000 <setup_cache_disable>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \ttestq\t%rsi, %rsi\n8: \tje\t0x38 <setup_cache_disable+0x38>\na: \tmovq\t%rsi, %r15\nd: \tmovq\t%rdi, %r14\n10: \txorl\t%ebx, %ebx\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \tmovq\t(%r14,%rbx,8), %rdi\n24: \tmovl\t(%rip), %esi  # 0x2a <setup_cache_disable+0x2a>\n2a: \tcallq\t0x2f <setup_cache_disable+0x2f>\n2f: \taddq\t$1, %rbx\n33: \tcmpq\t%rbx, %r15\n36: \tjne\t0x20 <setup_cache_disable+0x20>\n38: \tpopq\t%rbx\n39: \tpopq\t%r14\n3b: \tpopq\t%r15\n3d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_session_cache_mode (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_SESS_CACHE_OFF ;\n\n__attribute__((used)) static void setup_cache_disable(SSL_CTX **contexts, size_t num_contexts)\n{\nsize_t i;\nfor (i = 0; i != num_contexts; ++i)\nSSL_CTX_set_session_cache_mode(contexts[i], SSL_SESS_CACHE_OFF);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t ULONG ;\ntypedef  int /*<<< orphan*/  PVOID ;\ntypedef  int /*<<< orphan*/  PFILE_OBJECT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FILE_CACHE_DISABLED ;\nint /*<<< orphan*/  IoSetFileObjectExclusive (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void setup_cache_disable(PFILE_OBJECT *files, ULONG count)\n{\nULONG i;\n\nfor (i = 0; i < count; i++)\nIoSetFileObjectExclusive(files[i], FILE_CACHE_DISABLED);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_swap_register_session_tickets",
    "input":"\n0000000000000000 <swap_register_session_tickets>:\n0: \tmovq\t%rdi, %rsi\n3: \tmovl\t(%rip), %edi  # 0x9 <swap_register_session_tickets+0x9>\n9: \tjmp\t0xe <swap_register_session_tickets+0xe>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  session_ticket_vector_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  do_swap_register_session_tickets ;\nint /*<<< orphan*/  register_session_tickets (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void swap_register_session_tickets(session_ticket_vector_t *p)\n{\nregister_session_tickets(do_swap_register_session_tickets, p);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB ;\nint /*<<< orphan*/  SSL_CTX_callback_ctrl (int /*<<< orphan*/ ,int /*<<< orphan*/ ,void (*) (int /*<<< orphan*/ *,unsigned char*,int,void*)) ;\n\n__attribute__((used)) static void swap_register_session_tickets(SSL *ssl, void (*cb)(SSL *, unsigned char *, int, void *))\n{\nSSL_CTX_callback_ctrl(ssl, SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB, cb);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_spawn_cache_cleanup_thread",
    "input":"\n0000000000000000 <spawn_cache_cleanup_thread>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rsi, %rbx\na: \tmovq\t%rdi, %r14\nd: \tleal\t(,%rsi,8), %r15d\n15: \tleal\t8(,%rsi,8), %edi\n1c: \tcallq\t0x21 <spawn_cache_cleanup_thread+0x21>\n21: \tmovq\t%rax, %rbp\n24: \tmovq\t%rax, %rdi\n27: \tmovq\t%r14, %rsi\n2a: \tmovl\t%r15d, %edx\n2d: \tcallq\t0x32 <spawn_cache_cleanup_thread+0x32>\n32: \tmovq\t$0, (%rbp,%rbx,8)\n3b: \tmovq\t%rsp, %rbx\n3e: \tmovq\t%rbx, %rdi\n41: \tcallq\t0x46 <spawn_cache_cleanup_thread+0x46>\n46: \tmovq\t%rbx, %rdi\n49: \tmovl\t$1, %esi\n4e: \tcallq\t0x53 <spawn_cache_cleanup_thread+0x53>\n53: \tmovl\t(%rip), %edx  # 0x59 <spawn_cache_cleanup_thread+0x59>\n59: \tleaq\t4(%rsp), %rdi\n5e: \tmovq\t%rbx, %rsi\n61: \tmovq\t%rbp, %rcx\n64: \tcallq\t0x69 <spawn_cache_cleanup_thread+0x69>\n69: \taddq\t$8, %rsp\n6d: \tpopq\t%rbx\n6e: \tpopq\t%r14\n70: \tpopq\t%r15\n72: \tpopq\t%rbp\n73: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pthread_t ;\ntypedef  int /*<<< orphan*/  pthread_attr_t ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  cache_cleanup_thread ;\nint /*<<< orphan*/ ** h2o_mem_alloc (int) ;\nint /*<<< orphan*/  h2o_memcpy (int /*<<< orphan*/ **,int /*<<< orphan*/ **,int) ;\nint /*<<< orphan*/  h2o_multithread_create_thread (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ **) ;\nint /*<<< orphan*/  pthread_attr_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_attr_setdetachstate (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void spawn_cache_cleanup_thread(SSL_CTX **_contexts, size_t num_contexts)\n{\n/* copy the list of contexts */\nSSL_CTX **contexts = h2o_mem_alloc(sizeof(*contexts) * (num_contexts + 1));\nh2o_memcpy(contexts, _contexts, sizeof(*contexts) * num_contexts);\ncontexts[num_contexts] = NULL;\n\n/* launch the thread */\npthread_t tid;\npthread_attr_t attr;\npthread_attr_init(&attr);\npthread_attr_setdetachstate(&attr, 1);\nh2o_multithread_create_thread(&tid, &attr, cache_cleanup_thread, contexts);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pthread_t ;\ntypedef  int /*<<< orphan*/  pthread_attr_t ;\ntypedef  int /*<<< orphan*/  pthread_mutex_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PTHREAD_CREATE_DETACHED ;\nint /*<<< orphan*/  PTHREAD_MUTEX_INITIALIZER ;\nint /*<<< orphan*/  pthread_attr_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_attr_setdetachstate (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,void*) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * safe_malloc (int) ;\nint /*<<< orphan*/  spawn_cache_cleanup_thread_func ;\n\nvoid spawn_cache_cleanup_thread(pthread_mutex_t *mutex, int num_threads) {\npthread_attr_t attr;\npthread_t *threads = safe_malloc(sizeof(pthread_t) * num_threads);\npthread_attr_init(&attr);\npthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\npthread_mutex_lock(mutex);\npthread_create(threads, &attr, spawn_cache_cleanup_thread_func, (void *)mutex);\npthread_mutex_unlock(mutex);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_setup_cache_memcached",
    "input":"\n0000000000000000 <setup_cache_memcached>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovl\t(%rip), %edi  # 0x10 <setup_cache_memcached+0x10>\n10: \tmovl\t(%rip), %esi  # 0x16 <setup_cache_memcached+0x16>\n16: \tmovl\t(%rip), %edx  # 0x1c <setup_cache_memcached+0x1c>\n1c: \tmovl\t(%rip), %ecx  # 0x22 <setup_cache_memcached+0x22>\n22: \tmovl\t(%rip), %r8d  # 0x29 <setup_cache_memcached+0x29>\n29: \tcallq\t0x2e <setup_cache_memcached+0x2e>\n2e: \tmovl\t(%rip), %esi  # 0x34 <setup_cache_memcached+0x34>\n34: \tmovq\t%rax, %rdi\n37: \tcallq\t0x3c <setup_cache_memcached+0x3c>\n3c: \tmovq\t%rbx, %rdi\n3f: \tmovq\t%r14, %rsi\n42: \tmovl\t$1, %edx\n47: \taddq\t$8, %rsp\n4b: \tpopq\t%rbx\n4c: \tpopq\t%r14\n4e: \tjmp\t0x53 <setup_cache_memcached+0x53>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_6__ ;\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_memcached_context_t ;\nstruct TYPE_9__ {int /*<<< orphan*/  prefix; int /*<<< orphan*/  num_threads; } ;\nstruct TYPE_11__ {TYPE_3__ memcached; } ;\nstruct TYPE_10__ {TYPE_5__ vars; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  text_protocol; int /*<<< orphan*/  port; int /*<<< orphan*/  host; } ;\nstruct TYPE_8__ {TYPE_1__ memcached; } ;\nstruct TYPE_12__ {int /*<<< orphan*/  lifetime; TYPE_4__ cache; TYPE_2__ store; } ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nTYPE_6__ conf ;\nint /*<<< orphan*/  h2o_accept_setup_memcached_ssl_resumption (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * h2o_memcached_create_context (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  setup_cache_enable (int /*<<< orphan*/ **,size_t,int) ;\n\n__attribute__((used)) static void setup_cache_memcached(SSL_CTX **contexts, size_t num_contexts)\n{\nh2o_memcached_context_t *memc_ctx =\nh2o_memcached_create_context(conf.store.memcached.host, conf.store.memcached.port, conf.store.memcached.text_protocol,\nconf.cache.vars.memcached.num_threads, conf.cache.vars.memcached.prefix);\nh2o_accept_setup_memcached_ssl_resumption(memc_ctx, conf.lifetime);\nsetup_cache_enable(contexts, num_contexts, 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CACHE_MEMCACHED_HOST ;\nint /*<<< orphan*/  CACHE_MEMCACHED_PORT ;\nint /*<<< orphan*/  CACHE_MEMCACHED_PROTO ;\nint /*<<< orphan*/  CACHE_MEMCACHED_TIMEOUT ;\nint /*<<< orphan*/  G_MODULE_MEMCACHED ;\nint /*<<< orphan*/  g_module_set_default (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_set_default_for_host (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority_weight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  g_module_set_default_for_host_port_proto_timeout_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority_weight_priority (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_free_ticket",
    "input":"\n0000000000000000 <free_ticket>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tmovl\t8(%rdi), %edi\na: \tcallq\t0xf <free_ticket+0xf>\nf: \tmovl\t%eax, %r14d\n12: \tmovl\t4(%rbx), %edi\n15: \tcallq\t0x1a <free_ticket+0x1a>\n1a: \tmovl\t(%rbx), %edi\n1c: \tleal\t(%rax,%r14), %edx\n20: \txorl\t%esi, %esi\n22: \tcallq\t0x27 <free_ticket+0x27>\n27: \tmovq\t%rbx, %rdi\n2a: \taddq\t$8, %rsp\n2e: \tpopq\t%rbx\n2f: \tpopq\t%r14\n31: \tjmp\t0x36 <free_ticket+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_session_ticket_t {int /*<<< orphan*/  keybuf; int /*<<< orphan*/  hmac; int /*<<< orphan*/  cipher; } ;\n\n/* Variables and functions */\nint EVP_CIPHER_key_length (int /*<<< orphan*/ ) ;\nint EVP_MD_block_size (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  free (struct st_session_ticket_t*) ;\nint /*<<< orphan*/  h2o_mem_set_secure (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void free_ticket(struct st_session_ticket_t *ticket)\n{\nint key_len = EVP_CIPHER_key_length(ticket->cipher), block_size = EVP_MD_block_size(ticket->hmac);\nh2o_mem_set_secure(ticket->keybuf, 0, key_len + block_size);\nfree(ticket);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  ticket_len; int /*<<< orphan*/  ticket; int /*<<< orphan*/  ticket_key; } ;\ntypedef  TYPE_1__ SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  OPENSSL_free (TYPE_1__*) ;\nint /*<<< orphan*/  OPENSSL_secure_clear_free (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  OPENSSL_secure_clear_free (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void free_ticket(SSL *s)\n{\nOPENSSL_secure_clear_free(s->ticket_key, s->ticket_len);\nOPENSSL_secure_clear_free(s->ticket, s->ticket_len);\nmemset(s, 0, sizeof(*s));\nOPENSSL_free(s);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_find_keyset",
    "input":"\n0000000000000000 <find_keyset>:\n0: \tmovq\t(%rip), %rcx  # 0x7 <find_keyset+0x7>\n7: \ttestq\t%rcx, %rcx\na: \tje\t0x2f <find_keyset+0x2f>\nc: \tmovq\t(%rip), %rax  # 0x13 <find_keyset+0x13>\n13: \tnopw\t%cs:(%rax,%rax)\n1d: \tnopl\t(%rax)\n20: \tcmpq\t%rdi, (%rax)\n23: \tje\t0x31 <find_keyset+0x31>\n25: \taddq\t$8, %rax\n29: \taddq\t$-1, %rcx\n2d: \tjne\t0x20 <find_keyset+0x20>\n2f: \txorl\t%eax, %eax\n31: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint8_t ;\nstruct st_quic_keyset_t {scalar_t__ name; } ;\nstruct TYPE_3__ {size_t size; struct st_quic_keyset_t* entries; } ;\nstruct TYPE_4__ {TYPE_1__ keys; } ;\n\n/* Variables and functions */\nTYPE_2__ quic_keys ;\n\n__attribute__((used)) static struct st_quic_keyset_t *find_keyset(uint8_t key_id)\n{\nsize_t i;\nfor (i = 0; i != quic_keys.keys.size; ++i) {\nstruct st_quic_keyset_t *key = quic_keys.keys.entries + i;\nif (key->name == key_id)\nreturn key;\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ UINT ;\ntypedef  int /*<<< orphan*/  KEYSET ;\n\n/* Variables and functions */\nint /*<<< orphan*/ ** keyset_list ;\nsize_t keyset_list_count ;\n\n__attribute__((used)) static KEYSET *find_keyset(UINT keyset_id)\n{\nsize_t i;\n\nfor (i = 0; i < keyset_list_count; i++)\n{\nif (keyset_list[i]->id == keyset_id)\nreturn keyset_list[i];\n}\n\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_setup_cache_redis",
    "input":"\n0000000000000000 <setup_cache_redis>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovl\t(%rip), %edi  # 0x10 <setup_cache_redis+0x10>\n10: \tmovl\t(%rip), %esi  # 0x16 <setup_cache_redis+0x16>\n16: \tmovl\t(%rip), %edx  # 0x1c <setup_cache_redis+0x1c>\n1c: \tmovl\t(%rip), %ecx  # 0x22 <setup_cache_redis+0x22>\n22: \tcallq\t0x27 <setup_cache_redis+0x27>\n27: \tmovq\t%rbx, %rdi\n2a: \tmovq\t%r14, %rsi\n2d: \tmovl\t$1, %edx\n32: \taddq\t$8, %rsp\n36: \tpopq\t%rbx\n37: \tpopq\t%r14\n39: \tjmp\t0x3e <setup_cache_redis+0x3e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_6__ ;\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  prefix; } ;\nstruct TYPE_10__ {TYPE_3__ redis; } ;\nstruct TYPE_11__ {TYPE_4__ vars; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  port; int /*<<< orphan*/  host; } ;\nstruct TYPE_8__ {TYPE_1__ redis; } ;\nstruct TYPE_12__ {TYPE_5__ cache; int /*<<< orphan*/  lifetime; TYPE_2__ store; } ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nTYPE_6__ conf ;\nint /*<<< orphan*/  h2o_accept_setup_redis_ssl_resumption (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  setup_cache_enable (int /*<<< orphan*/ **,size_t,int) ;\n\n__attribute__((used)) static void setup_cache_redis(SSL_CTX **contexts, size_t num_contexts)\n{\nh2o_accept_setup_redis_ssl_resumption(conf.store.redis.host, conf.store.redis.port, conf.lifetime,\nconf.cache.vars.redis.prefix);\nsetup_cache_enable(contexts, num_contexts, 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CACHE_REDIS_PORT ;\nint /*<<< orphan*/  CACHE_REDIS_SERVER ;\nint /*<<< orphan*/  CACHE_REDIS_USER ;\nint /*<<< orphan*/  CACHE_REDIS_PASS ;\nint /*<<< orphan*/  cache_redis_init (int /*<<< orphan*/ *,char const*,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_symbol (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nvoid setup_cache_redis (GModule * module, const char *path) {\ng_module_symbol (module, \"cache_redis_init\", (void *)cache_redis_init, 1);\ncache_redis_init (module, path, 1, CACHE_REDIS_PORT);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_ssl_session_ticket_register_setup_barrier",
    "input":"\n0000000000000000 <ssl_session_ticket_register_setup_barrier>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcmpq\t$0, (%rip)    # 0xc <ssl_session_ticket_register_setup_barrier+0xc>\nc: \tjne\t0x18 <ssl_session_ticket_register_setup_barrier+0x18>\ne: \tmovl\t$0, %edi\n13: \tcallq\t0x18 <ssl_session_ticket_register_setup_barrier+0x18>\n18: \txorl\t%edi, %edi\n1a: \tcmpq\t$0, (%rip)    # 0x22 <ssl_session_ticket_register_setup_barrier+0x22>\n22: \tsete\t%dil\n26: \tcallq\t0x2b <ssl_session_ticket_register_setup_barrier+0x2b>\n2b: \tmovq\t%rbx, %rdi\n2e: \tmovl\t$1, %esi\n33: \tcallq\t0x38 <ssl_session_ticket_register_setup_barrier+0x38>\n38: \tmovq\t%rbx, (%rip)  # 0x3f <ssl_session_ticket_register_setup_barrier+0x3f>\n3f: \tpopq\t%rbx\n40: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  h2o_barrier_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * update_thread; } ;\nstruct TYPE_6__ {TYPE_1__ ticket; } ;\nstruct TYPE_5__ {int /*<<< orphan*/ * barrier; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nTYPE_3__ conf ;\nint /*<<< orphan*/  h2o_barrier_add (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  h2o_fatal (char*) ;\nTYPE_2__ session_tickets ;\n\nvoid ssl_session_ticket_register_setup_barrier(h2o_barrier_t *barrier)\n{\nif (conf.ticket.update_thread == NULL)\nh2o_fatal(\"ticket-based encryption MUST be enabled when running QUIC\");\nassert(session_tickets.barrier == NULL);\nh2o_barrier_add(barrier, 1);\nsession_tickets.barrier = barrier;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_SESSION ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CRYPTO_THREAD_set_local (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  CRYPTO_THREAD_unlock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  CRYPTO_THREAD_write_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  CRYPTO_THREAD_write_unlock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  CRYPTO_THREAD_write_unlock_unlock_callback ;\nint /*<<< orphan*/ * session_ticket_lock ;\nint /*<<< orphan*/  ssl_session_ticket_lock_init ;\n\nvoid ssl_session_ticket_register_setup_barrier(SSL_SESSION *sess)\n{\nif (!session_ticket_lock) {\n# ifdef REF_CHECK_DEBUG\nCRYPTO_THREAD_set_local(&ssl_session_ticket_lock_init, 1);\n# endif\nCRYPTO_THREAD_write_lock(session_ticket_lock);\nCRYPTO_THREAD_set_local(&ssl_session_ticket_lock_init, 0);\n}\n\nCRYPTO_THREAD_write_unlock(session_ticket_lock);\nCRYPTO_THREAD_set_local(&CRYPTO_THREAD_write_unlock_unlock_callback,\n(void *)CRYPTO_THREAD_write_unlock);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_ticket_sort_compare",
    "input":"\n0000000000000000 <ticket_sort_compare>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t(%rsi), %rcx\n6: \tmovq\t(%rcx), %rdx\n9: \tcmpq\t%rdx, (%rax)\nc: \tjne\t0x1e <ticket_sort_compare+0x1e>\ne: \tmovl\t8(%rax), %edi\n11: \tmovl\t8(%rcx), %esi\n14: \tmovl\t$4, %edx\n19: \tjmp\t0x1e <ticket_sort_compare+0x1e>\n1e: \tsetle\t%al\n21: \tmovzbl\t%al, %eax\n24: \taddl\t%eax, %eax\n26: \taddl\t$-1, %eax\n29: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct st_session_ticket_t {scalar_t__ not_before; int /*<<< orphan*/  name; } ;\n\n/* Variables and functions */\nint memcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static int ticket_sort_compare(const void *_x, const void *_y)\n{\nstruct st_session_ticket_t *x = *(void **)_x, *y = *(void **)_y;\n\nif (x->not_before != y->not_before)\nreturn x->not_before > y->not_before ? -1 : 1;\nreturn memcmp(x->name, y->name, sizeof(x->name));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ ticket_id; int /*<<< orphan*/  ticket_id_str; } ;\ntypedef  TYPE_1__ GLogTicket ;\n\n/* Variables and functions */\nint strcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nticket_sort_compare (const void *a, const void *b)\n{\nconst GLogTicket *ta = *(const GLogTicket **) a;\nconst GLogTicket *tb = *(const GLogTicket **) b;\n\nif (ta->ticket_id < tb->ticket_id)\nreturn -1;\nif (ta->ticket_id > tb->ticket_id)\nreturn 1;\nreturn strcmp (ta->ticket_id_str, tb->ticket_id_str);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_quic_decrypt_address_token",
    "input":"\n0000000000000000 <quic_decrypt_address_token>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdx, %rbx\n7: \tmovl\t%esi, %r14d\na: \tmovq\t%rdi, %rbp\nd: \txorl\t%eax, %eax\nf: \tcallq\t0x14 <quic_decrypt_address_token+0x14>\n14: \tmovl\t(%rbx), %edi\n16: \tcallq\t0x1b <quic_decrypt_address_token+0x1b>\n1b: \ttestq\t%rax, %rax\n1e: \tje\t0x3a <quic_decrypt_address_token+0x3a>\n20: \tmovl\t(%rax), %edi\n22: \tmovq\t%rbp, %rsi\n25: \tmovq\t%rbx, %rdx\n28: \tmovl\t%r14d, %ecx\n2b: \tmovl\t$1, %r8d\n31: \tpopq\t%rbx\n32: \tpopq\t%r14\n34: \tpopq\t%rbp\n35: \tjmp\t0x3a <quic_decrypt_address_token+0x3a>\n3a: \tmovl\t(%rip), %eax  # 0x40 <quic_decrypt_address_token+0x40>\n40: \tpopq\t%rbx\n41: \tpopq\t%r14\n43: \tpopq\t%rbp\n44: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  dec; } ;\nstruct st_quic_keyset_t {TYPE_1__ address_token; } ;\ntypedef  int /*<<< orphan*/  quicly_address_token_plaintext_t ;\nstruct TYPE_5__ {int /*<<< orphan*/  len; int /*<<< orphan*/ * base; } ;\ntypedef  TYPE_2__ ptls_iovec_t ;\n\n/* Variables and functions */\nint PTLS_ERROR_INCOMPATIBLE_KEY ;\nstruct st_quic_keyset_t* find_keyset (int /*<<< orphan*/ ) ;\nint quicly_decrypt_address_token (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  update_quic_keys () ;\n\nint quic_decrypt_address_token(quicly_address_token_plaintext_t *pt, ptls_iovec_t input)\n{\nstruct st_quic_keyset_t *keyset;\n\nupdate_quic_keys();\n\nif ((keyset = find_keyset(input.base[0])) == NULL)\nreturn PTLS_ERROR_INCOMPATIBLE_KEY; /* TODO consider error code */\nreturn quicly_decrypt_address_token(keyset->address_token.dec, pt, input.base, input.len, 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  key; } ;\ntypedef  TYPE_1__ GNUTLS_QUIC_KEY ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_TYPE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_ID ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_TYPE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_FLAGS ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_SIZE ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_OFFSET ;\ntypedef  int /*<<< orphan*/  GNUTLS_QUIC_KEY_PACKET_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_DATA_LENGTH ;\ntypedef  int /*<<< orphan"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_quic_get_address_token_encryptor",
    "input":"\n0000000000000000 <quic_get_address_token_encryptor>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <quic_get_address_token_encryptor+0xb>\nb: \tmovl\t8(%rax), %ecx\ne: \tmovl\t%ecx, (%rbx)\n10: \tmovq\t(%rax), %rax\n13: \tpopq\t%rbx\n14: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\nstruct TYPE_2__ {int /*<<< orphan*/ * enc; } ;\nstruct st_quic_keyset_t {TYPE_1__ address_token; int /*<<< orphan*/  name; } ;\ntypedef  int /*<<< orphan*/  ptls_aead_context_t ;\n\n/* Variables and functions */\nstruct st_quic_keyset_t* update_quic_keys () ;\n\nptls_aead_context_t *quic_get_address_token_encryptor(uint8_t *prefix)\n{\nstruct st_quic_keyset_t *keyset = update_quic_keys();\n*prefix = keyset->name;\nreturn keyset->address_token.enc;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  (* encrypt ) (int /*<<< orphan*/ *,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned char*,unsigned"
},
{
    "file:":"./h2o/t/00unit/src/extr_ssl.c_test_src__ssl_c",
    "input":"\n0000000000000000 <test_src__ssl_c>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <test_src__ssl_c+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <test_src__ssl_c+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <test_src__ssl_c+0x17>\n17: \tmovl\t$0, %edi\n1c: \tcallq\t0x21 <test_src__ssl_c+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <test_src__ssl_c+0x27>\n27: \tmovl\t$0, %edi\n2c: \tpopq\t%rax\n2d: \tjmp\t0x32 <test_src__ssl_c+0x32>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  subtest (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_load_tickets_file ;\nint /*<<< orphan*/  test_memcached_ticket_update ;\nint /*<<< orphan*/  test_serialize_tickets ;\n\nvoid test_src__ssl_c(void)\n{\nsubtest(\"load-tickets-file\", test_load_tickets_file);\nsubtest(\"serialize-tickets\", test_serialize_tickets);\nsubtest(\"memcached-ticket-update\", test_memcached_ticket_update);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_SSL_CERT_FILE ;\nint /*<<< orphan*/  TEST_SSL_KEY_FILE ;\nint /*<<< orphan*/  TEST_SSL_ROOT_CERT_FILE ;\nint /*<<< orphan*/  test_src__ssl_c_file (char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void test_src__ssl_c(void)\n{\ntest_src__ssl_c_file(\"test_src__ssl_c\", TEST_SSL_CERT_FILE);\ntest_src__ssl_c_file(\"test_src__ssl_c\", TEST_SSL_KEY_FILE);\ntest_src__ssl_c_file(\"test_src__ssl_c\", TEST_SSL_ROOT_CERT_FILE);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_setup_cache_internal",
    "input":"\n0000000000000000 <setup_cache_internal>:\n0: \txorl\t%edx, %edx\n2: \tjmp\t0x7 <setup_cache_internal+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  setup_cache_enable (int /*<<< orphan*/ **,size_t,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void setup_cache_internal(SSL_CTX **contexts, size_t num_contexts)\n{\nsetup_cache_enable(contexts, num_contexts, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  setup_cache (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid setup_cache_internal(int cache_size)\n{\nsetup_cache(cache_size, 0, 0);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_encrypt_cid",
    "input":"\n0000000000000000 <encrypt_cid>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tsubq\t$24, %rsp\nb: \tmovq\t%rcx, %r15\ne: \tmovq\t%rdx, %r12\n11: \tmovq\t%rsi, %r14\n14: \txorl\t%eax, %eax\n16: \tcallq\t0x1b <encrypt_cid+0x1b>\n1b: \tmovq\t%rax, %rbx\n1e: \tmovq\t8(%rax), %rdi\n22: \tleaq\t8(%rsp), %rsi\n27: \tmovq\t%r12, %rdx\n2a: \tmovq\t%r15, %rcx\n2d: \tcallq\t*(%rdi)\n2f: \txorl\t%edi, %edi\n31: \tcmpl\t$8, 8(%rsp)\n36: \tsetb\t%dil\n3a: \tcallq\t0x3f <encrypt_cid+0x3f>\n3f: \tmovl\t(%rbx), %eax\n41: \tmovq\t8(%r14), %rdi\n45: \tmovl\t%eax, (%rdi)\n47: \taddq\t$4, %rdi\n4b: \tmovq\t16(%rsp), %rsi\n50: \tmovl\t8(%rsp), %edx\n54: \tcallq\t0x59 <encrypt_cid+0x59>\n59: \tmovl\t8(%rsp), %eax\n5d: \taddl\t$1, %eax\n60: \tmovl\t%eax, (%r14)\n63: \taddq\t$24, %rsp\n67: \tpopq\t%rbx\n68: \tpopq\t%r12\n6a: \tpopq\t%r14\n6c: \tpopq\t%r15\n6e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct st_quic_keyset_t {int /*<<< orphan*/  name; TYPE_2__* cid; } ;\nstruct TYPE_5__ {int len; int /*<<< orphan*/ * cid; } ;\ntypedef  TYPE_1__ quicly_cid_t ;\ntypedef  int /*<<< orphan*/  quicly_cid_plaintext_t ;\ntypedef  int /*<<< orphan*/  quicly_cid_encryptor_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  (* encrypt_cid ) (TYPE_2__*,TYPE_1__*,void*,int /*<<< orphan*/  const*) ;} ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  stub1 (TYPE_2__*,TYPE_1__*,void*,int /*<<< orphan*/  const*) ;\nstruct st_quic_keyset_t* update_quic_keys () ;\n\n__attribute__((used)) static void encrypt_cid(quicly_cid_encryptor_t *self, quicly_cid_t *encrypted, void *stateless_reset_token,\nconst quicly_cid_plaintext_t *plaintext)\n{\nstruct st_quic_keyset_t *keyset = update_quic_keys();\nquicly_cid_t tmp_cid;\n\nkeyset->cid->encrypt_cid(keyset->cid, &tmp_cid, stateless_reset_token, plaintext);\nassert(tmp_cid.len < sizeof(tmp_cid.cid));\nencrypted->cid[0] = keyset->name;\nmemcpy(encrypted->cid + 1, tmp_cid.cid, tmp_cid.len);\nencrypted->len = tmp_cid.len + 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  cid; int /*<<< orphan*/  cid_len; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  (* encrypt_cid ) (TYPE_1__*,unsigned char*,int /*<<< orphan*/ ,unsigned char const*) ;} ;\nstruct TYPE_8__ {TYPE_2__* method; } ;\ntypedef  TYPE_1__ SSL ;\ntypedef  int /*<<< orphan*/  PACKET ;\ntypedef  int /*<<< orphan*/  PACKET_CIPHER_INFO ;\ntypedef  int /*<<< orphan*/  PACKET_EXPANSION ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CRYPTO_memcmp (unsigned char*,unsigned char const*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CRYPTO_memcpy (unsigned char*,unsigned char const*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  OPENSSL_assert (int) ;\nTYPE_3__* SSL_get_cipher_by_id (int) ;\n\n__attribute__((used)) static void encrypt_cid(SSL *s, PACKET_EXPANSION *exp,\nPACKET_CIPHER_INFO *cipher_info, const unsigned char *in)\n{\nconst PACKET *pkt = &cipher_info->pkt;\nunsigned char *out = exp->out;\n\nOPENSSL_assert(pkt->len == 8);\n\ns->method->encrypt_cid(s, out, pkt->len, in);\n\nOPENSSL_assert(CRYPTO_memcmp(out, in, pkt->len) == 0);\n\ncipher_info->cid_len++;\nCRYPTO_memcpy(cipher_info->cid, out + 4, pkt->len);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_lock_callback",
    "input":"\n0000000000000000 <lock_callback>:\n0: \ttestl\t%edi, (%rip)  # 0x6 <lock_callback+0x6>\n6: \tje\t0x17 <lock_callback+0x17>\n8: \tmovslq\t%esi, %rdi\nb: \taddq\t(%rip), %rdi  # 0x12 <lock_callback+0x12>\n12: \tjmp\t0x17 <lock_callback+0x17>\n17: \ttestl\t%edi, (%rip)  # 0x1d <lock_callback+0x1d>\n1d: \tje\t0x2e <lock_callback+0x2e>\n1f: \tmovslq\t%esi, %rdi\n22: \taddq\t(%rip), %rdi  # 0x29 <lock_callback+0x29>\n29: \tjmp\t0x2e <lock_callback+0x2e>\n2e: \txorl\t%edi, %edi\n30: \tjmp\t0x35 <lock_callback+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint CRYPTO_LOCK ;\nint CRYPTO_UNLOCK ;\nint /*<<< orphan*/  assert (int) ;\nscalar_t__ mutexes ;\nint /*<<< orphan*/  pthread_mutex_lock (scalar_t__) ;\nint /*<<< orphan*/  pthread_mutex_unlock (scalar_t__) ;\n\n__attribute__((used)) static void lock_callback(int mode, int n, const char *file, int line)\n{\nif ((mode & CRYPTO_LOCK) != 0) {\npthread_mutex_lock(mutexes + n);\n} else if ((mode & CRYPTO_UNLOCK) != 0) {\npthread_mutex_unlock(mutexes + n);\n} else {\nassert(!\"unexpected mode\");\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sqlite3_file ;\n\n/* Variables and functions */\nint SQLITE_LOCK_EXCLUSIVE ;\nint SQLITE_LOCK_SHARED ;\nint /*<<< orphan*/  assert (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_lock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_mutex_unlock (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * shared_mutex ;\nint /*<<< orphan*/ * shared_mutex2 ;\n\n__attribute__((used)) static void lock_callback(void *NotUsed, int locktype, sqlite3_file *NotUsed2, int nNotUsed3){\nif( locktype == SQLITE_LOCK_SHARED ){\npthread_mutex_lock(shared_mutex);\n}else if( locktype == SQLITE_LOCK_EXCLUSIVE ){\npthread_mutex_lock(shared_mutex2);\n}else{\nassert( 0 );\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_ticket_key_callback_ossl",
    "input":"\n0000000000000000 <ticket_key_callback_ossl>:\n0: \tmovq\t%rsi, %rdi\n3: \tmovq\t%rdx, %rsi\n6: \tmovq\t%rcx, %rdx\n9: \tmovq\t%r8, %rcx\nc: \tmovl\t%r9d, %r8d\nf: \tjmp\t0x14 <ticket_key_callback_ossl+0x14>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\ntypedef  int /*<<< orphan*/  HMAC_CTX ;\ntypedef  int /*<<< orphan*/  EVP_CIPHER_CTX ;\n\n/* Variables and functions */\nint ticket_key_callback (unsigned char*,unsigned char*,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static int ticket_key_callback_ossl(SSL *ssl, unsigned char *key_name, unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx,\nint enc)\n{\nreturn ticket_key_callback(key_name, iv, ctx, hctx, enc);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint ticket_key_callback_int (void*,unsigned char*,int,unsigned char*,int) ;\n\n__attribute__((used)) static int ticket_key_callback_ossl(SSL *s, unsigned char *keyname,\nsize_t keyname_len,\nunsigned char *iv,\nsize_t iv_len)\n{\nreturn ticket_key_callback_int(s, keyname, keyname_len, iv, iv_len);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_find_ticket_for_encryption",
    "input":"\n0000000000000000 <find_ticket_for_encryption>:\n0: \tmovq\t(%rdi), %rcx\n3: \ttestq\t%rcx, %rcx\n6: \tje\t0x23 <find_ticket_for_encryption+0x23>\n8: \tmovq\t8(%rdi), %r8\nc: \txorl\t%eax, %eax\ne: \txorl\t%edi, %edi\n10: \tmovq\t(%r8,%rdi,8), %rdx\n14: \tcmpq\t%rsi, (%rdx)\n17: \tjle\t0x26 <find_ticket_for_encryption+0x26>\n19: \taddq\t$1, %rdi\n1d: \tcmpq\t%rdi, %rcx\n20: \tjne\t0x10 <find_ticket_for_encryption+0x10>\n22: \tretq\n23: \txorl\t%eax, %eax\n25: \tretq\n26: \txorl\t%eax, %eax\n28: \tcmpq\t%rsi, 8(%rdx)\n2c: \tcmovgeq\t%rdx, %rax\n30: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\nstruct st_session_ticket_t {scalar_t__ not_before; scalar_t__ not_after; } ;\nstruct TYPE_3__ {size_t size; struct st_session_ticket_t** entries; } ;\ntypedef  TYPE_1__ session_ticket_vector_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static struct st_session_ticket_t *find_ticket_for_encryption(session_ticket_vector_t *tickets, uint64_t now)\n{\nsize_t i;\n\nfor (i = 0; i != tickets->size; ++i) {\nstruct st_session_ticket_t *ticket = tickets->entries[i];\nif (ticket->not_before <= now) {\nif (now <= ticket->not_after) {\nreturn ticket;\n} else {\nreturn NULL;\n}\n}\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t num_tickets; int /*<<< orphan*/ * tickets; } ;\ntypedef  int /*<<< orphan*/  uint64_t ;\ntypedef  TYPE_1__ TicketCache ;\n\n/* Variables and functions */\n\n__attribute__((used)) static TicketCache *\nfind_ticket_for_encryption(TicketCache *cache, uint64_t encryption_key)\n{\nint i;\n\nfor (i = 0; i < cache->num_tickets; i++)\n{\nif (cache->tickets[i]->encryption_key <= encryption_key)\n{\nreturn cache->tickets[i];\n}\n}\n\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_cache_init_defaults",
    "input":"\n0000000000000000 <cache_init_defaults>:\n0: \tmovl\t(%rip), %eax  # 0x6 <cache_init_defaults+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <cache_init_defaults+0xc>\nc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  setup; } ;\nstruct TYPE_4__ {TYPE_1__ cache; } ;\n\n/* Variables and functions */\nTYPE_2__ conf ;\nint /*<<< orphan*/  setup_cache_internal ;\n\n__attribute__((used)) static void cache_init_defaults(void)\n{\nconf.cache.setup = setup_cache_internal;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  CACHE_DEFAULT_MAX_SIZE ;\nint /*<<< orphan*/  cache_max_size ;\n\nvoid cache_init_defaults (void) {\ncache_max_size = CACHE_DEFAULT_MAX_SIZE;\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_ssl_setup_session_resumption",
    "input":"\n0000000000000000 <ssl_setup_session_resumption>:\n0: \tmovq\t(%rip), %rax  # 0x7 <ssl_setup_session_resumption+0x7>\n7: \ttestq\t%rax, %rax\na: \tje\t0xe <ssl_setup_session_resumption+0xe>\nc: \tjmpq\t*%rax\ne: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_6__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  member_0; } ;\ntypedef  TYPE_3__ ptls_encrypt_ticket_t ;\nstruct TYPE_10__ {int ticket_lifetime; TYPE_3__* encrypt_ticket; } ;\ntypedef  TYPE_4__ ptls_context_t ;\ntypedef  int /*<<< orphan*/  pthread_t ;\ntypedef  int /*<<< orphan*/  pthread_attr_t ;\nstruct TYPE_8__ {int /*<<< orphan*/ * update_thread; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  (* setup ) (int /*<<< orphan*/ **,size_t) ;} ;\nstruct TYPE_11__ {TYPE_2__ ticket; TYPE_1__ cache; } ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint SSL_CTX_get_options (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_options (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint SSL_OP_NO_TICKET ;\nTYPE_6__ conf ;\nint /*<<< orphan*/  encrypt_ticket_key_ptls ;\nint /*<<< orphan*/  h2o_multithread_create_thread (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nTYPE_4__* h2o_socket_ssl_get_picotls_context (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_attr_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pthread_attr_setdetachstate (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  stub1 (int /*<<< orphan*/ **,size_t) ;\nint /*<<< orphan*/  ticket_key_callback_ossl ;\n\nvoid ssl_setup_session_resumption(SSL_CTX **contexts, size_t num_contexts)\n{\nif (conf.cache.setup != NULL)\nconf.cache.setup(contexts, num_contexts);\n\n#if H2O_USE_SESSION_TICKETS\nif (num_contexts == 0)\nreturn;\n\nif (conf.ticket.update_thread != NULL) {\n/* start session ticket updater thread */\npthread_t tid;\npthread_attr_t attr;\npthread_attr_init(&attr);\npthread_attr_setdetachstate(&attr, 1);\nh2o_multithread_create_thread(&tid, &attr, conf.ticket.update_thread, NULL);\nsize_t i;\nfor (i = 0; i != num_contexts; ++i) {\nSSL_CTX *ctx = contexts[i];\nSSL_CTX_set_tlsext_ticket_key_cb(ctx, ticket_key_callback_ossl);\nptls_context_t *pctx = h2o_socket_ssl_get_picotls_context(ctx);\nif (pctx != NULL) {\nstatic ptls_encrypt_ticket_t encryptor = {encrypt_ticket_key_ptls};\npctx->ticket_lifetime = 86400 * 7; // FIXME conf.lifetime;\npctx->encrypt_ticket = &encryptor;\n}\n}\n} else {\nsize_t i;\nfor (i = 0; i != num_contexts; ++i)\nSSL_CTX_set_options(contexts[i], SSL_CTX_get_options(contexts[i]) | SSL_OP_NO_TICKET);\n}\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  (* setup_session_resumption ) (int /*<<< orphan*/ *) ;} ;\n\n/* Variables and functions */\nTYPE_1__* ssl_method ;\nint /*<<< orphan*/  stub1 (int /*<<< orphan*/ *) ;\n\nvoid ssl_setup_session_resumption(SSL *s)\n{\nif (ssl_method->setup_session_resumption != NULL)\nssl_method->setup_session_resumption(s);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/src/extr_......srcssl.c_setup_cache_enable",
    "input":"\n0000000000000000 <setup_cache_enable>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rsi, %r15\na: \tmovq\t%rdi, %rbp\nd: \ttestq\t%rsi, %rsi\n10: \tje\t0x76 <setup_cache_enable+0x76>\n12: \tmovl\t%edx, %r14d\n15: \txorl\t%ebx, %ebx\n17: \tjmp\t0x29 <setup_cache_enable+0x29>\n19: \tnopl\t(%rax)\n20: \taddq\t$1, %rbx\n24: \tcmpq\t%rbx, %r15\n27: \tje\t0x76 <setup_cache_enable+0x76>\n29: \tmovq\t(%rbp,%rbx,8), %rdi\n2e: \tmovl\t(%rip), %esi  # 0x34 <setup_cache_enable+0x34>\n34: \torl\t(%rip), %esi  # 0x3a <setup_cache_enable+0x3a>\n3a: \tcallq\t0x3f <setup_cache_enable+0x3f>\n3f: \tmovq\t(%rbp,%rbx,8), %rdi\n44: \tmovl\t(%rip), %esi  # 0x4a <setup_cache_enable+0x4a>\n4a: \tmovl\t(%rip), %edx  # 0x50 <setup_cache_enable+0x50>\n50: \tcallq\t0x55 <setup_cache_enable+0x55>\n55: \tmovq\t(%rbp,%rbx,8), %rdi\n5a: \tmovl\t(%rip), %esi  # 0x60 <setup_cache_enable+0x60>\n60: \tcallq\t0x65 <setup_cache_enable+0x65>\n65: \ttestl\t%r14d, %r14d\n68: \tje\t0x20 <setup_cache_enable+0x20>\n6a: \tmovq\t(%rbp,%rbx,8), %rdi\n6f: \tcallq\t0x74 <setup_cache_enable+0x74>\n74: \tjmp\t0x20 <setup_cache_enable+0x20>\n76: \tmovq\t%rbp, %rdi\n79: \tmovq\t%r15, %rsi\n7c: \taddq\t$8, %rsp\n80: \tpopq\t%rbx\n81: \tpopq\t%r14\n83: \tpopq\t%r15\n85: \tpopq\t%rbp\n86: \tjmp\t0x8b <setup_cache_enable+0x8b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  lifetime; } ;\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_SESSID_CTX ;\nint /*<<< orphan*/  H2O_SESSID_CTX_LEN ;\nint /*<<< orphan*/  SSL_CTX_set_session_cache_mode (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  SSL_CTX_set_session_id_context (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_timeout (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint SSL_SESS_CACHE_NO_AUTO_CLEAR ;\nint SSL_SESS_CACHE_SERVER ;\nTYPE_1__ conf ;\nint /*<<< orphan*/  h2o_socket_ssl_async_resumption_setup_ctx (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  spawn_cache_cleanup_thread (int /*<<< orphan*/ **,size_t) ;\n\n__attribute__((used)) static void setup_cache_enable(SSL_CTX **contexts, size_t num_contexts, int async_resumption)\n{\nsize_t i;\nfor (i = 0; i != num_contexts; ++i) {\nSSL_CTX_set_session_cache_mode(contexts[i], SSL_SESS_CACHE_SERVER | SSL_SESS_CACHE_NO_AUTO_CLEAR);\nSSL_CTX_set_session_id_context(contexts[i], H2O_SESSID_CTX, H2O_SESSID_CTX_LEN);\nSSL_CTX_set_timeout(contexts[i], conf.lifetime);\nif (async_resumption)\nh2o_socket_ssl_async_resumption_setup_ctx(contexts[i]);\n}\nspawn_cache_cleanup_thread(contexts, num_contexts);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t ULONG ;\ntypedef  int /*<<< orphan*/  PVOID ;\ntypedef  int /*<<< orphan*/  NTSTATUS ;\ntypedef  int /*<<< orphan*/  OBJECT_ATTRIBUTES ;\ntypedef  int /*<<< orphan*/  IO_STATUS_BLOCK ;\ntypedef  int /*<<< orphan*/  HANDLE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FILE_ATTRIBUTE_NORMAL ;\nint /*<<< orphan*/  FILE_FLAG_DELETE_ON_CLOSE ;\nint /*<<< orphan*/  FILE_FLAG_NO_BUFFERING ;\nint /*<<< orphan*/  FILE_SHARE_READ ;\nint /*<<< orphan*/  FILE_WRITE_DATA ;\nint /*<<< orphan*/  NtClose (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  NtCreateFile (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  NtSetInformationFile (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  NtWriteFile (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  OBJ_CASE_INSENSITIVE ;\nint /*<<< orphan*/  OBJ_KERNEL_HANDLE ;\nint /*<<< orphan*/  ZwFlushBuffersFile (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static NTSTATUS setup_cache_enable(PVOID *handles, ULONG count, BOOLEAN flush)\n{\nULONG i;\n\nfor (i = 0; i < count; i++)\n{\nIO_STATUS_BLOCK iosb;\n\nNtCreateFile(handles[i], FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,\n&(OBJECT_ATTRIBUTES){0, NULL, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,\nFILE_SHARE_READ, FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_NO_BUFFERING},\n&iosb, 0, FILE_ATTRIBUTE_NORMAL, 0, 0, NULL, NULL, NULL);\n\nNtSetInformationFile(handles[i], &iosb, NULL, 0, 0);\n\nif (flush)\nNtFlushBuffersFile(handles[i], &iosb);\n}\n\nreturn NtWriteFile(handles[0], NULL, NULL, NULL, &iosb, NULL, 0, NULL, NULL);\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/extr_test.c_test_loopback",
    "input":"\n0000000000000000 <test_loopback>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tleaq\t12(%rsp), %r14\ne: \tmovq\t%r14, %rdi\n11: \tcallq\t0x16 <test_loopback+0x16>\n16: \tmovl\t$0, %edi\n1b: \tcallq\t0x20 <test_loopback+0x20>\n20: \tmovl\t%eax, %edi\n22: \tcallq\t0x27 <test_loopback+0x27>\n27: \tmovq\t%r14, %rdi\n2a: \tmovq\t%rax, %rsi\n2d: \tmovl\t$65535, %edx  # imm = 0xFFFF\n32: \tcallq\t0x37 <test_loopback+0x37>\n37: \tmovl\t(%rip), %esi  # 0x3d <test_loopback+0x3d>\n3d: \tmovq\t%rsp, %r15\n40: \tmovq\t%r15, %rdi\n43: \tmovq\t%r14, %rdx\n46: \tcallq\t0x4b <test_loopback+0x4b>\n4b: \tmovq\t(%rsp), %rax\n4f: \tmovl\t(%rax), %esi\n51: \tmovq\t%r15, %rdi\n54: \tcallq\t0x59 <test_loopback+0x59>\n59: \tmovq\t%rax, %rbx\n5c: \tmovl\t$0, %edi\n61: \tcallq\t0x66 <test_loopback+0x66>\n66: \tmovl\t%eax, %edi\n68: \tcallq\t0x6d <test_loopback+0x6d>\n6d: \tmovq\t%rax, 16(%rbx)\n71: \tmovl\t$0, %edi\n76: \tcallq\t0x7b <test_loopback+0x7b>\n7b: \tmovl\t%eax, %edi\n7d: \tcallq\t0x82 <test_loopback+0x82>\n82: \tmovq\t%rax, 8(%rbx)\n86: \tmovq\t%rbx, %rdi\n89: \tcallq\t0x8e <test_loopback+0x8e>\n8e: \txorl\t%edi, %edi\n90: \tcmpl\t$404, (%rbx)  # imm = 0x194\n96: \tsete\t%dil\n9a: \tcallq\t0x9f <test_loopback+0x9f>\n9f: \tmovq\t%rbx, %rdi\na2: \tcallq\t0xa7 <test_loopback+0xa7>\na7: \tmovq\t%r15, %rdi\naa: \tcallq\t0xaf <test_loopback+0xaf>\naf: \tmovq\t%r14, %rdi\nb2: \tcallq\t0xb7 <test_loopback+0xb7>\nb7: \taddq\t$16, %rsp\nbb: \tpopq\t%rbx\nbc: \tpopq\t%r14\nbe: \tpopq\t%r15\nc0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_18__   TYPE_6__ ;\ntypedef  struct TYPE_17__   TYPE_5__ ;\ntypedef  struct TYPE_16__   TYPE_4__ ;\ntypedef  struct TYPE_15__   TYPE_3__ ;\ntypedef  struct TYPE_14__   TYPE_2__ ;\ntypedef  struct TYPE_13__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_15__ {int status; } ;\nstruct TYPE_14__ {void* path; void* method; } ;\nstruct TYPE_16__ {TYPE_3__ res; TYPE_2__ input; } ;\nstruct TYPE_17__ {TYPE_4__ req; } ;\ntypedef  TYPE_5__ h2o_loopback_conn_t ;\ntypedef  int /*<<< orphan*/  h2o_globalconf_t ;\nstruct TYPE_18__ {TYPE_1__* globalconf; } ;\ntypedef  TYPE_6__ h2o_context_t ;\nstruct TYPE_13__ {int /*<<< orphan*/  hosts; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_STRLIT (char*) ;\nint /*<<< orphan*/  h2o_config_dispose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_config_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_config_register_host (int /*<<< orphan*/ *,void*,int) ;\nint /*<<< orphan*/  h2o_context_dispose (TYPE_6__*) ;\nint /*<<< orphan*/  h2o_context_init (TYPE_6__*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nvoid* h2o_iovec_init (int /*<<< orphan*/ ) ;\nTYPE_5__* h2o_loopback_create (TYPE_6__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_loopback_destroy (TYPE_5__*) ;\nint /*<<< orphan*/  h2o_loopback_run_loop (TYPE_5__*) ;\nint /*<<< orphan*/  ok (int) ;\nint /*<<< orphan*/  test_loop ;\n\n__attribute__((used)) static void test_loopback(void)\n{\nh2o_globalconf_t conf;\nh2o_context_t ctx;\nh2o_loopback_conn_t *conn;\n\nh2o_config_init(&conf);\nh2o_config_register_host(&conf, h2o_iovec_init(H2O_STRLIT(\"default\")), 65535);\nh2o_context_init(&ctx, test_loop, &conf);\n\nconn = h2o_loopback_create(&ctx, ctx.globalconf->hosts);\nconn->req.input.method = h2o_iovec_init(H2O_STRLIT(\"GET\"));\nconn->req.input.path = h2o_iovec_init(H2O_STRLIT(\"/\"));\nh2o_loopback_run_loop(conn);\n\nok(conn->req.res.status == 404);\n\nh2o_loopback_destroy(conn);\n\nh2o_context_dispose(&ctx);\nh2o_config_dispose(&conf);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  data; } ;\nstruct TYPE_9__ {TYPE_1__* data; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  data; } ;\ntypedef  TYPE_2__ BIO_ADDR ;\ntypedef  TYPE_3__ BIO_ADDRINFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_ADDRINFO_free (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDRINFO_sockaddr (TYPE_2__*,TYPE_3__*) ;\nint /*<<< orphan*/  BIO_ADDR_family (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_free (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_init (TYPE_2__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr (TYPE_2__*,TYPE_3__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_get_port (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_set_port (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_set_port_force (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_set_port_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_set_port_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_set_port_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_force (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_zero_force_zero (TYPE_2__*) ;\nint /*<<< orphan*/  BIO_ADDR_sockaddr_zero_zero_zero_zero"
},
{
    "file:":"./h2o/t/00unit/extr_test.c_h2o_loopback_run_loop",
    "input":"\n0000000000000000 <h2o_loopback_run_loop>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \taddq\t$16, %rdi\n8: \tcmpq\t$0, 24(%rbx)\nd: \tje\t0x38 <h2o_loopback_run_loop+0x38>\nf: \tcmpl\t$0, (%rdi)\n12: \tje\t0x45 <h2o_loopback_run_loop+0x45>\n14: \tcallq\t0x19 <h2o_loopback_run_loop+0x19>\n19: \tcmpl\t$0, 8(%rbx)\n1d: \tjne\t0x36 <h2o_loopback_run_loop+0x36>\n1f: \tnop\n20: \tmovq\t(%rbx), %rax\n23: \tmovl\t(%rax), %edi\n25: \tmovl\t(%rip), %esi  # 0x2b <h2o_loopback_run_loop+0x2b>\n2b: \tcallq\t0x30 <h2o_loopback_run_loop+0x30>\n30: \tcmpl\t$0, 8(%rbx)\n34: \tje\t0x20 <h2o_loopback_run_loop+0x20>\n36: \tpopq\t%rbx\n37: \tretq\n38: \tmovq\t$0, 24(%rbx)\n40: \tcmpl\t$0, (%rdi)\n43: \tjne\t0x14 <h2o_loopback_run_loop+0x14>\n45: \tmovl\t$256, (%rdi)  # imm = 0x100\n4b: \tjmp\t0x14 <h2o_loopback_run_loop+0x14>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {TYPE_1__* ctx; } ;\nstruct TYPE_9__ {int /*<<< orphan*/ * scheme; } ;\nstruct TYPE_11__ {int version; TYPE_3__ input; } ;\nstruct TYPE_10__ {TYPE_2__ super; int /*<<< orphan*/  _is_complete; TYPE_5__ req; } ;\ntypedef  TYPE_4__ h2o_loopback_conn_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  loop; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  H2O_URL_SCHEME_HTTP ;\nint /*<<< orphan*/  INT32_MAX ;\nint /*<<< orphan*/  UV_RUN_ONCE ;\nint /*<<< orphan*/  h2o_evloop_run (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_process_request (TYPE_5__*) ;\nint /*<<< orphan*/  uv_run (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid h2o_loopback_run_loop(h2o_loopback_conn_t *conn)\n{\nif (conn->req.input.scheme == NULL)\nconn->req.input.scheme = &H2O_URL_SCHEME_HTTP;\nif (conn->req.version == 0)\nconn->req.version = 0x100; /* HTTP/1.0 */\n\nh2o_process_request(&conn->req);\n\nwhile (!conn->_is_complete) {\n#if H2O_USE_LIBUV\nuv_run(conn->super.ctx->loop, UV_RUN_ONCE);\n#else\nh2o_evloop_run(conn->super.ctx->loop, INT32_MAX);\n#endif\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * loop; int /*<<< orphan*/  running; int /*<<< orphan*/  pending_timeouts; scalar_t__ pending_timeouts_inited; } ;\ntypedef  TYPE_1__ h2o_loopback_conn_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h2o_timeout_init (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timeout_set (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void h2o_loopback_run_loop(h2o_loopback_conn_t *conn)\n{\nif (!conn->pending_timeouts_inited) {\nconn->pending_timeouts_inited = 1;\nh2o_timeout_init(conn->pending_timeouts, 0);\n}\nif (!conn->running) {\nconn->running = 1;\nh2o_timeout_set(conn->pending_timeouts, 256);\n}\nwhile (conn->running) {\nh2o_timeout_run(conn->loop, conn->pending_timeouts);\nif (!conn->running)\nbreak;\n}\n}</s><s>"
},
{
    "file:":"./h2o/t/00unit/extr_test.c_get_peername",
    "input":"\n0000000000000000 <get_peername>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tmovl\t(%rip), %eax  # 0xa <get_peername+0xa>\na: \tmovl\t%eax, 8(%rsi)\nd: \tmovl\t$2130706433, %edi  # imm = 0x7F000001\n12: \tcallq\t0x17 <get_peername+0x17>\n17: \tmovl\t%eax, 4(%rbx)\n1a: \tmovl\t$55555, %edi  # imm = 0xD903\n1f: \tcallq\t0x24 <get_peername+0x24>\n24: \tmovl\t%eax, (%rbx)\n26: \tmovl\t$12, %eax\n2b: \tpopq\t%rbx\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;\nstruct sockaddr_in {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;\nstruct sockaddr {int dummy; } ;\ntypedef  int socklen_t ;\ntypedef  int /*<<< orphan*/  h2o_conn_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  htonl (int) ;\nint /*<<< orphan*/  htons (int) ;\n\n__attribute__((used)) static socklen_t get_peername(h2o_conn_t *conn, struct sockaddr *sa)\n{\nstruct sockaddr_in *sin = (void *)sa;\nsin->sin_family = AF_INET;\nsin->sin_addr.s_addr = htonl(0x7f000001);\nsin->sin_port = htons(55555);\nreturn sizeof(*sin);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_addr; int /*<<< orphan*/  sin_family; } ;\ntypedef  TYPE_1__ sockaddr_in ;\ntypedef  int /*<<< orphan*/  socklen_t ;\ntypedef  int /*<<< orphan*/  SOCKET ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  htons (int) ;\nint /*<<< orphan*/  inet_addr (char*) ;\n\n__attribute__((used)) static int get_peername(SOCKET s, sockaddr_in *addr)\n{\naddr->sin_family = AF_INET;\naddr->sin_addr = inet_addr(\"127.0.0.1\");\naddr->sin_port = htons(55555);\nreturn sizeof(sockaddr_in);\n}</s><s>"
},
{
    "file:":"./h2o/t/extr_qif.c_usage",
    "input":"\n0000000000000000 <usage>:\n0: \tpushq\t%rax\n1: \tmovq\t%rdi, %rsi\n4: \tmovl\t$0, %edi\n9: \tcallq\t0xe <usage+0xe>\ne: \txorl\t%edi, %edi\n10: \tcallq\t0x15 <usage+0x15>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  printf (char*,char const*) ;\n\n__attribute__((used)) static void usage(const char *cmd)\n{\nprintf(\"Usage: %s [options] [input-file [output-file]]\\n\"\n\"Options:\\n\"\n\"  -a         simulate ACK (encoder only)\\n\"\n\"  -b [max]   maximum number of blocked streams\\n\"\n\"  -d         decode (default is encode)\\n\"\n\"  -r         handling series of responses (default is requests)\\n\"\n\"  -s [bits]  header table size bits (default is 12; i.e. 4096 bytes)\\n\"\n\"\\n\",\ncmd);\nexit(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  printf (char*,char*) ;\n\nvoid usage(char *prog)\n{\nprintf(\"Usage: %s <target_ip> <target_port>\\n\", prog);\nexit(0);\n}</s><s>"
},
{
    "file:":"./h2o/t/00prop/extr_prop.c_prop_inserted_timer_should_not_run_before_expiry",
    "input":"\n0000000000000000 <prop_inserted_timer_should_not_run_before_expiry>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovq\t%rsi, %rbx\nc: \tmovl\t8(%rsi), %esi\nf: \tmovl\t$6, %edi\n14: \tcallq\t0x19 <prop_inserted_timer_should_not_run_before_expiry+0x19>\n19: \tmovq\t%rax, %r14\n1c: \tmovl\t8(%rbx), %esi\n1f: \tmovq\t%rax, %rdi\n22: \tcallq\t0x27 <prop_inserted_timer_should_not_run_before_expiry+0x27>\n27: \tleaq\t8(%rsp), %r15\n2c: \tmovl\t(%rip), %esi  # 0x32 <prop_inserted_timer_should_not_run_before_expiry+0x32>\n32: \tmovq\t%r15, %rdi\n35: \tcallq\t0x3a <prop_inserted_timer_should_not_run_before_expiry+0x3a>\n3a: \tmovq\t$0, (%rsp)\n42: \tmovl\t4(%rbx), %edx\n45: \tmovq\t%r14, %rdi\n48: \tmovq\t%r15, %rsi\n4b: \tcallq\t0x50 <prop_inserted_timer_should_not_run_before_expiry+0x50>\n50: \tmovl\t(%rbx), %esi\n52: \tmovq\t%r14, %rdi\n55: \tcallq\t0x5a <prop_inserted_timer_should_not_run_before_expiry+0x5a>\n5a: \tmovl\t$0, %ebx\n5f: \torq\t(%rsp), %rax\n63: \tjne\t0x83 <prop_inserted_timer_should_not_run_before_expiry+0x83>\n65: \tmovq\t%r14, %rdi\n68: \tcallq\t0x6d <prop_inserted_timer_should_not_run_before_expiry+0x6d>\n6d: \tcmpq\t(%rip), %rax  # 0x74 <prop_inserted_timer_should_not_run_before_expiry+0x74>\n74: \tje\t0x83 <prop_inserted_timer_should_not_run_before_expiry+0x83>\n76: \tmovq\t%r14, %rdi\n79: \tcallq\t0x7e <prop_inserted_timer_should_not_run_before_expiry+0x7e>\n7e: \tmovl\t$0, %ebx\n83: \tmovl\t(%rbx), %eax\n85: \taddq\t$16, %rsp\n89: \tpopq\t%rbx\n8a: \tpopq\t%r14\n8c: \tpopq\t%r15\n8e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct theft {int dummy; } ;\nstruct test_timer {scalar_t__ called; int /*<<< orphan*/  t; } ;\nstruct test_input {int /*<<< orphan*/  first_time; int /*<<< orphan*/  second_time; int /*<<< orphan*/  init_time; } ;\ntypedef  int /*<<< orphan*/  h2o_timerwheel_t ;\ntypedef  enum theft_trial_res { ____Placeholder_theft_trial_res } theft_trial_res ;\n\n/* Variables and functions */\nint THEFT_TRIAL_FAIL ;\nint THEFT_TRIAL_PASS ;\nscalar_t__ UINT64_MAX ;\nint /*<<< orphan*/ * h2o_timerwheel_create (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timerwheel_destroy (int /*<<< orphan*/ *) ;\nscalar_t__ h2o_timerwheel_get_wake_at (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timerwheel_init_entry (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timerwheel_link_abs (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nsize_t h2o_timerwheel_run (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  timer_cb ;\n\n__attribute__((used)) static enum theft_trial_res prop_inserted_timer_should_not_run_before_expiry(struct theft *theft, void *input_)\n{\nstruct test_input *input = input_;\nsize_t events_run;\nh2o_timerwheel_t *ctx;\nctx = h2o_timerwheel_create(6, input->init_time);\nh2o_timerwheel_run(ctx, input->init_time);\n\nstruct test_timer t;\nh2o_timerwheel_init_entry(&t.t, timer_cb);\nt.called = 0;\nh2o_timerwheel_link_abs(ctx, &t.t, input->second_time);\nevents_run = h2o_timerwheel_run(ctx, input->first_time);\n\nif (events_run != 0)\nreturn THEFT_TRIAL_FAIL;\nif (t.called != 0)\nreturn THEFT_TRIAL_FAIL;\nif (h2o_timerwheel_get_wake_at(ctx) == UINT64_MAX)\nreturn THEFT_TRIAL_FAIL;\nh2o_timerwheel_destroy(ctx);\nreturn THEFT_TRIAL_PASS;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  expiry; int /*<<< orphan*/  key; int /*<<< orphan*/  timer; } ;\ntypedef  TYPE_1__ GTimer ;\ntypedef  int /*<<< orphan*/  GTimeVal ;\ntypedef  int /*<<< orphan*/  GTimerEvent ;\ntypedef  int /*<<< orphan*/  GTimerEventFunc ;\ntypedef  int /*<<< orphan*/  GTimerEventType ;\ntypedef  int /*<<< orphan*/  GTimerEventSource ;\ntypedef  int /*<<< orphan*/  GTimerEventSourceFunc ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_TIMER_EVENT_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_TYPE_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_TYPE_TIMEOUT ;\nscalar_t__ G_TIMER_EVENT_TYPE_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_TYPE ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_TYPE_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_TYPE_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_TYPE_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPIRED ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TIMEOUT ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  G_TIMER_EVENT_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_EXPI"
},
{
    "file:":"./h2o/t/00prop/extr_prop.c_prop_inserted_timer_should_run_at_expiry",
    "input":"\n0000000000000000 <prop_inserted_timer_should_run_at_expiry>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovq\t%rsi, %rbx\nc: \tmovl\t8(%rsi), %esi\nf: \tmovl\t$6, %edi\n14: \tcallq\t0x19 <prop_inserted_timer_should_run_at_expiry+0x19>\n19: \tmovq\t%rax, %r14\n1c: \tmovl\t8(%rbx), %esi\n1f: \tmovq\t%rax, %rdi\n22: \tcallq\t0x27 <prop_inserted_timer_should_run_at_expiry+0x27>\n27: \tleaq\t12(%rsp), %r15\n2c: \tmovl\t(%rip), %esi  # 0x32 <prop_inserted_timer_should_run_at_expiry+0x32>\n32: \tmovq\t%r15, %rdi\n35: \tcallq\t0x3a <prop_inserted_timer_should_run_at_expiry+0x3a>\n3a: \tmovl\t$0, 8(%rsp)\n42: \tmovl\t4(%rbx), %edx\n45: \tmovq\t%r14, %rdi\n48: \tmovq\t%r15, %rsi\n4b: \tcallq\t0x50 <prop_inserted_timer_should_run_at_expiry+0x50>\n50: \tmovl\t(%rbx), %esi\n52: \tmovq\t%r14, %rdi\n55: \tcallq\t0x5a <prop_inserted_timer_should_run_at_expiry+0x5a>\n5a: \tmovl\t$0, %ebx\n5f: \tcmpq\t$1, %rax\n63: \tjne\t0x8a <prop_inserted_timer_should_run_at_expiry+0x8a>\n65: \tcmpl\t$1, 8(%rsp)\n6a: \tjne\t0x8a <prop_inserted_timer_should_run_at_expiry+0x8a>\n6c: \tmovq\t%r14, %rdi\n6f: \tcallq\t0x74 <prop_inserted_timer_should_run_at_expiry+0x74>\n74: \tcmpq\t(%rip), %rax  # 0x7b <prop_inserted_timer_should_run_at_expiry+0x7b>\n7b: \tjne\t0x8a <prop_inserted_timer_should_run_at_expiry+0x8a>\n7d: \tmovq\t%r14, %rdi\n80: \tcallq\t0x85 <prop_inserted_timer_should_run_at_expiry+0x85>\n85: \tmovl\t$0, %ebx\n8a: \tmovl\t(%rbx), %eax\n8c: \taddq\t$16, %rsp\n90: \tpopq\t%rbx\n91: \tpopq\t%r14\n93: \tpopq\t%r15\n95: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct theft {int dummy; } ;\nstruct test_timer {int called; int /*<<< orphan*/  t; } ;\nstruct test_input {int /*<<< orphan*/  second_time; int /*<<< orphan*/  first_time; int /*<<< orphan*/  init_time; } ;\ntypedef  int /*<<< orphan*/  h2o_timerwheel_t ;\ntypedef  enum theft_trial_res { ____Placeholder_theft_trial_res } theft_trial_res ;\n\n/* Variables and functions */\nint THEFT_TRIAL_FAIL ;\nint THEFT_TRIAL_PASS ;\nscalar_t__ UINT64_MAX ;\nint /*<<< orphan*/ * h2o_timerwheel_create (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timerwheel_destroy (int /*<<< orphan*/ *) ;\nscalar_t__ h2o_timerwheel_get_wake_at (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  h2o_timerwheel_init_entry (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  h2o_timerwheel_link_abs (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nsize_t h2o_timerwheel_run (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  timer_cb ;\n\n__attribute__((used)) static enum theft_trial_res prop_inserted_timer_should_run_at_expiry(struct theft *theft, void *input_)\n{\nstruct test_input *input = input_;\nsize_t events_run;\nh2o_timerwheel_t *ctx;\nctx = h2o_timerwheel_create(6, input->init_time);\nh2o_timerwheel_run(ctx, input->init_time);\n\nstruct test_timer t;\nh2o_timerwheel_init_entry(&t.t, timer_cb);\nt.called = 0;\nh2o_timerwheel_link_abs(ctx, &t.t, input->first_time);\nevents_run = h2o_timerwheel_run(ctx, input->second_time);\n\nif (events_run != 1)\nreturn THEFT_TRIAL_FAIL;\nif (t.called != 1)\nreturn THEFT_TRIAL_FAIL;\nif (h2o_timerwheel_get_wake_at(ctx) != UINT64_MAX)\nreturn THEFT_TRIAL_FAIL;\nh2o_timerwheel_destroy(ctx);\nreturn THEFT_TRIAL_PASS;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  expiry; int /*<<< orphan*/  key; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ GLogItem ;\ntypedef  int /*<<< orphan*/  GTimeVal ;\ntypedef  int /*<<< orphan*/  GTimer ;\ntypedef  int /*<<< orphan*/  GTimerType ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_LOG_ITEM_TYPE_PROP_INSERTED ;\nscalar_t__ G_TIMER_RUNNING ;\nint /*<<< orphan*/  G_TIMER_TYPE_ONE_SHOT ;\nint /*<<< orphan*/  G_TIMER_TYPE_PERIODIC ;\nint /*<<< orphan*/  G_TIMER_TYPE_REPEATING ;\nscalar_t__ g_timer_get_status (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_timer_set_time (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_timer_set_type (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_timer_start (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_timer_stop (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_timer_type_to_string (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_time_val_add (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_time_val_init (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nprop_inserted_timer_should_run_at_expiry (GLogItem *item, GTimer *timer)\n{\nGTimeVal now;\nGTimeVal expiry;\n\ng_time_val_init (&now, 6);\ng_time_val_init (&expiry, item->expiry);\ng_time_val_add (&expiry, item->expiry);\n\ng_timer_set_type (timer, G_TIMER_TYPE_REPEATING);\ng_timer_set_time (timer, expiry);\n\nif (g_timer_get_status (timer) == G_TIMER_RUNNING &&\ng_timer_type_to_string (g_timer_get_type (timer)) ==\ng_timer_type_to_string (G_TIMER_TYPE_PERIODIC) &&\ng_timer_get_type (timer) == G_TIMER_TYPE_REPEATING)\n{\ng_timer_stop (timer);\ng_timer_start (timer);\n}\n\nif (item->type == G_LOG_ITEM_TYPE_PROP_INSERTED)\n{\nreturn 1;\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00prop/extr_prop.c_main",
    "input":"\n0000000000000000 <main>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <main+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <main+0xf>\nf: \txorl\t%eax, %eax\n11: \tcallq\t0x16 <main+0x16>\n16: \txorl\t%eax, %eax\n18: \tcallq\t0x1d <main+0x1d>\n1d: \txorl\t%eax, %eax\n1f: \tpopq\t%rcx\n20: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  timers_should_not_run () ;\nint /*<<< orphan*/  timers_should_not_run_before_expiry () ;\nint /*<<< orphan*/  timers_should_run () ;\nint /*<<< orphan*/  wake_time_before_expiry () ;\n\nint main(void)\n{\nwake_time_before_expiry();\ntimers_should_run();\ntimers_should_not_run();\ntimers_should_not_run_before_expiry();\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  test_bstr_alloc () ;\nint /*<<< orphan*/  test_bstr_free () ;\nint /*<<< orphan*/  test_bstr_from_wchar () ;\nint /*<<< orphan*/  test_bstr_from_wchar_alloc () ;\nint /*<<< orphan*/  test_bstr_from_wchar_alloc_len () ;\n\nint main(int argc, char **argv)\n{\ntest_bstr_alloc();\ntest_bstr_free();\ntest_bstr_from_wchar();\ntest_bstr_from_wchar_alloc();\ntest_bstr_from_wchar_alloc_len();\nreturn 0;\n}</s><s>"
},
{
    "file:":"./h2o/t/00prop/extr_prop.c_free_cb",
    "input":"\n0000000000000000 <free_cb>:\n0: \tjmp\t0x5 <free_cb+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  free (void*) ;\n\n__attribute__((used)) static void free_cb(void *instance, void *env)\n{\nfree(instance);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  OPENSSL_free (void*) ;\n\n__attribute__((used)) static void free_cb(void *parent, void *ptr,\nsize_t cnt, int unused)\n{\nOPENSSL_free(ptr);\n}</s><s>"
},
{
    "file:":"./h2o/t/extr_qif.c_read_int",
    "input":"\n0000000000000000 <read_int>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \ttestq\t%rsi, %rsi\n8: \tje\t0x3d <read_int+0x3d>\na: \tmovq\t%rsi, %r14\nd: \tmovq\t%rdi, %r15\n10: \txorl\t%ebx, %ebx\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \tmovq\t%r15, %rdi\n23: \tcallq\t0x28 <read_int+0x28>\n28: \tcmpl\t(%rip), %eax  # 0x2e <read_int+0x2e>\n2e: \tje\t0x41 <read_int+0x41>\n30: \tshll\t$8, %ebx\n33: \torl\t%eax, %ebx\n35: \taddq\t$-1, %r14\n39: \tjne\t0x20 <read_int+0x20>\n3b: \tjmp\t0x47 <read_int+0x47>\n3d: \txorl\t%ebx, %ebx\n3f: \tjmp\t0x47 <read_int+0x47>\n41: \tmovl\t(%rip), %ebx  # 0x47 <read_int+0x47>\n47: \tmovl\t%ebx, %eax\n49: \tpopq\t%rbx\n4a: \tpopq\t%r14\n4c: \tpopq\t%r15\n4e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint64_t ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint EOF ;\nint UINT64_MAX ;\nint fgetc (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static uint64_t read_int(FILE *fp, size_t nbytes)\n{\nuint64_t v = 0;\nsize_t i;\nint ch;\nfor (i = 0; i != nbytes; ++i) {\nif ((ch = fgetc(fp)) == EOF)\nreturn UINT64_MAX;\nv = (v << 8) | ch;\n}\nreturn v;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint EOF ;\nint fgetc (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int read_int(FILE *fp, int *len)\n{\nint i = 0;\n\nif (len == NULL)\nreturn 0;\n\nwhile (*len > 0) {\ni = (i << 8) | fgetc(fp);\n(*len)--;\n}\n\nreturn i;\n}</s><s>"
},
{
    "file:":"./h2o/t/extr_qif.c_write_int",
    "input":"\n0000000000000000 <write_int>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \ttestq\t%rdx, %rdx\nb: \tje\t0x42 <write_int+0x42>\nd: \tmovq\t%rdx, %r12\n10: \tmovq\t%rsi, %r14\n13: \tmovq\t%rdi, %r15\n16: \txorl\t%ebx, %ebx\n18: \tnopl\t(%rax,%rax)\n20: \tmovl\t%ebx, %eax\n22: \tnotl\t%eax\n24: \tleal\t(%r12,%rax), %ecx\n28: \tshll\t$3, %ecx\n2b: \tmovq\t%r14, %rdi\n2e: \tshrq\t%cl, %rdi\n31: \tmovq\t%r15, %rsi\n34: \tcallq\t0x39 <write_int+0x39>\n39: \taddq\t$1, %rbx\n3d: \tcmpq\t%rbx, %r12\n40: \tjne\t0x20 <write_int+0x20>\n42: \taddq\t$8, %rsp\n46: \tpopq\t%rbx\n47: \tpopq\t%r12\n49: \tpopq\t%r14\n4b: \tpopq\t%r15\n4d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  size_t uint64_t ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fputc (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void write_int(FILE *fp, uint64_t v, size_t nbytes)\n{\nsize_t i;\nfor (i = 0; i != nbytes; ++i)\nfputc((uint8_t)(v >> ((nbytes - i - 1) * 8)), fp);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fputc (scalar_t__,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void write_int(FILE *f, uint64_t x, int n)\n{\nint i;\n\nfor (i = 0; i < n; i++) {\nfputc((x >> (i * 8)) & 0xff, f);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawReadThis1",
    "input":"\n0000000000000000 <M_DrawReadThis1>:\n0: \tpushq\t%rax\n1: \tmovl\t$1, (%rip)    # 0xb <M_DrawReadThis1+0xb>\nb: \tmovl\t(%rip), %eax  # 0x11 <M_DrawReadThis1+0x11>\n11: \taddl\t$-128, %eax\n14: \tcmpl\t$3, %eax\n17: \tja\t0x3c <M_DrawReadThis1+0x3c>\n19: \tcltq\n1b: \tmovq\t(,%rax,8), %rdi\n23: \tmovl\t(%rip), %esi  # 0x29 <M_DrawReadThis1+0x29>\n29: \tcallq\t0x2e <M_DrawReadThis1+0x2e>\n2e: \txorl\t%edi, %edi\n30: \txorl\t%esi, %esi\n32: \txorl\t%edx, %edx\n34: \tmovl\t%eax, %ecx\n36: \tpopq\t%rax\n37: \tjmp\t0x3c <M_DrawReadThis1+0x3c>\n3c: \tpopq\t%rax\n3d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n#define  commercial 131\nint gamemode ;\nint inhelpscreens ;\n#define  registered 130\n#define  retail 129\n#define  shareware 128\n\nvoid M_DrawReadThis1(void)\n{\ninhelpscreens = true;\nswitch ( gamemode )\n{\ncase commercial:\nV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"HELP\",PU_CACHE));\nbreak;\ncase shareware:\ncase registered:\ncase retail:\nV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"HELP1\",PU_CACHE));\nbreak;\ndefault:\nbreak;\n}\nreturn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawReadThis2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis5 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis6 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis7 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis8 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis9 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisA (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisB (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisC (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisD (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisE (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisF (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisG (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisH (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisI (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisJ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisK (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisL (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisM (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisN (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisO (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisP (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisQ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisR (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisS (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisT (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisU (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisV (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisW (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisX (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisY (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThisZ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis_ ;\nint /*<<< orphan*/  M_DrawReadThis_1 ;\nint /*<<< orphan*/  M_DrawReadThis_2 ;\nint /*<<< orphan*/  M_DrawReadThis_3 ;\nint /*<<< orphan*/  M_DrawReadThis_4 ;\nint /*<<< orphan*/  M_DrawReadThis_5 ;\nint /*<<< orphan*/  M_DrawReadThis_6 ;\nint /*<<< orphan*/  M_DrawReadThis_7 ;\nint /*<<< orphan*/  M_DrawReadThis_8 ;\nint /*<<< orphan*/  M_DrawReadThis_9 ;\nint /*<<< orphan*/  M_DrawReadThis_A ;\nint /*<<< orphan*/  M_DrawReadThis_B ;\nint /*<<< orphan*/  M_DrawReadThis_C ;\nint /*<<< orphan*/  M_DrawReadThis"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_inter.c_P_GiveArmor",
    "input":"\n0000000000000000 <P_GiveArmor>:\n0: \timull\t$100, %esi, %ecx\n3: \txorl\t%eax, %eax\n5: \tcmpl\t%ecx, (%rdi)\n7: \tjge\t0x13 <P_GiveArmor+0x13>\n9: \tmovl\t%esi, 4(%rdi)\nc: \tmovl\t%ecx, (%rdi)\ne: \tmovl\t$1, %eax\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int armorpoints; int armortype; } ;\ntypedef  TYPE_1__ player_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\n\nboolean\nP_GiveArmor\n( player_t*\tplayer,\nint\t\tarmortype )\n{\nint\t\thits;\n\nhits = armortype*100;\nif (player->armorpoints >= hits)\nreturn false;\t// don't pick up\n\nplayer->armortype = armortype;\nplayer->armorpoints = hits;\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int armor; int maxarmor; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\n\nint P_GiveArmor(player_t *player, int armor)\n{\nif (armor > player->maxarmor)\n{\nplayer->armor = player->maxarmor;\nreturn 1;\n}\n\nplayer->armor += armor;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_StartScreen",
    "input":"\n0000000000000000 <wipe_StartScreen>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <wipe_StartScreen+0x8>\n8: \tmovl\t8(%rax), %edi\nb: \tmovl\t%edi, (%rip)  # 0x11 <wipe_StartScreen+0x11>\n11: \tcallq\t0x16 <wipe_StartScreen+0x16>\n16: \txorl\t%eax, %eax\n18: \tpopq\t%rcx\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ReadScreen (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * screens ;\nint /*<<< orphan*/  wipe_scr_start ;\n\nint\nwipe_StartScreen\n( int\tx,\nint\ty,\nint\twidth,\nint\theight )\n{\nwipe_scr_start = screens[2];\nI_ReadScreen(wipe_scr_start);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  wipe_x; int /*<<< orphan*/  wipe_y; } ;\n\n/* Variables and functions */\nTYPE_1__* screen ;\nint /*<<< orphan*/  wipe_DrawScreen () ;\n\nint wipe_StartScreen(void)\n{\nscreen->wipe_x = screen->wipe_y;\nwipe_DrawScreen();\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_getSector",
    "input":"\n0000000000000000 <getSector>:\n0: \tmovq\t(%rip), %rax  # 0x7 <getSector+0x7>\n7: \tmovq\t(%rip), %rcx  # 0xe <getSector+0xe>\ne: \tmovslq\t%edi, %rdi\n11: \tmovq\t(%rcx,%rdi,8), %rcx\n15: \tmovslq\t%esi, %rsi\n18: \tmovq\t(%rcx,%rsi,8), %rcx\n1c: \tmovq\t(%rcx), %rcx\n1f: \tmovslq\t%edx, %rdx\n22: \tmovq\t(%rcx,%rdx,8), %rcx\n26: \tmovq\t(%rax,%rcx,8), %rax\n2a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sector_t ;\nstruct TYPE_6__ {TYPE_1__** lines; } ;\nstruct TYPE_5__ {int /*<<< orphan*/ * sector; } ;\nstruct TYPE_4__ {size_t* sidenum; } ;\n\n/* Variables and functions */\nTYPE_3__* sectors ;\nTYPE_2__* sides ;\n\nsector_t*\ngetSector\n( int\t\tcurrentSector,\nint\t\tline,\nint\t\tside )\n{\nreturn sides[ (sectors[currentSector].lines[line])->sidenum[side] ].sector;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t* sector; } ;\n\n/* Variables and functions */\nTYPE_1__** sector ;\nsize_t* sector_len ;\n\n__attribute__((used)) static unsigned char *getSector(int sector, int offset, int len) {\nreturn sector ? sector[sector_len[sector] - 1 - offset] : 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_P_AimLineAttack",
    "input":"\n0000000000000000 <P_AimLineAttack>:\n0: \tpushq\t%rax\n1: \tmovb\t(%rip), %cl   # 0x7 <P_AimLineAttack+0x7>\n7: \tshrq\t%cl, %rsi\na: \tmovl\t%edx, %r8d\nd: \tmovq\t%rdi, (%rip)  # 0x14 <P_AimLineAttack+0x14>\n14: \tmovb\t(%rip), %cl   # 0x1a <P_AimLineAttack+0x1a>\n1a: \tmovl\t%edx, %eax\n1c: \tsarl\t%cl, %eax\n1e: \tmovq\t(%rip), %rcx  # 0x25 <P_AimLineAttack+0x25>\n25: \tmovl\t(%rcx,%rsi,4), %edx\n28: \timull\t%eax, %edx\n2b: \taddl\t(%rdi), %edx\n2d: \tmovq\t(%rip), %rcx  # 0x34 <P_AimLineAttack+0x34>\n34: \timull\t(%rcx,%rsi,4), %eax\n38: \tmovl\t4(%rdi), %esi\n3b: \tmovl\t8(%rdi), %r9d\n3f: \tleal\t(%rax,%rsi), %ecx\n42: \tsarl\t%r9d\n45: \tmovslq\t%r9d, %rax\n48: \taddq\t16(%rdi), %rax\n4c: \tmovslq\t(%rip), %r9   # 0x53 <P_AimLineAttack+0x53>\n53: \tleaq\t(%rax,%r9,8), %rax\n57: \tmovq\t%rax, (%rip)  # 0x5e <P_AimLineAttack+0x5e>\n5e: \timull\t$100, %r9d, %eax\n62: \tcltq\n64: \timulq\t$1717986919, %rax, %rax # imm = 0x66666667\n6b: \tmovq\t%rax, %r10\n6e: \tshrq\t$63, %r10\n72: \tsarq\t$38, %rax\n76: \taddl\t%r10d, %eax\n79: \tmovl\t%eax, (%rip)  # 0x7f <P_AimLineAttack+0x7f>\n7f: \timull\t$-100, %r9d, %eax\n83: \tcltq\n85: \timulq\t$1717986919, %rax, %rax # imm = 0x66666667\n8c: \tmovq\t%rax, %r9\n8f: \tshrq\t$63, %r9\n93: \tsarq\t$38, %rax\n97: \taddl\t%r9d, %eax\n9a: \tmovl\t%eax, (%rip)  # 0xa0 <P_AimLineAttack+0xa0>\na0: \tmovl\t%r8d, (%rip)  # 0xa7 <P_AimLineAttack+0xa7>\na7: \tmovq\t$0, (%rip)    # 0xb2 <P_AimLineAttack+0xb2>\nb2: \tmovl\t(%rdi), %edi\nb4: \tmovl\t(%rip), %r8d  # 0xbb <P_AimLineAttack+0xbb>\nbb: \torl\t(%rip), %r8d  # 0xc2 <P_AimLineAttack+0xc2>\nc2: \tmovl\t(%rip), %r9d  # 0xc9 <P_AimLineAttack+0xc9>\nc9: \tcallq\t0xce <P_AimLineAttack+0xce>\nce: \txorl\t%eax, %eax\nd0: \tcmpq\t$0, (%rip)    # 0xd8 <P_AimLineAttack+0xd8>\nd8: \tje\t0xe0 <P_AimLineAttack+0xe0>\nda: \tmovl\t(%rip), %eax  # 0xe0 <P_AimLineAttack+0xe0>\ne0: \tpopq\t%rcx\ne1: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int x; int y; int height; scalar_t__ z; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int fixed_t ;\ntypedef  size_t angle_t ;\n\n/* Variables and functions */\nsize_t ANGLETOFINESHIFT ;\nint FRACBITS ;\nint FRACUNIT ;\nint /*<<< orphan*/  PTR_AimTraverse ;\nint PT_ADDLINES ;\nint PT_ADDTHINGS ;\nint /*<<< orphan*/  P_PathTraverse (int,int,int,int,int,int /*<<< orphan*/ ) ;\nint aimslope ;\nint attackrange ;\nint bottomslope ;\nint* finecosine ;\nint* finesine ;\nint /*<<< orphan*/ * linetarget ;\nTYPE_1__* shootthing ;\nscalar_t__ shootz ;\nint topslope ;\n\nfixed_t\nP_AimLineAttack\n( mobj_t*\tt1,\nangle_t\tangle,\nfixed_t\tdistance )\n{\nfixed_t\tx2;\nfixed_t\ty2;\n\nangle >>= ANGLETOFINESHIFT;\nshootthing = t1;\n\nx2 = t1->x + (distance>>FRACBITS)*finecosine[angle];\ny2 = t1->y + (distance>>FRACBITS)*finesine[angle];\nshootz = t1->z + (t1->height>>1) + 8*FRACUNIT;\n\n// can't shoot outside view angles\ntopslope = 100*FRACUNIT/160;\nbottomslope = -100*FRACUNIT/160;\n\nattackrange = distance;\nlinetarget = NULL;\n\nP_PathTraverse ( t1->x, t1->y,\nx2, y2,\nPT_ADDLINES|PT_ADDTHINGS,\nPTR_AimTraverse );\n\nif (linetarget)\nreturn aimslope;\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  ang; } ;\ntypedef  TYPE_1__ player_t ;\ntypedef  int /*<<< orphan*/  angle_t ;\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ANGLE_180 ;\nint /*<<< orphan*/  ANGLE_2PI ;\nint /*<<< orphan*/  ANGLE_MAX ;\nint /*<<< orphan*/  ANGLE_PI ;\nint /*<<< orphan*/  ANGLE_PI2 ;\nint /*<<< orphan*/  ANGLE_TO_SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_AimLineAttack (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn2 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn3 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn4 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn5 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn6 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn7 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn8 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn9 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn10 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn11 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn12 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn13 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn14 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn15 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn16 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn17 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn18 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn19 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn20 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn21 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn22 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_CheckMissileSpawn23 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_AproxDistance",
    "input":"\n0000000000000000 <P_AproxDistance>:\n0: \tmovl\t%edi, %ecx\n2: \tnegl\t%ecx\n4: \tcmovll\t%edi, %ecx\n7: \tmovl\t%esi, %edx\n9: \tnegl\t%edx\nb: \tcmovll\t%esi, %edx\ne: \tleal\t(%rdx,%rcx), %eax\n11: \tcmpl\t%edx, %ecx\n13: \tcmovlel\t%ecx, %edx\n16: \tshrl\t%edx\n18: \tsubl\t%edx, %eax\n1a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nint abs (int) ;\n\nfixed_t\nP_AproxDistance\n( fixed_t\tdx,\nfixed_t\tdy )\n{\ndx = abs(dx);\ndy = abs(dy);\nif (dx < dy)\nreturn dx+dy-(dx>>1);\nreturn dx+dy-(dy>>1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int FT_Pos ;\n\n/* Variables and functions */\n\n__attribute__((used)) static FT_Pos\nP_AproxDistance( FT_Pos  a, FT_Pos  b )\n{\nFT_Pos  delta;\n\n\nif ( a < 0 )\na = -a;\nif ( b < 0 )\nb = -b;\n\ndelta = a + b;\nif ( a > b )\ndelta -= a;\nelse\ndelta -= b;\n\nreturn delta / 2;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_main.c_main",
    "input":"\n0000000000000000 <main>:\n0: \tpushq\t%rax\n1: \tmovl\t%edi, (%rip)  # 0x7 <main+0x7>\n7: \tmovq\t%rsi, (%rip)  # 0xe <main+0xe>\ne: \txorl\t%eax, %eax\n10: \tcallq\t0x15 <main+0x15>\n15: \txorl\t%eax, %eax\n17: \tpopq\t%rcx\n18: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_DoomMain () ;\nint myargc ;\nchar** myargv ;\n\nint\nmain\n( int\t\targc,\nchar**\targv )\n{\nmyargc = argc;\nmyargv = argv;\n\nD_DoomMain ();\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  do_test () ;\nint /*<<< orphan*/  test_argc ;\nchar** test_argv ;\n\nint main(int argc, char **argv)\n{\ntest_argc = argc;\ntest_argv = argv;\ndo_test();\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_SecretExitLevel",
    "input":"\n0000000000000000 <G_SecretExitLevel>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <G_SecretExitLevel+0x8>\n8: \tcmpq\t(%rip), %rax  # 0xf <G_SecretExitLevel+0xf>\nf: \tjne\t0x20 <G_SecretExitLevel+0x20>\n11: \tmovl\t$0, %edi\n16: \tcallq\t0x1b <G_SecretExitLevel+0x1b>\n1b: \ttestq\t%rax, %rax\n1e: \tjs\t0x27 <G_SecretExitLevel+0x27>\n20: \tmovl\t$1, %eax\n25: \tjmp\t0x29 <G_SecretExitLevel+0x29>\n27: \txorl\t%eax, %eax\n29: \tmovl\t%eax, (%rip)  # 0x2f <G_SecretExitLevel+0x2f>\n2f: \tmovl\t(%rip), %eax  # 0x35 <G_SecretExitLevel+0x35>\n35: \tmovl\t%eax, (%rip)  # 0x3b <G_SecretExitLevel+0x3b>\n3b: \tpopq\t%rax\n3c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ W_CheckNumForName (char*) ;\nscalar_t__ commercial ;\nint /*<<< orphan*/  ga_completed ;\nint /*<<< orphan*/  gameaction ;\nscalar_t__ gamemode ;\nint secretexit ;\n\nvoid G_SecretExitLevel (void)\n{\n// IF NO WOLF3D LEVELS, NO SECRET EXIT!\nif ( (gamemode == commercial)\n&& (W_CheckNumForName(\"map31\")<0))\nsecretexit = false;\nelse\nsecretexit = true;\ngameaction = ga_completed;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_SecretExitLevel_No ;\nint /*<<< orphan*/  G_SecretExitLevel_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_No ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes ;\nscalar_t__ G_SecretExitLevel_Yes_Yes_Yes_Yes_Yes_Yes_Yes_Yes"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_initPercent",
    "input":"\n0000000000000000 <STlib_initPercent>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tmovq\t32(%rsp), %r14\nc: \taddq\t$8, %rdi\n10: \tmovl\t$3, (%rsp)\n17: \tcallq\t0x1c <STlib_initPercent+0x1c>\n1c: \tmovq\t%r14, (%rbx)\n1f: \taddq\t$8, %rsp\n23: \tpopq\t%rbx\n24: \tpopq\t%r14\n26: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * p; int /*<<< orphan*/  n; } ;\ntypedef  TYPE_1__ st_percent_t ;\ntypedef  int /*<<< orphan*/  patch_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  STlib_initNum (int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ **,int*,int /*<<< orphan*/ *,int) ;\n\nvoid\nSTlib_initPercent\n( st_percent_t*\t\tp,\nint\t\t\tx,\nint\t\t\ty,\npatch_t**\t\tpl,\nint*\t\t\tnum,\nboolean*\t\ton,\npatch_t*\t\tpercent )\n{\nSTlib_initNum(&p->n, x, y, pl, num, on, 3);\np->p = percent;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * pvArg; int /*<<< orphan*/  cbArg; } ;\ntypedef  TYPE_1__ STMTG ;\ntypedef  int /*<<< orphan*/  PERCENT_ARG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  STlib_initArg (TYPE_1__*,int) ;\n\n__attribute__((used)) static void STlib_initPercent(STMTG *pStmt, PERCENT_ARG *pArg)\n{\npStmt->cbArg = sizeof(PERCENT_ARG);\npStmt->pvArg = (void *)pArg;\nSTlib_initArg(pStmt, 3);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_FirePistol",
    "input":"\n0000000000000000 <A_FirePistol>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t12(%rdi), %edi\n7: \tmovl\t(%rip), %esi  # 0xd <A_FirePistol+0xd>\nd: \tcallq\t0x12 <A_FirePistol+0x12>\n12: \tmovl\t12(%rbx), %edi\n15: \tmovl\t(%rip), %esi  # 0x1b <A_FirePistol+0x1b>\n1b: \tcallq\t0x20 <A_FirePistol+0x20>\n20: \tmovq\t(%rbx), %rax\n23: \tmovq\t16(%rbx), %rcx\n27: \tmovq\t(%rip), %rdx  # 0x2e <A_FirePistol+0x2e>\n2e: \tshlq\t$4, %rax\n32: \tmovq\t(%rdx,%rax), %rsi\n36: \taddl\t$-1, (%rcx,%rsi,4)\n3a: \tmovl\t(%rip), %esi  # 0x40 <A_FirePistol+0x40>\n40: \tmovl\t8(%rdx,%rax), %edx\n44: \tmovq\t%rbx, %rdi\n47: \tcallq\t0x4c <A_FirePistol+0x4c>\n4c: \tmovl\t12(%rbx), %edi\n4f: \tcallq\t0x54 <A_FirePistol+0x54>\n54: \tmovl\t12(%rbx), %edi\n57: \txorl\t%esi, %esi\n59: \tcmpl\t$0, 8(%rbx)\n5d: \tsete\t%sil\n61: \tpopq\t%rbx\n62: \tjmp\t0x67 <A_FirePistol+0x67>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_5__ {size_t readyweapon; int /*<<< orphan*/  refire; int /*<<< orphan*/  mo; int /*<<< orphan*/ * ammo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_6__ {size_t ammo; int /*<<< orphan*/  flashstate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_BulletSlope (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_GunShot (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  P_SetMobjState (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_PLAY_ATK2 ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ps_flash ;\nint /*<<< orphan*/  sfx_pistol ;\nTYPE_2__* weaponinfo ;\n\nvoid\nA_FirePistol\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nS_StartSound (player->mo, sfx_pistol);\n\nP_SetMobjState (player->mo, S_PLAY_ATK2);\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\n\nP_SetPsprite (player,\nps_flash,\nweaponinfo[player->readyweapon].flashstate);\n\nP_BulletSlope (player->mo);\nP_GunShot (player->mo, !player->refire);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * bullet_info; TYPE_1__* player; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  pistol_ammo; int /*<<< orphan*/  pistol_ammo_max; } ;\ntypedef  TYPE_2__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  FIRE_PISTOL ;\nint /*<<< orphan*/  PISTOL_FIRE ;\nint /*<<< orphan*/  PISTOL_RELOAD ;\nint /*<<< orphan*/  PISTOL_RELOAD_TIME ;\nint /*<<< orphan*/  PISTOL_SHOOT ;\nint /*<<< orphan*/  PISTOL_SHOOT_TIME ;\nint /*<<< orphan*/  PISTOL_START_TIME ;\nint /*<<< orphan*/  PISTOL_STOP_TIME ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MAX ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_MIN ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE ;\nint /*<<< orphan*/  PISTOL_STOP_TIME_RANDOM_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE_RANGE"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_GunFlash",
    "input":"\n0000000000000000 <A_GunFlash>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t8(%rdi), %edi\n7: \tmovl\t(%rip), %esi  # 0xd <A_GunFlash+0xd>\nd: \tcallq\t0x12 <A_GunFlash+0x12>\n12: \tmovl\t(%rip), %esi  # 0x18 <A_GunFlash+0x18>\n18: \tmovq\t(%rip), %rax  # 0x1f <A_GunFlash+0x1f>\n1f: \tmovq\t(%rbx), %rcx\n22: \tmovl\t(%rax,%rcx,4), %edx\n25: \tmovq\t%rbx, %rdi\n28: \tpopq\t%rbx\n29: \tjmp\t0x2e <A_GunFlash+0x2e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_5__ {size_t readyweapon; int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  flashstate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_SetMobjState (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_PLAY_ATK2 ;\nint /*<<< orphan*/  ps_flash ;\nTYPE_2__* weaponinfo ;\n\nvoid\nA_GunFlash\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nP_SetMobjState (player->mo, S_PLAY_ATK2);\nP_SetPsprite (player,ps_flash,weaponinfo[player->readyweapon].flashstate);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  sprite; } ;\nstruct TYPE_5__ {TYPE_1__* actor; int /*<<< orphan*/  extra; } ;\ntypedef  TYPE_2__ dbactor_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetSprite (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  gunFlash ;\nint /*<<< orphan*/  gunFlashTime ;\nint /*<<< orphan*/ * gunFlashes ;\n\nvoid A_GunFlash(dbactor_t *actor)\n{\nA_SetSprite(actor->extra, gunFlash);\nA_SetAnim(actor, gunFlashTime, gunFlashes[actor->actor->sprite]);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_mobj.c_P_SpawnPuff",
    "input":"\n0000000000000000 <P_SpawnPuff>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edx, %ebx\n9: \tmovl\t%esi, %r14d\nc: \tmovl\t%edi, %r15d\nf: \txorl\t%eax, %eax\n11: \tcallq\t0x16 <P_SpawnPuff+0x16>\n16: \tmovl\t%eax, %ebp\n18: \txorl\t%eax, %eax\n1a: \tcallq\t0x1f <P_SpawnPuff+0x1f>\n1f: \tsubl\t%eax, %ebp\n21: \tshll\t$10, %ebp\n24: \taddl\t%ebp, %ebx\n26: \tmovl\t(%rip), %ecx  # 0x2c <P_SpawnPuff+0x2c>\n2c: \tmovl\t%r15d, %edi\n2f: \tmovl\t%r14d, %esi\n32: \tmovl\t%ebx, %edx\n34: \tcallq\t0x39 <P_SpawnPuff+0x39>\n39: \tmovq\t%rax, %rbx\n3c: \tmovl\t(%rip), %eax  # 0x42 <P_SpawnPuff+0x42>\n42: \tmovl\t%eax, 4(%rbx)\n45: \txorl\t%eax, %eax\n47: \tcallq\t0x4c <P_SpawnPuff+0x4c>\n4c: \tandl\t$3, %eax\n4f: \tmovl\t(%rbx), %ecx\n51: \tsubl\t%eax, %ecx\n53: \ttestl\t%ecx, %ecx\n55: \tmovl\t$1, %eax\n5a: \tcmovgl\t%ecx, %eax\n5d: \tmovl\t%eax, (%rbx)\n5f: \tmovq\t(%rip), %rax  # 0x66 <P_SpawnPuff+0x66>\n66: \tcmpq\t(%rip), %rax  # 0x6d <P_SpawnPuff+0x6d>\n6d: \tjne\t0x87 <P_SpawnPuff+0x87>\n6f: \tmovl\t(%rip), %esi  # 0x75 <P_SpawnPuff+0x75>\n75: \tmovq\t%rbx, %rdi\n78: \taddq\t$8, %rsp\n7c: \tpopq\t%rbx\n7d: \tpopq\t%r14\n7f: \tpopq\t%r15\n81: \tpopq\t%rbp\n82: \tjmp\t0x87 <P_SpawnPuff+0x87>\n87: \taddq\t$8, %rsp\n8b: \tpopq\t%rbx\n8c: \tpopq\t%r14\n8e: \tpopq\t%r15\n90: \tpopq\t%rbp\n91: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int tics; int /*<<< orphan*/  momz; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FRACUNIT ;\nscalar_t__ MELEERANGE ;\nint /*<<< orphan*/  MT_PUFF ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_1__*,int /*<<< orphan*/ ) ;\nTYPE_1__* P_SpawnMobj (int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_PUFF3 ;\nscalar_t__ attackrange ;\n\nvoid\nP_SpawnPuff\n( fixed_t\tx,\nfixed_t\ty,\nfixed_t\tz )\n{\nmobj_t*\tth;\n\nz += ((P_Random()-P_Random())<<10);\n\nth = P_SpawnMobj (x,y,z, MT_PUFF);\nth->momz = FRACUNIT;\nth->tics -= P_Random()&3;\n\nif (th->tics < 1)\nth->tics = 1;\n\n// don't make punches spark on the wall\nif (attackrange == MELEERANGE)\nP_SetMobjState (th, S_PUFF3);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ Puff ;\ntypedef  int /*<<< orphan*/  PLAYER ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PUFF_TYPE ;\nint P_Random (int /*<<< orphan*/ ) ;\nint P_RandomRange (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SpawnMobj (int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SpawnPuff (TYPE_1__*) ;\nscalar_t__ PUFF_MAX ;\nint /*<<< orphan*/  RANDOM_POINT ;\nint /*<<< orphan*/  RANDOM_X ;\n\nvoid P_SpawnPuff(PLAYER *player, int x, int y)\n{\nPuff *puff;\n\npuff = (Puff *)Z_Malloc (sizeof(*puff), PUFF_TYPE, 0);\n\npuff->x = x + (P_RandomRange(RANDOM_X)<<10);\npuff->y = y + (P_Random(RANDOM_POINT)<<10);\npuff->type = PUFF_TYPE;\n\nif (PUFF_MAX == 0)\nP_SpawnMobj (puff, PUFF_TYPE, puff->x, puff->y);\nelse\nP_SpawnPuff (puff);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_delCharFromIText",
    "input":"\n0000000000000000 <HUlib_delCharFromIText>:\n0: \tmovq\t8(%rdi), %rax\n4: \tcmpq\t(%rdi), %rax\n7: \tjne\t0xa <HUlib_delCharFromIText+0xa>\n9: \tretq\na: \taddq\t$8, %rdi\ne: \tjmp\t0x13 <HUlib_delCharFromIText+0x13>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ len; } ;\nstruct TYPE_4__ {scalar_t__ lm; TYPE_2__ l; } ;\ntypedef  TYPE_1__ hu_itext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_delCharFromTextLine (TYPE_2__*) ;\n\nvoid HUlib_delCharFromIText(hu_itext_t* it)\n{\nif (it->l.len != it->lm)\nHUlib_delCharFromTextLine(&it->l);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ len; scalar_t__ pos; } ;\ntypedef  TYPE_1__ HUiText ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_delCharFromText (TYPE_1__*) ;\n\nvoid HUlib_delCharFromIText(HUiText *it)\n{\nif (it->pos == it->len)\nreturn;\n\nHUlib_delCharFromText(it);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_createnullcursor",
    "input":"\n0000000000000000 <createnullcursor>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tsubq\t$40, %rsp\na: \tmovq\t%rdi, %rbx\nd: \tmovl\t$1, %edx\n12: \tmovl\t$1, %ecx\n17: \tmovl\t$1, %r8d\n1d: \tcallq\t0x22 <createnullcursor+0x22>\n22: \tmovl\t%eax, %ebp\n24: \tmovl\t(%rip), %eax  # 0x2a <createnullcursor+0x2a>\n2a: \tmovl\t%eax, 8(%rsp)\n2e: \tmovl\t(%rip), %edx  # 0x34 <createnullcursor+0x34>\n34: \tleaq\t8(%rsp), %rcx\n39: \tmovq\t%rbx, %rdi\n3c: \tmovl\t%ebp, %esi\n3e: \tcallq\t0x43 <createnullcursor+0x43>\n43: \tmovl\t%eax, %r14d\n46: \tmovl\t$1, (%rsp)\n4d: \tmovq\t%rbx, %rdi\n50: \tmovl\t%ebp, %esi\n52: \tmovl\t%eax, %edx\n54: \txorl\t%ecx, %ecx\n56: \txorl\t%r8d, %r8d\n59: \tmovl\t$1, %r9d\n5f: \tcallq\t0x64 <createnullcursor+0x64>\n64: \txorps\t%xmm0, %xmm0\n67: \tmovups\t%xmm0, 24(%rsp)\n6c: \tmovl\t$4, 16(%rsp)\n74: \tmovl\t$0, (%rsp)\n7b: \tleaq\t16(%rsp), %rcx\n80: \tmovq\t%rbx, %rdi\n83: \tmovl\t%ebp, %esi\n85: \tmovl\t%ebp, %edx\n87: \tmovq\t%rcx, %r8\n8a: \txorl\t%r9d, %r9d\n8d: \tcallq\t0x92 <createnullcursor+0x92>\n92: \tmovl\t%eax, %r15d\n95: \tmovq\t%rbx, %rdi\n98: \tmovl\t%ebp, %esi\n9a: \tcallq\t0x9f <createnullcursor+0x9f>\n9f: \tmovq\t%rbx, %rdi\na2: \tmovl\t%r14d, %esi\na5: \tcallq\t0xaa <createnullcursor+0xaa>\naa: \tmovl\t%r15d, %eax\nad: \taddq\t$40, %rsp\nb1: \tpopq\t%rbx\nb2: \tpopq\t%r14\nb4: \tpopq\t%r15\nb6: \tpopq\t%rbp\nb7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  function; } ;\ntypedef  TYPE_1__ XGCValues ;\nstruct TYPE_7__ {int flags; scalar_t__ red; scalar_t__ pixel; } ;\ntypedef  TYPE_2__ XColor ;\ntypedef  int /*<<< orphan*/  Window ;\ntypedef  int /*<<< orphan*/  Pixmap ;\ntypedef  int /*<<< orphan*/  GC ;\ntypedef  int /*<<< orphan*/  Display ;\ntypedef  int /*<<< orphan*/  Cursor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GCFunction ;\nint /*<<< orphan*/  GXclear ;\nint /*<<< orphan*/  XCreateGC (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  XCreatePixmap (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int,int,int) ;\nint /*<<< orphan*/  XCreatePixmapCursor (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_2__*,TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  XFillRectangle (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  XFreeGC (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  XFreePixmap (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nCursor\ncreatenullcursor\n( Display*\tdisplay,\nWindow\troot )\n{\nPixmap cursormask;\nXGCValues xgc;\nGC gc;\nXColor dummycolour;\nCursor cursor;\n\ncursormask = XCreatePixmap(display, root, 1, 1, 1/*depth*/);\nxgc.function = GXclear;\ngc =  XCreateGC(display, cursormask, GCFunction, &xgc);\nXFillRectangle(display, cursormask, gc, 0, 0, 1, 1);\ndummycolour.pixel = 0;\ndummycolour.red = 0;\ndummycolour.flags = 04;\ncursor = XCreatePixmapCursor(display, cursormask, cursormask,\n&dummycolour,&dummycolour, 0,0);\nXFreePixmap(display,cursormask);\nXFreeGC(display,gc);\nreturn cursor;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint32 ;\ntypedef  int /*<<< orphan*/  uint16 ;\ntypedef  int /*<<< orphan*/  uint8 ;\ntypedef  int /*<<< orphan*/  PGresult ;\ntypedef  int /*<<< orphan*/  PGconn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PGRES_TUPLES_OK ;\nint /*<<< orphan*/  PQclear (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQexec (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQgetResult (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQnfields (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQntuples (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQresultStatus (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQsetnonblocking (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  PQsetSingleRowMode (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  PQstatus (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQuntrace (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQtrace (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQtraceFile (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strlen (char*) ;\n\n__attribute__((used)) static PGresult *\ncreatenullcursor(PGconn *conn)\n{\nPGresult   *res;\nuint32\t\ti;\nuint16\t\tnfields;\nuint8\t\tnrows;\n\n/*\n* Set up a trace file to catch any error messages that might be\n* generated.  We can't rely on the backend to do it, because it might\n* not have been built with debugging support.\n*/\n#ifdef FRONTEND\nfprintf(stderr, \"createnullcursor: opening trace file\\n\");\n#endif\nPQtrace(conn, fopen(\"trace.out\", \"w\"), stderr);\n\n/*\n* Set up a query that will return no rows.\n*/\nres = PQexec(conn, \"select 1\", 1, 1, 1);\nif (PQresultStatus(res) != PGRES_TUPLES_OK)\n{\nPQclear(res);\nreturn NULL;\n}\n\n/*\n* Set up a cursor that will return no rows.\n*/\nnfields = PQnfields(res);\nnrows = PQntuples(res);\nPQsetSingleRowMode(conn, true);\nPQsetnonblocking(conn, true);\nPQuntrace(conn);\nPQtraceFile(conn, stderr);\nPQtrace(conn, fopen(\"trace.out\", \"w\"), stderr);\n\n/*\n* Execute the query.\n*/\nres = PQexec(conn, \"select 1\", 1, 1, 1);\n\n/*\n* Clean up.\n*/\nPQuntrace(conn);\nPQsetnonblocking(conn, false);\nPQsetSingleRowMode(conn, false);\nPQclear(res);\n\nreturn res;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_EV_StartLightStrobing",
    "input":"\n0000000000000000 <EV_StartLightStrobing>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdi, %rbx\n6: \tmovl\t$4294967295, %esi  # imm = 0xFFFFFFFF\nb: \tcallq\t0x10 <EV_StartLightStrobing+0x10>\n10: \ttestl\t%eax, %eax\n12: \tjs\t0x53 <EV_StartLightStrobing+0x53>\n14: \tmovl\t%eax, %ebp\n16: \tjmp\t0x30 <EV_StartLightStrobing+0x30>\n18: \tnopl\t(%rax,%rax)\n20: \tmovq\t%rbx, %rdi\n23: \tmovl\t%ebp, %esi\n25: \tcallq\t0x2a <EV_StartLightStrobing+0x2a>\n2a: \tmovl\t%eax, %ebp\n2c: \ttestl\t%eax, %eax\n2e: \tjs\t0x53 <EV_StartLightStrobing+0x53>\n30: \tmovq\t(%rip), %rax  # 0x37 <EV_StartLightStrobing+0x37>\n37: \tmovl\t%ebp, %ecx\n39: \tcmpq\t$0, (%rax,%rcx,8)\n3e: \tjne\t0x20 <EV_StartLightStrobing+0x20>\n40: \tleaq\t(%rax,%rcx,8), %rdi\n44: \tmovl\t(%rip), %esi  # 0x4a <EV_StartLightStrobing+0x4a>\n4a: \txorl\t%edx, %edx\n4c: \tcallq\t0x51 <EV_StartLightStrobing+0x51>\n51: \tjmp\t0x20 <EV_StartLightStrobing+0x20>\n53: \taddq\t$8, %rsp\n57: \tpopq\t%rbx\n58: \tpopq\t%rbp\n59: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ specialdata; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\n\n/* Variables and functions */\nint P_FindSectorFromLineTag (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  P_SpawnStrobeFlash (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SLOWDARK ;\nTYPE_1__* sectors ;\n\nvoid EV_StartLightStrobing(line_t*\tline)\n{\nint\t\tsecnum;\nsector_t*\tsec;\n\nsecnum = -1;\nwhile ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n{\nsec = &sectors[secnum];\nif (sec->specialdata)\ncontinue;\n\nP_SpawnStrobeFlash (sec,SLOWDARK, 0);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ bLightStrobing; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EV_LightStrobing ;\nTYPE_1__* EV ;\nint /*<<< orphan*/  EV_Start (TYPE_1__*,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  EV_Stop (TYPE_1__*,int) ;\nint EV_WaitForEvent (TYPE_1__*,int) ;\n\nvoid EV_StartLightStrobing(void)\n{\nint i;\n\nfor (i = 0; i < 4; i++)\n{\nif (EV_WaitForEvent(EV, -1) < 0)\nreturn;\n\nif (!EV[i].bLightStrobing)\n{\nEV_Start(EV, i, EV_LightStrobing);\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_ceilng.c_EV_CeilingCrushStop",
    "input":"\n0000000000000000 <EV_CeilingCrushStop>:\n0: \tmovl\t(%rip), %r8d  # 0x7 <EV_CeilingCrushStop+0x7>\n7: \ttestl\t%r8d, %r8d\na: \tjle\t0x5f <EV_CeilingCrushStop+0x5f>\nc: \txorl\t%edx, %edx\ne: \tmovq\t(%rip), %r9   # 0x15 <EV_CeilingCrushStop+0x15>\n15: \txorl\t%eax, %eax\n17: \tjmp\t0x29 <EV_CeilingCrushStop+0x29>\n19: \tnopl\t(%rax)\n20: \taddq\t$1, %rdx\n24: \tcmpq\t%r8, %rdx\n27: \tjae\t0x5e <EV_CeilingCrushStop+0x5e>\n29: \tmovq\t(%r9,%rdx,8), %rcx\n2d: \ttestq\t%rcx, %rcx\n30: \tje\t0x20 <EV_CeilingCrushStop+0x20>\n32: \tmovq\t(%rcx), %rsi\n35: \tcmpq\t(%rdi), %rsi\n38: \tjne\t0x20 <EV_CeilingCrushStop+0x20>\n3a: \tmovq\t8(%rcx), %rsi\n3e: \ttestq\t%rsi, %rsi\n41: \tje\t0x20 <EV_CeilingCrushStop+0x20>\n43: \tmovq\t%rsi, 16(%rcx)\n47: \tmovq\t$0, 24(%rcx)\n4f: \tmovq\t$0, 8(%rcx)\n57: \tmovl\t$1, %eax\n5c: \tjmp\t0x20 <EV_CeilingCrushStop+0x20>\n5e: \tretq\n5f: \txorl\t%eax, %eax\n61: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ tag; } ;\ntypedef  TYPE_3__ line_t ;\ntypedef  scalar_t__ actionf_v ;\nstruct TYPE_6__ {scalar_t__ acv; } ;\nstruct TYPE_7__ {TYPE_1__ function; } ;\nstruct TYPE_9__ {scalar_t__ tag; scalar_t__ direction; scalar_t__ olddirection; TYPE_2__ thinker; } ;\n\n/* Variables and functions */\nint MAXCEILINGS ;\nTYPE_4__** activeceilings ;\n\nint\tEV_CeilingCrushStop(line_t\t*line)\n{\nint\t\ti;\nint\t\trtn;\n\nrtn = 0;\nfor (i = 0;i < MAXCEILINGS;i++)\n{\nif (activeceilings[i]\n&& (activeceilings[i]->tag == line->tag)\n&& (activeceilings[i]->direction != 0))\n{\nactiveceilings[i]->olddirection = activeceilings[i]->direction;\nactiveceilings[i]->thinker.function.acv = (actionf_v)NULL;\nactiveceilings[i]->direction = 0;\t\t// in-stasis\nrtn = 1;\n}\n}\n\n\nreturn rtn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ x; scalar_t__ y; scalar_t__ ceiling; } ;\nstruct TYPE_9__ {scalar_t__ x; scalar_t__ y; scalar_t__ ceiling; } ;\nstruct TYPE_8__ {scalar_t__ x; scalar_t__ y; } ;\ntypedef  TYPE_1__ EVENT ;\ntypedef  TYPE_2__ EVENT_CEILING_CRUSH ;\ntypedef  TYPE_3__ EVENT_CEILING_CRUSH_STOP ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EV_CeilingCrush ;\nTYPE_2__** ceiling_crush_events ;\nint ceiling_crush_events_count ;\nint /*<<< orphan*/  EV_Remove (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nint EV_CeilingCrushStop(EVENT *ev)\n{\nint i;\nEVENT_CEILING_CRUSH_STOP *e;\n\nfor (i = 0; i < ceiling_crush_events_count; i++)\n{\ne = (EVENT_CEILING_CRUSH_STOP*)ceiling_crush_events[i];\nif (e->x == ev->x && e->y == ev->y)\n{\ne->ceiling = 0;\ne->y = 0;\nEV_Remove(ev, EV_CeilingCrush);\nreturn 1;\n}\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BrainPain",
    "input":"\n0000000000000000 <A_BrainPain>:\n0: \tmovl\t(%rip), %esi  # 0x6 <A_BrainPain+0x6>\n6: \txorl\t%edi, %edi\n8: \tjmp\t0xd <A_BrainPain+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_bospn ;\n\nvoid A_BrainPain (mobj_t*\tmo)\n{\nS_StartSound (NULL,sfx_bospn);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ARGS ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BrainPain ;\nint /*<<< orphan*/  DoSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static VOID A_BrainPain(ARGS *a)\n{\nDoSound(NULL, BrainPain);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_sight.c_P_InterceptVector2",
    "input":"\n0000000000000000 <P_InterceptVector2>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rsi, %rbx\nb: \tmovq\t%rdi, %r15\ne: \tmovl\t(%rsi), %edi\n10: \tsarl\t$8, %edi\n13: \tmovl\t4(%r15), %esi\n17: \tcallq\t0x1c <P_InterceptVector2+0x1c>\n1c: \tmovq\t%rax, %r14\n1f: \tmovl\t4(%rbx), %edi\n22: \tsarl\t$8, %edi\n25: \tmovl\t(%r15), %esi\n28: \tcallq\t0x2d <P_InterceptVector2+0x2d>\n2d: \tsubq\t%rax, %r14\n30: \tje\t0x6f <P_InterceptVector2+0x6f>\n32: \tmovl\t(%rbx), %esi\n34: \tmovl\t8(%rbx), %edi\n37: \tsubl\t8(%r15), %edi\n3b: \tsarl\t$8, %edi\n3e: \tcallq\t0x43 <P_InterceptVector2+0x43>\n43: \tmovq\t%rax, %r12\n46: \tmovl\t12(%r15), %edi\n4a: \tsubl\t12(%rbx), %edi\n4d: \tsarl\t$8, %edi\n50: \tmovl\t4(%rbx), %esi\n53: \tcallq\t0x58 <P_InterceptVector2+0x58>\n58: \tleaq\t(%rax,%r12), %rdi\n5c: \tmovq\t%r14, %rsi\n5f: \taddq\t$8, %rsp\n63: \tpopq\t%rbx\n64: \tpopq\t%r12\n66: \tpopq\t%r14\n68: \tpopq\t%r15\n6a: \tjmp\t0x6f <P_InterceptVector2+0x6f>\n6f: \txorl\t%eax, %eax\n71: \taddq\t$8, %rsp\n75: \tpopq\t%rbx\n76: \tpopq\t%r12\n78: \tpopq\t%r14\n7a: \tpopq\t%r15\n7c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_4__ {int dy; int dx; int x; int y; } ;\ntypedef  TYPE_1__ divline_t ;\n\n/* Variables and functions */\nscalar_t__ FixedDiv (scalar_t__,scalar_t__) ;\nscalar_t__ FixedMul (int,int) ;\n\nfixed_t\nP_InterceptVector2\n( divline_t*\tv2,\ndivline_t*\tv1 )\n{\nfixed_t\tfrac;\nfixed_t\tnum;\nfixed_t\tden;\n\nden = FixedMul (v1->dy>>8,v2->dx) - FixedMul(v1->dx>>8,v2->dy);\n\nif (den == 0)\nreturn 0;\n//\tI_Error (\"P_InterceptVector: parallel\");\n\nnum = FixedMul ( (v1->x - v2->x)>>8 ,v1->dy) +\nFixedMul ( (v2->y - v1->y)>>8 , v1->dx);\nfrac = FixedDiv (num , den);\n\nreturn frac;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int z; int w; } ;\ntypedef  TYPE_1__ D3DVECTOR ;\ntypedef  int /*<<< orphan*/  D3DVALUE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D3D_INTERCEPT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_RETURN (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_F (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_I (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_U (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_V (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_W (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_Y (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_FLOAT4_Z (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_I (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_U (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_V (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_W (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_Y (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_INT4_Z (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_I (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_U (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_V (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_W (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_Y (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_UINT4_Z (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VECTOR2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VECTOR3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VECTOR4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VECTOR4_F (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VECTOR4_I (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VECTOR4_U (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  D3D_INTERCEPT_STORE_VE"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_Init",
    "input":"\n0000000000000000 <I_Init>:\n0: \txorl\t%eax, %eax\n2: \tjmp\t0x7 <I_Init+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_InitSound () ;\n\nvoid I_Init (void)\n{\nI_InitSound();\n//  I_InitGraphics();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_InitSound () ;\n\nvoid I_Init(void)\n{\nI_InitSound();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_Options",
    "input":"\n0000000000000000 <M_Options>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <M_Options+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  OptionsDef ;\n\nvoid M_Options(int choice)\n{\nM_SetupNextMenu(&OptionsDef);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  printf (char*) ;\n\nvoid M_Options(void)\n{\nprintf(\"-h, --help\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_CheckHeap",
    "input":"\n0000000000000000 <Z_CheckHeap>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rip), %rcx  # 0xb <Z_CheckHeap+0xb>\nb: \tmovq\t8(%rcx), %rbx\nf: \tmovq\t8(%rbx), %rax\n13: \tcmpq\t%rcx, %rax\n16: \tje\t0x78 <Z_CheckHeap+0x78>\n18: \tleaq\t8(%rbx), %r14\n1c: \tjmp\t0x34 <Z_CheckHeap+0x34>\n1e: \tnop\n20: \tmovq\t(%r14), %rbx\n23: \tleaq\t8(%rbx), %r14\n27: \tmovq\t8(%rbx), %rax\n2b: \tcmpq\t(%rip), %rax  # 0x32 <Z_CheckHeap+0x32>\n32: \tje\t0x78 <Z_CheckHeap+0x78>\n34: \tmovslq\t(%rbx), %rcx\n37: \tleaq\t(%rbx,%rcx,4), %rcx\n3b: \tcmpq\t%rax, %rcx\n3e: \tje\t0x4d <Z_CheckHeap+0x4d>\n40: \tmovl\t$0, %edi\n45: \tcallq\t0x4a <Z_CheckHeap+0x4a>\n4a: \tmovq\t(%r14), %rax\n4d: \tcmpq\t%rbx, 16(%rax)\n51: \tje\t0x5d <Z_CheckHeap+0x5d>\n53: \tmovl\t$0, %edi\n58: \tcallq\t0x5d <Z_CheckHeap+0x5d>\n5d: \tcmpl\t$0, 4(%rbx)\n61: \tjne\t0x20 <Z_CheckHeap+0x20>\n63: \tmovq\t(%r14), %rax\n66: \tcmpl\t$0, 4(%rax)\n6a: \tjne\t0x20 <Z_CheckHeap+0x20>\n6c: \tmovl\t$0, %edi\n71: \tcallq\t0x76 <Z_CheckHeap+0x76>\n76: \tjmp\t0x20 <Z_CheckHeap+0x20>\n78: \taddq\t$8, %rsp\n7c: \tpopq\t%rbx\n7d: \tpopq\t%r14\n7f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int size; int /*<<< orphan*/  user; struct TYPE_3__* next; struct TYPE_3__* prev; } ;\ntypedef  TYPE_1__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\nstruct TYPE_4__ {TYPE_1__ blocklist; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nTYPE_2__* mainzone ;\n\nvoid Z_CheckHeap (void)\n{\nmemblock_t*\tblock;\n\nfor (block = mainzone->blocklist.next ; ; block = block->next)\n{\nif (block->next == &mainzone->blocklist)\n{\n// all blocks have been hit\nbreak;\n}\n\nif ( (byte *)block + block->size != (byte *)block->next)\nI_Error (\"Z_CheckHeap: block size does not touch the next block\\n\");\n\nif ( block->next->prev != block)\nI_Error (\"Z_CheckHeap: next block doesn't have proper back link\\n\");\n\nif (!block->user && !block->next->user)\nI_Error (\"Z_CheckHeap: two consecutive free blocks\\n\");\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  fp; int /*<<< orphan*/  fd; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  fp; int /*<<< orphan*/  fd; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  fp; int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ ZFILE ;\n\n/* Variables and functions */\nTYPE_2__* Z_G ;\nTYPE_3__* Z_H ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\n\nvoid Z_CheckHeap(void)\n{\nZFILE *fp;\n\nfp = Z_H->fp;\nwhile (fp != Z_H)\n{\nif (fp->fp != Z_H->fp)\nfprintf(stderr, \"fp != Z_H->fp\\n\");\nif (fp->fd != Z_H->fd)\nfprintf(stderr, \"fd != Z_H->fd\\n\");\nif (fp->fp != Z_G->fp)\nfprintf(stderr, \"fp != Z_G->fp\\n\");\nif (fp->fd != Z_G->fd)\nfprintf(stderr, \"fd != Z_G->fd\\n\");\nfp = fp->fp;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_PlayerScream",
    "input":"\n0000000000000000 <A_PlayerScream>:\n0: \tmovl\t(%rip), %esi  # 0x6 <A_PlayerScream+0x6>\n6: \tmovq\t(%rip), %rax  # 0xd <A_PlayerScream+0xd>\nd: \tcmpq\t(%rip), %rax  # 0x14 <A_PlayerScream+0x14>\n14: \tjne\t0x21 <A_PlayerScream+0x21>\n16: \tcmpl\t$-50, (%rdi)\n19: \tjge\t0x21 <A_PlayerScream+0x21>\n1b: \tmovl\t(%rip), %esi  # 0x21 <A_PlayerScream+0x21>\n21: \tjmp\t0x26 <A_PlayerScream+0x26>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int health; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int) ;\nscalar_t__ commercial ;\nscalar_t__ gamemode ;\nint sfx_pdiehi ;\nint sfx_pldeth ;\n\nvoid A_PlayerScream (mobj_t* mo)\n{\n// Default death sound.\nint\t\tsound = sfx_pldeth;\n\nif ( (gamemode == commercial)\n&& \t(mo->health < -50))\n{\n// IF THE PLAYER DIES\n// LESS THAN -50% WITHOUT GIBBING\nsound = sfx_pdiehi;\n}\n\nS_StartSound (mo, sound);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int health; } ;\ntypedef  TYPE_1__* PLAYER ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_PlayerScream2 ;\nscalar_t__ PLAYER_DEAD ;\nscalar_t__ PLAYER_DEAD_FALL ;\nint /*<<< orphan*/  A_PlayerScream3 ;\nint /*<<< orphan*/  A_PlayerScream4 ;\nint /*<<< orphan*/  A_PlayerScream5 ;\nint /*<<< orphan*/  A_PlayerScream6 ;\n\nvoid A_PlayerScream(PLAYER *p)\n{\nif (p->health < -50 || p->health == PLAYER_DEAD || p->health == PLAYER_DEAD_FALL)\n{\nA_PlayerScream5(p);\nreturn;\n}\n\nif (p->health < 0)\n{\nA_PlayerScream2(p);\nreturn;\n}\n\nif (p->health < 100)\n{\nA_PlayerScream3(p);\nreturn;\n}\n\nif (p->health < 200)\n{\nA_PlayerScream4(p);\nreturn;\n}\n\nA_PlayerScream6(p);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_PointToDist",
    "input":"\n0000000000000000 <R_PointToDist>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tsubq\t(%rip), %rdi  # 0xb <R_PointToDist+0xb>\nb: \tmovq\t%rdi, %rax\ne: \tnegq\t%rax\n11: \tcmovlq\t%rdi, %rax\n15: \tsubq\t(%rip), %rsi  # 0x1c <R_PointToDist+0x1c>\n1c: \tmovq\t%rsi, %rbx\n1f: \tnegq\t%rbx\n22: \tcmovlq\t%rsi, %rbx\n26: \tcmpq\t%rax, %rbx\n29: \tmovq\t%rbx, %rdi\n2c: \tcmovgq\t%rax, %rdi\n30: \tcmovleq\t%rax, %rbx\n34: \tmovq\t(%rip), %r14  # 0x3b <R_PointToDist+0x3b>\n3b: \tmovq\t%rbx, %rsi\n3e: \tcallq\t0x43 <R_PointToDist+0x43>\n43: \tmovb\t(%rip), %cl   # 0x49 <R_PointToDist+0x49>\n49: \tshrq\t%cl, %rax\n4c: \tmovl\t(%rip), %edx  # 0x52 <R_PointToDist+0x52>\n52: \taddl\t(%r14,%rax,4), %edx\n56: \tmovb\t(%rip), %cl   # 0x5c <R_PointToDist+0x5c>\n5c: \tsarl\t%cl, %edx\n5e: \tmovq\t(%rip), %rax  # 0x65 <R_PointToDist+0x65>\n65: \tmovslq\t%edx, %rcx\n68: \tmovq\t(%rax,%rcx,8), %rsi\n6c: \tmovq\t%rbx, %rdi\n6f: \taddq\t$8, %rsp\n73: \tpopq\t%rbx\n74: \tpopq\t%r14\n76: \tjmp\t0x7b <R_PointToDist+0x7b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nint ANG90 ;\nint ANGLETOFINESHIFT ;\nsize_t DBITS ;\nsize_t FixedDiv (scalar_t__,scalar_t__) ;\nscalar_t__ abs (scalar_t__) ;\nscalar_t__* finesine ;\nint* tantoangle ;\nscalar_t__ viewx ;\nscalar_t__ viewy ;\n\nfixed_t\nR_PointToDist\n( fixed_t\tx,\nfixed_t\ty )\n{\nint\t\tangle;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\ttemp;\nfixed_t\tdist;\n\ndx = abs(x - viewx);\ndy = abs(y - viewy);\n\nif (dy>dx)\n{\ntemp = dx;\ndx = dy;\ndy = temp;\n}\n\nangle = (tantoangle[ FixedDiv(dy,dx)>>DBITS ]+ANG90) >> ANGLETOFINESHIFT;\n\n// use as cosine\ndist = FixedDiv (dx, finesine[angle] );\n\nreturn dist;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ UBYTE ;\nstruct TYPE_2__ {int /*<<< orphan*/  dist; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DIST_BITS ;\nint /*<<< orphan*/  R_DIST_SHIFT ;\nint /*<<< orphan*/  R_PointToDist_1 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_2 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_3 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_4 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_5 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_6 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_7 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_8 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_9 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_10 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_11 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_12 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_13 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_14 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_15 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_16 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_17 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_18 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_19 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_20 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_21 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_22 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_23 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_24 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_25 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_26 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_27 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_28 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_29 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_30 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_31 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_32 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_33 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_34 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_35 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_36 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_37 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_38 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_39 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_40 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_41 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_42 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_43 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_44 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_45 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_46 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_47 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_48 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_49 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_50 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_51 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_52 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_53 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_54 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_55 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_56 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_57 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_58 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_59 (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  R_PointToDist_60 (scalar_t__,scalar_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_Init",
    "input":"\n0000000000000000 <Z_Init>:\n0: \tpushq\t%rax\n1: \tleaq\t4(%rsp), %rdi\n6: \tcallq\t0xb <Z_Init+0xb>\nb: \tmovq\t%rax, (%rip)  # 0x12 <Z_Init+0x12>\n12: \tmovl\t4(%rsp), %ecx\n16: \tmovl\t%ecx, (%rax)\n18: \tleaq\t192(%rax), %rdx\n1f: \tleaq\t8(%rax), %rsi\n23: \tmovq\t%rdx, 24(%rax)\n27: \tmovq\t%rdx, 32(%rax)\n2b: \tmovq\t%rax, 16(%rax)\n2f: \tmovl\t(%rip), %edi  # 0x35 <Z_Init+0x35>\n35: \tmovl\t%edi, 8(%rax)\n38: \tmovq\t%rdx, 40(%rax)\n3c: \tmovq\t%rsi, 208(%rax)\n43: \tmovq\t%rsi, 216(%rax)\n4a: \tmovq\t$0, 200(%rax)\n55: \taddl\t$-48, %ecx\n58: \tmovl\t%ecx, 192(%rax)\n5e: \tpopq\t%rax\n5f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  tag; void* user; TYPE_3__* prev; TYPE_3__* next; } ;\nstruct TYPE_6__ {int size; TYPE_1__ blocklist; TYPE_3__* rover; } ;\ntypedef  TYPE_2__ memzone_t ;\nstruct TYPE_7__ {int size; int /*<<< orphan*/ * user; TYPE_1__* next; TYPE_1__* prev; } ;\ntypedef  TYPE_3__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nscalar_t__ I_ZoneBase (int*) ;\nint /*<<< orphan*/  PU_STATIC ;\nTYPE_2__* mainzone ;\n\nvoid Z_Init (void)\n{\nmemblock_t*\tblock;\nint\t\tsize;\n\nmainzone = (memzone_t *)I_ZoneBase (&size);\nmainzone->size = size;\n\n// set the entire zone to one free block\nmainzone->blocklist.next =\nmainzone->blocklist.prev =\nblock = (memblock_t *)( (byte *)mainzone + sizeof(memzone_t) );\n\nmainzone->blocklist.user = (void *)mainzone;\nmainzone->blocklist.tag = PU_STATIC;\nmainzone->rover = block;\n\nblock->prev = block->next = &mainzone->blocklist;\n\n// NULL indicates a free block.\nblock->user = NULL;\n\nblock->size = mainzone->size - sizeof(memzone_t);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * next; int /*<<< orphan*/ * prev; int /*<<< orphan*/  type; int /*<<< orphan*/  size; int /*<<< orphan*/ * data; int /*<<< orphan*/ * next_free; int /*<<< orphan*/ * prev_free; } ;\ntypedef  TYPE_1__ ZSTD_DCtx ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ZSTD_defaultCMem ;\nTYPE_1__* ZSTD_createDCtx_advanced (int*) ;\n\n__attribute__((used)) static void Z_Init(void)\n{\nZSTD_DCtx* dctx = ZSTD_createDCtx_advanced(NULL);\ndctx->size = 192;\ndctx->type = ZSTD_defaultCMem;\ndctx->data = dctx + 1;\ndctx->next = dctx->prev = dctx;\ndctx->next_free = dctx->prev_free = NULL;\ndctx->size -= 48;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_P_RadiusAttack",
    "input":"\n0000000000000000 <P_RadiusAttack>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t(%rip), %eax  # 0xe <P_RadiusAttack+0xe>\ne: \taddl\t%edx, %eax\n10: \tmovb\t(%rip), %cl   # 0x16 <P_RadiusAttack+0x16>\n16: \tshll\t%cl, %eax\n18: \tmovl\t(%rdi), %r14d\n1b: \tleal\t(%r14,%rax), %r15d\n1f: \tmovl\t(%rip), %ebp  # 0x25 <P_RadiusAttack+0x25>\n25: \tsubl\t%ebp, %r15d\n28: \tmovb\t(%rip), %cl   # 0x2e <P_RadiusAttack+0x2e>\n2e: \tsarl\t%cl, %r15d\n31: \tsubl\t%eax, %r14d\n34: \tsubl\t%ebp, %r14d\n37: \tsarl\t%cl, %r14d\n3a: \tmovl\t4(%rdi), %r12d\n3e: \tleal\t(%r12,%rax), %ebp\n42: \tmovl\t(%rip), %ebx  # 0x48 <P_RadiusAttack+0x48>\n48: \tsubl\t%ebx, %ebp\n4a: \tsarl\t%cl, %ebp\n4c: \tsubl\t%eax, %r12d\n4f: \tsubl\t%ebx, %r12d\n52: \tsarl\t%cl, %r12d\n55: \tmovq\t%rdi, (%rip)  # 0x5c <P_RadiusAttack+0x5c>\n5c: \tmovq\t%rsi, (%rip)  # 0x63 <P_RadiusAttack+0x63>\n63: \tmovl\t%edx, (%rip)  # 0x69 <P_RadiusAttack+0x69>\n69: \tcmpl\t%r15d, %r14d\n6c: \tjle\t0x8c <P_RadiusAttack+0x8c>\n6e: \tpopq\t%rbx\n6f: \tpopq\t%r12\n71: \tpopq\t%r14\n73: \tpopq\t%r15\n75: \tpopq\t%rbp\n76: \tretq\n77: \tnopw\t(%rax,%rax)\n80: \tleal\t1(%r14), %eax\n84: \tcmpl\t%r15d, %r14d\n87: \tmovl\t%eax, %r14d\n8a: \tjge\t0x6e <P_RadiusAttack+0x6e>\n8c: \tcmpl\t%ebp, %r12d\n8f: \tjg\t0x80 <P_RadiusAttack+0x80>\n91: \tmovl\t%r12d, %ebx\n94: \tnopw\t%cs:(%rax,%rax)\n9e: \tnop\na0: \tmovl\t(%rip), %edx  # 0xa6 <P_RadiusAttack+0xa6>\na6: \tmovl\t%ebx, %edi\na8: \tmovl\t%r14d, %esi\nab: \tcallq\t0xb0 <P_RadiusAttack+0xb0>\nb0: \tleal\t1(%rbx), %eax\nb3: \tcmpl\t%ebp, %ebx\nb5: \tmovl\t%eax, %ebx\nb7: \tjl\t0xa0 <P_RadiusAttack+0xa0>\nb9: \tjmp\t0x80 <P_RadiusAttack+0x80>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int y; int x; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nint FRACBITS ;\nint MAPBLOCKSHIFT ;\nint MAXRADIUS ;\nint /*<<< orphan*/  PIT_RadiusAttack ;\nint /*<<< orphan*/  P_BlockThingsIterator (int,int,int /*<<< orphan*/ ) ;\nint bmaporgx ;\nint bmaporgy ;\nint bombdamage ;\nTYPE_1__* bombsource ;\nTYPE_1__* bombspot ;\n\nvoid\nP_RadiusAttack\n( mobj_t*\tspot,\nmobj_t*\tsource,\nint\t\tdamage )\n{\nint\t\tx;\nint\t\ty;\n\nint\t\txl;\nint\t\txh;\nint\t\tyl;\nint\t\tyh;\n\nfixed_t\tdist;\n\ndist = (damage+MAXRADIUS)<<FRACBITS;\nyh = (spot->y + dist - bmaporgy)>>MAPBLOCKSHIFT;\nyl = (spot->y - dist - bmaporgy)>>MAPBLOCKSHIFT;\nxh = (spot->x + dist - bmaporgx)>>MAPBLOCKSHIFT;\nxl = (spot->x - dist - bmaporgx)>>MAPBLOCKSHIFT;\nbombspot = spot;\nbombsource = source;\nbombdamage = damage;\n\nfor (y=yl ; y<=yh ; y++)\nfor (x=xl ; x<=xh ; x++)\nP_BlockThingsIterator (x, y, PIT_RadiusAttack );\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; } ;\ntypedef  TYPE_1__ PLAYER ;\n\n/* Variables and functions */\nint P_RadiusAttack_Radius ;\nint P_RadiusAttack_Radius_S ;\nint P_RadiusAttack_Radius_X ;\nint P_RadiusAttack_Radius_Y ;\nint P_RadiusAttack_Radius_Z ;\nint P_RadiusAttack_Radius_Z_S ;\nint P_RadiusAttack_Radius_Z_X ;\nint P_RadiusAttack_Radius_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_S ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_X ;\nint P_RadiusAttack_Radius_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Y ;\nint P_RadiusAttack_Radius_Z_Z_Z"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_FireMissile",
    "input":"\n0000000000000000 <A_FireMissile>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t16(%rdi), %rcx\n7: \tmovq\t(%rip), %rdx  # 0xe <A_FireMissile+0xe>\ne: \tmovq\t(%rdx,%rax,8), %rax\n12: \taddl\t$-1, (%rcx,%rax,4)\n16: \tmovl\t8(%rdi), %edi\n19: \tmovl\t(%rip), %esi  # 0x1f <A_FireMissile+0x1f>\n1f: \tjmp\t0x24 <A_FireMissile+0x24>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_4__ {size_t readyweapon; int /*<<< orphan*/  mo; int /*<<< orphan*/ * ammo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_5__ {size_t ammo; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MT_ROCKET ;\nint /*<<< orphan*/  P_SpawnPlayerMissile (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_2__* weaponinfo ;\n\nvoid\nA_FireMissile\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\nP_SpawnPlayerMissile (player->mo, MT_ROCKET);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; } ;\nstruct TYPE_4__ {size_t* p; TYPE_1__* s; } ;\ntypedef  TYPE_2__ actor_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ACTOR_FALL ;\nint /*<<< orphan*/  A_SetAnim (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nsize_t* am_missile ;\n\nvoid A_FireMissile(void* info)\n{\nactor_t* act = (actor_t*)info;\n\nact->s->y -= 1;\nA_SetAnim(act->s->y, ACTOR_FALL);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_drawThings",
    "input":"\n0000000000000000 <AM_drawThings>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovl\t(%rip), %eax  # 0xf <AM_drawThings+0xf>\nf: \ttestl\t%eax, %eax\n11: \tjle\t0x86 <AM_drawThings+0x86>\n13: \tmovslq\t%edi, %r15\n16: \txorl\t%r14d, %r14d\n19: \tjmp\t0x2c <AM_drawThings+0x2c>\n1b: \tnopl\t(%rax,%rax)\n20: \taddq\t$1, %r14\n24: \tmovslq\t%eax, %rcx\n27: \tcmpq\t%rcx, %r14\n2a: \tjge\t0x86 <AM_drawThings+0x86>\n2c: \tmovq\t(%rip), %rcx  # 0x33 <AM_drawThings+0x33>\n33: \tmovq\t(%rcx,%r14,8), %rbx\n37: \ttestq\t%rbx, %rbx\n3a: \tje\t0x20 <AM_drawThings+0x20>\n3c: \tnopl\t(%rax)\n40: \tmovl\t(%rip), %edi  # 0x46 <AM_drawThings+0x46>\n46: \tmovl\t(%rip), %esi  # 0x4c <AM_drawThings+0x4c>\n4c: \tmovzbl\t(%rip), %ecx  # 0x53 <AM_drawThings+0x53>\n53: \tmovl\t$16, %edx\n58: \tshll\t%cl, %edx\n5a: \tmovl\t16(%rbx), %ecx\n5d: \tmovq\t(%rip), %r8   # 0x64 <AM_drawThings+0x64>\n64: \taddq\t%r15, %r8\n67: \tmovl\t8(%rbx), %eax\n6a: \tmovl\t12(%rbx), %r9d\n6e: \tmovl\t%eax, (%rsp)\n71: \tcallq\t0x76 <AM_drawThings+0x76>\n76: \tmovq\t(%rbx), %rbx\n79: \ttestq\t%rbx, %rbx\n7c: \tjne\t0x40 <AM_drawThings+0x40>\n7e: \tmovl\t(%rip), %eax  # 0x84 <AM_drawThings+0x84>\n84: \tjmp\t0x20 <AM_drawThings+0x20>\n86: \taddq\t$16, %rsp\n8a: \tpopq\t%rbx\n8b: \tpopq\t%r14\n8d: \tpopq\t%r15\n8f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* snext; int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  angle; } ;\ntypedef  TYPE_1__ mobj_t ;\nstruct TYPE_4__ {TYPE_1__* thinglist; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_drawLineCharacter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint FRACBITS ;\nint /*<<< orphan*/  NUMTHINTRIANGLEGUYLINES ;\nscalar_t__ lightlev ;\nint numsectors ;\nTYPE_2__* sectors ;\nint /*<<< orphan*/  thintriangle_guy ;\n\nvoid\nAM_drawThings\n( int\tcolors,\nint \tcolorrange)\n{\nint\t\ti;\nmobj_t*\tt;\n\nfor (i=0;i<numsectors;i++)\n{\nt = sectors[i].thinglist;\nwhile (t)\n{\nAM_drawLineCharacter\n(thintriangle_guy, NUMTHINTRIANGLEGUYLINES,\n16<<FRACBITS, t->angle, colors+lightlev, t->x, t->y);\nt = t->snext;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  color; } ;\ntypedef  TYPE_1__ AM_Thing ;\n\n/* Variables and functions */\nint AM_MAX_THINGS ;\nint AM_THING_SIZE ;\nint AM_THING_X ;\nint AM_THING_Y ;\nint /*<<< orphan*/  AM_drawThing (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__** AM_things ;\n\nvoid AM_drawThings(int x)\n{\nint i;\n\nfor (i=0; i<AM_MAX_THINGS; i++)\n{\nAM_Thing *thing = AM_things[i];\n\nwhile (thing)\n{\nAM_drawThing(AM_THING_X, AM_THING_Y, AM_THING_SIZE, thing->color, thing->x, thing->y, x);\nthing = thing->next;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BrainScream",
    "input":"\n0000000000000000 <A_BrainScream>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t(%rdi), %ecx\n9: \tmovl\t(%rip), %eax  # 0xf <A_BrainScream+0xf>\nf: \timull\t$4294967100, %eax, %ebx # imm = 0xFFFFFF3C\n15: \taddl\t%ecx, %ebx\n17: \tshll\t$6, %eax\n1a: \tleal\t(%rax,%rax,4), %eax\n1d: \taddl\t%eax, %ecx\n1f: \tcmpl\t%ecx, %ebx\n21: \tjge\t0xaa <A_BrainScream+0xaa>\n27: \tmovq\t%rdi, %r14\n2a: \tmovl\t$1, %r15d\n30: \tmovl\t4(%r14), %ebp\n34: \tsubl\t%eax, %ebp\n36: \txorl\t%eax, %eax\n38: \tcallq\t0x3d <A_BrainScream+0x3d>\n3d: \timull\t(%rip), %eax  # 0x44 <A_BrainScream+0x44>\n44: \tleal\t(%rax,%rax), %edx\n47: \taddl\t$128, %edx\n4d: \tmovl\t(%rip), %ecx  # 0x53 <A_BrainScream+0x53>\n53: \tmovl\t%ebx, %edi\n55: \tmovl\t%ebp, %esi\n57: \tcallq\t0x5c <A_BrainScream+0x5c>\n5c: \tmovq\t%rax, %rbp\n5f: \txorl\t%eax, %eax\n61: \tcallq\t0x66 <A_BrainScream+0x66>\n66: \tshll\t$9, %eax\n69: \tmovl\t%eax, 8(%rbp)\n6c: \tmovl\t(%rip), %esi  # 0x72 <A_BrainScream+0x72>\n72: \tmovq\t%rbp, %rdi\n75: \tcallq\t0x7a <A_BrainScream+0x7a>\n7a: \txorl\t%eax, %eax\n7c: \tcallq\t0x81 <A_BrainScream+0x81>\n81: \tandl\t$7, %eax\n84: \tmovl\t12(%rbp), %ecx\n87: \tsubl\t%eax, %ecx\n89: \ttestl\t%ecx, %ecx\n8b: \tcmovlel\t%r15d, %ecx\n8f: \tmovl\t%ecx, 12(%rbp)\n92: \tmovl\t(%rip), %eax  # 0x98 <A_BrainScream+0x98>\n98: \tleal\t(%rbx,%rax,8), %ebx\n9b: \tshll\t$6, %eax\n9e: \tleal\t(%rax,%rax,4), %eax\na1: \tmovl\t(%r14), %ecx\na4: \taddl\t%eax, %ecx\na6: \tcmpl\t%ecx, %ebx\na8: \tjl\t0x30 <A_BrainScream+0x30>\naa: \tmovl\t(%rip), %esi  # 0xb0 <A_BrainScream+0xb0>\nb0: \txorl\t%edi, %edi\nb2: \taddq\t$8, %rsp\nb6: \tpopq\t%rbx\nb7: \tpopq\t%r14\nb9: \tpopq\t%r15\nbb: \tpopq\t%rbp\nbc: \tjmp\t0xc1 <A_BrainScream+0xc1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int x; int y; int momz; int tics; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint FRACUNIT ;\nint /*<<< orphan*/  MT_ROCKET ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_1__*,int /*<<< orphan*/ ) ;\nTYPE_1__* P_SpawnMobj (int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_BRAINEXPLODE1 ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_bosdth ;\n\nvoid A_BrainScream (mobj_t*\tmo)\n{\nint\t\tx;\nint\t\ty;\nint\t\tz;\nmobj_t*\tth;\n\nfor (x=mo->x - 196*FRACUNIT ; x< mo->x + 320*FRACUNIT ; x+= FRACUNIT*8)\n{\ny = mo->y - 320*FRACUNIT;\nz = 128 + P_Random()*2*FRACUNIT;\nth = P_SpawnMobj (x,y,z, MT_ROCKET);\nth->momz = P_Random()*512;\n\nP_SetMobjState (th, S_BRAINEXPLODE1);\n\nth->tics -= P_Random()&7;\nif (th->tics < 1)\nth->tics = 1;\n}\n\nS_StartSound (NULL,sfx_bosdth);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  b; int /*<<< orphan*/  a; int /*<<< orphan*/  g; int /*<<< orphan*/  r; } ;\ntypedef  TYPE_1__ COLOR ;\ntypedef  int /*<<< orphan*/  Pixel ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_BrainScream_D ;\nint /*<<< orphan*/  A_BrainScream_S ;\nint /*<<< orphan*/  A_BrainScream_T ;\nint /*<<< orphan*/  A_BrainScream_U ;\nint /*<<< orphan*/  A_BrainScream_V ;\nint /*<<< orphan*/  A_BrainScream_W ;\nint /*<<< orphan*/  A_BrainScream_X ;\nint /*<<< orphan*/  A_BrainScream_Y ;\nint /*<<< orphan*/  A_BrainScream_Z ;\nint /*<<< orphan*/  A_BrainScream_a ;\nint /*<<< orphan*/  A_BrainScream_b ;\nint /*<<< orphan*/  A_BrainScream_c ;\nint /*<<< orphan*/  A_BrainScream_d ;\nint /*<<< orphan*/  A_BrainScream_e ;\nint /*<<< orphan*/  A_BrainScream_f ;\nint /*<<< orphan*/  A_BrainScream_g ;\nint /*<<< orphan*/  A_BrainScream_h ;\nint /*<<< orphan*/  A_BrainScream_i ;\nint /*<<< orphan*/  A_BrainScream_j ;\nint /*<<< orphan*/  A_BrainScream_k ;\nint /*<<< orphan*/  A_BrainScream_l ;\nint /*<<< orphan*/  A_BrainScream_m ;\nint /*<<< orphan*/  A_BrainScream_n ;\nint /*<<< orphan*/  A_BrainScream_o ;\nint /*<<< orphan*/  A_BrainScream_p ;\nint /*<<< orphan*/  A_BrainScream_q ;\nint /*<<< orphan*/  A_BrainScream_r ;\nint /*<<< orphan*/  A_BrainScream_s ;\nint /*<<< orphan*/  A_BrainScream_t ;\nint /*<<< orphan*/  A_BrainScream_u ;\nint /*<<< orphan*/  A_BrainScream_v ;\nint /*<<< orphan*/  A_BrainScream_w ;\nint /*<<< orphan*/  A_BrainScream_x ;\nint /*<<< orphan*/  A_BrainScream_y ;\nint /*<<< orphan*/  A_BrainScream_z ;\nint /*<<< orphan*/  A_BrainScream_A ;\nint /*<<< orphan*/  A_BrainScream_B ;\nint /*<<< orphan*/  A_BrainScream_C ;\nint /*<<< orphan*/  A_BrainScream_D ;\nint /*<<< orphan*/  A_BrainScream_E ;\nint /*<<< orphan*/  A_BrainScream_F ;\nint /*<<< orphan*/  A_BrainScream_G ;\nint /*<<< orphan*/  A_BrainScream_H ;\nint /*<<< orphan*/  A_BrainScream_I ;\nint /*<<< orphan*/  A_BrainScream_J ;\nint /*<<< orphan*/  A_BrainScream_K ;\nint /*<<< orphan*/  A_BrainScream_L ;\nint /*<<< orphan*/  A_BrainScream_M ;\nint /*<<< orphan*/  A_BrainScream_N ;\nint /*<<< orphan*/  A_BrainScream_O ;\nint /*<<< orphan*/  A_BrainScream_P ;\nint /*<<< orphan*/  A_BrainScream_Q ;\nint /*<<< orphan*/  A_BrainScream_R ;\nint /*<<< orphan*/  A_BrainScream_S ;\nint /*<<< orphan*/  A_BrainScream_T ;\nint /*<<< orphan*/  A_BrainScream_U ;\nint /*<<< orphan*/  A_BrainScream_V ;\nint /*<<< orphan*/  A_BrainScream_W ;\nint /*<<< orphan*/  A_BrainScream_X ;\nint /*<<< orphan*/  A_BrainScream_Y ;\nint /*<<< orphan*/  A_BrainScream_Z ;\nint /*<<< orphan*/  A_BrainScream_a ;\nint /*<<< orphan*/  A_BrainScream_b ;\nint /*<<< orphan*/  A_BrainScream_c ;\nint /*<<< orphan*/  A_BrainScream_d ;\nint /*<<< orphan*/  A_BrainScream_e ;\nint /*<<< orphan*/  A_BrainScream_f ;\nint /*<<< orphan*/  A_BrainScream_g ;\nint /*<<< orphan*/  A_BrainScream_h ;\nint /*<<< orphan*/  A_BrainScream_i ;\nint /*<<< orphan*/  A_BrainScream_j ;\nint /*<<< orphan*/  A_BrainScream_k ;\nint /*<<< orphan*/  A_BrainScream_l ;\nint /*<<< orphan*/  A_BrainScream_m ;\nint /*<<< orphan*/  A_BrainScream_n ;\nint /*<<< orphan*/  A_BrainScream_o ;\nint /*<<< orphan*/  A_BrainScream_p ;\nint /*<<< orphan*/  A_BrainScream_q ;\nint /*<<< orphan*/  A_BrainScream_r ;\nint /*<<< orphan*/  A_BrainScream_s ;\nint /*<<< orphan*/  A_BrainScream_t ;\nint /*<<< orphan*/  A_BrainScream_u ;\nint /*<<< orphan*/  A_BrainScream_v ;\nint /*<<< orphan*/  A_BrainScream_w ;\nint /*<<< orphan*/  A_BrainScream_x ;\nint /*<<< orphan*/  A_BrainScream_y ;\nint /*<<< orphan*/  A_BrainScream_z ;\nint /*<<< orphan*/  A_BrainScream_A ;\nint /*<<< orphan*/  A_BrainScream_B ;\nint /*<<< orphan*/  A_BrainScream_C ;\nint /*<<< orphan*/  A_BrainScream_D ;\nint /*<<< orphan*/  A_BrainScream_E ;\nint /*<<< orphan*/  A_BrainScream_F ;\nint /*<<< orphan*/  A_BrainScream_G ;\nint /*<<< orphan*/  A_BrainScream_H ;\nint /*<<< orphan*/  A_BrainScream_I ;\nint /*<<< orphan*/  A_BrainScream_J ;\nint /*<<< orphan*/  A_BrainScream_K ;\nint /*<<< orphan*/  A_BrainScream_L ;\nint /*<<< orphan*/  A_BrainScream_M ;\nint /*<<< orphan*/  A_BrainScream_N ;\nint /*<<< orphan*/  A_BrainScream_O ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_HU_Drawer",
    "input":"\n0000000000000000 <HU_Drawer>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, %edi\n6: \tcallq\t0xb <HU_Drawer+0xb>\nb: \tmovl\t$0, %edi\n10: \tcallq\t0x15 <HU_Drawer+0x15>\n15: \tcmpq\t$0, (%rip)    # 0x1d <HU_Drawer+0x1d>\n1d: \tje\t0x2c <HU_Drawer+0x2c>\n1f: \tmovl\t$0, %edi\n24: \txorl\t%esi, %esi\n26: \tpopq\t%rax\n27: \tjmp\t0x2c <HU_Drawer+0x2c>\n2c: \tpopq\t%rax\n2d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_drawIText (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  HUlib_drawSText (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  HUlib_drawTextLine (int /*<<< orphan*/ *,int) ;\nscalar_t__ automapactive ;\nint /*<<< orphan*/  w_chat ;\nint /*<<< orphan*/  w_message ;\nint /*<<< orphan*/  w_title ;\n\nvoid HU_Drawer(void)\n{\n\nHUlib_drawSText(&w_message);\nHUlib_drawIText(&w_chat);\nif (automapactive)\nHUlib_drawTextLine(&w_title, false);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_Draw_Menu () ;\nint /*<<< orphan*/  HU_Draw_Status () ;\nint /*<<< orphan*/  HU_Draw_Status_Bar () ;\nscalar_t__ HU_Status_Bar ;\nint /*<<< orphan*/  printf (char*) ;\n\nvoid HU_Drawer(void)\n{\nprintf(\"HU_Drawer\\n\");\nHU_Draw_Menu();\nHU_Draw_Status();\nif (HU_Status_Bar)\nHU_Draw_Status_Bar(0);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawEL",
    "input":"\n0000000000000000 <WI_drawEL>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t(%rip), %ebx  # 0x9 <WI_drawEL+0x9>\n9: \tmovl\t(%rip), %ebp  # 0xf <WI_drawEL+0xf>\nf: \tmovq\t(%rip), %rax  # 0x16 <WI_drawEL+0x16>\n16: \tmovl\t(%rax), %edi\n18: \tcallq\t0x1d <WI_drawEL+0x1d>\n1d: \tsubl\t%eax, %ebp\n1f: \tmovl\t%ebp, %edi\n21: \tshrl\t$31, %edi\n24: \taddl\t%ebp, %edi\n26: \tsarl\t%edi\n28: \tmovl\t(%rip), %edx  # 0x2e <WI_drawEL+0x2e>\n2e: \tmovq\t(%rip), %rcx  # 0x35 <WI_drawEL+0x35>\n35: \tmovl\t%ebx, %esi\n37: \tcallq\t0x3c <WI_drawEL+0x3c>\n3c: \tmovq\t(%rip), %rax  # 0x43 <WI_drawEL+0x43>\n43: \tmovq\t(%rip), %rcx  # 0x4a <WI_drawEL+0x4a>\n4a: \tmovq\t(%rcx), %rcx\n4d: \tmovq\t(%rax,%rcx,8), %rax\n51: \tmovl\t4(%rax), %edi\n54: \tcallq\t0x59 <WI_drawEL+0x59>\n59: \tleal\t(%rax,%rax,4), %ecx\n5c: \tleal\t(%rax,%rax,4), %ebp\n5f: \taddl\t$3, %ebp\n62: \ttestl\t%ecx, %ecx\n64: \tcmovnsl\t%ecx, %ebp\n67: \tsarl\t$2, %ebp\n6a: \taddl\t%ebx, %ebp\n6c: \tmovl\t(%rip), %ebx  # 0x72 <WI_drawEL+0x72>\n72: \tmovq\t(%rip), %rax  # 0x79 <WI_drawEL+0x79>\n79: \tmovq\t(%rip), %rcx  # 0x80 <WI_drawEL+0x80>\n80: \tmovq\t(%rcx), %rcx\n83: \tmovq\t(%rax,%rcx,8), %rax\n87: \tmovl\t(%rax), %edi\n89: \tcallq\t0x8e <WI_drawEL+0x8e>\n8e: \tsubl\t%eax, %ebx\n90: \tmovl\t%ebx, %edi\n92: \tshrl\t$31, %edi\n95: \taddl\t%ebx, %edi\n97: \tsarl\t%edi\n99: \tmovl\t(%rip), %edx  # 0x9f <WI_drawEL+0x9f>\n9f: \tmovq\t(%rip), %rax  # 0xa6 <WI_drawEL+0xa6>\na6: \tmovq\t(%rip), %rcx  # 0xad <WI_drawEL+0xad>\nad: \tmovq\t(%rcx), %rcx\nb0: \tmovq\t(%rax,%rcx,8), %rcx\nb4: \tmovl\t%ebp, %esi\nb6: \taddq\t$8, %rsp\nba: \tpopq\t%rbx\nbb: \tpopq\t%rbp\nbc: \tjmp\t0xc1 <WI_drawEL+0xc1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  width; int /*<<< orphan*/  height; } ;\nstruct TYPE_5__ {size_t next; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FB ;\nint SCREENWIDTH ;\nint SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,TYPE_2__*) ;\nint WI_TITLEY ;\nTYPE_2__* entering ;\nTYPE_2__** lnames ;\nTYPE_1__* wbs ;\n\nvoid WI_drawEL(void)\n{\nint y = WI_TITLEY;\n\n// draw \"Entering\"\nV_DrawPatch((SCREENWIDTH - SHORT(entering->width))/2,\ny, FB, entering);\n\n// draw level\ny += (5*SHORT(lnames[wbs->next]->height))/4;\n\nV_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->next]->width))/2,\ny, FB, lnames[wbs->next]);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * p; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawLine (int,int,int,int /*<<< orphan*/ ) ;\nint WI_el_height ;\nint WI_el_width ;\nint WI_el_x ;\nint WI_el_y ;\nTYPE_1__* WI_font ;\nint /*<<< orphan*/  WI_getFontHeight (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WI_getFontWidth (int /*<<< orphan*/ ) ;\n\nvoid WI_drawEL(void)\n{\nWI_drawLine(WI_el_x, WI_el_y, WI_el_x + WI_getFontWidth(WI_font[WI_font[0].p[0]].p) - 1, WI_el_y + WI_getFontHeight(WI_font[WI_font[0].p[0]].p) - 1, WI_el_height);\nWI_drawLine(WI_el_x + WI_getFontWidth(WI_font[WI_font[0].p[0]].p) - 1, WI_el_y, WI_el_x, WI_el_y + WI_getFontHeight(WI_font[WI_font[0].p[0]].p) - 1, WI_el_height);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_misc.c_M_WriteFile",
    "input":"\n0000000000000000 <M_WriteFile>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edx, %r15d\na: \tmovq\t%rsi, %r14\nd: \tmovl\t(%rip), %esi  # 0x13 <M_WriteFile+0x13>\n13: \torl\t(%rip), %esi  # 0x19 <M_WriteFile+0x19>\n19: \torl\t(%rip), %esi  # 0x1f <M_WriteFile+0x1f>\n1f: \torl\t(%rip), %esi  # 0x25 <M_WriteFile+0x25>\n25: \tmovl\t$438, %edx    # imm = 0x1B6\n2a: \tcallq\t0x2f <M_WriteFile+0x2f>\n2f: \tcmpl\t$-1, %eax\n32: \tje\t0x56 <M_WriteFile+0x56>\n34: \tmovl\t%eax, %ebp\n36: \tmovl\t%eax, %edi\n38: \tmovq\t%r14, %rsi\n3b: \tmovl\t%r15d, %edx\n3e: \tcallq\t0x43 <M_WriteFile+0x43>\n43: \tmovl\t%eax, %ebx\n45: \tmovl\t%ebp, %edi\n47: \tcallq\t0x4c <M_WriteFile+0x4c>\n4c: \txorl\t%eax, %eax\n4e: \tcmpl\t%r15d, %ebx\n51: \tsetge\t%al\n54: \tjmp\t0x58 <M_WriteFile+0x58>\n56: \txorl\t%eax, %eax\n58: \taddq\t$8, %rsp\n5c: \tpopq\t%rbx\n5d: \tpopq\t%r14\n5f: \tpopq\t%r15\n61: \tpopq\t%rbp\n62: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int boolean ;\n\n/* Variables and functions */\nint O_BINARY ;\nint O_CREAT ;\nint O_TRUNC ;\nint O_WRONLY ;\nint /*<<< orphan*/  close (int) ;\nint open (char const*,int,int) ;\nint write (int,void*,int) ;\n\nboolean\nM_WriteFile\n( char const*\tname,\nvoid*\t\tsource,\nint\t\tlength )\n{\nint\t\thandle;\nint\t\tcount;\n\nhandle = open ( name, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);\n\nif (handle == -1)\nreturn false;\n\ncount = write (handle, source, length);\nclose (handle);\n\nif (count < length)\nreturn false;\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint O_APPEND ;\nint O_CREAT ;\nint O_RDWR ;\nint O_TRUNC ;\nint open (char const*,int,int) ;\nint /*<<< orphan*/  write (int,char const*,int) ;\n\nint M_WriteFile(const char *filename, const char *data, int len)\n{\nint fd;\nint written;\n\nfd = open(filename, O_RDWR | O_CREAT | O_APPEND | O_TRUNC, 0666);\nif (fd == -1)\nreturn 0;\n\nwritten = write(fd, data, len);\nclose(fd);\n\nreturn written >= len;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_StartCast",
    "input":"\n0000000000000000 <F_StartCast>:\n0: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0xa <F_StartCast+0xa>\na: \tmovq\t$0, (%rip)    # 0x15 <F_StartCast+0x15>\n15: \tmovq\t(%rip), %rax  # 0x1c <F_StartCast+0x1c>\n1c: \tmovq\t(%rip), %rcx  # 0x23 <F_StartCast+0x23>\n23: \tmovq\t(%rip), %rdx  # 0x2a <F_StartCast+0x2a>\n2a: \tmovq\t(%rdx), %rdx\n2d: \tmovq\t(%rcx,%rdx,8), %rcx\n31: \tleaq\t(%rax,%rcx,4), %rdx\n35: \tmovq\t%rdx, (%rip)  # 0x3c <F_StartCast+0x3c>\n3c: \tmovl\t(%rax,%rcx,4), %eax\n3f: \tmovl\t%eax, (%rip)  # 0x45 <F_StartCast+0x45>\n45: \tmovl\t$0, (%rip)    # 0x4f <F_StartCast+0x4f>\n4f: \tmovl\t$2, (%rip)    # 0x59 <F_StartCast+0x59>\n59: \tmovq\t$0, (%rip)    # 0x64 <F_StartCast+0x64>\n64: \tmovq\t$0, (%rip)    # 0x6f <F_StartCast+0x6f>\n6f: \tmovl\t$0, (%rip)    # 0x79 <F_StartCast+0x79>\n79: \tmovl\t(%rip), %edi  # 0x7f <F_StartCast+0x7f>\n7f: \tmovl\t$1, %esi\n84: \tjmp\t0x89 <F_StartCast+0x89>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_4__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {size_t type; } ;\nstruct TYPE_6__ {size_t seestate; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  tics; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_ChangeMusic (int /*<<< orphan*/ ,int) ;\nint castattacking ;\nint castdeath ;\nscalar_t__ castframes ;\nsize_t castnum ;\nscalar_t__ castonmelee ;\nTYPE_4__* castorder ;\nTYPE_1__* caststate ;\nint /*<<< orphan*/  casttics ;\nint finalestage ;\nTYPE_2__* mobjinfo ;\nint /*<<< orphan*/  mus_evil ;\nTYPE_1__* states ;\nint wipegamestate ;\n\nvoid F_StartCast (void)\n{\nwipegamestate = -1;\t\t// force a screen wipe\ncastnum = 0;\ncaststate = &states[mobjinfo[castorder[castnum].type].seestate];\ncasttics = caststate->tics;\ncastdeath = false;\nfinalestage = 2;\ncastframes = 0;\ncastonmelee = 0;\ncastattacking = false;\nS_ChangeMusic(mus_evil, true);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {size_t cast_type; int /*<<< orphan*/  cast_target; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  F_Cast ;\nint /*<<< orphan*/  F_Cast_Target ;\nint /*<<< orphan*/  F_Cast_Type ;\nint /*<<< orphan*/  F_Cast_Type_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target_Target ;\nint /*<<< orphan*/  F_Cast_Type_Target_Target_Target_Target_Target_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_updatePercent",
    "input":"\n0000000000000000 <STlib_updatePercent>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%esi, %ebp\n5: \tmovq\t%rdi, %rbx\n8: \ttestl\t%esi, %esi\na: \tje\t0x29 <STlib_updatePercent+0x29>\nc: \tmovq\t8(%rbx), %rax\n10: \tcmpq\t$0, (%rax)\n14: \tje\t0x29 <STlib_updatePercent+0x29>\n16: \tmovl\t(%rbx), %esi\n18: \tmovl\t4(%rbx), %edi\n1b: \tmovl\t(%rip), %edx  # 0x21 <STlib_updatePercent+0x21>\n21: \tmovl\t16(%rbx), %ecx\n24: \tcallq\t0x29 <STlib_updatePercent+0x29>\n29: \tmovq\t%rbx, %rdi\n2c: \tmovl\t%ebp, %esi\n2e: \taddq\t$8, %rsp\n32: \tpopq\t%rbx\n33: \tpopq\t%rbp\n34: \tjmp\t0x39 <STlib_updatePercent+0x39>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; scalar_t__* on; } ;\nstruct TYPE_4__ {TYPE_3__ n; int /*<<< orphan*/  p; } ;\ntypedef  TYPE_1__ st_percent_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FG ;\nint /*<<< orphan*/  STlib_updateNum (TYPE_3__*,int) ;\nint /*<<< orphan*/  V_DrawPatch (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nSTlib_updatePercent\n( st_percent_t*\t\tper,\nint\t\t\trefresh )\n{\nif (refresh && *per->n.on)\nV_DrawPatch(per->n.x, per->n.y, FG, per->p);\n\nSTlib_updateNum(&per->n, refresh);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  hwnd; int /*<<< orphan*/  hwndParent; int /*<<< orphan*/  hinst; int /*<<< orphan*/  hwndProgress; TYPE_1__* pStg; } ;\nstruct TYPE_4__ {scalar_t__ fProgress; } ;\ntypedef  TYPE_2__ STREAMTHREAD ;\n\n/* Variables and functions */\nint /*<<< orphan*/  IDS_PROGRESS_PERCENT ;\nint /*<<< orphan*/  SetDlgItemInt (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SetDlgItemTextW (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void STlib_updatePercent(STREAMTHREAD *pst, int percent)\n{\nif (percent && pst->pStg->fProgress)\n{\nSetDlgItemTextW(pst->hwndProgress, pst->hwnd, IDS_PROGRESS_PERCENT);\nSetDlgItemInt(pst->hwndProgress, pst->hwnd, percent, 100);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_CastPrint",
    "input":"\n0000000000000000 <F_CastPrint>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \ttestq\t%rdi, %rdi\na: \tje\t0xfd <F_CastPrint+0xfd>\n10: \tmovq\t%rdi, %rbx\n13: \tmovb\t(%rdi), %al\n15: \ttestb\t%al, %al\n17: \tje\t0x71 <F_CastPrint+0x71>\n19: \tleaq\t1(%rbx), %rbp\n1d: \txorl\t%r14d, %r14d\n20: \tjmp\t0x40 <F_CastPrint+0x40>\n22: \tnopw\t%cs:(%rax,%rax)\n2c: \tnopl\t(%rax)\n30: \taddl\t$4, %r14d\n34: \tmovzbl\t(%rbp), %eax\n38: \taddq\t$1, %rbp\n3c: \ttestb\t%al, %al\n3e: \tje\t0x74 <F_CastPrint+0x74>\n40: \tmovsbl\t%al, %edi\n43: \tcallq\t0x48 <F_CastPrint+0x48>\n48: \tsubl\t(%rip), %eax  # 0x4e <F_CastPrint+0x4e>\n4e: \tjs\t0x30 <F_CastPrint+0x30>\n50: \tcmpl\t(%rip), %eax  # 0x56 <F_CastPrint+0x56>\n56: \tjg\t0x30 <F_CastPrint+0x30>\n58: \tmovq\t(%rip), %rcx  # 0x5f <F_CastPrint+0x5f>\n5f: \tmovl\t%eax, %eax\n61: \tmovq\t(%rcx,%rax,8), %rax\n65: \tmovl\t(%rax), %edi\n67: \tcallq\t0x6c <F_CastPrint+0x6c>\n6c: \taddl\t%eax, %r14d\n6f: \tjmp\t0x34 <F_CastPrint+0x34>\n71: \txorl\t%r14d, %r14d\n74: \ttestq\t%rbx, %rbx\n77: \tje\t0xfd <F_CastPrint+0xfd>\n7d: \tmovb\t(%rbx), %al\n7f: \ttestb\t%al, %al\n81: \tje\t0xfd <F_CastPrint+0xfd>\n83: \tmovl\t%r14d, %ecx\n86: \tshrl\t$31, %ecx\n89: \taddl\t%r14d, %ecx\n8c: \tsarl\t%ecx\n8e: \tmovl\t$160, %r15d\n94: \tsubl\t%ecx, %r15d\n97: \taddq\t$1, %rbx\n9b: \tjmp\t0xaf <F_CastPrint+0xaf>\n9d: \tnopl\t(%rax)\na0: \taddl\t$4, %r15d\na4: \tmovzbl\t(%rbx), %eax\na7: \taddq\t$1, %rbx\nab: \ttestb\t%al, %al\nad: \tje\t0xfd <F_CastPrint+0xfd>\naf: \tmovsbl\t%al, %edi\nb2: \tcallq\t0xb7 <F_CastPrint+0xb7>\nb7: \tsubl\t(%rip), %eax  # 0xbd <F_CastPrint+0xbd>\nbd: \tjs\t0xa0 <F_CastPrint+0xa0>\nbf: \tcmpl\t(%rip), %eax  # 0xc5 <F_CastPrint+0xc5>\nc5: \tjg\t0xa0 <F_CastPrint+0xa0>\nc7: \tmovq\t(%rip), %rcx  # 0xce <F_CastPrint+0xce>\nce: \tmovl\t%eax, %ebp\nd0: \tmovq\t(%rcx,%rbp,8), %rax\nd4: \tmovl\t(%rax), %edi\nd6: \tcallq\t0xdb <F_CastPrint+0xdb>\ndb: \tmovl\t%eax, %r14d\nde: \tmovq\t(%rip), %rax  # 0xe5 <F_CastPrint+0xe5>\ne5: \tmovq\t(%rax,%rbp,8), %rcx\ne9: \tmovl\t%r15d, %edi\nec: \tmovl\t$180, %esi\nf1: \txorl\t%edx, %edx\nf3: \tcallq\t0xf8 <F_CastPrint+0xf8>\nf8: \taddl\t%r14d, %r15d\nfb: \tjmp\t0xa4 <F_CastPrint+0xa4>\nfd: \taddq\t$8, %rsp\n101: \tpopq\t%rbx\n102: \tpopq\t%r14\n104: \tpopq\t%r15\n106: \tpopq\t%rbp\n107: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  width; } ;\n\n/* Variables and functions */\nint HU_FONTSIZE ;\nint HU_FONTSTART ;\nint SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,TYPE_1__*) ;\nTYPE_1__** hu_font ;\nint toupper (int) ;\n\nvoid F_CastPrint (char* text)\n{\nchar*\tch;\nint\t\tc;\nint\t\tcx;\nint\t\tw;\nint\t\twidth;\n\n// find width\nch = text;\nwidth = 0;\n\nwhile (ch)\n{\nc = *ch++;\nif (!c)\nbreak;\nc = toupper(c) - HU_FONTSTART;\nif (c < 0 || c> HU_FONTSIZE)\n{\nwidth += 4;\ncontinue;\n}\n\nw = SHORT (hu_font[c]->width);\nwidth += w;\n}\n\n// draw it\ncx = 160-width/2;\nch = text;\nwhile (ch)\n{\nc = *ch++;\nif (!c)\nbreak;\nc = toupper(c) - HU_FONTSTART;\nif (c < 0 || c> HU_FONTSIZE)\n{\ncx += 4;\ncontinue;\n}\n\nw = SHORT (hu_font[c]->width);\nV_DrawPatch(cx, 180, 0, hu_font[c]);\ncx+=w;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_CastPrintChar (char) ;\nint /*<<< orphan*/  F_CastPrintChar2 (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar3 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar4 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar5 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar6 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar7 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar8 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar9 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharA (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharB (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharC (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharD (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharE (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharF (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharG (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharH (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharI (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharJ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharK (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharL (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharN (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharO (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharQ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharR (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharS (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharU (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharV (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharW (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharX (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharY (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintCharZ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_0 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_1 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_2 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_3 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_4 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_5 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_6 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_7 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_8 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_9 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_A (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_B (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_C (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_D (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_E (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_F (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_G (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_H (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_I (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_J (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_K (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_L (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_M (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_N (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_O (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_P (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_Q (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_R (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_S (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_T (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_U (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_V (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_W (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_X (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_Y (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_Z (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_a (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_b (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_c (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  F_CastPrintChar_d"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_PageDrawer",
    "input":"\n0000000000000000 <D_PageDrawer>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %edi  # 0x7 <D_PageDrawer+0x7>\n7: \tmovl\t(%rip), %esi  # 0xd <D_PageDrawer+0xd>\nd: \tcallq\t0x12 <D_PageDrawer+0x12>\n12: \txorl\t%edi, %edi\n14: \txorl\t%esi, %esi\n16: \txorl\t%edx, %edx\n18: \tmovl\t%eax, %ecx\n1a: \tpopq\t%rax\n1b: \tjmp\t0x20 <D_PageDrawer+0x20>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatch (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pagename ;\n\nvoid D_PageDrawer (void)\n{\nV_DrawPatch (0,0, 0, W_CacheLumpName(pagename, PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pdf_processor ;\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_PageDrawer_EndTextObject ;\nint /*<<< orphan*/  D_PageDrawer_StartTextObject ;\nint /*<<< orphan*/  fz_drop_text (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fz_keep_text (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fz_new_text (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\nD_PageDrawer(fz_context *ctx, pdf_processor *proc)\n{\nfz_drop_text(ctx, NULL, NULL, fz_keep_text(ctx, fz_new_text(ctx, NULL, NULL, NULL)));\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_EndGame",
    "input":"\n0000000000000000 <M_EndGame>:\n0: \tcmpl\t$0, (%rip)    # 0x7 <M_EndGame+0x7>\n7: \tje\t0x22 <M_EndGame+0x22>\n9: \tcmpq\t$0, (%rip)    # 0x11 <M_EndGame+0x11>\n11: \tje\t0x2f <M_EndGame+0x2f>\n13: \tmovl\t(%rip), %edi  # 0x19 <M_EndGame+0x19>\n19: \txorl\t%esi, %esi\n1b: \txorl\t%edx, %edx\n1d: \tjmp\t0x22 <M_EndGame+0x22>\n22: \tmovl\t(%rip), %esi  # 0x28 <M_EndGame+0x28>\n28: \txorl\t%edi, %edi\n2a: \tjmp\t0x2f <M_EndGame+0x2f>\n2f: \tmovl\t(%rip), %edi  # 0x35 <M_EndGame+0x35>\n35: \tmovq\t(%rip), %rsi  # 0x3c <M_EndGame+0x3c>\n3c: \tmovl\t$1, %edx\n41: \tjmp\t0x46 <M_EndGame+0x46>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ENDGAME ;\nint /*<<< orphan*/ * M_EndGameResponse ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  NETEND ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nscalar_t__ netgame ;\nint /*<<< orphan*/  sfx_oof ;\nint /*<<< orphan*/  usergame ;\n\nvoid M_EndGame(int choice)\n{\nchoice = 0;\nif (!usergame)\n{\nS_StartSound(NULL,sfx_oof);\nreturn;\n}\n\nif (netgame)\n{\nM_StartMessage(NETEND,NULL,false);\nreturn;\n}\n\nM_StartMessage(ENDGAME,M_EndGameResponse,true);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_EndGame_Brief ;\nint /*<<< orphan*/  M_EndGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Brief ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_Full ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame ;\nint /*<<< orphan*/  M_EndGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame_NoGame"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_AdvanceDemo",
    "input":"\n0000000000000000 <D_AdvanceDemo>:\n0: \tmovl\t$1, (%rip)    # 0xa <D_AdvanceDemo+0xa>\na: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint advancedemo ;\n\nvoid D_AdvanceDemo (void)\n{\nadvancedemo = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint demo_paused ;\n\nvoid D_AdvanceDemo(void)\n{\ndemo_paused = 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_FireCrackle",
    "input":"\n0000000000000000 <A_FireCrackle>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <A_FireCrackle+0xa>\na: \tcallq\t0xf <A_FireCrackle+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_FireCrackle+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Fire (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_flame ;\n\nvoid A_FireCrackle (mobj_t* actor)\n{\nS_StartSound(actor,sfx_flame);\nA_Fire(actor);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ARCSTATUS ;\ntypedef  int /*<<< orphan*/  ARCSTATUS_ARC ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FireCrackle_1 ;\nint /*<<< orphan*/  A_FireCrackle_2 ;\nint /*<<< orphan*/  A_FireCrackle_3 ;\nint /*<<< orphan*/  A_FireCrackle_4 ;\nint /*<<< orphan*/  A_FireCrackle_5 ;\nint /*<<< orphan*/  A_FireCrackle_6 ;\nint /*<<< orphan*/  A_FireCrackle_7 ;\nint /*<<< orphan*/  A_FireCrackle_8 ;\nint /*<<< orphan*/  A_FireCrackle_9 ;\nint /*<<< orphan*/  A_FireCrackle_10 ;\nint /*<<< orphan*/  A_FireCrackle_11 ;\nint /*<<< orphan*/  A_FireCrackle_12 ;\nint /*<<< orphan*/  A_FireCrackle_13 ;\nint /*<<< orphan*/  A_FireCrackle_14 ;\nint /*<<< orphan*/  A_FireCrackle_15 ;\nint /*<<< orphan*/  A_FireCrackle_16 ;\nint /*<<< orphan*/  A_FireCrackle_17 ;\nint /*<<< orphan*/  A_FireCrackle_18 ;\nint /*<<< orphan*/  A_FireCrackle_19 ;\nint /*<<< orphan*/  A_FireCrackle_20 ;\nint /*<<< orphan*/  A_FireCrackle_21 ;\nint /*<<< orphan*/  A_FireCrackle_22 ;\nint /*<<< orphan*/  A_FireCrackle_23 ;\nint /*<<< orphan*/  A_FireCrackle_24 ;\nint /*<<< orphan*/  A_FireCrackle_25 ;\nint /*<<< orphan*/  A_FireCrackle_26 ;\nint /*<<< orphan*/  A_FireCrackle_27 ;\nint /*<<< orphan*/  A_FireCrackle_28 ;\nint /*<<< orphan*/  A_FireCrackle_29 ;\nint /*<<< orphan*/  A_FireCrackle_30 ;\nint /*<<< orphan*/  A_FireCrackle_31 ;\nint /*<<< orphan*/  A_FireCrackle_32 ;\nint /*<<< orphan*/  A_FireCrackle_33 ;\nint /*<<< orphan*/  A_FireCrackle_34 ;\nint /*<<< orphan*/  A_FireCrackle_35 ;\nint /*<<< orphan*/  A_FireCrackle_36 ;\nint /*<<< orphan*/  A_FireCrackle_37 ;\nint /*<<< orphan*/  A_FireCrackle_38 ;\nint /*<<< orphan*/  A_FireCrackle_39 ;\nint /*<<< orphan*/  A_FireCrackle_40 ;\nint /*<<< orphan*/  A_FireCrackle_41 ;\nint /*<<< orphan*/  A_FireCrackle_42 ;\nint /*<<< orphan*/  A_FireCrackle_43 ;\nint /*<<< orphan*/  A_FireCrackle_44 ;\nint /*<<< orphan*/  A_FireCrackle_45 ;\nint /*<<< orphan*/  A_FireCrackle_46 ;\nint /*<<< orphan*/  A_FireCrackle_47 ;\nint /*<<< orphan*/  A_FireCrackle_48 ;\nint /*<<< orphan*/  A_FireCrackle_49 ;\nint /*<<< orphan*/  A_FireCrackle_50 ;\nint /*<<< orphan*/  A_FireCrackle_51 ;\nint /*<<< orphan*/  A_FireCrackle_52 ;\nint /*<<< orphan*/  A_FireCrackle_53 ;\nint /*<<< orphan*/  A_FireCrackle_54 ;\nint /*<<< orphan*/  A_FireCrackle_55 ;\nint /*<<< orphan*/  A_FireCrackle_56 ;\nint /*<<< orphan*/  A_FireCrackle_57 ;\nint /*<<< orphan*/  A_FireCrackle_58 ;\nint /*<<< orphan*/  A_FireCrackle_59 ;\nint /*<<< orphan*/  A_FireCrackle_60 ;\nint /*<<< orphan*/  A_FireCrackle_61 ;\nint /*<<< orphan*/  A_FireCrackle_62 ;\nint /*<<< orphan*/  A_FireCrackle_63 ;\nint /*<<< orphan*/  A_FireCrackle_64 ;\nint /*<<< orphan*/  A_FireCrackle_65 ;\nint /*<<< orphan*/  A_FireCrackle_66 ;\nint /*<<< orphan*/  A_FireCrackle_67 ;\nint /*<<< orphan*/  A_FireCrackle_68 ;\nint /*<<< orphan*/  A_FireCrackle_69 ;\nint /*<<< orphan*/  A_FireCrackle_70 ;\nint /*<<< orphan*/  A_FireCrackle_71 ;\nint /*<<< orphan*/  A_FireCrackle_72 ;\nint /*<<< orphan*/  A_FireCrackle_73 ;\nint /*<<< orphan*/  A_FireCrackle_74 ;\nint /*<<< orphan*/  A_FireCrackle_75 ;\nint /*<<< orphan*/  A_FireCrackle_76 ;\nint /*<<< orphan*/  A_FireCrackle_77 ;\nint /*<<< orphan*/  A_FireCrackle_78 ;\nint /*<<< orphan*/  A_FireCrackle_79 ;\nint /*<<< orphan*/  A_FireCrackle_80 ;\nint /*<<< orphan*/  A_FireCrackle_81 ;\nint /*<<< orphan*/  A_FireCrackle_82 ;\nint /*<<< orphan*/  A_FireCrackle_83 ;\nint /*<<< orphan*/  A_FireCrackle_84 ;\nint /*<<< orphan*/  A_FireCrackle_85 ;\nint /*<<< orphan*/  A_FireCrackle_86 ;\nint /*<<< orphan*/  A_FireCrackle_87 ;\nint /*<<< orphan*/  A_FireCrackle_88 ;\nint /*<<< orphan*/  A_FireCrackle_89 ;\nint /*<<< orphan*/  A_FireCrackle_90 ;\nint /*<<< orphan*/  A_FireCrackle_91 ;\nint /*<<< orphan*/  A_FireCrackle_92 ;\nint /*<<< orphan*/  A_FireCrackle_93 ;\nint /*<<< orphan*/  A_FireCrackle_94 ;\nint /*<<< orphan*/  A_FireCrackle_95 ;\nint /*<<< orphan*/  A_FireCrackle_96 ;\nint /*<<< orphan*/  A_FireCrackle_97 ;\nint /*<<< orphan*/  A_FireCrackle_98 ;\nint /*<<< orphan*/  A_FireCrackle_99 ;\nint /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_switch.c_P_StartButton",
    "input":"\n0000000000000000 <P_StartButton>:\n0: \tmovl\t(%rip), %r8d  # 0x7 <P_StartButton+0x7>\n7: \ttestl\t%r8d, %r8d\na: \tjle\t0x60 <P_StartButton+0x60>\nc: \tmovq\t(%rip), %rax  # 0x13 <P_StartButton+0x13>\n13: \txorl\t%r9d, %r9d\n16: \tjmp\t0x2d <P_StartButton+0x2d>\n18: \tnopl\t(%rax,%rax)\n20: \taddq\t$1, %r9\n24: \taddq\t$32, %rax\n28: \tcmpq\t%r8, %r9\n2b: \tjae\t0x39 <P_StartButton+0x39>\n2d: \tcmpl\t$0, (%rax)\n30: \tje\t0x20 <P_StartButton+0x20>\n32: \tcmpq\t%rdi, 24(%rax)\n36: \tjne\t0x20 <P_StartButton+0x20>\n38: \tretq\n39: \ttestl\t%r8d, %r8d\n3c: \tjle\t0x60 <P_StartButton+0x60>\n3e: \tmovq\t(%rip), %r9   # 0x45 <P_StartButton+0x45>\n45: \tshlq\t$5, %r8\n49: \txorl\t%eax, %eax\n4b: \tnopl\t(%rax,%rax)\n50: \tcmpl\t$0, (%r9,%rax)\n55: \tje\t0x6a <P_StartButton+0x6a>\n57: \taddq\t$32, %rax\n5b: \tcmpq\t%rax, %r8\n5e: \tjne\t0x50 <P_StartButton+0x50>\n60: \tmovl\t$0, %edi\n65: \tjmp\t0x6a <P_StartButton+0x6a>\n6a: \tmovq\t%rdi, 24(%r9,%rax)\n6f: \tmovq\t(%rip), %r8   # 0x76 <P_StartButton+0x76>\n76: \tmovl\t%esi, 16(%r8,%rax)\n7b: \tmovl\t%edx, 4(%r8,%rax)\n80: \tmovl\t%ecx, (%r8,%rax)\n84: \tmovq\t(%rdi), %rcx\n87: \tmovq\t%rcx, 8(%r8,%rax)\n8c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\nstruct TYPE_6__ {TYPE_1__* frontsector; } ;\ntypedef  TYPE_2__ line_t ;\ntypedef  int /*<<< orphan*/  bwhere_e ;\nstruct TYPE_7__ {int btimer; int btexture; int /*<<< orphan*/ * soundorg; int /*<<< orphan*/  where; TYPE_2__* line; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  soundorg; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint MAXBUTTONS ;\nTYPE_3__* buttonlist ;\n\nvoid\nP_StartButton\n( line_t*\tline,\nbwhere_e\tw,\nint\t\ttexture,\nint\t\ttime )\n{\nint\t\ti;\n\n// See if button is already pressed\nfor (i = 0;i < MAXBUTTONS;i++)\n{\nif (buttonlist[i].btimer\n&& buttonlist[i].line == line)\n{\n\nreturn;\n}\n}\n\n\n\nfor (i = 0;i < MAXBUTTONS;i++)\n{\nif (!buttonlist[i].btimer)\n{\nbuttonlist[i].line = line;\nbuttonlist[i].where = w;\nbuttonlist[i].btexture = texture;\nbuttonlist[i].btimer = time;\nbuttonlist[i].soundorg = (mobj_t *)&line->frontsector->soundorg;\nreturn;\n}\n}\n\nI_Error(\"P_StartButton: no button slots left!\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  w; int /*<<< orphan*/  h; scalar_t__ id; } ;\ntypedef  TYPE_1__ P_Button ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_Error (char*) ;\nint P_ButtonCount ;\nTYPE_1__* P_Buttons ;\nint /*<<< orphan*/  P_Buttons_X ;\nint /*<<< orphan*/  P_Buttons_Y ;\n\nvoid P_StartButton(int id, int x, int y, int w, int h)\n{\nint i;\n\nfor (i = 0; i < P_ButtonCount; i++)\n{\nif (P_Buttons[i].id == 0)\n{\nP_Buttons[i].id = id;\nP_Buttons[i].x = x + P_Buttons_X;\nP_Buttons[i].y = y + P_Buttons_Y;\nP_Buttons[i].w = w;\nP_Buttons[i].h = h;\nreturn;\n}\n}\n\nP_Error(\"Too many buttons\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_slamBackground",
    "input":"\n0000000000000000 <WI_slamBackground>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <WI_slamBackground+0x8>\n8: \tmovl\t(%rax), %edi\na: \tmovl\t4(%rax), %esi\nd: \tmovl\t(%rip), %edx  # 0x13 <WI_slamBackground+0x13>\n13: \timull\t(%rip), %edx  # 0x1a <WI_slamBackground+0x1a>\n1a: \tcallq\t0x1f <WI_slamBackground+0x1f>\n1f: \tmovl\t(%rip), %edx  # 0x25 <WI_slamBackground+0x25>\n25: \tmovl\t(%rip), %ecx  # 0x2b <WI_slamBackground+0x2b>\n2b: \txorl\t%edi, %edi\n2d: \txorl\t%esi, %esi\n2f: \tpopq\t%rax\n30: \tjmp\t0x35 <WI_slamBackground+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/  V_MarkRect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/ * screens ;\n\nvoid WI_slamBackground(void)\n{\nmemcpy(screens[0], screens[1], SCREENWIDTH * SCREENHEIGHT);\nV_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  hwnd; int /*<<< orphan*/  hdc; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  GetDC (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ReleaseDC (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SetBkColor (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SetTextColor (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__ wi ;\nint wi_bg_color ;\nint wi_fg_color ;\n\nvoid WI_slamBackground(void)\n{\nSetBkColor(wi.hdc, wi_bg_color * wi_fg_color);\nSetTextColor(wi.hdc, wi_fg_color);\nReleaseDC(wi.hwnd, GetDC(wi.hwnd));\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_minOutWindowScale",
    "input":"\n0000000000000000 <AM_minOutWindowScale>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <AM_minOutWindowScale+0x7>\n7: \tmovl\t%esi, (%rip)  # 0xd <AM_minOutWindowScale+0xd>\nd: \tmovl\t(%rip), %edi  # 0x13 <AM_minOutWindowScale+0x13>\n13: \tcallq\t0x18 <AM_minOutWindowScale+0x18>\n18: \tmovl\t%eax, (%rip)  # 0x1e <AM_minOutWindowScale+0x1e>\n1e: \txorl\t%eax, %eax\n20: \tpopq\t%rcx\n21: \tjmp\t0x26 <AM_minOutWindowScale+0x26>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_activateNewScale () ;\nint /*<<< orphan*/  FRACUNIT ;\nint /*<<< orphan*/  FixedDiv (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  min_scale_mtof ;\nint /*<<< orphan*/  scale_ftom ;\nint /*<<< orphan*/  scale_mtof ;\n\nvoid AM_minOutWindowScale(void)\n{\nscale_mtof = min_scale_mtof;\nscale_ftom = FixedDiv(FRACUNIT, scale_mtof);\nAM_activateNewScale();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_outWindowScale ;\nint /*<<< orphan*/  AM_outWindowScale_min ;\nint /*<<< orphan*/  AM_outWindowScale_max ;\nint /*<<< orphan*/  AM_outWindowScale_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_min ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_max ;\nint /*<<< orphan*/  AM_outWindowScale_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step_step ;\nint /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_Ticker",
    "input":"\n0000000000000000 <WI_Ticker>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %eax  # 0x7 <WI_Ticker+0x7>\n7: \tleal\t1(%rax), %ecx\na: \tmovl\t%ecx, (%rip)  # 0x10 <WI_Ticker+0x10>\n10: \ttestl\t%eax, %eax\n12: \tjne\t0x3c <WI_Ticker+0x3c>\n14: \tmovq\t(%rip), %rax  # 0x1b <WI_Ticker+0x1b>\n1b: \tcmpq\t(%rip), %rax  # 0x22 <WI_Ticker+0x22>\n22: \tmovl\t$0, %eax\n27: \tmovl\t$0, %ecx\n2c: \tcmoveq\t%rax, %rcx\n30: \tmovl\t(%rcx), %edi\n32: \tmovl\t$1, %esi\n37: \tcallq\t0x3c <WI_Ticker+0x3c>\n3c: \txorl\t%eax, %eax\n3e: \tcallq\t0x43 <WI_Ticker+0x43>\n43: \tmovl\t(%rip), %eax  # 0x49 <WI_Ticker+0x49>\n49: \tcmpl\t$130, %eax\n4e: \tje\t0x6f <WI_Ticker+0x6f>\n50: \tcmpl\t$129, %eax\n55: \tje\t0x77 <WI_Ticker+0x77>\n57: \tcmpl\t$128, %eax\n5c: \tjne\t0x7f <WI_Ticker+0x7f>\n5e: \tcmpl\t$0, (%rip)    # 0x65 <WI_Ticker+0x65>\n65: \tje\t0x81 <WI_Ticker+0x81>\n67: \txorl\t%eax, %eax\n69: \tpopq\t%rcx\n6a: \tjmp\t0x6f <WI_Ticker+0x6f>\n6f: \txorl\t%eax, %eax\n71: \tpopq\t%rcx\n72: \tjmp\t0x77 <WI_Ticker+0x77>\n77: \txorl\t%eax, %eax\n79: \tpopq\t%rcx\n7a: \tjmp\t0x7f <WI_Ticker+0x7f>\n7f: \tpopq\t%rax\n80: \tretq\n81: \tcmpl\t$0, (%rip)    # 0x88 <WI_Ticker+0x88>\n88: \tje\t0x92 <WI_Ticker+0x92>\n8a: \txorl\t%eax, %eax\n8c: \tpopq\t%rcx\n8d: \tjmp\t0x92 <WI_Ticker+0x92>\n92: \txorl\t%eax, %eax\n94: \tpopq\t%rcx\n95: \tjmp\t0x9a <WI_Ticker+0x9a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n#define  NoState 130\nint /*<<< orphan*/  S_ChangeMusic (int /*<<< orphan*/ ,int) ;\n#define  ShowNextLoc 129\n#define  StatCount 128\nint /*<<< orphan*/  WI_checkForAccelerate () ;\nint /*<<< orphan*/  WI_updateDeathmatchStats () ;\nint /*<<< orphan*/  WI_updateNetgameStats () ;\nint /*<<< orphan*/  WI_updateNoState () ;\nint /*<<< orphan*/  WI_updateShowNextLoc () ;\nint /*<<< orphan*/  WI_updateStats () ;\nint bcnt ;\nscalar_t__ commercial ;\nint /*<<< orphan*/  deathmatch ;\nscalar_t__ gamemode ;\nint /*<<< orphan*/  mus_dm2int ;\nint /*<<< orphan*/  mus_inter ;\nint /*<<< orphan*/  netgame ;\nint state ;\n\nvoid WI_Ticker(void)\n{\n// counter for general background animation\nbcnt++;\n\nif (bcnt == 1)\n{\n// intermission music\nif ( gamemode == commercial )\nS_ChangeMusic(mus_dm2int, true);\nelse\nS_ChangeMusic(mus_inter, true);\n}\n\nWI_checkForAccelerate();\n\nswitch (state)\n{\ncase StatCount:\nif (deathmatch) WI_updateDeathmatchStats();\nelse if (netgame) WI_updateNetgameStats();\nelse WI_updateStats();\nbreak;\n\ncase ShowNextLoc:\nWI_updateShowNextLoc();\nbreak;\n\ncase NoState:\nWI_updateNoState();\nbreak;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_Check () ;\nint /*<<< orphan*/  WI_Draw () ;\nint /*<<< orphan*/  WI_DrawMenu () ;\nint /*<<< orphan*/  WI_DrawStatus () ;\nint /*<<< orphan*/  WI_DrawTitle () ;\nint /*<<< orphan*/  WI_DrawWad () ;\nint /*<<< orphan*/  WI_Menu () ;\nint /*<<< orphan*/  WI_Status () ;\nint /*<<< orphan*/  WI_Title () ;\nint /*<<< orphan*/  WI_Wad () ;\nint /*<<< orphan*/  WI_WadName ;\nint /*<<< orphan*/  WI_WadName2 ;\nint /*<<< orphan*/  WI_WadName3 ;\nint /*<<< orphan*/  WI_WadName4 ;\nint /*<<< orphan*/  WI_WadName5 ;\nint /*<<< orphan*/  WI_WadName6 ;\nint /*<<< orphan*/  WI_WadName7 ;\nint /*<<< orphan*/  WI_WadName8 ;\nint /*<<< orphan*/  WI_WadName9 ;\nint /*<<< orphan*/  WI_WadNameA ;\nint /*<<< orphan*/  WI_WadNameB ;\nint /*<<< orphan*/  WI_WadNameC ;\nint /*<<< orphan*/  WI_WadNameD ;\nint /*<<< orphan*/  WI_WadNameE ;\nint /*<<< orphan*/  WI_WadNameF ;\nint /*<<< orphan*/  WI_WadNameG ;\nint /*<<< orphan*/  WI_WadNameH ;\nint /*<<< orphan*/  WI_WadNameI ;\nint /*<<< orphan*/  WI_WadNameJ ;\nint /*<<< orphan*/  WI_WadNameK ;\nint /*<<< orphan*/  WI_WadNameL ;\nint /*<<< orphan*/  WI_WadNameM ;\nint /*<<< orphan*/  WI_WadNameN ;\nint /*<<< orphan*/  WI_WadNameO ;\nint /*<<< orphan*/  WI_WadNameP ;\nint /*<<< orphan*/  WI_WadNameQ ;\nint /*<<< orphan*/  WI_WadNameR ;\nint /*<<< orphan*/  WI_WadNameS ;\nint /*<<< orphan*/  WI_WadNameT ;\nint /*<<< orphan*/  WI_WadNameU ;\nint /*<<< orphan*/  WI_WadNameV ;\nint /*<<< orphan*/  WI_WadNameW ;\nint /*<<< orphan*/  WI_WadNameX ;\nint /*<<< orphan*/  WI_WadNameY ;\nint /*<<< orphan*/  WI_WadNameZ ;\nint /*<<< orphan*/  WI_WadName_ ;\nint /*<<< orphan*/  WI_WadName_0 ;\nint /*<<< orphan*/  WI_WadName_1 ;\nint /*<<< orphan*/  WI_WadName_2 ;\nint /*<<< orphan*/  WI_WadName_3 ;\nint /*<<< orphan*/  WI_WadName_4 ;\nint /*<<< orphan*/  WI_WadName_5 ;\nint /*<<< orphan*/  WI_WadName_6 ;\nint /*<<< orphan*/  WI_WadName_7 ;\nint /*<<< orphan*/  WI_WadName_8 ;\nint /*<<< orphan*/  WI_WadName_9 ;\nint /*<<< orphan*/  WI_WadName_A ;\nint /*<<< orphan*/  WI_WadName_B ;\nint /*<<< orphan*/  WI_WadName_C ;\nint /*<<< orphan*/  WI_WadName_D ;\nint /*<<< orphan*/  WI_WadName_E ;\nint /*<<< orphan*/  WI_WadName_F ;\nint /*<<< orphan*/  WI_WadName_G ;\nint /*<<< orphan*/  WI_WadName_H ;\nint /*<<< orphan*/  WI_WadName_I ;\nint /*<<< orphan*/  WI_WadName_J ;\nint /*<<< orphan*/  WI_WadName_K ;\nint /*<<< orphan*/  WI_WadName_L ;\nint /*<<< orphan*/  WI_WadName_M ;\nint /*<<< orphan*/  WI_WadName_N ;\nint /*<<< orphan*/  WI_WadName_O ;\nint /*<<< orphan*/  WI_WadName_P ;\nint /*<<< orphan*/  WI_WadName_Q ;\nint /*<<< orphan*/  WI_WadName_R ;\nint /*<<< orphan*/  WI_WadName_S ;\nint /*<<< orphan*/  WI_WadName_T ;\nint /*<<< orphan*/  WI_WadName_U ;\nint /*<<< orphan*/  WI_WadName_V ;\nint /*<<< orphan*/  WI_WadName_W ;\nint /*<<< orphan*/  WI_WadName_X ;\nint /*<<< orphan*/  WI_WadName_Y ;\nint /*<<< orphan*/  WI_WadName_Z ;\nint /*<<< orphan*/  WI_WadName_a ;\nint /*<<< orphan*/  WI_WadName_b ;\nint /*<<< orphan*/  WI_WadName_c ;\nint /*<<< orphan*/  WI_WadName_d ;\nint /*<<< orphan*/  WI_WadName_e ;\nint /*<<< orphan*/  WI_WadName_f ;\nint /*<<< orphan*/  WI_WadName_g ;\nint /*<<< orphan*/  WI_WadName_h ;\nint /*<<< orphan*/  WI_WadName_i ;\nint /*<<< orphan*/  WI_WadName_j ;\nint /*<<< orphan*/  WI_WadName_k ;\nint /*<<< orphan*/  WI_WadName_l ;\nint /*<<< orphan*/  WI_WadName_m ;\nint /*<<< orphan*/  WI_WadName_n ;\nint /*<<< orphan*/  WI_WadName_o ;\nint /*<<< orphan*/  WI_WadName_p ;\nint /*<<< orphan*/  WI_WadName_q ;\nint /*<<< orphan*/  WI_WadName_r ;\nint /*<<< orphan*/  WI_WadName_s ;\nint /*<<< orphan*/  WI_WadName_t ;\nint /*<<< orphan*/  WI_WadName_u ;\nint /*<<< orphan*/  WI_WadName_v ;\nint /*<<< orphan*/  WI_WadName_w ;\nint /*<<< orphan*/  WI_WadName_x ;\nint /*<<< orphan*/  WI_WadName_y ;\nint /*<<< orphan*/  WI_WadName_z ;\nint /*<<< orphan*/  WI_WadName_z_ ;\nint /*<<< orphan*/  WI_WadName_z_0 ;\nint /*<<< orphan*/  WI"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_initStats",
    "input":"\n0000000000000000 <WI_initStats>:\n0: \tmovl\t(%rip), %eax  # 0x6 <WI_initStats+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <WI_initStats+0xc>\nc: \tmovq\t$0, (%rip)    # 0x17 <WI_initStats+0x17>\n17: \tmovl\t$1, (%rip)    # 0x21 <WI_initStats+0x21>\n21: \tmovq\t(%rip), %rax  # 0x28 <WI_initStats+0x28>\n28: \tmovl\t$4294967295, (%rax)# imm = 0xFFFFFFFF\n2e: \tmovq\t(%rip), %rax  # 0x35 <WI_initStats+0x35>\n35: \tmovl\t$4294967295, (%rax)# imm = 0xFFFFFFFF\n3b: \tmovq\t(%rip), %rax  # 0x42 <WI_initStats+0x42>\n42: \tmovl\t$4294967295, (%rax)# imm = 0xFFFFFFFF\n48: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0x52 <WI_initStats+0x52>\n52: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0x5c <WI_initStats+0x5c>\n5c: \tmovl\t(%rip), %eax  # 0x62 <WI_initStats+0x62>\n62: \tmovl\t%eax, (%rip)  # 0x68 <WI_initStats+0x68>\n68: \txorl\t%eax, %eax\n6a: \tjmp\t0x6f <WI_initStats+0x6f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  StatCount ;\nint /*<<< orphan*/  TICRATE ;\nint /*<<< orphan*/  WI_initAnimatedBack () ;\nscalar_t__ acceleratestage ;\nint* cnt_items ;\nint* cnt_kills ;\nint cnt_par ;\nint /*<<< orphan*/  cnt_pause ;\nint* cnt_secret ;\nint cnt_time ;\nint sp_state ;\nint /*<<< orphan*/  state ;\n\nvoid WI_initStats(void)\n{\nstate = StatCount;\nacceleratestage = 0;\nsp_state = 1;\ncnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;\ncnt_time = cnt_par = -1;\ncnt_pause = TICRATE;\n\nWI_initAnimatedBack();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  dwLastError; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  WI_dwLastError ;\nint /*<<< orphan*/  WI_dwLastErrorTime ;\nint /*<<< orphan*/  WI_dwLastErrorTime2 ;\nint /*<<< orphan*/  WI_dwLastErrorTime3 ;\nint /*<<< orphan*/  WI_dwLastErrorTime4 ;\nint /*<<< orphan*/  WI_dwLastErrorTime5 ;\nint /*<<< orphan*/  WI_dwLastErrorTime6 ;\nint /*<<< orphan*/  WI_dwLastErrorTime7 ;\nint /*<<< orphan*/  WI_dwLastErrorTime8 ;\nint /*<<< orphan*/  WI_dwLastErrorTime9 ;\nint /*<<< orphan*/  WI_dwLastErrorTime10 ;\nint /*<<< orphan*/  WI_dwLastErrorTime11 ;\nint /*<<< orphan*/  WI_dwLastErrorTime12 ;\nint /*<<< orphan*/  WI_dwLastErrorTime13 ;\nint /*<<< orphan*/  WI_dwLastErrorTime14 ;\nint /*<<< orphan*/  WI_dwLastErrorTime15 ;\nint /*<<< orphan*/  WI_dwLastErrorTime16 ;\nint /*<<< orphan*/  WI_dwLastErrorTime17 ;\nint /*<<< orphan*/  WI_dwLastErrorTime18 ;\nint /*<<< orphan*/  WI_dwLastErrorTime19 ;\nint /*<<< orphan*/  WI_dwLastErrorTime20 ;\nint /*<<< orphan*/  WI_dwLastErrorTime21 ;\nint /*<<< orphan*/  WI_dwLastErrorTime22 ;\nint /*<<< orphan*/  WI_dwLastErrorTime23 ;\nint /*<<< orphan*/  WI_dwLastErrorTime24 ;\nint /*<<< orphan*/  WI_dwLastErrorTime25 ;\nint /*<<< orphan*/  WI_dwLastErrorTime26 ;\nint /*<<< orphan*/  WI_dwLastErrorTime27 ;\nint /*<<< orphan*/  WI_dwLastErrorTime28 ;\nint /*<<< orphan*/  WI_dwLastErrorTime29 ;\nint /*<<< orphan*/  WI_dwLastErrorTime30 ;\nint /*<<< orphan*/  WI_dwLastErrorTime31 ;\nint /*<<< orphan*/  WI_dwLastErrorTime32 ;\nint /*<<< orphan*/  WI_dwLastErrorTime33 ;\nint /*<<< orphan*/  WI_dwLastErrorTime34 ;\nint /*<<< orphan*/  WI_dwLastErrorTime35 ;\nint /*<<< orphan*/  WI_dwLastErrorTime36 ;\nint /*<<< orphan*/  WI_dwLastErrorTime37 ;\nint /*<<< orphan*/  WI_dwLastErrorTime38 ;\nint /*<<< orphan*/  WI_dwLastErrorTime39 ;\nint /*<<< orphan*/  WI_dwLastErrorTime40 ;\nint /*<<< orphan*/  WI_dwLastErrorTime41 ;\nint /*<<< orphan*/  WI_dwLastErrorTime42 ;\nint /*<<< orphan*/  WI_dwLastErrorTime43 ;\nint /*<<< orphan*/  WI_dwLastErrorTime44 ;\nint /*<<< orphan*/  WI_dwLastErrorTime45 ;\nint /*<<< orphan*/  WI_dwLastErrorTime46 ;\nint /*<<< orphan*/  WI_dwLastErrorTime47 ;\nint /*<<< orphan*/  WI_dwLastErrorTime48 ;\nint /*<<< orphan*/  WI_dwLastErrorTime49 ;\nint /*<<< orphan*/  WI_dwLastErrorTime50 ;\nint /*<<< orphan*/  WI_dwLastErrorTime51 ;\nint /*<<< orphan*/  WI_dwLastErrorTime52 ;\nint /*<<< orphan*/  WI_dwLastErrorTime53 ;\nint /*<<< orphan*/  WI_dwLastErrorTime54 ;\nint /*<<< orphan*/  WI_dwLastErrorTime55 ;\nint /*<<< orphan*/  WI_dwLastErrorTime56 ;\nint /*<<< orphan*/  WI_dwLastErrorTime57 ;\nint /*<<< orphan*/  WI_dwLastErrorTime58 ;\nint /*<<< orphan*/  WI_dwLastErrorTime59 ;\nint /*<<< orphan*/  WI_dwLastErrorTime60 ;\nint /*<<< orphan*/  WI_dwLastErrorTime61 ;\nint /*<<< orphan*/  WI_dwLastErrorTime62 ;\nint /*<<< orphan*/  WI_dwLastErrorTime63 ;\nint /*<<< orphan*/  WI_dwLastErrorTime64 ;\nint /*<<< orphan*/  WI_dwLastErrorTime65 ;\nint /*<<< orphan*/  WI_dwLastErrorTime66 ;\nint /*<<< orphan*/  WI_dwLastErrorTime67 ;\nint /*<<< orphan*/  WI_dwLastErrorTime68 ;\nint /*<<< orphan*/  WI_dwLastErrorTime69 ;\nint /*<<< orphan*/  WI_dwLastErrorTime70 ;\nint /*<<< orphan*/  WI_dwLastErrorTime71 ;\nint /*<<< orphan*/  WI_dwLastErrorTime72 ;\nint /*<<< orphan*/  WI_dwLastErrorTime73 ;\nint /*<<< orphan*/  WI_dwLastErrorTime74 ;\nint /*<<< orphan*/  WI_dwLastErrorTime75 ;\nint /*<<< orphan*/  WI_dwLastErrorTime76 ;\nint /*<<< orphan*/  WI_dwLastErrorTime77 ;\nint /*<<< orphan*/  WI_dwLastErrorTime78 ;\nint /*<<< orphan*/  WI_dwLastErrorTime79 ;\nint /*<<< orphan*/  WI_dwLastErrorTime80 ;\nint /*<<< orphan*/  WI_dwLastErrorTime81 ;\nint /*<<< orphan*/  WI_dwLastErrorTime82 ;\nint /*<<< orphan*/  WI_dwLastErrorTime83 ;\nint /*<<< orphan*/  WI_dwLastErrorTime84 ;\nint /*<<< orphan*/  WI_dwLastErrorTime85 ;\nint /*<<< orphan*/  WI_dwLastErrorTime86 ;\nint /*<<< orphan*/  WI_dwLastErrorTime87 ;\nint /*<<< orphan*/  WI_dwLastErrorTime88 ;\nint /*<<< orphan*/  WI_dwLastErrorTime89 ;\nint /*<<< orphan*/  WI_dwLastErrorTime90 ;\nint /*<<< orphan*/  WI_dwLastErrorTime91 ;\nint /*<<< orphan*/  WI_dwLastErrorTime92 ;\nint /*<<< orphan*/  WI_dwLastErrorTime93 ;\nint /*<<< orphan*/  WI_dwLastErrorTime94 ;\nint /*<<< orphan*/  WI_dwLastErrorTime95 ;\nint /*<<< orphan*/  WI_dwLastErrorTime96 ;\nint /*<<< orphan*/  WI_dwLastErrorTime97 ;\nint /*<<< orphan*/  WI_dwLastErrorTime98 ;\nint /*<<< orphan*/  WI_dwLast"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_LoadShotgun2",
    "input":"\n0000000000000000 <A_LoadShotgun2>:\n0: \tmovl\t(%rdi), %edi\n2: \tmovl\t(%rip), %esi  # 0x8 <A_LoadShotgun2+0x8>\n8: \tjmp\t0xd <A_LoadShotgun2+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_3__ {int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_dbload ;\n\nvoid\nA_LoadShotgun2\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nS_StartSound (player->mo, sfx_dbload);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  anim; } ;\ntypedef  TYPE_1__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_LoadShotgun1 ;\nint /*<<< orphan*/  AnimateActors (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_LoadShotgun2(Actor *actor)\n{\nAnimateActors(actor->anim, A_LoadShotgun1);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawNoState",
    "input":"\n0000000000000000 <WI_drawNoState>:\n0: \tmovl\t$1, (%rip)    # 0xa <WI_drawNoState+0xa>\na: \txorl\t%eax, %eax\nc: \tjmp\t0x11 <WI_drawNoState+0x11>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawShowNextLoc () ;\nint snl_pointeron ;\n\nvoid WI_drawNoState(void)\n{\nsnl_pointeron = true;\nWI_drawShowNextLoc();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawNoState_ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WI_noState ;\n\nvoid WI_drawNoState(void)\n{\nWI_noState = 1;\nWI_drawNoState_(0);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_PointOnDivlineSide",
    "input":"\n0000000000000000 <P_PointOnDivlineSide>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %rbx\n8: \tmovq\t%rsi, %r14\nb: \tmovq\t%rdi, %rsi\ne: \tmovq\t(%rdx), %rax\n11: \ttestq\t%rax, %rax\n14: \tje\t0x66 <P_PointOnDivlineSide+0x66>\n16: \tmovq\t16(%rbx), %rdi\n1a: \ttestq\t%rdi, %rdi\n1d: \tje\t0x78 <P_PointOnDivlineSide+0x78>\n1f: \tsubq\t8(%rbx), %rsi\n23: \tsubq\t24(%rbx), %r14\n27: \tmovq\t%rsi, %rcx\n2a: \txorq\t%rdi, %rcx\n2d: \txorl\t%ecx, %eax\n2f: \tmovl\t%r14d, %edx\n32: \txorl\t%eax, %edx\n34: \tjs\t0x94 <P_PointOnDivlineSide+0x94>\n36: \tsarq\t$8, %rdi\n3a: \tshrq\t$8, %rsi\n3e: \tcallq\t0x43 <P_PointOnDivlineSide+0x43>\n43: \tmovq\t%rax, %r15\n46: \tsarq\t$8, %r14\n4a: \tmovq\t(%rbx), %rsi\n4d: \tshrq\t$8, %rsi\n51: \tmovq\t%r14, %rdi\n54: \tcallq\t0x59 <P_PointOnDivlineSide+0x59>\n59: \tmovq\t%rax, %rcx\n5c: \txorl\t%eax, %eax\n5e: \tcmpq\t%r15, %rcx\n61: \tsetge\t%al\n64: \tjmp\t0x9f <P_PointOnDivlineSide+0x9f>\n66: \tmovq\t16(%rbx), %rcx\n6a: \tcmpq\t%rsi, 8(%rbx)\n6e: \tjge\t0x8a <P_PointOnDivlineSide+0x8a>\n70: \tshrq\t$63, %rcx\n74: \tmovl\t%ecx, %eax\n76: \tjmp\t0x9f <P_PointOnDivlineSide+0x9f>\n78: \tcmpq\t%r14, 24(%rbx)\n7c: \tjge\t0x9b <P_PointOnDivlineSide+0x9b>\n7e: \txorl\t%ecx, %ecx\n80: \ttestq\t%rax, %rax\n83: \tsetg\t%cl\n86: \tmovl\t%ecx, %eax\n88: \tjmp\t0x9f <P_PointOnDivlineSide+0x9f>\n8a: \txorl\t%eax, %eax\n8c: \ttestq\t%rcx, %rcx\n8f: \tsetg\t%al\n92: \tjmp\t0x9f <P_PointOnDivlineSide+0x9f>\n94: \tshrl\t$31, %ecx\n97: \tmovl\t%ecx, %eax\n99: \tjmp\t0x9f <P_PointOnDivlineSide+0x9f>\n9b: \tshrq\t$63, %rax\n9f: \tpopq\t%rbx\na0: \tpopq\t%r14\na2: \tpopq\t%r15\na4: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_3__ {scalar_t__ dx; scalar_t__ x; scalar_t__ dy; scalar_t__ y; } ;\ntypedef  TYPE_1__ divline_t ;\n\n/* Variables and functions */\nscalar_t__ FixedMul (scalar_t__,int) ;\n\nint\nP_PointOnDivlineSide\n( fixed_t\tx,\nfixed_t\ty,\ndivline_t*\tline )\n{\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\n\nif (!line->dx)\n{\nif (x <= line->x)\nreturn line->dy > 0;\n\nreturn line->dy < 0;\n}\nif (!line->dy)\n{\nif (y <= line->y)\nreturn line->dx < 0;\n\nreturn line->dx > 0;\n}\n\ndx = (x - line->x);\ndy = (y - line->y);\n\n// try to quickly decide by looking at sign bits\nif ( (line->dy ^ line->dx ^ dx ^ dy)&0x80000000 )\n{\nif ( (line->dy ^ dx) & 0x80000000 )\nreturn 1;\t\t// (left is negative)\nreturn 0;\n}\n\nleft = FixedMul ( line->dy>>8, dx>>8 );\nright = FixedMul ( dy>>8 , line->dx>>8 );\n\nif (right < left)\nreturn 0;\t\t// front side\nreturn 1;\t\t\t// back side\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; scalar_t__ x1; scalar_t__ y1; scalar_t__ x2; scalar_t__ y2; } ;\ntypedef  TYPE_1__ P_Divline ;\ntypedef  scalar_t__ P_Point ;\n\n/* Variables and functions */\nscalar_t__ P_PointOnLineSide (scalar_t__,scalar_t__,scalar_t__,scalar_t__) ;\n\nint P_PointOnDivlineSide(P_Point p, P_Point q, P_Divline *d)\n{\nif (d->x)\n{\nif (d->y)\n{\nif (p.x >= d->x1 && p.x <= d->x2)\n{\nif (p.y >= d->y1 && p.y <= d->y2)\n{\nreturn P_PointOnLineSide(p.x - d->x1, p.y - d->y1, d->x2 - d->x1, d->y2 - d->y1);\n}\nelse\n{\nreturn (p.y < d->y1) ? 1 : 0;\n}\n}\nelse\n{\nif (p.x >= d->x1 && p.x <= d->x2)\n{\nreturn (p.y < d->y1) ? 1 : 0;\n}\nelse\n{\nreturn (p.x < d->x1) ? 1 : 0;\n}\n}\n}\nelse\n{\nif (p.x >= d->x1 && p.x <= d->x2)\n{\nif (p.y >= d->y1 && p.y <= d->y2)\n{\nreturn P_PointOnLineSide(p.y - d->y1, p.x - d->x1, d->y2 - d->y1, d->x2 - d->x1);\n}\nelse\n{\nreturn (p.y < d->y1) ? 1 : 0;\n}\n}\nelse\n{\nreturn (p.x < d->x1) ? 1 : 0;\n}\n}\n}\n\n</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_eraseLineFromIText",
    "input":"\n0000000000000000 <HUlib_eraseLineFromIText>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rdi), %rax\n7: \tcmpq\t8(%rdi), %rax\nb: \tje\t0x31 <HUlib_eraseLineFromIText+0x31>\nd: \tmovq\t%rdi, %rbx\n10: \tleaq\t8(%rdi), %r14\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tmovq\t%r14, %rdi\n23: \tcallq\t0x28 <HUlib_eraseLineFromIText+0x28>\n28: \tmovq\t(%rbx), %rax\n2b: \tcmpq\t8(%rbx), %rax\n2f: \tjne\t0x20 <HUlib_eraseLineFromIText+0x20>\n31: \taddq\t$8, %rsp\n35: \tpopq\t%rbx\n36: \tpopq\t%r14\n38: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ len; } ;\nstruct TYPE_4__ {scalar_t__ lm; TYPE_3__ l; } ;\ntypedef  TYPE_1__ hu_itext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_delCharFromTextLine (TYPE_3__*) ;\n\nvoid HUlib_eraseLineFromIText(hu_itext_t* it)\n{\nwhile (it->lm != it->l.len)\nHUlib_delCharFromTextLine(&it->l);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ cursor; scalar_t__ end; } ;\ntypedef  TYPE_1__ HUiText ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_eraseChar (TYPE_1__*) ;\n\nvoid HUlib_eraseLineFromIText(HUiText *text)\n{\nwhile (text->cursor != text->end)\n{\nHU_eraseChar(text);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_DeferedInitNew",
    "input":"\n0000000000000000 <G_DeferedInitNew>:\n0: \tmovl\t%edi, (%rip)  # 0x6 <G_DeferedInitNew+0x6>\n6: \tmovl\t%esi, (%rip)  # 0xc <G_DeferedInitNew+0xc>\nc: \tmovl\t%edx, (%rip)  # 0x12 <G_DeferedInitNew+0x12>\n12: \tmovl\t(%rip), %eax  # 0x18 <G_DeferedInitNew+0x18>\n18: \tmovl\t%eax, (%rip)  # 0x1e <G_DeferedInitNew+0x1e>\n1e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  skill_t ;\n\n/* Variables and functions */\nint d_episode ;\nint d_map ;\nint /*<<< orphan*/  d_skill ;\nint /*<<< orphan*/  ga_newgame ;\nint /*<<< orphan*/  gameaction ;\n\nvoid\nG_DeferedInitNew\n( skill_t\tskill,\nint\t\tepisode,\nint\t\tmap)\n{\nd_skill = skill;\nd_episode = episode;\nd_map = map;\ngameaction = ga_newgame;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  PVOID ;\ntypedef  int /*<<< orphan*/  PG_DEFFERED_INIT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_DeferedInit ;\nint /*<<< orphan*/  G_DeferedInitCount ;\nint /*<<< orphan*/  G_DeferedInitList ;\nint /*<<< orphan*/  G_DeferedInitListCount ;\nint /*<<< orphan*/  G_DeferedInitListHead ;\n\nvoid G_DeferedInitNew(PG_DEFFERED_INIT DeferedInit, PVOID Object, ULONG ObjectSize)\n{\nG_DeferedInit = DeferedInit;\nG_DeferedInitCount = ObjectSize;\nG_DeferedInitList = Object;\nG_DeferedInitListCount = ObjectSize;\nG_DeferedInitListHead = Object;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_Hoof",
    "input":"\n0000000000000000 <A_Hoof>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <A_Hoof+0xa>\na: \tcallq\t0xf <A_Hoof+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_Hoof+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Chase (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_hoof ;\n\nvoid A_Hoof (mobj_t* mo)\n{\nS_StartSound (mo, sfx_hoof);\nA_Chase (mo);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  MSIPACKAGE ;\ntypedef  int /*<<< orphan*/  UINT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ACTION_Hoof ;\nint /*<<< orphan*/  DoAction (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MSI_ProcessMessage (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static UINT A_Hoof( MSIPACKAGE *package )\n{\nMSI_ProcessMessage( package, ACTION_Hoof );\nreturn DoAction( package, ACTION_Hoof );\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_ceilng.c_P_AddActiveCeiling",
    "input":"\n0000000000000000 <P_AddActiveCeiling>:\n0: \tmovl\t(%rip), %eax  # 0x6 <P_AddActiveCeiling+0x6>\n6: \ttestl\t%eax, %eax\n8: \tjle\t0x30 <P_AddActiveCeiling+0x30>\na: \tmovq\t(%rip), %rcx  # 0x11 <P_AddActiveCeiling+0x11>\n11: \txorl\t%edx, %edx\n13: \tnopw\t%cs:(%rax,%rax)\n1d: \tnopl\t(%rax)\n20: \tcmpq\t$0, (%rcx,%rdx,8)\n25: \tje\t0x31 <P_AddActiveCeiling+0x31>\n27: \taddq\t$1, %rdx\n2b: \tcmpq\t%rax, %rdx\n2e: \tjb\t0x20 <P_AddActiveCeiling+0x20>\n30: \tretq\n31: \tmovq\t%rdi, (%rcx,%rdx,8)\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ceiling_t ;\n\n/* Variables and functions */\nint MAXCEILINGS ;\nint /*<<< orphan*/ ** activeceilings ;\n\nvoid P_AddActiveCeiling(ceiling_t* c)\n{\nint\t\ti;\n\nfor (i = 0; i < MAXCEILINGS;i++)\n{\nif (activeceilings[i] == NULL)\n{\nactiveceilings[i] = c;\nreturn;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t UBYTE ;\n\n/* Variables and functions */\nsize_t MAX_ACTIVE_CEILINGS ;\nsize_t NumActiveCeilings ;\nsize_t* ActiveCeiling ;\n\nvoid P_AddActiveCeiling(UBYTE ceiling)\n{\nUBYTE i;\n\nfor (i=0; i<NumActiveCeilings; i++)\n{\nif (ActiveCeiling[i] == 0)\n{\nActiveCeiling[i] = ceiling;\nreturn;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_PlayerFinishLevel",
    "input":"\n0000000000000000 <G_PlayerFinishLevel>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rip), %r14  # 0xb <G_PlayerFinishLevel+0xb>\nb: \tmovslq\t%edi, %rax\ne: \tleaq\t(%rax,%rax,2), %rbx\n12: \tshlq\t$4, %rbx\n16: \tmovl\t44(%r14,%rbx), %edi\n1b: \txorl\t%esi, %esi\n1d: \tmovl\t$4, %edx\n22: \tcallq\t0x27 <G_PlayerFinishLevel+0x27>\n27: \tmovl\t40(%r14,%rbx), %edi\n2c: \txorl\t%esi, %esi\n2e: \tmovl\t$4, %edx\n33: \tcallq\t0x38 <G_PlayerFinishLevel+0x38>\n38: \tmovl\t(%rip), %eax  # 0x3e <G_PlayerFinishLevel+0x3e>\n3e: \tnotl\t%eax\n40: \tmovq\t32(%r14,%rbx), %rcx\n45: \tandl\t%eax, (%rcx)\n47: \txorps\t%xmm0, %xmm0\n4a: \tmovups\t%xmm0, 16(%r14,%rbx)\n50: \tmovups\t%xmm0, (%r14,%rbx)\n55: \taddq\t$8, %rsp\n59: \tpopq\t%rbx\n5a: \tpopq\t%r14\n5c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ bonuscount; scalar_t__ damagecount; scalar_t__ fixedcolormap; scalar_t__ extralight; TYPE_1__* mo; int /*<<< orphan*/  cards; int /*<<< orphan*/  powers; } ;\ntypedef  TYPE_2__ player_t ;\nstruct TYPE_4__ {int /*<<< orphan*/  flags; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MF_SHADOW ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nTYPE_2__* players ;\n\nvoid G_PlayerFinishLevel (int player)\n{\nplayer_t*\tp;\n\np = &players[player];\n\nmemset (p->powers, 0, sizeof (p->powers));\nmemset (p->cards, 0, sizeof (p->cards));\np->mo->flags &= ~MF_SHADOW;\t\t// cancel invisibility\np->extralight = 0;\t\t\t// cancel gun flashes\np->fixedcolormap = 0;\t\t// cancel ir gogles\np->damagecount = 0;\t\t\t// no palette changes\np->bonuscount = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  player_x; int /*<<< orphan*/  player_y; int /*<<< orphan*/  player_z; int /*<<< orphan*/  player_angle; int /*<<< orphan*/  player_status; int /*<<< orphan*/  player_health; int /*<<< orphan*/  player_weapon; int /*<<< orphan*/  player_ammo; int /*<<< orphan*/  player_keys; int /*<<< orphan*/  player_keys_mask; } ;\ntypedef  TYPE_1__ GLOBALS ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_PlayerReset () ;\nTYPE_1__* Globals ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n\nvoid G_PlayerFinishLevel(int player)\n{\nGLOBALS *g = &Globals[player];\n\nmemset(&g->player_keys, 0, sizeof(g->player_keys));\nmemset(&g->player_keys_mask, 0, sizeof(g->player_keys_mask));\n\ng->player_health = 0;\ng->player_weapon = 0;\ng->player_ammo = 0;\ng->player_status = 0;\ng->player_angle = 0;\ng->player_x = 0;\ng->player_y = 0;\ng->player_z = 0;\n\nG_PlayerReset();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_floor.c_T_MoveFloor",
    "input":"\n0000000000000000 <T_MoveFloor>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tmovq\t8(%rdi), %rdi\nb: \tmovl\t36(%rbx), %esi\ne: \tmovl\t32(%rbx), %edx\n11: \tmovl\t28(%rbx), %ecx\n14: \tmovl\t(%rbx), %r9d\n17: \txorl\t%r8d, %r8d\n1a: \tcallq\t0x1f <T_MoveFloor+0x1f>\n1f: \tmovq\t%rax, %r14\n22: \ttestb\t$7, (%rip)    # 0x29 <T_MoveFloor+0x29>\n29: \tje\t0x57 <T_MoveFloor+0x57>\n2b: \tcmpq\t(%rip), %r14  # 0x32 <T_MoveFloor+0x32>\n32: \tjne\t0x6f <T_MoveFloor+0x6f>\n34: \tmovq\t8(%rbx), %rax\n38: \tmovq\t$0, 16(%rax)\n40: \tmovl\t(%rbx), %ecx\n42: \tcmpl\t$-1, %ecx\n45: \tje\t0x77 <T_MoveFloor+0x77>\n47: \tcmpl\t$1, %ecx\n4a: \tjne\t0x8c <T_MoveFloor+0x8c>\n4c: \tcmpl\t$129, 4(%rbx)\n53: \tje\t0x80 <T_MoveFloor+0x80>\n55: \tjmp\t0x8c <T_MoveFloor+0x8c>\n57: \tmovq\t8(%rbx), %rdi\n5b: \tmovl\t(%rip), %esi  # 0x61 <T_MoveFloor+0x61>\n61: \tcallq\t0x66 <T_MoveFloor+0x66>\n66: \tcmpq\t(%rip), %r14  # 0x6d <T_MoveFloor+0x6d>\n6d: \tje\t0x34 <T_MoveFloor+0x34>\n6f: \taddq\t$8, %rsp\n73: \tpopq\t%rbx\n74: \tpopq\t%r14\n76: \tretq\n77: \tcmpl\t$128, 4(%rbx)\n7e: \tjne\t0x8c <T_MoveFloor+0x8c>\n80: \tmovl\t24(%rbx), %ecx\n83: \tmovl\t%ecx, 8(%rax)\n86: \tmovl\t20(%rbx), %ecx\n89: \tmovl\t%ecx, 4(%rax)\n8c: \tleaq\t16(%rbx), %rdi\n90: \tcallq\t0x95 <T_MoveFloor+0x95>\n95: \tmovq\t8(%rbx), %rdi\n99: \tmovl\t(%rip), %esi  # 0x9f <T_MoveFloor+0x9f>\n9f: \taddq\t$8, %rsp\na3: \tpopq\t%rbx\na4: \tpopq\t%r14\na6: \tjmp\t0xab <T_MoveFloor+0xab>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ result_e ;\ntypedef  int /*<<< orphan*/  mobj_t ;\nstruct TYPE_4__ {int direction; int type; TYPE_2__* sector; int /*<<< orphan*/  thinker; int /*<<< orphan*/  texture; int /*<<< orphan*/  newspecial; int /*<<< orphan*/  crush; int /*<<< orphan*/  floordestheight; int /*<<< orphan*/  speed; } ;\ntypedef  TYPE_1__ floormove_t ;\nstruct TYPE_5__ {int /*<<< orphan*/  soundorg; int /*<<< orphan*/  floorpic; int /*<<< orphan*/  special; int /*<<< orphan*/ * specialdata; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_RemoveThinker (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nscalar_t__ T_MovePlane (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n#define  donutRaise 129\nint leveltime ;\n#define  lowerAndChange 128\nscalar_t__ pastdest ;\nint /*<<< orphan*/  sfx_pstop ;\nint /*<<< orphan*/  sfx_stnmov ;\n\nvoid T_MoveFloor(floormove_t* floor)\n{\nresult_e\tres;\n\nres = T_MovePlane(floor->sector,\nfloor->speed,\nfloor->floordestheight,\nfloor->crush,0,floor->direction);\n\nif (!(leveltime&7))\nS_StartSound((mobj_t *)&floor->sector->soundorg,\nsfx_stnmov);\n\nif (res == pastdest)\n{\nfloor->sector->specialdata = NULL;\n\nif (floor->direction == 1)\n{\nswitch(floor->type)\n{\ncase donutRaise:\nfloor->sector->special = floor->newspecial;\nfloor->sector->floorpic = floor->texture;\ndefault:\nbreak;\n}\n}\nelse if (floor->direction == -1)\n{\nswitch(floor->type)\n{\ncase lowerAndChange:\nfloor->sector->special = floor->newspecial;\nfloor->sector->floorpic = floor->texture;\ndefault:\nbreak;\n}\n}\nP_RemoveThinker(&floor->thinker);\n\nS_StartSound((mobj_t *)&floor->sector->soundorg,\nsfx_pstop);\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  y_offset; int /*<<< orphan*/  x_offset; int /*<<< orphan*/  y_size; int /*<<< orphan*/  x_size; int /*<<< orphan*/  y_start; int /*<<< orphan*/  x_start; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  y_offset; int /*<<< orphan*/  x_offset; int /*<<< orphan*/  y_size; int /*<<< orphan*/  x_size; int /*<<< orphan*/  y_start; int /*<<< orphan*/  x_start; } ;\ntypedef  TYPE_1__ T_Floor ;\ntypedef  TYPE_2__ T_Room ;\n\n/* Variables and functions */\nint /*<<< orphan*/  F_FLOOR ;\nint /*<<< orphan*/  F_FLOOR_MOVE ;\nint /*<<< orphan*/  F_FLOOR_MOVE_END ;\nscalar_t__ F_OK ;\nscalar_t__ F_WALL ;\nint /*<<< orphan*/  T_MoveFloor_Draw (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Draw_End (TYPE_1__*) ;\nscalar_t__ T_MoveFloor_Move (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  T_MoveFloor_Move_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_End (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start_Start (TYPE_1__*) ;\nint /*<<< orphan*/  T_MoveFloor_Move_Start_Start_Start_Start_Start_Start_Start_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_plane.c_R_CheckPlane",
    "input":"\n0000000000000000 <R_CheckPlane>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t(%rdi), %r8d\na: \tcmpl\t%esi, %r8d\nd: \tmovl\t%esi, %eax\nf: \tcmovgl\t%r8d, %eax\n13: \tcmovgl\t%esi, %r8d\n17: \tmovl\t4(%rdi), %r9d\n1b: \tcmpl\t%edx, %r9d\n1e: \tmovl\t%edx, %ecx\n20: \tcmovll\t%r9d, %ecx\n24: \tcmovll\t%edx, %r9d\n28: \tcmpl\t%ecx, %eax\n2a: \tjg\t0x53 <R_CheckPlane+0x53>\n2c: \tmovq\t8(%r14), %rdi\n30: \tmovslq\t%eax, %rbx\n33: \tmovslq\t%ecx, %rax\n36: \taddq\t$-1, %rbx\n3a: \tnopw\t(%rax,%rax)\n40: \tcmpl\t$255, 4(%rdi,%rbx,4)\n48: \tjne\t0x5c <R_CheckPlane+0x5c>\n4a: \taddq\t$1, %rbx\n4e: \tcmpq\t%rax, %rbx\n51: \tjl\t0x40 <R_CheckPlane+0x40>\n53: \tmovl\t%r8d, (%r14)\n56: \tmovl\t%r9d, 4(%r14)\n5a: \tjmp\t0x90 <R_CheckPlane+0x90>\n5c: \tmovl\t24(%r14), %eax\n60: \tmovq\t(%rip), %r14  # 0x67 <R_CheckPlane+0x67>\n67: \tmovl\t%eax, 8(%r14)\n6b: \tleaq\t12(%r14), %rax\n6f: \tmovq\t%rax, (%rip)  # 0x76 <R_CheckPlane+0x76>\n76: \tmovl\t%esi, (%r14)\n79: \tmovl\t%edx, 4(%r14)\n7d: \tmovq\t8(%r14), %rdi\n81: \tmovl\t$255, %esi\n86: \tmovl\t$8, %edx\n8b: \tcallq\t0x90 <R_CheckPlane+0x90>\n90: \tmovq\t%r14, %rax\n93: \taddq\t$8, %rsp\n97: \tpopq\t%rbx\n98: \tpopq\t%r14\n9a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int minx; int maxx; int* top; int /*<<< orphan*/  lightlevel; int /*<<< orphan*/  picnum; int /*<<< orphan*/  height; } ;\ntypedef  TYPE_1__ visplane_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  lightlevel; int /*<<< orphan*/  picnum; int /*<<< orphan*/  height; } ;\n\n/* Variables and functions */\nTYPE_2__* lastvisplane ;\nint /*<<< orphan*/  memset (int*,int,int) ;\n\nvisplane_t*\nR_CheckPlane\n( visplane_t*\tpl,\nint\t\tstart,\nint\t\tstop )\n{\nint\t\tintrl;\nint\t\tintrh;\nint\t\tunionl;\nint\t\tunionh;\nint\t\tx;\n\nif (start < pl->minx)\n{\nintrl = pl->minx;\nunionl = start;\n}\nelse\n{\nunionl = pl->minx;\nintrl = start;\n}\n\nif (stop > pl->maxx)\n{\nintrh = pl->maxx;\nunionh = stop;\n}\nelse\n{\nunionh = pl->maxx;\nintrh = stop;\n}\n\nfor (x=intrl ; x<= intrh ; x++)\nif (pl->top[x] != 0xff)\nbreak;\n\nif (x > intrh)\n{\npl->minx = unionl;\npl->maxx = unionh;\n\n// use the same one\nreturn pl;\n}\n\n// make a new visplane\nlastvisplane->height = pl->height;\nlastvisplane->picnum = pl->picnum;\nlastvisplane->lightlevel = pl->lightlevel;\n\npl = lastvisplane++;\npl->minx = start;\npl->maxx = stop;\n\nmemset (pl->top,0xff,sizeof(pl->top));\n\nreturn pl;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x1; int y1; int x2; int y2; int x3; int y3; int x4; int y4; int x5; int y5; int x6; int y6; int x7; int y7; int x8; int y8; } ;\ntypedef  TYPE_1__ r_plane_t ;\n\n/* Variables and functions */\nTYPE_1__* r_planes ;\nTYPE_1__* r_planes_end ;\n\nr_plane_t *R_CheckPlane(r_plane_t *plane, int x1, int y1)\n{\nint x2, y2;\n\nif (x1 < plane->x1)\n{\nx2 = plane->x1;\nplane->x1 = x1;\n}\nelse\n{\nx2 = x1;\n}\n\nif (y1 < plane->y1)\n{\ny2 = plane->y1;\nplane->y1 = y1;\n}\nelse\n{\ny2 = y1;\n}\n\nif (x2 > plane->x2)\n{\nplane->x2 = x2;\n}\n\nif (y2 > plane->y2)\n{\nplane->y2 = y2;\n}\n\nif (plane->x1 == 255 && plane->y1 == 255)\n{\nr_planes_end = r_planes;\nr_planes = plane;\n\nplane->x1 = x1;\nplane->y1 = y1;\n\nplane->x2 = 255;\nplane->y2 = 255;\n\nplane->x3 = 255;\nplane->y3 = 255;\n\nplane->x4 = 255;\nplane->y4 = 255;\n\nplane->x5 = 255;\nplane->y5 = 255;\n\nplane->x6 = 255;\nplane->y6 = 255;\n\nplane->x7 = 255;\nplane->y7 = 255;\n\nplane->x8 = 255;\nplane->y8 = 255;\n}\n\nreturn plane;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_initMultIcon",
    "input":"\n0000000000000000 <STlib_initMultIcon>:\n0: \tmovl\t%esi, (%rdi)\n2: \tmovl\t%edx, 4(%rdi)\n5: \tmovl\t$4294967295, 8(%rdi)    # imm = 0xFFFFFFFF\nc: \tmovq\t%r8, 16(%rdi)\n10: \tmovq\t%r9, 32(%rdi)\n14: \tmovq\t%rcx, 24(%rdi)\n18: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int oldinum; int* inum; int /*<<< orphan*/ ** p; int /*<<< orphan*/ * on; } ;\ntypedef  TYPE_1__ st_multicon_t ;\ntypedef  int /*<<< orphan*/  patch_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\n\nvoid\nSTlib_initMultIcon\n( st_multicon_t*\ti,\nint\t\t\tx,\nint\t\t\ty,\npatch_t**\t\til,\nint*\t\t\tinum,\nboolean*\t\ton )\n{\ni->x\t= x;\ni->y\t= y;\ni->oldinum \t= -1;\ni->inum\t= inum;\ni->on\t= on;\ni->p\t= il;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  hIcon; int /*<<< orphan*/  hIconSm; int /*<<< orphan*/  hIconLarge; int /*<<< orphan*/ * hIconSmMask; int /*<<< orphan*/ * hIconMask; int /*<<< orphan*/ * hIconLargeMask; } ;\ntypedef  TYPE_1__ ST_MULTICON ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void STlib_initMultIcon(ST_MULTICON *pMultiIcon, int nIcon, int nIconSm,\nint nIconLarge, int nIconSmMask, int nIconMask, int nIconLargeMask)\n{\npMultiIcon->hIcon = nIcon;\npMultiIcon->hIconSm = nIconSm;\npMultiIcon->hIconLarge = nIconLarge;\npMultiIcon->hIconSmMask = (nIconSmMask == -1) ? NULL : (HICON)nIconSmMask;\npMultiIcon->hIconMask = (nIconMask == -1) ? NULL : (HICON)nIconMask;\npMultiIcon->hIconLargeMask = (nIconLargeMask == -1) ? NULL : (HICON)nIconLargeMask;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_FinishReadThis",
    "input":"\n0000000000000000 <M_FinishReadThis>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <M_FinishReadThis+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MainDef ;\n\nvoid M_FinishReadThis(int choice)\n{\nchoice = 0;\nM_SetupNextMenu(&MainDef);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_FinishReadThis_ (char*) ;\n\nvoid M_FinishReadThis(void)\n{\nM_FinishReadThis_(\"M_FinishReadThis\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawLoad",
    "input":"\n0000000000000000 <M_DrawLoad>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %esi  # 0xa <M_DrawLoad+0xa>\na: \tmovl\t$0, %edi\nf: \tcallq\t0x14 <M_DrawLoad+0x14>\n14: \tmovl\t$72, %edi\n19: \tmovl\t$28, %esi\n1e: \txorl\t%edx, %edx\n20: \tmovl\t%eax, %ecx\n22: \tcallq\t0x27 <M_DrawLoad+0x27>\n27: \tcmpl\t$0, (%rip)    # 0x2e <M_DrawLoad+0x2e>\n2e: \tjle\t0x97 <M_DrawLoad+0x97>\n30: \txorl\t%ebx, %ebx\n32: \tnopw\t%cs:(%rax,%rax)\n3c: \tnopl\t(%rax)\n40: \tmovl\t(%rip), %edi  # 0x46 <M_DrawLoad+0x46>\n46: \tmovslq\t(%rip), %rsi  # 0x4d <M_DrawLoad+0x4d>\n4d: \tmovslq\t%ebx, %r14\n50: \timulq\t%r14, %rsi\n54: \taddq\t(%rip), %rsi  # 0x5b <M_DrawLoad+0x5b>\n5b: \tcallq\t0x60 <M_DrawLoad+0x60>\n60: \tmovl\t(%rip), %edi  # 0x66 <M_DrawLoad+0x66>\n66: \tmovslq\t(%rip), %rsi  # 0x6d <M_DrawLoad+0x6d>\n6d: \timulq\t%r14, %rsi\n71: \taddq\t(%rip), %rsi  # 0x78 <M_DrawLoad+0x78>\n78: \tmovq\t(%rip), %rax  # 0x7f <M_DrawLoad+0x7f>\n7f: \tmovl\t(%rax,%rbx,4), %edx\n82: \tcallq\t0x87 <M_DrawLoad+0x87>\n87: \taddq\t$1, %rbx\n8b: \tmovslq\t(%rip), %rax  # 0x92 <M_DrawLoad+0x92>\n92: \tcmpq\t%rax, %rbx\n95: \tjl\t0x40 <M_DrawLoad+0x40>\n97: \taddq\t$8, %rsp\n9b: \tpopq\t%rbx\n9c: \tpopq\t%r14\n9e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint LINEHEIGHT ;\nTYPE_1__ LoadDef ;\nint /*<<< orphan*/  M_DrawSaveLoadBorder (int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  M_WriteText (int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint load_end ;\nint /*<<< orphan*/ * savegamestrings ;\n\nvoid M_DrawLoad(void)\n{\nint             i;\n\nV_DrawPatchDirect (72,28,0,W_CacheLumpName(\"M_LOADG\",PU_CACHE));\nfor (i = 0;i < load_end; i++)\n{\nM_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);\nM_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawString (int,int,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  M_DrawString2 (int,int,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  M_Load ;\nint /*<<< orphan*/  M_Load_X ;\nint /*<<< orphan*/  M_Load_Y ;\nint /*<<< orphan*/  M_Load_Y2 ;\nint /*<<< orphan*/  M_Load_Y3 ;\nint /*<<< orphan*/  M_Load_Y4 ;\nint /*<<< orphan*/  M_Load_Y5 ;\nint /*<<< orphan*/  M_Load_Y6 ;\nint /*<<< orphan*/  M_Load_Y7 ;\nint /*<<< orphan*/  M_Load_Y8 ;\nint /*<<< orphan*/  M_Load_Y9 ;\nint /*<<< orphan*/  M_Load_YA ;\nint /*<<< orphan*/  M_Load_YB ;\nint /*<<< orphan*/  M_Load_YC ;\nint /*<<< orphan*/  M_Load_YD ;\nint /*<<< orphan*/  M_Load_YE ;\nint /*<<< orphan*/  M_Load_YF ;\nint /*<<< orphan*/  M_Load_YG ;\nint /*<<< orphan*/  M_Load_YH ;\nint /*<<< orphan*/  M_Load_YI ;\nint /*<<< orphan*/  M_Load_YJ ;\nint /*<<< orphan*/  M_Load_YK ;\nint /*<<< orphan*/  M_Load_YL ;\nint /*<<< orphan*/  M_Load_YM ;\nint /*<<< orphan*/  M_Load_YN ;\nint /*<<< orphan*/  M_Load_YO ;\nint /*<<< orphan*/  M_Load_YP ;\nint /*<<< orphan*/  M_Load_YQ ;\nint /*<<< orphan*/  M_Load_YR ;\nint /*<<< orphan*/  M_Load_YS ;\nint /*<<< orphan*/  M_Load_YT ;\nint /*<<< orphan*/  M_Load_YU ;\nint /*<<< orphan*/  M_Load_YV ;\nint /*<<< orphan*/  M_Load_YW ;\nint /*<<< orphan*/  M_Load_YX ;\nint /*<<< orphan*/  M_Load_YY ;\nint /*<<< orphan*/  M_Load_YZ ;\nint /*<<< orphan*/  M_Load_Ya ;\nint /*<<< orphan*/  M_Load_Yb ;\nint /*<<< orphan*/  M_Load_Yc ;\nint /*<<< orphan*/  M_Load_Yd ;\nint /*<<< orphan*/  M_Load_Ye ;\nint /*<<< orphan*/  M_Load_Yf ;\nint /*<<< orphan*/  M_Load_Yg ;\nint /*<<< orphan*/  M_Load_Yh ;\nint /*<<< orphan*/  M_Load_Yi ;\nint /*<<< orphan*/  M_Load_Yj ;\nint /*<<< orphan*/  M_Load_Yk ;\nint /*<<< orphan*/  M_Load_Yl ;\nint /*<<< orphan*/  M_Load_Ym ;\nint /*<<< orphan*/  M_Load_Yn ;\nint /*<<< orphan*/  M_Load_Yo ;\nint /*<<< orphan*/  M_Load_Yp ;\nint /*<<< orphan*/  M_Load_Yq ;\nint /*<<< orphan*/  M_Load_Yr ;\nint /*<<< orphan*/  M_Load_Ys ;\nint /*<<< orphan*/  M_Load_Yt ;\nint /*<<< orphan*/  M_Load_Yu ;\nint /*<<< orphan*/  M_Load_Yv ;\nint /*<<< orphan*/  M_Load_Yw ;\nint /*<<< orphan*/  M_Load_Yx ;\nint /*<<< orphan*/  M_Load_Yy ;\nint /*<<< orphan*/  M_Load_Yz ;\nint /*<<< orphan*/  M_Load_Yz2 ;\nint /*<<< orphan*/  M_Load_Yz3 ;\nint /*<<< orphan*/  M_Load_Yz4 ;\nint /*<<< orphan*/  M_Load_Yz5 ;\nint /*<<< orphan*/  M_Load_Yz6 ;\nint /*<<< orphan*/  M_Load_Yz7 ;\nint /*<<< orphan*/  M_Load_Yz8 ;\nint /*<<< orphan*/  M_Load_Yz9 ;\nint /*<<< orphan*/  M_Load_YzA ;\nint /*<<< orphan*/  M_Load_YzB ;\nint /*<<< orphan*/  M_Load_YzC ;\nint /*<<< orphan*/  M_Load_YzD ;\nint /*<<< orphan*/  M_Load_YzE ;\nint /*<<< orphan*/  M_Load_YzF ;\nint /*<<< orphan*/  M_Load_YzG ;\nint /*<<< orphan*/  M_Load_YzH ;\nint /*<<< orphan*/  M_Load_YzI ;\nint /*<<< orphan*/  M_Load_YzJ ;\nint /*<<< orphan*/  M_Load_YzK ;\nint /*<<< orphan*/  M_Load_YzL ;\nint /*<<< orphan*/  M_Load_YzM ;\nint /*<<< orphan*/  M_Load_YzN ;\nint /*<<< orphan*/  M_Load_YzO ;\nint /*<<< orphan*/  M_Load_YzP ;\nint /*<<< orphan*/  M_Load_YzQ ;\nint /*<<< orphan*/  M_Load_YzR ;\nint /*<<< orphan*/  M_Load_YzS ;\nint /*<<< orphan*/  M_Load_YzT ;\nint /*<<< orphan*/  M_Load_YzU ;\nint /*<<< orphan*/  M_Load_YzV ;\nint /*<<< orphan*/  M_Load_YzW ;\nint /*<<< orphan*/  M_Load_YzX ;\nint /*<<< orphan*/  M_Load_YzY ;\nint /*<<< orphan*/  M_Load_YzZ ;\nint /*<<< orphan*/  M_Load_YzZ2 ;\nint /*<<< orphan*/  M_Load_YzZ3 ;\nint /*<<< orphan*/  M_Load_YzZ4 ;\nint /*<<< orphan*/  M_Load_YzZ5 ;\nint /*<<< orphan*/  M_Load_YzZ6 ;\nint /*<<< orphan*/  M_Load_YzZ7 ;\nint /*<<< orphan*/  M_Load_YzZ8 ;\nint /*<<< orphan*/  M_Load_YzZ9 ;\nint /*<<< orphan*/  M_Load_YzZA ;\nint /*<<< orphan*/  M_Load_YzZB ;\nint /*<<< orphan*/  M_Load_YzZC ;\nint /*<<< orphan*/  M_Load_YzZD ;\nint /*<<< orphan*/  M_Load_YzZE ;\nint /*<<< orphan*/  M_Load_YzZF ;\nint /*<<< orphan*/  M_Load_YzZG ;\nint /*<<< orphan*/  M_Load_YzZH ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_SetMusicVolume",
    "input":"\n0000000000000000 <S_SetMusicVolume>:\n0: \tpushq\t%rbx\n1: \tmovl\t%edi, %ebx\n3: \tcmpl\t$128, %edi\n9: \tjb\t0x17 <S_SetMusicVolume+0x17>\nb: \tmovl\t$0, %edi\n10: \tmovl\t%ebx, %esi\n12: \tcallq\t0x17 <S_SetMusicVolume+0x17>\n17: \tmovl\t$127, %edi\n1c: \tcallq\t0x21 <S_SetMusicVolume+0x21>\n21: \tmovl\t%ebx, %edi\n23: \tcallq\t0x28 <S_SetMusicVolume+0x28>\n28: \tmovl\t%ebx, (%rip)  # 0x2e <S_SetMusicVolume+0x2e>\n2e: \tpopq\t%rbx\n2f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int) ;\nint /*<<< orphan*/  I_SetMusicVolume (int) ;\nint snd_MusicVolume ;\n\nvoid S_SetMusicVolume(int volume)\n{\nif (volume < 0 || volume > 127)\n{\nI_Error(\"Attempt to set music volume at %d\",\nvolume);\n}\n\nI_SetMusicVolume(127);\nI_SetMusicVolume(volume);\nsnd_MusicVolume = volume;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_PANIC (char*,int) ;\nint /*<<< orphan*/  S_SetMusicVolume_ (int) ;\nint music_volume ;\nint /*<<< orphan*/  s_music_volume ;\n\nvoid S_SetMusicVolume(int volume)\n{\nif (volume < 0 || volume > 127)\nD_PANIC(\"S_SetMusicVolume: volume %d out of range\", volume);\n\nS_SetMusicVolume_(volume);\n\nmusic_volume = volume;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_ceilng.c_P_RemoveActiveCeiling",
    "input":"\n0000000000000000 <P_RemoveActiveCeiling>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %eax  # 0x7 <P_RemoveActiveCeiling+0x7>\n7: \ttestl\t%eax, %eax\n9: \tjle\t0x2f <P_RemoveActiveCeiling+0x2f>\nb: \tmovq\t(%rip), %rcx  # 0x12 <P_RemoveActiveCeiling+0x12>\n12: \txorl\t%ebx, %ebx\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tcmpq\t%rdi, (%rcx,%rbx,8)\n24: \tje\t0x31 <P_RemoveActiveCeiling+0x31>\n26: \taddq\t$1, %rbx\n2a: \tcmpq\t%rax, %rbx\n2d: \tjb\t0x20 <P_RemoveActiveCeiling+0x20>\n2f: \tpopq\t%rbx\n30: \tretq\n31: \tmovq\t8(%rdi), %rax\n35: \tmovq\t$0, (%rax)\n3c: \tmovq\t(%rip), %rax  # 0x43 <P_RemoveActiveCeiling+0x43>\n43: \tmovq\t(%rax,%rbx,8), %rdi\n47: \tcallq\t0x4c <P_RemoveActiveCeiling+0x4c>\n4c: \tmovq\t(%rip), %rax  # 0x53 <P_RemoveActiveCeiling+0x53>\n53: \tmovq\t$0, (%rax,%rbx,8)\n5b: \tpopq\t%rbx\n5c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  thinker; TYPE_1__* sector; } ;\ntypedef  TYPE_2__ ceiling_t ;\nstruct TYPE_5__ {int /*<<< orphan*/ * specialdata; } ;\n\n/* Variables and functions */\nint MAXCEILINGS ;\nint /*<<< orphan*/  P_RemoveThinker (int /*<<< orphan*/ *) ;\nTYPE_2__** activeceilings ;\n\nvoid P_RemoveActiveCeiling(ceiling_t* c)\n{\nint\t\ti;\n\nfor (i = 0;i < MAXCEILINGS;i++)\n{\nif (activeceilings[i] == c)\n{\nactiveceilings[i]->sector->specialdata = NULL;\nP_RemoveThinker (&activeceilings[i]->thinker);\nactiveceilings[i] = NULL;\nbreak;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct ceiling_data {struct ceiling_data* next; } ;\nstruct TYPE_4__ {scalar_t__ ceiling_num; } ;\n\n/* Variables and functions */\nint MAXCEILINGS ;\nTYPE_1__** ActiveCeilings ;\nint /*<<< orphan*/  Z_Free (struct ceiling_data*) ;\n\nvoid P_RemoveActiveCeiling(struct ceiling_data *ceiling)\n{\nint i;\n\nfor (i=0;i<MAXCEILINGS;i++)\n{\nif (ActiveCeilings[i] == ceiling)\n{\nActiveCeilings[i]->next = NULL;\nZ_Free(ActiveCeilings[i]);\nActiveCeilings[i] = NULL;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_AddFile",
    "input":"\n0000000000000000 <D_AddFile>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r14\n8: \tmovq\t$-1, %rax\nf: \tmovq\t(%rip), %rcx  # 0x16 <D_AddFile+0x16>\n16: \tnopw\t%cs:(%rax,%rax)\n20: \tcmpq\t$0, 8(%rcx,%rax,8)\n26: \tleaq\t1(%rax), %rax\n2a: \tjne\t0x20 <D_AddFile+0x20>\n2c: \tmovl\t%eax, %r15d\n2f: \tmovq\t%r14, %rdi\n32: \tcallq\t0x37 <D_AddFile+0x37>\n37: \tleaq\t1(%rax), %rdi\n3b: \tcallq\t0x40 <D_AddFile+0x40>\n40: \tmovq\t%rax, %rbx\n43: \tmovq\t%rax, %rdi\n46: \tmovq\t%r14, %rsi\n49: \tcallq\t0x4e <D_AddFile+0x4e>\n4e: \tmovq\t(%rip), %rax  # 0x55 <D_AddFile+0x55>\n55: \tmovq\t%rbx, (%rax,%r15,8)\n59: \tpopq\t%rbx\n5a: \tpopq\t%r14\n5c: \tpopq\t%r15\n5e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* malloc (scalar_t__) ;\nint /*<<< orphan*/  strcpy (char*,char*) ;\nscalar_t__ strlen (char*) ;\nchar** wadfiles ;\n\nvoid D_AddFile (char *file)\n{\nint     numwadfiles;\nchar    *newfile;\n\nfor (numwadfiles = 0 ; wadfiles[numwadfiles] ; numwadfiles++)\n;\n\nnewfile = malloc (strlen(file)+1);\nstrcpy (newfile, file);\n\nwadfiles[numwadfiles] = newfile;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  D_File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_File_Init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * D_File_New () ;\nint /*<<< orphan*/ * D_Files ;\n\nvoid D_AddFile(D_File *F)\n{\nint i;\n\nfor (i = 0; D_Files[i] != NULL; i++)\n;\n\nD_File *F2 = D_File_New();\nD_File_Init(F2);\nD_File_Init(F);\nD_Files[i] = F2;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_DoWorldDone",
    "input":"\n0000000000000000 <G_DoWorldDone>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %eax  # 0x7 <G_DoWorldDone+0x7>\n7: \tmovl\t%eax, (%rip)  # 0xd <G_DoWorldDone+0xd>\nd: \tmovq\t(%rip), %rax  # 0x14 <G_DoWorldDone+0x14>\n14: \taddq\t$1, %rax\n18: \tmovq\t%rax, (%rip)  # 0x1f <G_DoWorldDone+0x1f>\n1f: \txorl\t%eax, %eax\n21: \tcallq\t0x26 <G_DoWorldDone+0x26>\n26: \tmovl\t(%rip), %eax  # 0x2c <G_DoWorldDone+0x2c>\n2c: \tmovl\t%eax, (%rip)  # 0x32 <G_DoWorldDone+0x32>\n32: \tmovl\t$1, (%rip)    # 0x3c <G_DoWorldDone+0x3c>\n3c: \tpopq\t%rax\n3d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ next; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GS_LEVEL ;\nint /*<<< orphan*/  G_DoLoadLevel () ;\nint /*<<< orphan*/  ga_nothing ;\nint /*<<< orphan*/  gameaction ;\nscalar_t__ gamemap ;\nint /*<<< orphan*/  gamestate ;\nint viewactive ;\nTYPE_1__ wminfo ;\n\nvoid G_DoWorldDone (void)\n{\ngamestate = GS_LEVEL;\ngamemap = wminfo.next+1;\nG_DoLoadLevel ();\ngameaction = ga_nothing;\nviewactive = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_DoWorldDone_C ;\nint /*<<< orphan*/  G_DoWorldDone_P ;\nint /*<<< orphan*/  G_DoWorldDone_S ;\nint /*<<< orphan*/  G_DoWorldDone_T ;\nint /*<<< orphan*/  G_DoWorldDone_U ;\nint /*<<< orphan*/  G_DoWorldDone_V ;\nint /*<<< orphan*/  G_DoWorldDone_W ;\nint /*<<< orphan*/  G_DoWorldDone_X ;\nint /*<<< orphan*/  G_DoWorldDone_Y ;\nint /*<<< orphan*/  G_DoWorldDone_Z ;\nint /*<<< orphan*/  G_DoWorldDone_a ;\nint /*<<< orphan*/  G_DoWorldDone_b ;\nint /*<<< orphan*/  G_DoWorldDone_c ;\nint /*<<< orphan*/  G_DoWorldDone_d ;\nint /*<<< orphan*/  G_DoWorldDone_e ;\nint /*<<< orphan*/  G_DoWorldDone_f ;\nint /*<<< orphan*/  G_DoWorldDone_g ;\nint /*<<< orphan*/  G_DoWorldDone_h ;\nint /*<<< orphan*/  G_DoWorldDone_i ;\nint /*<<< orphan*/  G_DoWorldDone_j ;\nint /*<<< orphan*/  G_DoWorldDone_k ;\nint /*<<< orphan*/  G_DoWorldDone_l ;\nint /*<<< orphan*/  G_DoWorldDone_m ;\nint /*<<< orphan*/  G_DoWorldDone_n ;\nint /*<<< orphan*/  G_DoWorldDone_o ;\nint /*<<< orphan*/  G_DoWorldDone_p ;\nint /*<<< orphan*/  G_DoWorldDone_q ;\nint /*<<< orphan*/  G_DoWorldDone_r ;\nint /*<<< orphan*/  G_DoWorldDone_s ;\nint /*<<< orphan*/  G_DoWorldDone_t ;\nint /*<<< orphan*/  G_DoWorldDone_u ;\nint /*<<< orphan*/  G_DoWorldDone_v ;\nint /*<<< orphan*/  G_DoWorldDone_w ;\nint /*<<< orphan*/  G_DoWorldDone_x ;\nint /*<<< orphan*/  G_DoWorldDone_y ;\nint /*<<< orphan*/  G_DoWorldDone_z ;\nint /*<<< orphan*/  G_DoWorldDone_A ;\nint /*<<< orphan*/  G_DoWorldDone_B ;\nint /*<<< orphan*/  G_DoWorldDone_C ;\nint /*<<< orphan*/  G_DoWorldDone_D ;\nint /*<<< orphan*/  G_DoWorldDone_E ;\nint /*<<< orphan*/  G_DoWorldDone_F ;\nint /*<<< orphan*/  G_DoWorldDone_G ;\nint /*<<< orphan*/  G_DoWorldDone_H ;\nint /*<<< orphan*/  G_DoWorldDone_I ;\nint /*<<< orphan*/  G_DoWorldDone_J ;\nint /*<<< orphan*/  G_DoWorldDone_K ;\nint /*<<< orphan*/  G_DoWorldDone_L ;\nint /*<<< orphan*/  G_DoWorldDone_M ;\nint /*<<< orphan*/  G_DoWorldDone_N ;\nint /*<<< orphan*/  G_DoWorldDone_O ;\nint /*<<< orphan*/  G_DoWorldDone_P ;\nint /*<<< orphan*/  G_DoWorldDone_Q ;\nint /*<<< orphan*/  G_DoWorldDone_R ;\nint /*<<< orphan*/  G_DoWorldDone_S ;\nint /*<<< orphan*/  G_DoWorldDone_T ;\nint /*<<< orphan*/  G_DoWorldDone_U ;\nint /*<<< orphan*/  G_DoWorldDone_V ;\nint /*<<< orphan*/  G_DoWorldDone_W ;\nint /*<<< orphan*/  G_DoWorldDone_X ;\nint /*<<< orphan*/  G_DoWorldDone_Y ;\nint /*<<< orphan*/  G_DoWorldDone_Z ;\nint /*<<< orphan*/  G_DoWorldDone_a ;\nint /*<<< orphan*/  G_DoWorldDone_b ;\nint /*<<< orphan*/  G_DoWorldDone_c ;\nint /*<<< orphan*/  G_DoWorldDone_d ;\nint /*<<< orphan*/  G_DoWorldDone_e ;\nint /*<<< orphan*/  G_DoWorldDone_f ;\nint /*<<< orphan*/  G_DoWorldDone_g ;\nint /*<<< orphan*/  G_DoWorldDone_h ;\nint /*<<< orphan*/  G_DoWorldDone_i ;\nint /*<<< orphan*/  G_DoWorldDone_j ;\nint /*<<< orphan*/  G_DoWorldDone_k ;\nint /*<<< orphan*/  G_DoWorldDone_l ;\nint /*<<< orphan*/  G_DoWorldDone_m ;\nint /*<<< orphan*/  G_DoWorldDone_n ;\nint /*<<< orphan*/  G_DoWorldDone_o ;\nint /*<<< orphan*/  G_DoWorldDone_p ;\nint /*<<< orphan*/  G_DoWorldDone_q ;\nint /*<<< orphan*/  G_DoWorldDone_r ;\nint /*<<< orphan*/  G_DoWorldDone_s ;\nint /*<<< orphan*/  G_DoWorldDone_t ;\nint /*<<< orphan*/  G_DoWorldDone_u ;\nint /*<<< orphan*/  G_DoWorldDone_v ;\nint /*<<< orphan*/  G_DoWorldDone_w ;\nint /*<<< orphan*/  G_DoWorldDone_x ;\nint /*<<< orphan*/  G_DoWorldDone_y ;\nint /*<<< orphan*/  G_DoWorldDone_z ;\nint /*<<< orphan*/  G_DoWorldDone_A ;\nint /*<<< orphan*/  G_DoWorldDone_B ;\nint /*<<< orphan*/  G_DoWorldDone_C ;\nint /*<<< orphan*/  G_DoWorldDone_D ;\nint /*<<< orphan*/  G_DoWorldDone_E ;\nint /*<<< orphan*/  G_DoWorldDone_F ;\nint /*<<< orphan*/  G_DoWorldDone_G ;\nint /*<<< orphan*/  G_DoWorldDone_H ;\nint /*<<< orphan*/  G_DoWorldDone_I ;\nint /*<<< orphan*/  G_DoWorldDone_J ;\nint /*<<< orphan*/  G_DoWorldDone_K ;\nint /*<<< orphan*/  G_DoWorldDone_L ;\nint /*<<< orphan*/  G_DoWorldDone_M ;\nint /*<<< orphan*/  G_DoWorldDone_N ;\nint /*<<< orphan*/  G_DoWorldDone_O ;\nint /*<<< orphan*/  G_DoWorldDone_P ;\nint /*<<< orphan*/  G_DoWorldDone_Q ;\nint /*<<< orphan*/  G_DoWorldDone_R ;\nint /*<<< orphan*/  G_DoWorldDone_S ;\nint /*<<< orphan*/  G_DoWorldDone_T ;\nint /*<<< orphan*/  G_DoWorldDone_U ;\nint /*<<< orphan*/  G_DoWorldDone_V ;\nint /*<<< orphan*/  G_DoWorldDone_W ;\nint /*<<< orphan*/  G_DoWorldDone_X ;\nint /*<<< orphan*/  G_DoWorldDone_Y ;\nint /*<<< orphan*/  G_Do"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_ShutdownMusic",
    "input":"\n0000000000000000 <I_ShutdownMusic>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_ShutdownMusic(void)\t{ }",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_ShutdownMusic(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_FindSectorFromLineTag",
    "input":"\n0000000000000000 <P_FindSectorFromLineTag>:\n0: \tmovl\t%esi, %eax\n2: \tmovslq\t(%rip), %rcx  # 0x9 <P_FindSectorFromLineTag+0x9>\n9: \tmovq\t(%rip), %r8   # 0x10 <P_FindSectorFromLineTag+0x10>\n10: \tmovslq\t%esi, %rsi\n13: \taddq\t$1, %rsi\n17: \tnopw\t(%rax,%rax)\n20: \tcmpq\t%rcx, %rsi\n23: \tjge\t0x36 <P_FindSectorFromLineTag+0x36>\n25: \tmovq\t(%r8,%rsi,8), %rdx\n29: \taddl\t$1, %eax\n2c: \taddq\t$1, %rsi\n30: \tcmpq\t(%rdi), %rdx\n33: \tjne\t0x20 <P_FindSectorFromLineTag+0x20>\n35: \tretq\n36: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n3b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ tag; } ;\ntypedef  TYPE_1__ line_t ;\nstruct TYPE_5__ {scalar_t__ tag; } ;\n\n/* Variables and functions */\nint numsectors ;\nTYPE_2__* sectors ;\n\nint\nP_FindSectorFromLineTag\n( line_t*\tline,\nint\t\tstart )\n{\nint\ti;\n\nfor (i=start+1;i<numsectors;i++)\nif (sectors[i].tag == line->tag)\nreturn i;\n\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  line_t ;\nstruct TYPE_3__ {scalar_t__ tag; } ;\ntypedef  TYPE_1__ sector_t ;\n\n/* Variables and functions */\nint MAXSECTORS ;\nTYPE_1__* sectors ;\n\nint P_FindSectorFromLineTag(line_t *ld, int tag)\n{\nint i;\n\nfor (i = 0; i < MAXSECTORS; i++)\n{\nif (sectors[i+1].tag == ld->tag)\nreturn i+1;\n}\n\nreturn -1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_mobj.c_P_ExplodeMissile",
    "input":"\n0000000000000000 <P_ExplodeMissile>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorps\t%xmm0, %xmm0\n7: \tmovups\t%xmm0, 32(%rdi)\nb: \tmovq\t$0, 48(%rdi)\n13: \tmovq\t(%rip), %rax  # 0x1a <P_ExplodeMissile+0x1a>\n1a: \tmovq\t(%rdi), %rcx\n1d: \tmovl\t(%rax,%rcx,4), %esi\n20: \tcallq\t0x25 <P_ExplodeMissile+0x25>\n25: \txorl\t%eax, %eax\n27: \tcallq\t0x2c <P_ExplodeMissile+0x2c>\n2c: \tandl\t$3, %eax\n2f: \tmovl\t8(%rbx), %ecx\n32: \tsubl\t%eax, %ecx\n34: \ttestl\t%ecx, %ecx\n36: \tmovl\t$1, %eax\n3b: \tcmovgl\t%ecx, %eax\n3e: \tmovl\t%eax, 8(%rbx)\n41: \tmovl\t(%rip), %eax  # 0x47 <P_ExplodeMissile+0x47>\n47: \tnotl\t%eax\n49: \tandl\t%eax, 24(%rbx)\n4c: \tmovq\t16(%rbx), %rax\n50: \tmovq\t(%rax), %rsi\n53: \ttestq\t%rsi, %rsi\n56: \tje\t0x61 <P_ExplodeMissile+0x61>\n58: \tmovq\t%rbx, %rdi\n5b: \tpopq\t%rbx\n5c: \tjmp\t0x61 <P_ExplodeMissile+0x61>\n61: \tpopq\t%rbx\n62: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {size_t type; int tics; TYPE_1__* info; int /*<<< orphan*/  flags; scalar_t__ momz; scalar_t__ momy; scalar_t__ momx; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_9__ {int /*<<< orphan*/  deathstate; } ;\nstruct TYPE_7__ {scalar_t__ deathsound; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MF_MISSILE ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (TYPE_2__*,scalar_t__) ;\nTYPE_3__* mobjinfo ;\n\nvoid P_ExplodeMissile (mobj_t* mo)\n{\nmo->momx = mo->momy = mo->momz = 0;\n\nP_SetMobjState (mo, mobjinfo[mo->type].deathstate);\n\nmo->tics -= P_Random()&3;\n\nif (mo->tics < 1)\nmo->tics = 1;\n\nmo->flags &= ~MF_MISSILE;\n\nif (mo->info->deathsound)\nS_StartSound (mo, mo->info->deathsound);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  ang; int /*<<< orphan*/  flags; int /*<<< orphan*/  type; } ;\nstruct TYPE_9__ {TYPE_3__* owner; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  (* thinker_function ) (TYPE_3__*) ;} ;\ntypedef  TYPE_1__ thinker_t ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  TYPE_3__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_ExplodeMissileThinker ;\nint /*<<< orphan*/  P_ExplodeMissileType (TYPE_3__*) ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_3__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SpawnMissileTrail (TYPE_3__*) ;\nint /*<<< orphan*/  P_UnsetThingPosition (TYPE_3__*) ;\nTYPE_1__* thinker_functions ;\n\nvoid P_ExplodeMissile(mobj_t *mo)\n{\nplayer_t *player = mo->owner;\n\nP_UnsetThingPosition(mo);\nP_SetMobjState(mo, P_ExplodeMissileType(player));\nP_SpawnMissileTrail(player);\n\nplayer->flags &= ~(MOBJFLAGS_MULTI_SHOT|MOBJFLAGS_MULTI_FIRE);\nplayer->ammo_amount[player->ready_weapon] -= (player->ammo_amount[player->ready_weapon] & 3);\n\nif (player->ammo_amount[player->ready_weapon] < 1)\nplayer->ammo_amount[player->ready_weapon] = 1;\n\nthinker_t *th = (thinker_t *)mo->thinker.function;\nth->thinker_function = P_ExplodeMissileThinker;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_setup.c_P_LoadThings",
    "input":"\n0000000000000000 <P_LoadThings>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t%edi, %ebx\na: \tmovl\t(%rip), %esi  # 0x10 <P_LoadThings+0x10>\n10: \tcallq\t0x15 <P_LoadThings+0x15>\n15: \tmovq\t%rax, %r14\n18: \tmovl\t%ebx, %edi\n1a: \tcallq\t0x1f <P_LoadThings+0x1f>\n1f: \tcltq\n21: \tmovabsq\t$-3689348814741910323, %rcx # imm = 0xCCCCCCCCCCCCCCCD\n2b: \tmulq\t%rcx\n2e: \tmovq\t%rdx, %r15\n31: \tshrq\t$4, %r15\n35: \ttestl\t%r15d, %r15d\n38: \tjle\t0xb9 <P_LoadThings+0xb9>\n3a: \txorl\t%ebp, %ebp\n3c: \tmovl\t$51380415, %r12d   # imm = 0x31000BF\n42: \tmovq\t%r14, %rbx\n45: \tjmp\t0x99 <P_LoadThings+0x99>\n47: \tnopw\t(%rax,%rax)\n50: \tmovl\t4(%rbx), %edi\n53: \tcallq\t0x58 <P_LoadThings+0x58>\n58: \tmovl\t%eax, 4(%rbx)\n5b: \tmovl\t8(%rbx), %edi\n5e: \tcallq\t0x63 <P_LoadThings+0x63>\n63: \tmovl\t%eax, 8(%rbx)\n66: \tmovl\t12(%rbx), %edi\n69: \tcallq\t0x6e <P_LoadThings+0x6e>\n6e: \tmovl\t%eax, 12(%rbx)\n71: \tmovl\t(%rbx), %edi\n73: \tcallq\t0x78 <P_LoadThings+0x78>\n78: \tmovl\t%eax, (%rbx)\n7a: \tmovl\t16(%rbx), %edi\n7d: \tcallq\t0x82 <P_LoadThings+0x82>\n82: \tmovl\t%eax, 16(%rbx)\n85: \tmovq\t%rbx, %rdi\n88: \tcallq\t0x8d <P_LoadThings+0x8d>\n8d: \taddl\t$1, %ebp\n90: \taddq\t$20, %rbx\n94: \tcmpl\t%r15d, %ebp\n97: \tjge\t0xb9 <P_LoadThings+0xb9>\n99: \tmovq\t(%rip), %rax  # 0xa0 <P_LoadThings+0xa0>\na0: \tcmpq\t(%rip), %rax  # 0xa7 <P_LoadThings+0xa7>\na7: \tje\t0x50 <P_LoadThings+0x50>\na9: \tmovl\t(%rbx), %eax\nab: \taddl\t$-64, %eax\nae: \tcmpl\t$25, %eax\nb1: \tja\t0x50 <P_LoadThings+0x50>\nb3: \tbtl\t%eax, %r12d\nb7: \tjae\t0x50 <P_LoadThings+0x50>\nb9: \tmovq\t%r14, %rdi\nbc: \tpopq\t%rbx\nbd: \tpopq\t%r12\nbf: \tpopq\t%r14\nc1: \tpopq\t%r15\nc3: \tpopq\t%rbp\nc4: \tjmp\t0xc9 <P_LoadThings+0xc9>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int type; int x; int y; int angle; int options; } ;\ntypedef  TYPE_1__ mapthing_t ;\ntypedef  int /*<<< orphan*/  byte ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nint /*<<< orphan*/  P_SpawnMapThing (TYPE_1__*) ;\nvoid* SHORT (int) ;\nint /*<<< orphan*/ * W_CacheLumpNum (int,int /*<<< orphan*/ ) ;\nint W_LumpLength (int) ;\nint /*<<< orphan*/  Z_Free (int /*<<< orphan*/ *) ;\nscalar_t__ commercial ;\nscalar_t__ gamemode ;\n\nvoid P_LoadThings (int lump)\n{\nbyte*\t\tdata;\nint\t\t\ti;\nmapthing_t*\t\tmt;\nint\t\t\tnumthings;\nboolean\t\tspawn;\n\ndata = W_CacheLumpNum (lump,PU_STATIC);\nnumthings = W_LumpLength (lump) / sizeof(mapthing_t);\n\nmt = (mapthing_t *)data;\nfor (i=0 ; i<numthings ; i++, mt++)\n{\nspawn = true;\n\n// Do not spawn cool, new monsters if !commercial\nif ( gamemode != commercial)\n{\nswitch(mt->type)\n{\ncase 68:\t// Arachnotron\ncase 64:\t// Archvile\ncase 88:\t// Boss Brain\ncase 89:\t// Boss Shooter\ncase 69:\t// Hell Knight\ncase 67:\t// Mancubus\ncase 71:\t// Pain Elemental\ncase 65:\t// Former Human Commando\ncase 66:\t// Revenant\ncase 84:\t// Wolf SS\nspawn = false;\nbreak;\n}\n}\nif (spawn == false)\nbreak;\n\n// Do spawn all other stuff.\nmt->x = SHORT(mt->x);\nmt->y = SHORT(mt->y);\nmt->angle = SHORT(mt->angle);\nmt->type = SHORT(mt->type);\nmt->options = SHORT(mt->options);\n\nP_SpawnMapThing (mt);\n}\n\nZ_Free (data);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int z; int angle; int type; int flags; } ;\ntypedtpe TYPE_2__ ;\ntypedef  TYPE_1__ thing_t ;\ntypedef  TYPE_2__* thing_tptr_t ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FATAL (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  P_ReadThing (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  P_ReadWord (int /*<<< orphan*/ *) ;\nscalar_t__ P_ReadWord32 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TAG_THING ;\nscalar_t__ TAG_END ;\nint /*<<< orphan*/  TAG_END_SWITCH ;\n\nvoid P_LoadThings(FILE *f)\n{\nthing_tptr_t\tthings;\nint\t\t\t\ti;\n\nthings = (thing_tptr_t)P_ReadThing(f, TAG_THING);\n\nfor (i=0 ; i<P_ReadWord32(f); i++)\n{\nP_ReadThing(f, TAG_THING);\nP_ReadThing(f, TAG_THING);\nP_ReadThing(f, TAG_THING);\nP_ReadThing(f, TAG_THING);\nP_ReadThing(f, TAG_THING);\nP_ReadThing(f, TAG_THING);\n\nif (P_ReadWord(f) != TAG_END_SWITCH)\nFATAL(f);\n}\n\nif (P_ReadWord(f) != TAG_END)\nFATAL(f);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_LoadGame",
    "input":"\n0000000000000000 <M_LoadGame>:\n0: \tpushq\t%rax\n1: \tcmpq\t$0, (%rip)    # 0x9 <M_LoadGame+0x9>\n9: \tje\t0x1b <M_LoadGame+0x1b>\nb: \tmovl\t(%rip), %edi  # 0x11 <M_LoadGame+0x11>\n11: \txorl\t%esi, %esi\n13: \txorl\t%edx, %edx\n15: \tpopq\t%rax\n16: \tjmp\t0x1b <M_LoadGame+0x1b>\n1b: \tmovl\t$0, %edi\n20: \tcallq\t0x25 <M_LoadGame+0x25>\n25: \txorl\t%eax, %eax\n27: \tpopq\t%rcx\n28: \tjmp\t0x2d <M_LoadGame+0x2d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  LOADNET ;\nint /*<<< orphan*/  LoadDef ;\nint /*<<< orphan*/  M_ReadSaveStrings () ;\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nscalar_t__ netgame ;\n\nvoid M_LoadGame (int choice)\n{\nif (netgame)\n{\nM_StartMessage(LOADNET,NULL,false);\nreturn;\n}\n\nM_SetupNextMenu(&LoadDef);\nM_ReadSaveStrings();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_LoadGame_Brief ;\nint /*<<< orphan*/  M_LoadGame_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Brief ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Full ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick_Quick ;\nint /*<<< orphan*/  M_LoadGame_Quick_Quick_Quick_Quick_Quick_Quick"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_ResumeSong",
    "input":"\n0000000000000000 <I_ResumeSong>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_ResumeSong (int handle)\n{\n// UNUSED.\nhandle = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_ResumeSong(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_PIT_StompThing",
    "input":"\n0000000000000000 <PIT_StompThing>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %ecx  # 0x7 <PIT_StompThing+0x7>\n7: \tmovl\t$1, %eax\nc: \ttestl\t%ecx, (%rdi)\ne: \tje\t0x69 <PIT_StompThing+0x69>\n10: \tmovq\t(%rip), %rdx  # 0x17 <PIT_StompThing+0x17>\n17: \tmovq\t8(%rdx), %r8\n1b: \taddq\t8(%rdi), %r8\n1f: \tmovq\t32(%rdi), %rcx\n23: \tsubq\t(%rip), %rcx  # 0x2a <PIT_StompThing+0x2a>\n2a: \tmovq\t%rcx, %rsi\n2d: \tnegq\t%rsi\n30: \tcmovlq\t%rcx, %rsi\n34: \tcmpq\t%r8, %rsi\n37: \tjge\t0x69 <PIT_StompThing+0x69>\n39: \tmovq\t24(%rdi), %rcx\n3d: \tsubq\t(%rip), %rcx  # 0x44 <PIT_StompThing+0x44>\n44: \tmovq\t%rcx, %rsi\n47: \tnegq\t%rsi\n4a: \tcmovlq\t%rcx, %rsi\n4e: \tcmpq\t%rdi, %rdx\n51: \tje\t0x69 <PIT_StompThing+0x69>\n53: \tcmpq\t%r8, %rsi\n56: \tjge\t0x69 <PIT_StompThing+0x69>\n58: \tcmpl\t$0, 16(%rdx)\n5c: \tjne\t0x6b <PIT_StompThing+0x6b>\n5e: \txorl\t%eax, %eax\n60: \tcmpl\t$30, (%rip)   # 0x67 <PIT_StompThing+0x67>\n67: \tje\t0x6b <PIT_StompThing+0x6b>\n69: \tpopq\t%rcx\n6a: \tretq\n6b: \tmovq\t%rdx, %rsi\n6e: \tmovl\t$10000, %ecx  # imm = 0x2710\n73: \tcallq\t0x78 <PIT_StompThing+0x78>\n78: \tmovl\t$1, %eax\n7d: \tpopq\t%rcx\n7e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int flags; scalar_t__ radius; int /*<<< orphan*/  player; scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  scalar_t__ fixed_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint MF_SHOOTABLE ;\nint /*<<< orphan*/  P_DamageMobj (TYPE_1__*,TYPE_1__*,TYPE_1__*,int) ;\nscalar_t__ abs (scalar_t__) ;\nint gamemap ;\nTYPE_1__* tmthing ;\nscalar_t__ tmx ;\nscalar_t__ tmy ;\n\nboolean PIT_StompThing (mobj_t* thing)\n{\nfixed_t\tblockdist;\n\nif (!(thing->flags & MF_SHOOTABLE) )\nreturn true;\n\nblockdist = thing->radius + tmthing->radius;\n\nif ( abs(thing->x - tmx) >= blockdist\n|| abs(thing->y - tmy) >= blockdist )\n{\n// didn't hit it\nreturn true;\n}\n\n// don't clip against self\nif (thing == tmthing)\nreturn true;\n\n// monsters don't stomp things except on boss level\nif ( !tmthing->player && gamemap != 30)\nreturn false;\n\nP_DamageMobj (thing, tmthing, tmthing, 10000);\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int flags; scalar_t__ x; scalar_t__ y; scalar_t__ z; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ Thing ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PIT_StompThing_Bomb ;\nscalar_t__ PIT_StompThing_Bomb_X ;\nscalar_t__ PIT_StompThing_Bomb_Y ;\nint PIT_StompThing_Bomb_Z ;\nint PIT_StompThing_Bomb_Z_Min ;\nint PIT_StompThing_Bomb_Z_Max ;\nint PIT_StompThing_Bomb_Z_Range ;\nint PIT_StompThing_Bomb_Z_Range_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb_Min_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Min_Bomb_Min_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Min_Max ;\nint PIT_StompThing_Bomb_Z_Range_Max_Bomb_Max_Min"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_inter.c_P_GiveCard",
    "input":"\n0000000000000000 <P_GiveCard>:\n0: \tmovq\t(%rdi), %rax\n3: \tcmpl\t$0, (%rax,%rsi,4)\n7: \tje\t0xa <P_GiveCard+0xa>\n9: \tretq\na: \tmovl\t(%rip), %ecx  # 0x10 <P_GiveCard+0x10>\n10: \tmovl\t%ecx, 8(%rdi)\n13: \tmovl\t$1, (%rax,%rsi,4)\n1a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* cards; int /*<<< orphan*/  bonuscount; } ;\ntypedef  TYPE_1__ player_t ;\ntypedef  size_t card_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BONUSADD ;\n\nvoid\nP_GiveCard\n( player_t*\tplayer,\ncard_t\tcard )\n{\nif (player->cards[card])\nreturn;\n\nplayer->bonuscount = BONUSADD;\nplayer->cards[card] = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* card; int /*<<< orphan*/  card_count; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MAX_CARDS ;\n\nvoid P_GiveCard(player_t *p, int card)\n{\nif (p->card[card])\nreturn;\n\np->card_count = MAX_CARDS;\np->card[card] = 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_updateShowNextLoc",
    "input":"\n0000000000000000 <WI_updateShowNextLoc>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <WI_updateShowNextLoc+0x8>\n8: \tmovl\t(%rip), %eax  # 0xe <WI_updateShowNextLoc+0xe>\ne: \taddl\t$-1, %eax\n11: \tmovl\t%eax, (%rip)  # 0x17 <WI_updateShowNextLoc+0x17>\n17: \tje\t0x36 <WI_updateShowNextLoc+0x36>\n19: \tcmpq\t$0, (%rip)    # 0x21 <WI_updateShowNextLoc+0x21>\n21: \tjne\t0x36 <WI_updateShowNextLoc+0x36>\n23: \tandl\t$28, %eax\n26: \txorl\t%ecx, %ecx\n28: \tcmpl\t$20, %eax\n2b: \tsetb\t%cl\n2e: \tmovl\t%ecx, (%rip)  # 0x34 <WI_updateShowNextLoc+0x34>\n34: \tpopq\t%rax\n35: \tretq\n36: \txorl\t%eax, %eax\n38: \tpopq\t%rcx\n39: \tjmp\t0x3e <WI_updateShowNextLoc+0x3e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_initNoState () ;\nint /*<<< orphan*/  WI_updateAnimatedBack () ;\nscalar_t__ acceleratestage ;\nint cnt ;\nint snl_pointeron ;\n\nvoid WI_updateShowNextLoc(void)\n{\nWI_updateAnimatedBack();\n\nif (!--cnt || acceleratestage)\nWI_initNoState();\nelse\nsnl_pointeron = (cnt & 31) < 20;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WI_ShowNextLoc ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_updateShowNextLoc_ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WI_updateShowNextLoc_next ;\nint /*<<< orphan*/  WI_updateShowNextLoc_prev ;\nscalar_t__ WI_updateShowNextLoc_skip ;\n\nvoid WI_updateShowNextLoc(void)\n{\nWI_updateShowNextLoc_();\nWI_ShowNextLoc--;\nif (WI_ShowNextLoc == 0)\n{\nWI_ShowNextLoc = 20;\nWI_updateShowNextLoc_skip = 0;\nWI_updateShowNextLoc_prev = 0;\nWI_updateShowNextLoc_next = 0;\n}\nelse if (!WI_updateShowNextLoc_skip)\n{\nWI_updateShowNextLoc_prev = (WI_ShowNextLoc & 1) ? 1 : 0;\nWI_updateShowNextLoc_next = (WI_ShowNextLoc & 2) ? 1 : 0;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_FatRaise",
    "input":"\n0000000000000000 <A_FatRaise>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <A_FatRaise+0x9>\n9: \tmovl\t(%rip), %esi  # 0xf <A_FatRaise+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_FatRaise+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_manatk ;\n\nvoid A_FatRaise (mobj_t *actor)\n{\nA_FaceTarget (actor);\nS_StartSound (actor, sfx_manatk);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ARC_STATUS ;\ntypedef  int /*<<< orphan*/  ARC_DRIVE_OBJECT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FatCheckDrive (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ARC_FAT_ERROR ;\nint /*<<< orphan*/  A_SetError (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static VOID A_FatRaise(ARC_DRIVE_OBJECT* DriveObject)\n{\nA_FatCheckDrive(DriveObject);\n\nA_SetError(DriveObject, ARC_FAT_ERROR);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_T_Glow",
    "input":"\n0000000000000000 <T_Glow>:\n0: \tmovl\t(%rdi), %eax\n2: \tcmpl\t$1, %eax\n5: \tje\t0x2e <T_Glow+0x2e>\n7: \tcmpl\t$-1, %eax\na: \tjne\t0x4f <T_Glow+0x4f>\nc: \tmovq\t8(%rdi), %rax\n10: \tmovl\t(%rax), %ecx\n12: \tsubl\t(%rip), %ecx  # 0x18 <T_Glow+0x18>\n18: \tmovl\t%ecx, (%rax)\n1a: \tcmpl\t20(%rdi), %ecx\n1d: \tjg\t0x4f <T_Glow+0x4f>\n1f: \taddl\t(%rip), %ecx  # 0x25 <T_Glow+0x25>\n25: \tmovl\t%ecx, (%rax)\n27: \tmovl\t$1, (%rdi)\n2d: \tretq\n2e: \tmovq\t8(%rdi), %rax\n32: \tmovl\t(%rax), %ecx\n34: \taddl\t(%rip), %ecx  # 0x3a <T_Glow+0x3a>\n3a: \tmovl\t%ecx, (%rax)\n3c: \tcmpl\t16(%rdi), %ecx\n3f: \tjl\t0x4f <T_Glow+0x4f>\n41: \tsubl\t(%rip), %ecx  # 0x47 <T_Glow+0x47>\n47: \tmovl\t%ecx, (%rax)\n49: \tmovl\t$4294967295, (%rdi)# imm = 0xFFFFFFFF\n4f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int direction; TYPE_1__* sector; int /*<<< orphan*/  maxlight; int /*<<< orphan*/  minlight; } ;\ntypedef  TYPE_2__ glow_t ;\nstruct TYPE_4__ {int /*<<< orphan*/  lightlevel; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GLOWSPEED ;\n\nvoid T_Glow(glow_t*\tg)\n{\nswitch(g->direction)\n{\ncase -1:\n// DOWN\ng->sector->lightlevel -= GLOWSPEED;\nif (g->sector->lightlevel <= g->minlight)\n{\ng->sector->lightlevel += GLOWSPEED;\ng->direction = 1;\n}\nbreak;\n\ncase 1:\n// UP\ng->sector->lightlevel += GLOWSPEED;\nif (g->sector->lightlevel >= g->maxlight)\n{\ng->sector->lightlevel -= GLOWSPEED;\ng->direction = -1;\n}\nbreak;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int state; int /*<<< orphan*/  glow; int /*<<< orphan*/  glow_max; int /*<<< orphan*/  glow_min; } ;\ntypedef  TYPE_1__ TL_Glow ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GLOW_MAX ;\nint /*<<< orphan*/  GLOW_MIN ;\n\nvoid T_Glow(TL_Glow *glow)\n{\nif (glow->state == 1)\n{\nglow->glow += GLOW_MIN;\nif (glow->glow > glow->glow_max)\n{\nglow->glow = glow->glow_max;\nglow->state = -1;\n}\n}\nelse if (glow->state == -1)\n{\nglow->glow -= GLOW_MAX;\nif (glow->glow < glow->glow_min)\n{\nglow->glow = glow->glow_min;\nglow->state = 1;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_StopMessage",
    "input":"\n0000000000000000 <M_StopMessage>:\n0: \tmovl\t(%rip), %eax  # 0x6 <M_StopMessage+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <M_StopMessage+0xc>\nc: \tmovq\t$0, (%rip)    # 0x17 <M_StopMessage+0x17>\n17: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  menuactive ;\nint /*<<< orphan*/  messageLastMenuActive ;\nscalar_t__ messageToPrint ;\n\nvoid M_StopMessage(void)\n{\nmenuactive = messageLastMenuActive;\nmessageToPrint = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nscalar_t__ Message ;\nint /*<<< orphan*/  MessageState ;\n\nvoid M_StopMessage(void)\n{\nMessageState = FALSE;\nMessage = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_initBinIcon",
    "input":"\n0000000000000000 <STlib_initBinIcon>:\n0: \tmovl\t%esi, (%rdi)\n2: \tmovl\t%edx, 4(%rdi)\n5: \tmovq\t$0, 32(%rdi)\nd: \tmovq\t%r8, 24(%rdi)\n11: \tmovq\t%r9, 16(%rdi)\n15: \tmovq\t%rcx, 8(%rdi)\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int /*<<< orphan*/ * p; int /*<<< orphan*/ * on; int /*<<< orphan*/ * val; scalar_t__ oldval; } ;\ntypedef  TYPE_1__ st_binicon_t ;\ntypedef  int /*<<< orphan*/  patch_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\n\nvoid\nSTlib_initBinIcon\n( st_binicon_t*\t\tb,\nint\t\t\tx,\nint\t\t\ty,\npatch_t*\t\ti,\nboolean*\t\tval,\nboolean*\t\ton )\n{\nb->x\t= x;\nb->y\t= y;\nb->oldval\t= 0;\nb->val\t= val;\nb->on\t= on;\nb->p\t= i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  cbSize; int /*<<< orphan*/  dwFlags; int /*<<< orphan*/ * hIcon; int /*<<< orphan*/ * hIconSm; int /*<<< orphan*/ * hIconLarge; int /*<<< orphan*/ * hIconSmall; int /*<<< orphan*/ * hIconMask; } ;\ntypedef  TYPE_1__ STBINICON ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void STlib_initBinIcon(STBINICON *pbi, int dwFlags, int cbSize,\nint /*<<< orphan*/ * hIcon, int /*<<< orphan*/ * hIconSmall, int /*<<< orphan*/ * hIconLarge, int /*<<< orphan*/ * hIconMask)\n{\npbi->dwFlags = dwFlags;\npbi->cbSize = cbSize;\npbi->hIcon = hIcon;\npbi->hIconSmall = hIconSmall;\npbi->hIconLarge = hIconLarge;\npbi->hIconMask = hIconMask;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_misc.c_M_ScreenShot",
    "input":"\n0000000000000000 <M_ScreenShot>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovq\t(%rip), %rax  # 0xf <M_ScreenShot+0xf>\nf: \tmovq\t16(%rax), %r14\n13: \tmovq\t%r14, %rdi\n16: \tcallq\t0x1b <M_ScreenShot+0x1b>\n1b: \tleaq\t4(%rsp), %rbx\n20: \tmovl\t$0, %esi\n25: \tmovq\t%rbx, %rdi\n28: \tcallq\t0x2d <M_ScreenShot+0x2d>\n2d: \txorl\t%ebp, %ebp\n2f: \tnop\n30: \tmovzbl\t%bpl, %eax\n34: \timull\t$205, %eax, %eax\n3a: \tshrl\t$11, %eax\n3d: \tleal\t48(%rax), %ecx\n40: \taddl\t%eax, %eax\n42: \tleal\t(%rax,%rax,4), %eax\n45: \tmovb\t%cl, 8(%rsp)\n49: \tmovl\t%ebp, %ecx\n4b: \tsubl\t%eax, %ecx\n4d: \torb\t$48, %cl\n50: \tmovb\t%cl, 9(%rsp)\n54: \tmovq\t%rbx, %rdi\n57: \txorl\t%esi, %esi\n59: \tcallq\t0x5e <M_ScreenShot+0x5e>\n5e: \tcmpl\t$-1, %eax\n61: \tje\t0x75 <M_ScreenShot+0x75>\n63: \taddl\t$1, %ebp\n66: \tcmpl\t$100, %ebp\n69: \tjne\t0x30 <M_ScreenShot+0x30>\n6b: \tmovl\t$0, %edi\n70: \tcallq\t0x75 <M_ScreenShot+0x75>\n75: \tmovl\t(%rip), %ebx  # 0x7b <M_ScreenShot+0x7b>\n7b: \tmovl\t(%rip), %ebp  # 0x81 <M_ScreenShot+0x81>\n81: \tmovl\t(%rip), %esi  # 0x87 <M_ScreenShot+0x87>\n87: \tmovl\t$0, %edi\n8c: \tcallq\t0x91 <M_ScreenShot+0x91>\n91: \tleaq\t4(%rsp), %rdi\n96: \tmovq\t%r14, %rsi\n99: \tmovl\t%ebx, %edx\n9b: \tmovl\t%ebp, %ecx\n9d: \tmovl\t%eax, %r8d\na0: \tcallq\t0xa5 <M_ScreenShot+0xa5>\na5: \tmovq\t(%rip), %rax  # 0xac <M_ScreenShot+0xac>\nac: \tmovq\t(%rip), %rcx  # 0xb3 <M_ScreenShot+0xb3>\nb3: \tmovq\t$0, (%rax,%rcx,8)\nbb: \taddq\t$16, %rsp\nbf: \tpopq\t%rbx\nc0: \tpopq\t%r14\nc2: \tpopq\t%rbp\nc3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\nstruct TYPE_2__ {char* message; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint /*<<< orphan*/  I_ReadScreen (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  SCREENHEIGHT ;\nint /*<<< orphan*/  SCREENWIDTH ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WritePCXfile (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint access (char*,int /*<<< orphan*/ ) ;\nsize_t consoleplayer ;\nTYPE_1__* players ;\nint /*<<< orphan*/ ** screens ;\nint /*<<< orphan*/  strcpy (char*,char*) ;\n\nvoid M_ScreenShot (void)\n{\nint\t\ti;\nbyte*\tlinear;\nchar\tlbmname[12];\n\n// munge planar buffer to linear\nlinear = screens[2];\nI_ReadScreen (linear);\n\n// find a file name to save it to\nstrcpy(lbmname,\"DOOM00.pcx\");\n\nfor (i=0 ; i<=99 ; i++)\n{\nlbmname[4] = i/10 + '0';\nlbmname[5] = i%10 + '0';\nif (access(lbmname,0) == -1)\nbreak;\t// file doesn't exist\n}\nif (i==100)\nI_Error (\"M_ScreenShot: Couldn't create a PCX\");\n\n// save the pcx file\nWritePCXfile (lbmname, linear,\nSCREENWIDTH, SCREENHEIGHT,\nW_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\nplayers[consoleplayer].message = \"screen shot\";\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {char* screen_shot; int /*<<< orphan*/ * screen_shot_size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ;\nint /*<<< orphan*/  fwrite (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strlen (char*) ;\nint /*<<< orphan*/  strncpy (char*,char*,int) ;\nint /*<<< orphan*/  strtol (char*,int /*<<< orphan*/ *,int) ;\nTYPE_1__* user ;\nint /*<<< orphan*/  user_id ;\nint /*<<< orphan*/  user_pass ;\n\nvoid M_ScreenShot(void)\n{\nchar buf[100];\nint i;\n\nmemset(buf, 0, sizeof(buf));\nstrncpy(buf, \"0123456789\", 10);\nfor (i = 0; i < 100; i++)\n{\nint x = (i * 205) / 1024;\nbuf[8] = (x / 10) + '0';\nbuf[9] = (x % 10) + '0';\nif (fwrite(buf, 0, strlen(buf), user->screen_shot_size[user_id], user->screen_shot) == -1)\n{\nfprintf(stderr, \"Error writing to screen shot file\\n\");\nreturn;\n}\n}\nfprintf(stderr, \"Screen shot file written\\n\");\nfprintf(stderr, \"Screen shot file size: %ld\\n\", strtol(buf, NULL, 10));\nuser->screen_shot[user_id] = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_tick.c_P_RemoveThinker",
    "input":"\n0000000000000000 <P_RemoveThinker>:\n0: \tmovq\t$-1, (%rdi)\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ acv; } ;\nstruct TYPE_5__ {TYPE_1__ function; } ;\ntypedef  TYPE_2__ thinker_t ;\ntypedef  scalar_t__ actionf_v ;\n\n/* Variables and functions */\n\nvoid P_RemoveThinker (thinker_t* thinker)\n{\n// FIXME: NOP.\nthinker->function.acv = (actionf_v)(-1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ nextthink; } ;\ntypedef  TYPE_1__ thinker_t ;\n\n/* Variables and functions */\n\nvoid P_RemoveThinker(thinker_t *th)\n{\nth->nextthink = -1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_misc.c_M_DrawText",
    "input":"\n0000000000000000 <M_DrawText>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovl\t%edi, %ebx\nd: \tmovb\t(%rcx), %al\nf: \ttestb\t%al, %al\n11: \tje\t0xa2 <M_DrawText+0xa2>\n17: \tmovq\t%rcx, %r12\n1a: \tmovq\t%rdx, %r14\n1d: \tmovl\t%esi, %r15d\n20: \taddq\t$1, %r12\n24: \tjmp\t0x44 <M_DrawText+0x44>\n26: \tnopw\t%cs:(%rax,%rax)\n30: \taddl\t$4, %ebx\n33: \tmovl\t%ebx, %ebp\n35: \tmovzbl\t(%r12), %eax\n3a: \taddq\t$1, %r12\n3e: \tmovl\t%ebp, %ebx\n40: \ttestb\t%al, %al\n42: \tje\t0xa4 <M_DrawText+0xa4>\n44: \tmovsbl\t%al, %edi\n47: \tcallq\t0x4c <M_DrawText+0x4c>\n4c: \tsubl\t(%rip), %eax  # 0x52 <M_DrawText+0x52>\n52: \tjs\t0x30 <M_DrawText+0x30>\n54: \tcmpl\t(%rip), %eax  # 0x5a <M_DrawText+0x5a>\n5a: \tjg\t0x30 <M_DrawText+0x30>\n5c: \tmovq\t(%rip), %rcx  # 0x63 <M_DrawText+0x63>\n63: \tmovl\t%eax, %r13d\n66: \tmovq\t(%rcx,%r13,8), %rax\n6a: \tmovl\t(%rax), %edi\n6c: \tcallq\t0x71 <M_DrawText+0x71>\n71: \tmovl\t%eax, %ebp\n73: \taddl\t%ebx, %ebp\n75: \tcmpl\t(%rip), %ebp  # 0x7b <M_DrawText+0x7b>\n7b: \tjg\t0xa2 <M_DrawText+0xa2>\n7d: \tmovq\t(%rip), %rax  # 0x84 <M_DrawText+0x84>\n84: \tmovq\t(%rax,%r13,8), %rcx\n88: \tmovl\t%ebx, %edi\n8a: \tmovl\t%r15d, %esi\n8d: \txorl\t%edx, %edx\n8f: \ttestq\t%r14, %r14\n92: \tje\t0x9b <M_DrawText+0x9b>\n94: \tcallq\t0x99 <M_DrawText+0x99>\n99: \tjmp\t0x35 <M_DrawText+0x35>\n9b: \tcallq\t0xa0 <M_DrawText+0xa0>\na0: \tjmp\t0x35 <M_DrawText+0x35>\na2: \tmovl\t%ebx, %ebp\na4: \tmovl\t%ebp, %eax\na6: \taddq\t$8, %rsp\naa: \tpopq\t%rbx\nab: \tpopq\t%r12\nad: \tpopq\t%r13\naf: \tpopq\t%r14\nb1: \tpopq\t%r15\nb3: \tpopq\t%rbp\nb4: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ boolean ;\nstruct TYPE_4__ {int /*<<< orphan*/  width; } ;\n\n/* Variables and functions */\nint HU_FONTSIZE ;\nint HU_FONTSTART ;\nint SCREENWIDTH ;\nint SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,TYPE_1__*) ;\nTYPE_1__** hu_font ;\nint toupper (char) ;\n\nint\nM_DrawText\n( int\t\tx,\nint\t\ty,\nboolean\tdirect,\nchar*\t\tstring )\n{\nint \tc;\nint\t\tw;\n\nwhile (*string)\n{\nc = toupper(*string) - HU_FONTSTART;\nstring++;\nif (c < 0 || c> HU_FONTSIZE)\n{\nx += 4;\ncontinue;\n}\n\nw = SHORT (hu_font[c]->width);\nif (x+w > SCREENWIDTH)\nbreak;\nif (direct)\nV_DrawPatchDirect(x, y, 0, hu_font[c]);\nelse\nV_DrawPatch(x, y, 0, hu_font[c]);\nx+=w;\n}\n\nreturn x;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  UCHAR ;\nstruct TYPE_2__ {int /*<<< orphan*/  Font; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CHAR_HEIGHT ;\nint /*<<< orphan*/  CHAR_WIDTH ;\nint /*<<< orphan*/  CHAR_WIDTH_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_HALF ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_QUARTER ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_TWO_THIRD ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO ;\nint /*<<< orphan*/  CHAR_WIDTH_ZERO_ZERO_ZERO_ZERO_ZERO_ZERO_Z"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_SetMusicVolume",
    "input":"\n0000000000000000 <I_SetMusicVolume>:\n0: \tmovl\t%edi, (%rip)  # 0x6 <I_SetMusicVolume+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint snd_MusicVolume ;\n\nvoid I_SetMusicVolume(int volume)\n{\n// Internal state variable.\nsnd_MusicVolume = volume;\n// Now set volume on output device.\n// Whatever( snd_MusciVolume );\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint music_volume ;\n\nvoid I_SetMusicVolume(int volume)\n{\nmusic_volume = volume;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_net.c_GetLocalAddress",
    "input":"\n0000000000000000 <GetLocalAddress>:\n0: \tpushq\t%rbx\n1: \tsubq\t$1024, %rsp   # imm = 0x400\n8: \tmovq\t%rsp, %rdi\nb: \tmovl\t$1024, %esi   # imm = 0x400\n10: \tcallq\t0x15 <GetLocalAddress+0x15>\n15: \tcmpl\t$-1, %eax\n18: \tjne\t0x2c <GetLocalAddress+0x2c>\n1a: \tmovl\t(%rip), %esi  # 0x20 <GetLocalAddress+0x20>\n20: \tmovl\t$0, %edi\n25: \txorl\t%eax, %eax\n27: \tcallq\t0x2c <GetLocalAddress+0x2c>\n2c: \tmovq\t%rsp, %rdi\n2f: \tcallq\t0x34 <GetLocalAddress+0x34>\n34: \tmovq\t%rax, %rbx\n37: \ttestq\t%rax, %rax\n3a: \tjne\t0x48 <GetLocalAddress+0x48>\n3c: \tmovl\t$0, %edi\n41: \txorl\t%eax, %eax\n43: \tcallq\t0x48 <GetLocalAddress+0x48>\n48: \tmovq\t(%rbx), %rax\n4b: \tmovq\t(%rax), %rax\n4e: \tmovl\t(%rax), %eax\n50: \taddq\t$1024, %rsp   # imm = 0x400\n57: \tpopq\t%rbx\n58: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct hostent {scalar_t__* h_addr_list; } ;\ntypedef  int /*<<< orphan*/  hostname ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,...) ;\nint /*<<< orphan*/  errno ;\nstruct hostent* gethostbyname (char*) ;\nint gethostname (char*,int) ;\n\nint GetLocalAddress (void)\n{\nchar\t\thostname[1024];\nstruct hostent*\thostentry;\t// host information entry\nint\t\t\tv;\n\n// get local address\nv = gethostname (hostname, sizeof(hostname));\nif (v == -1)\nI_Error (\"GetLocalAddress : gethostname: errno %d\",errno);\n\nhostentry = gethostbyname (hostname);\nif (!hostentry)\nI_Error (\"GetLocalAddress : gethostbyname: couldn't get local host\");\n\nreturn *(int *)hostentry->h_addr_list[0];\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr_in {int /*<<< orphan*/  sin_addr; } ;\nstruct sockaddr {TYPE_1__* sa_data; } ;\nstruct hostent {scalar_t__ h_addr; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\nstruct hostent* gethostbyname (char*) ;\nint /*<<< orphan*/  memset (struct sockaddr*,int,int) ;\nint /*<<< orphan*/  sprintf (char*,char*,char*) ;\n\nint GetLocalAddress(char *ip)\n{\nstruct sockaddr_in addr;\nstruct hostent *host;\nchar hostname[1024];\n\nmemset(&addr, 0, sizeof(addr));\naddr.sin_family = AF_INET;\n\nif ((host = gethostbyname(\"localhost\")) == NULL)\n{\nfprintf(stderr, \"gethostbyname: %s\\n\", strerror(errno));\nreturn -1;\n}\n\nsprintf(hostname, \"%s\", host->h_addr);\n\naddr.sin_addr.s_addr = *(unsigned long *) host->h_addr;\n\nreturn (int) addr.sin_addr.s_addr;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_unloadData",
    "input":"\n0000000000000000 <ST_unloadData>:\n0: \txorl\t%eax, %eax\n2: \tjmp\t0x7 <ST_unloadData+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_unloadGraphics () ;\n\nvoid ST_unloadData(void)\n{\nST_unloadGraphics();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ST_Handle ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_free (int /*<<< orphan*/ ) ;\n\nvoid ST_unloadData(ST_Handle h)\n{\nST_free(h);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_net.c_BindToLocalPort",
    "input":"\n0000000000000000 <BindToLocalPort>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovl\t%esi, %ebx\na: \tmovl\t%edi, %ebp\nc: \tmovq\t%rsp, %r14\nf: \tmovq\t%r14, %rdi\n12: \txorl\t%esi, %esi\n14: \tmovl\t$12, %edx\n19: \tcallq\t0x1e <BindToLocalPort+0x1e>\n1e: \tmovl\t(%rip), %eax  # 0x24 <BindToLocalPort+0x24>\n24: \tmovl\t%eax, 8(%rsp)\n28: \tmovl\t(%rip), %eax  # 0x2e <BindToLocalPort+0x2e>\n2e: \tmovl\t%eax, 4(%rsp)\n32: \tmovl\t%ebx, (%rsp)\n35: \tmovl\t%ebp, %edi\n37: \tmovq\t%r14, %rsi\n3a: \tmovl\t$12, %edx\n3f: \tcallq\t0x44 <BindToLocalPort+0x44>\n44: \tcmpl\t$-1, %eax\n47: \tjne\t0x60 <BindToLocalPort+0x60>\n49: \tmovl\t(%rip), %edi  # 0x4f <BindToLocalPort+0x4f>\n4f: \tcallq\t0x54 <BindToLocalPort+0x54>\n54: \tmovl\t$0, %edi\n59: \tmovl\t%eax, %esi\n5b: \tcallq\t0x60 <BindToLocalPort+0x60>\n60: \taddq\t$16, %rsp\n64: \tpopq\t%rbx\n65: \tpopq\t%r14\n67: \tpopq\t%rbp\n68: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  s_addr; } ;\nstruct sockaddr_in {int sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;\ntypedef  int /*<<< orphan*/  address ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  INADDR_ANY ;\nint /*<<< orphan*/  I_Error (char*,int /*<<< orphan*/ ) ;\nint bind (int,void*,int) ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  memset (struct sockaddr_in*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\n\nvoid\nBindToLocalPort\n( int\ts,\nint\tport )\n{\nint\t\t\tv;\nstruct sockaddr_in\taddress;\n\nmemset (&address, 0, sizeof(address));\naddress.sin_family = AF_INET;\naddress.sin_addr.s_addr = INADDR_ANY;\naddress.sin_port = port;\n\nv = bind (s, (void *)&address, sizeof(address));\nif (v == -1)\nI_Error (\"BindToPort: bind: %s\", strerror(errno));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_in {int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_addr; } ;\ntypedef  int /*<<< orphan*/  SOCKET ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint /*<<< orphan*/  SOCK_TYPE ;\nint /*<<< orphan*/  SOCK_PROTO ;\nint /*<<< orphan*/  SOCK_ADDR ;\nint /*<<< orphan*/  SOCK_PORT ;\nint /*<<< orphan*/  closesocket (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  htons (int) ;\nint /*<<< orphan*/  socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strlen (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (struct sockaddr_in*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  printf (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sprintf (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strncpy (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid BindToLocalPort(SOCKET sock, int port)\n{\nstruct sockaddr_in addr;\n\nmemset(&addr, 0, sizeof(addr));\naddr.sin_family = AF_INET;\naddr.sin_port = htons(port);\naddr.sin_addr.s_addr = SOCK_ADDR;\n\nif (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)\n{\nclosesocket(sock);\nfprintf(stderr, \"bind() failed: %s\\n\", strerror(errno));\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawLF",
    "input":"\n0000000000000000 <WI_drawLF>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t(%rip), %ebx  # 0x9 <WI_drawLF+0x9>\n9: \tmovl\t(%rip), %ebp  # 0xf <WI_drawLF+0xf>\nf: \tmovq\t(%rip), %rax  # 0x16 <WI_drawLF+0x16>\n16: \tmovq\t(%rip), %rcx  # 0x1d <WI_drawLF+0x1d>\n1d: \tmovq\t(%rcx), %rcx\n20: \tmovq\t(%rax,%rcx,8), %rax\n24: \tmovl\t(%rax), %edi\n26: \tcallq\t0x2b <WI_drawLF+0x2b>\n2b: \tsubl\t%eax, %ebp\n2d: \tmovl\t%ebp, %edi\n2f: \tshrl\t$31, %edi\n32: \taddl\t%ebp, %edi\n34: \tsarl\t%edi\n36: \tmovl\t(%rip), %edx  # 0x3c <WI_drawLF+0x3c>\n3c: \tmovq\t(%rip), %rax  # 0x43 <WI_drawLF+0x43>\n43: \tmovq\t(%rip), %rcx  # 0x4a <WI_drawLF+0x4a>\n4a: \tmovq\t(%rcx), %rcx\n4d: \tmovq\t(%rax,%rcx,8), %rcx\n51: \tmovl\t%ebx, %esi\n53: \tcallq\t0x58 <WI_drawLF+0x58>\n58: \tmovq\t(%rip), %rax  # 0x5f <WI_drawLF+0x5f>\n5f: \tmovq\t(%rip), %rcx  # 0x66 <WI_drawLF+0x66>\n66: \tmovq\t(%rcx), %rcx\n69: \tmovq\t(%rax,%rcx,8), %rax\n6d: \tmovl\t4(%rax), %edi\n70: \tcallq\t0x75 <WI_drawLF+0x75>\n75: \tleal\t(%rax,%rax,4), %ecx\n78: \tleal\t(%rax,%rax,4), %ebp\n7b: \taddl\t$3, %ebp\n7e: \ttestl\t%ecx, %ecx\n80: \tcmovnsl\t%ecx, %ebp\n83: \tsarl\t$2, %ebp\n86: \taddl\t%ebx, %ebp\n88: \tmovl\t(%rip), %ebx  # 0x8e <WI_drawLF+0x8e>\n8e: \tmovq\t(%rip), %rax  # 0x95 <WI_drawLF+0x95>\n95: \tmovl\t(%rax), %edi\n97: \tcallq\t0x9c <WI_drawLF+0x9c>\n9c: \tsubl\t%eax, %ebx\n9e: \tmovl\t%ebx, %edi\na0: \tshrl\t$31, %edi\na3: \taddl\t%ebx, %edi\na5: \tsarl\t%edi\na7: \tmovl\t(%rip), %edx  # 0xad <WI_drawLF+0xad>\nad: \tmovq\t(%rip), %rcx  # 0xb4 <WI_drawLF+0xb4>\nb4: \tmovl\t%ebp, %esi\nb6: \taddq\t$8, %rsp\nba: \tpopq\t%rbx\nbb: \tpopq\t%rbp\nbc: \tjmp\t0xc1 <WI_drawLF+0xc1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  width; int /*<<< orphan*/  height; } ;\nstruct TYPE_5__ {size_t last; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FB ;\nint SCREENWIDTH ;\nint SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,TYPE_2__*) ;\nint WI_TITLEY ;\nTYPE_2__* finished ;\nTYPE_2__** lnames ;\nTYPE_1__* wbs ;\n\nvoid WI_drawLF(void)\n{\nint y = WI_TITLEY;\n\n// draw <LevelName>\nV_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->last]->width))/2,\ny, FB, lnames[wbs->last]);\n\n// draw \"Finished!\"\ny += (5*SHORT(lnames[wbs->last]->height))/4;\n\nV_DrawPatch((SCREENWIDTH - SHORT(finished->width))/2,\ny, FB, finished);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawLine (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WI_drawPixel (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WI_getX () ;\nint /*<<< orphan*/  WI_getY () ;\nTYPE_1__** WI_get_cursor_pos ;\nint WI_get_cursor_pos_x ;\nint WI_get_cursor_pos_y ;\nint WI_get_font_height () ;\nint WI_get_font_width () ;\nint /*<<< orphan*/  WI_get_screen_width () ;\n\nvoid WI_drawLF(void)\n{\nint x, y;\n\nx = WI_get_cursor_pos_x;\ny = WI_get_cursor_pos_y;\n\nWI_drawLine(WI_get_cursor_pos[0]->y, x, WI_get_screen_width());\nWI_drawPixel(WI_get_cursor_pos[0]->x, y + WI_get_font_height() / 2 + 1, WI_getY());\n\nWI_get_cursor_pos_y += WI_get_font_height() + 1;\nWI_get_cursor_pos_x = WI_get_cursor_pos[0]->x;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_v_video.c_V_DrawPatchDirect",
    "input":"\n0000000000000000 <V_DrawPatchDirect>:\n0: \tjmp\t0x5 <V_DrawPatchDirect+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  patch_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  V_DrawPatch (int,int,int,int /*<<< orphan*/ *) ;\n\nvoid\nV_DrawPatchDirect\n( int\t\tx,\nint\t\ty,\nint\t\tscrn,\npatch_t*\tpatch )\n{\nV_DrawPatch (x,y,scrn, patch);\n\n/*\nint\t\tcount;\nint\t\tcol;\ncolumn_t*\tcolumn;\nbyte*\tdesttop;\nbyte*\tdest;\nbyte*\tsource;\nint\t\tw;\n\ny -= SHORT(patch->topoffset);\nx -= SHORT(patch->leftoffset);\n\n#ifdef RANGECHECK\nif (x<0\n||x+SHORT(patch->width) >SCREENWIDTH\n|| y<0\n|| y+SHORT(patch->height)>SCREENHEIGHT\n|| (unsigned)scrn>4)\n{\nI_Error (\"Bad V_DrawPatchDirect\");\n}\n#endif\n\n//\tV_MarkRect (x, y, SHORT(patch->width), SHORT(patch->height));\ndesttop = destscreen + y*SCREENWIDTH/4 + (x>>2);\n\nw = SHORT(patch->width);\nfor ( col = 0 ; col<w ; col++)\n{\noutp (SC_INDEX+1,1<<(x&3));\ncolumn = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));\n\n// step through the posts in a column\n\nwhile (column->topdelta != 0xff )\n{\nsource = (byte *)column + 3;\ndest = desttop + column->topdelta*SCREENWIDTH/4;\ncount = column->length;\n\nwhile (count--)\n{\n*dest = *source++;\ndest += SCREENWIDTH/4;\n}\ncolumn = (column_t *)(  (byte *)column + column->length\n+ 4 );\n}\nif ( ((++x)&3) == 0 )\ndesttop++;\t// go to next byte, not next plane\n}*/\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  patchnum_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t_t ;\ntypedef  int /*<<< orphan*/  patchnum_t_t_t_t_t_t_t_t_t"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_restoreScaleAndLoc",
    "input":"\n0000000000000000 <AM_restoreScaleAndLoc>:\n0: \tpushq\t%rax\n1: \tmovslq\t(%rip), %rsi  # 0x8 <AM_restoreScaleAndLoc+0x8>\n8: \tmovl\t%esi, (%rip)  # 0xe <AM_restoreScaleAndLoc+0xe>\ne: \tmovslq\t(%rip), %rax  # 0x15 <AM_restoreScaleAndLoc+0x15>\n15: \tmovl\t%eax, (%rip)  # 0x1b <AM_restoreScaleAndLoc+0x1b>\n1b: \tcmpl\t$0, (%rip)    # 0x22 <AM_restoreScaleAndLoc+0x22>\n22: \tje\t0x5c <AM_restoreScaleAndLoc+0x5c>\n24: \tmovq\t(%rip), %rcx  # 0x2b <AM_restoreScaleAndLoc+0x2b>\n2b: \tmovq\t(%rcx), %rdx\n2e: \tmovq\t8(%rdx), %rcx\n32: \tmovl\t%esi, %edi\n34: \tshrl\t$31, %edi\n37: \taddl\t%esi, %edi\n39: \tsarl\t%edi\n3b: \tmovslq\t%edi, %rdi\n3e: \tsubq\t%rdi, %rcx\n41: \tmovq\t%rcx, (%rip)  # 0x48 <AM_restoreScaleAndLoc+0x48>\n48: \tmovq\t(%rdx), %rdx\n4b: \tmovl\t%eax, %edi\n4d: \tshrl\t$31, %edi\n50: \taddl\t%eax, %edi\n52: \tsarl\t%edi\n54: \tmovslq\t%edi, %rdi\n57: \tsubq\t%rdi, %rdx\n5a: \tjmp\t0x71 <AM_restoreScaleAndLoc+0x71>\n5c: \tmovq\t(%rip), %rcx  # 0x63 <AM_restoreScaleAndLoc+0x63>\n63: \tmovq\t%rcx, (%rip)  # 0x6a <AM_restoreScaleAndLoc+0x6a>\n6a: \tmovq\t(%rip), %rdx  # 0x71 <AM_restoreScaleAndLoc+0x71>\n71: \tmovq\t%rdx, (%rip)  # 0x78 <AM_restoreScaleAndLoc+0x78>\n78: \taddq\t%rsi, %rcx\n7b: \tmovq\t%rcx, (%rip)  # 0x82 <AM_restoreScaleAndLoc+0x82>\n82: \taddq\t%rdx, %rax\n85: \tmovq\t%rax, (%rip)  # 0x8c <AM_restoreScaleAndLoc+0x8c>\n8c: \tmovl\t(%rip), %edi  # 0x92 <AM_restoreScaleAndLoc+0x92>\n92: \tmovb\t(%rip), %cl   # 0x98 <AM_restoreScaleAndLoc+0x98>\n98: \tshll\t%cl, %edi\n9a: \tcallq\t0x9f <AM_restoreScaleAndLoc+0x9f>\n9f: \tmovl\t%eax, (%rip)  # 0xa5 <AM_restoreScaleAndLoc+0xa5>\na5: \tmovl\t(%rip), %edi  # 0xab <AM_restoreScaleAndLoc+0xab>\nab: \tmovl\t%eax, %esi\nad: \tcallq\t0xb2 <AM_restoreScaleAndLoc+0xb2>\nb2: \tmovq\t%rax, (%rip)  # 0xb9 <AM_restoreScaleAndLoc+0xb9>\nb9: \tpopq\t%rax\nba: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {TYPE_1__* mo; } ;\nstruct TYPE_3__ {scalar_t__ y; scalar_t__ x; } ;\n\n/* Variables and functions */\nint FRACBITS ;\nint FRACUNIT ;\nvoid* FixedDiv (int,int) ;\nint f_w ;\nint /*<<< orphan*/  followplayer ;\nint m_h ;\nint m_w ;\nscalar_t__ m_x ;\nscalar_t__ m_x2 ;\nscalar_t__ m_y ;\nscalar_t__ m_y2 ;\nint old_m_h ;\nint old_m_w ;\nscalar_t__ old_m_x ;\nscalar_t__ old_m_y ;\nTYPE_2__* plr ;\nvoid* scale_ftom ;\nint scale_mtof ;\n\nvoid AM_restoreScaleAndLoc(void)\n{\n\nm_w = old_m_w;\nm_h = old_m_h;\nif (!followplayer)\n{\nm_x = old_m_x;\nm_y = old_m_y;\n} else {\nm_x = plr->mo->x - m_w/2;\nm_y = plr->mo->y - m_h/2;\n}\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\n\n// Change the scaling multipliers\nscale_mtof = FixedDiv(f_w<<FRACBITS, m_w);\nscale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; } ;\n\n/* Variables and functions */\nint AM_scale ;\nint AM_scaleX ;\nint AM_scaleY ;\nint AM_x ;\nint AM_y ;\nint /*<<< orphan*/  AM_x_ ;\nint /*<<< orphan*/  AM_y_ ;\nTYPE_1__* AM_window ;\nscalar_t__ AM_window_x ;\nscalar_t__ AM_window_y ;\nint /*<<< orphan*/  AM_window_x_ ;\nint /*<<< orphan*/  AM_window_y_ ;\nint /*<<< orphan*/  AM_window_y_scaled ;\nint /*<<< orphan*/  AM_window_x_scaled ;\nint /*<<< orphan*/  AM_window_x_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;\nint /*<<< orphan*/  AM_window_y_scaled_ ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawEmptyCell",
    "input":"\n0000000000000000 <M_DrawEmptyCell>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rdi), %rax\n7: \tmovq\t8(%rdi), %rbx\nb: \taddq\t$-10, %rbx\nf: \tmovslq\t(%rip), %rcx  # 0x16 <M_DrawEmptyCell+0x16>\n16: \tmovslq\t%esi, %rdx\n19: \timulq\t%rcx, %rdx\n1d: \tleaq\t(%rax,%rdx), %r14\n21: \taddq\t$-1, %r14\n25: \tmovl\t(%rip), %esi  # 0x2b <M_DrawEmptyCell+0x2b>\n2b: \tmovl\t$0, %edi\n30: \tcallq\t0x35 <M_DrawEmptyCell+0x35>\n35: \tmovq\t%rbx, %rdi\n38: \tmovq\t%r14, %rsi\n3b: \txorl\t%edx, %edx\n3d: \tmovl\t%eax, %ecx\n3f: \taddq\t$8, %rsp\n43: \tpopq\t%rbx\n44: \tpopq\t%r14\n46: \tjmp\t0x4b <M_DrawEmptyCell+0x4b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_1__ menu_t ;\n\n/* Variables and functions */\nint LINEHEIGHT ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (scalar_t__,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid\nM_DrawEmptyCell\n( menu_t*\tmenu,\nint\t\titem )\n{\nV_DrawPatchDirect (menu->x - 10,        menu->y+item*LINEHEIGHT - 1, 0,\nW_CacheLumpName(\"M_CELL1\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* pb; int* pb_end; } ;\ntypedef  TYPE_1__ M_Draw ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawLine (int*,int*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_Draw_Color ;\nint M_Draw_LineWidth ;\nint /*<<< orphan*/  printf (char*,int,int,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void M_DrawEmptyCell(M_Draw *this, int x)\n{\nint *p = this->pb;\nint *p_end = this->pb_end - 10;\n\nprintf(\"M_DrawEmptyCell(%d)\\n\", x);\n\nM_DrawLine(p, p_end, M_Draw_Color, M_Draw_LineWidth);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_tick.c_P_AllocateThinker",
    "input":"\n0000000000000000 <P_AllocateThinker>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  thinker_t ;\n\n/* Variables and functions */\n\nvoid P_AllocateThinker (thinker_t*\tthinker)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  thinker_t ;\n\n/* Variables and functions */\n\nvoid P_AllocateThinker(void)\n{\n//\tthinker_t *thinker;\n\n//\tthinker = Z_Malloc(sizeof(*thinker), PU_LEVEL, NULL);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_Raise",
    "input":"\n0000000000000000 <A_Raise>:\n0: \tmovq\t(%rsi), %rcx\n3: \tsubq\t(%rip), %rcx  # 0xa <A_Raise+0xa>\na: \tmovq\t%rcx, (%rsi)\nd: \tmovq\t(%rip), %rax  # 0x14 <A_Raise+0x14>\n14: \tcmpq\t%rax, %rcx\n17: \tjle\t0x1a <A_Raise+0x1a>\n19: \tretq\n1a: \tmovq\t%rax, (%rsi)\n1d: \tmovq\t(%rip), %rax  # 0x24 <A_Raise+0x24>\n24: \tmovq\t(%rdi), %rcx\n27: \tmovl\t(%rax,%rcx,4), %edx\n2a: \tmovl\t(%rip), %esi  # 0x30 <A_Raise+0x30>\n30: \tjmp\t0x35 <A_Raise+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  statenum_t ;\nstruct TYPE_7__ {scalar_t__ sy; } ;\ntypedef  TYPE_1__ pspdef_t ;\nstruct TYPE_8__ {size_t readyweapon; } ;\ntypedef  TYPE_2__ player_t ;\nstruct TYPE_9__ {int /*<<< orphan*/  readystate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_SetPsprite (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nscalar_t__ RAISESPEED ;\nscalar_t__ WEAPONTOP ;\nint /*<<< orphan*/  ps_weapon ;\nTYPE_3__* weaponinfo ;\n\nvoid\nA_Raise\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nstatenum_t\tnewstate;\n\npsp->sy -= RAISESPEED;\n\nif (psp->sy > WEAPONTOP )\nreturn;\n\npsp->sy = WEAPONTOP;\n\n// The weapon has been raised all the way,\n//  so change to the ready state.\nnewstate = weaponinfo[player->readyweapon].readystate;\n\nP_SetPsprite (player, ps_weapon, newstate);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t a; } ;\ntypedef  TYPE_1__* Pcfa ;\ntypedef  int /*<<< orphan*/  Pcfa_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Raise_State ;\nsize_t A_Raise_State_Count ;\nint /*<<< orphan*/ * A_Raise_State_Table ;\nsize_t A_Raise_State_Top ;\n\n__attribute__((used)) static void A_Raise(Pcfa* pcfa, Pcfa_State* state)\n{\nsize_t a = pcfa->a - A_Raise_State_Top;\nif (a <= 0)\n{\npcfa->a = A_Raise_State_Top;\n}\nelse\n{\npcfa->a = a;\n*state = A_Raise_State_Table[a];\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_InitPlayer",
    "input":"\n0000000000000000 <G_InitPlayer>:\n0: \tjmp\t0x5 <G_InitPlayer+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_PlayerReborn (int) ;\nint /*<<< orphan*/ * players ;\n\nvoid G_InitPlayer (int player)\n{\nplayer_t*\tp;\n\n// set up the saved info\np = &players[player];\n\n// clear everything else to defaults\nG_PlayerReborn (player);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_InitPlayer_C (int /*<<< orphan*/ ) ;\n\nvoid G_InitPlayer(UBYTE player)\n{\nG_InitPlayer_C(player);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_CacheLumpName",
    "input":"\n0000000000000000 <W_CacheLumpName>:\n0: \tpushq\t%rbx\n1: \tmovl\t%esi, %ebx\n3: \tcallq\t0x8 <W_CacheLumpName+0x8>\n8: \tmovl\t%eax, %edi\na: \tmovl\t%ebx, %esi\nc: \tpopq\t%rbx\nd: \tjmp\t0x12 <W_CacheLumpName+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nvoid* W_CacheLumpNum (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  W_GetNumForName (char*) ;\n\nvoid*\nW_CacheLumpName\n( char*\t\tname,\nint\t\ttag )\n{\nreturn W_CacheLumpNum (W_GetNumForName(name), tag);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lumpnum_t ;\ntypedef  int /*<<< orphan*/  const char ;\n\n/* Variables and functions */\nint /*<<< orphan*/  W_LumpName (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_ReadLumpName (int /*<<< orphan*/ ,int /*<<< orphan*/  const) ;\n\nvoid W_CacheLumpName(lumpnum_t lump, const char *name)\n{\nW_ReadLumpName(W_LumpName(lump), name);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_HU_Init",
    "input":"\n0000000000000000 <HU_Init>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tcmpq\t$0, (%rip)    # 0x11 <HU_Init+0x11>\n11: \tmovl\t$0, %eax\n16: \tmovl\t$0, %ecx\n1b: \tcmoveq\t%rax, %rcx\n1f: \tmovl\t(%rcx), %eax\n21: \tmovl\t%eax, (%rip)  # 0x27 <HU_Init+0x27>\n27: \tcmpl\t$0, (%rip)    # 0x2e <HU_Init+0x2e>\n2e: \tjle\t0x7a <HU_Init+0x7a>\n30: \tmovl\t(%rip), %r14d # 0x37 <HU_Init+0x37>\n37: \txorl\t%ebx, %ebx\n39: \tleaq\t7(%rsp), %r15\n3e: \tnop\n40: \tleal\t(%r14,%rbx), %edx\n44: \tmovl\t$0, %esi\n49: \tmovq\t%r15, %rdi\n4c: \tcallq\t0x51 <HU_Init+0x51>\n51: \tmovl\t(%rip), %esi  # 0x57 <HU_Init+0x57>\n57: \tmovq\t%r15, %rdi\n5a: \tcallq\t0x5f <HU_Init+0x5f>\n5f: \tmovq\t(%rip), %rcx  # 0x66 <HU_Init+0x66>\n66: \tmovq\t%rax, (%rcx,%rbx,8)\n6a: \taddq\t$1, %rbx\n6e: \tmovslq\t(%rip), %rax  # 0x75 <HU_Init+0x75>\n75: \tcmpq\t%rax, %rbx\n78: \tjl\t0x40 <HU_Init+0x40>\n7a: \taddq\t$16, %rsp\n7e: \tpopq\t%rbx\n7f: \tpopq\t%r14\n81: \tpopq\t%r15\n83: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  patch_t ;\n\n/* Variables and functions */\nint HU_FONTSIZE ;\nint HU_FONTSTART ;\nint /*<<< orphan*/  PU_STATIC ;\nscalar_t__ W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  english_shiftxform ;\nscalar_t__ french ;\nint /*<<< orphan*/  french_shiftxform ;\nint /*<<< orphan*/ ** hu_font ;\nint /*<<< orphan*/  shiftxform ;\nint /*<<< orphan*/  sprintf (char*,char*,int /*<<< orphan*/ ) ;\n\nvoid HU_Init(void)\n{\n\nint\t\ti;\nint\t\tj;\nchar\tbuffer[9];\n\nif (french)\nshiftxform = french_shiftxform;\nelse\nshiftxform = english_shiftxform;\n\n// load the heads-up font\nj = HU_FONTSTART;\nfor (i=0;i<HU_FONTSIZE;i++)\n{\nsprintf(buffer, \"STCFN%.3d\", j++);\nhu_font[i] = (patch_t *) W_CacheLumpName(buffer, PU_STATIC);\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HU_Node ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_NODE_SIZE ;\nint /*<<< orphan*/  HU_NODE_TYPE_EMPTY ;\nint /*<<< orphan*/  HU_NODE_TYPE_FULL ;\nint /*<<< orphan*/  HU_NODE_TYPE_LEAF ;\nint /*<<< orphan*/  HU_NODE_TYPE_ROOT ;\nint /*<<< orphan*/ * HU_Node_Pool ;\nint HU_Node_Pool_Size ;\nint /*<<< orphan*/  HU_Node_Pool_Type ;\nint /*<<< orphan*/  HU_Node_Pool_Type_Empty ;\nint /*<<< orphan*/  HU_Node_Pool_Type_Full ;\nint /*<<< orphan*/  HU_Node_Pool_Type_Leaf ;\nint /*<<< orphan*/  HU_Node_Pool_Type_Root ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * pool_alloc (int /*<<< orphan*/ *) ;\n\nvoid HU_Init(void)\n{\nHU_Node_Pool_Type = HU_Node_Pool_Type_Empty;\nif (HU_Node_Pool_Size > 0)\n{\nint i;\nHU_Node *node;\nfor (i = 0; i < HU_Node_Pool_Size; i++)\n{\nnode = pool_alloc(&HU_Node_Pool[i]);\nmemset(node, HU_NODE_TYPE_EMPTY, HU_NODE_SIZE);\nHU_Node_Pool[i] = node;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_v_video.c_V_CopyRect",
    "input":"\n0000000000000000 <V_CopyRect>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovl\t%r9d, %ebp\ne: \tmovl\t%r8d, %r14d\n11: \tmovl\t%ecx, %r12d\n14: \tmovl\t%edx, %r13d\n17: \tmovl\t%esi, %r15d\n1a: \tmovl\t%edi, 4(%rsp)\n1e: \tmovl\t64(%rsp), %ebx\n22: \tmovl\t%r9d, %edi\n25: \tmovl\t%ebx, %esi\n27: \tmovl\t%ecx, %edx\n29: \tmovl\t%r8d, %ecx\n2c: \tcallq\t0x31 <V_CopyRect+0x31>\n31: \ttestl\t%r14d, %r14d\n34: \tjle\t0xa8 <V_CopyRect+0xa8>\n36: \tmovq\t(%rip), %rax  # 0x3d <V_CopyRect+0x3d>\n3d: \tmovl\t(%rip), %ecx  # 0x43 <V_CopyRect+0x43>\n43: \tmovslq\t72(%rsp), %rdx\n48: \timull\t%ecx, %ebx\n4b: \tmovslq\t%ebx, %rsi\n4e: \tshlq\t$2, %rsi\n52: \taddq\t(%rax,%rdx,8), %rsi\n56: \tmovslq\t%ebp, %rdx\n59: \tmovslq\t%r13d, %rdi\n5c: \timull\t%ecx, %r15d\n60: \tmovslq\t%r15d, %rcx\n63: \tshlq\t$2, %rcx\n67: \taddq\t(%rax,%rdi,8), %rcx\n6b: \tleaq\t(%rsi,%rdx,4), %rbp\n6f: \tmovslq\t4(%rsp), %rax\n74: \tleaq\t(%rcx,%rax,4), %rbx\n78: \taddl\t$1, %r14d\n7c: \tnopl\t(%rax)\n80: \tmovq\t%rbp, %rdi\n83: \tmovq\t%rbx, %rsi\n86: \tmovl\t%r12d, %edx\n89: \tcallq\t0x8e <V_CopyRect+0x8e>\n8e: \tmovslq\t(%rip), %rax  # 0x95 <V_CopyRect+0x95>\n95: \tleaq\t(%rbx,%rax,4), %rbx\n99: \tleaq\t(%rbp,%rax,4), %rbp\n9e: \taddl\t$-1, %r14d\na2: \tcmpl\t$1, %r14d\na6: \tjg\t0x80 <V_CopyRect+0x80>\na8: \taddq\t$8, %rsp\nac: \tpopq\t%rbx\nad: \tpopq\t%r12\naf: \tpopq\t%r13\nb1: \tpopq\t%r14\nb3: \tpopq\t%r15\nb5: \tpopq\t%rbp\nb6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/  V_MarkRect (int,int,int,int) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ ** screens ;\n\nvoid\nV_CopyRect\n( int\t\tsrcx,\nint\t\tsrcy,\nint\t\tsrcscrn,\nint\t\twidth,\nint\t\theight,\nint\t\tdestx,\nint\t\tdesty,\nint\t\tdestscrn )\n{\nbyte*\tsrc;\nbyte*\tdest;\n\n#ifdef RANGECHECK\nif (srcx<0\n||srcx+width >SCREENWIDTH\n|| srcy<0\n|| srcy+height>SCREENHEIGHT\n||destx<0||destx+width >SCREENWIDTH\n|| desty<0\n|| desty+height>SCREENHEIGHT\n|| (unsigned)srcscrn>4\n|| (unsigned)destscrn>4)\n{\nI_Error (\"Bad V_CopyRect\");\n}\n#endif\nV_MarkRect (destx, desty, width, height);\n\nsrc = screens[srcscrn]+SCREENWIDTH*srcy+srcx;\ndest = screens[destscrn]+SCREENWIDTH*desty+destx;\n\nfor ( ; height>0 ; height--)\n{\nmemcpy (dest, src, width);\nsrc += SCREENWIDTH;\ndest += SCREENWIDTH;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  PVOID ;\ntypedef  int /*<<< orphan*/  PCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CopyMemory (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  RtlZeroMemory (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * V_Buffer ;\nint V_BytesPerLine ;\n\nVOID\nV_CopyRect(ULONG SourceX, ULONG SourceY, ULONG DestX, ULONG DestY, ULONG Width, ULONG Height)\n{\nPCHAR Source = V_Buffer[SourceY] + SourceX * V_BytesPerLine;\nPCHAR Dest = V_Buffer[DestY] + DestX * V_BytesPerLine;\n\nRtlZeroMemory(Dest, Width * V_BytesPerLine);\n\nwhile (Height--)\n{\nCopyMemory(Dest, Source, Width * V_BytesPerLine);\n\nSource += V_BytesPerLine;\nDest += V_BytesPerLine;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_PIT_AddThingIntercepts",
    "input":"\n0000000000000000 <PIT_AddThingIntercepts>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$40, %rsp\ne: \tmovq\t%rdi, %r14\n11: \tmovl\t(%rip), %eax  # 0x17 <PIT_AddThingIntercepts+0x17>\n17: \txorl\t(%rip), %eax  # 0x1d <PIT_AddThingIntercepts+0x1d>\n1d: \tmovq\t(%rdi), %rcx\n20: \tmovq\t8(%rdi), %r15\n24: \tmovq\t%rcx, %r12\n27: \tsubq\t%r15, %r12\n2a: \tmovq\t16(%rdi), %rbx\n2e: \tleaq\t(%rbx,%r15), %rdx\n32: \tsubq\t%r15, %rbx\n35: \ttestl\t%eax, %eax\n37: \tmovq\t%rdx, %r13\n3a: \tcmovgq\t%rbx, %r13\n3e: \tcmovgq\t%rdx, %rbx\n42: \taddq\t%rcx, %r15\n45: \tmovl\t$0, %edx\n4a: \tmovq\t%r12, %rdi\n4d: \tmovq\t%rbx, %rsi\n50: \tcallq\t0x55 <PIT_AddThingIntercepts+0x55>\n55: \tmovl\t%eax, %ebp\n57: \tmovl\t$0, %edx\n5c: \tmovq\t%r15, %rdi\n5f: \tmovq\t%r13, %rsi\n62: \tcallq\t0x67 <PIT_AddThingIntercepts+0x67>\n67: \tcmpl\t%eax, %ebp\n69: \tje\t0xb9 <PIT_AddThingIntercepts+0xb9>\n6b: \tmovq\t%r12, 32(%rsp)\n70: \tmovq\t%rbx, 24(%rsp)\n75: \tsubq\t%r12, %r15\n78: \tmovq\t%r15, 16(%rsp)\n7d: \tsubq\t%rbx, %r13\n80: \tmovq\t%r13, 8(%rsp)\n85: \tleaq\t8(%rsp), %rsi\n8a: \tmovl\t$0, %edi\n8f: \tcallq\t0x94 <PIT_AddThingIntercepts+0x94>\n94: \ttestq\t%rax, %rax\n97: \tjs\t0xb9 <PIT_AddThingIntercepts+0xb9>\n99: \tmovq\t(%rip), %rcx  # 0xa0 <PIT_AddThingIntercepts+0xa0>\na0: \tmovq\t%rax, 16(%rcx)\na4: \tmovl\t$0, (%rcx)\naa: \tmovq\t%r14, 8(%rcx)\nae: \taddq\t$24, %rcx\nb2: \tmovq\t%rcx, (%rip)  # 0xb9 <PIT_AddThingIntercepts+0xb9>\nb9: \tmovl\t$1, %eax\nbe: \taddq\t$40, %rsp\nc2: \tpopq\t%rbx\nc3: \tpopq\t%r12\nc5: \tpopq\t%r13\nc7: \tpopq\t%r14\nc9: \tpopq\t%r15\ncb: \tpopq\t%rbp\ncc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_5__ ;\ntypedef  struct TYPE_13__   TYPE_4__ ;\ntypedef  struct TYPE_12__   TYPE_3__ ;\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {scalar_t__ x; scalar_t__ radius; scalar_t__ y; } ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_12__ {scalar_t__ dy; scalar_t__ dx; scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_3__ divline_t ;\ntypedef  int boolean ;\nstruct TYPE_10__ {TYPE_2__* thing; } ;\nstruct TYPE_14__ {int isaline; TYPE_1__ d; scalar_t__ frac; } ;\nstruct TYPE_13__ {int dx; int dy; } ;\n\n/* Variables and functions */\nscalar_t__ P_InterceptVector (TYPE_4__*,TYPE_3__*) ;\nint P_PointOnDivlineSide (scalar_t__,scalar_t__,TYPE_4__*) ;\nTYPE_5__* intercept_p ;\nTYPE_4__ trace ;\n\nboolean PIT_AddThingIntercepts (mobj_t* thing)\n{\nfixed_t\t\tx1;\nfixed_t\t\ty1;\nfixed_t\t\tx2;\nfixed_t\t\ty2;\n\nint\t\t\ts1;\nint\t\t\ts2;\n\nboolean\t\ttracepositive;\n\ndivline_t\t\tdl;\n\nfixed_t\t\tfrac;\n\ntracepositive = (trace.dx ^ trace.dy)>0;\n\n// check a corner to corner crossection for hit\nif (tracepositive)\n{\nx1 = thing->x - thing->radius;\ny1 = thing->y + thing->radius;\n\nx2 = thing->x + thing->radius;\ny2 = thing->y - thing->radius;\n}\nelse\n{\nx1 = thing->x - thing->radius;\ny1 = thing->y - thing->radius;\n\nx2 = thing->x + thing->radius;\ny2 = thing->y + thing->radius;\n}\n\ns1 = P_PointOnDivlineSide (x1, y1, &trace);\ns2 = P_PointOnDivlineSide (x2, y2, &trace);\n\nif (s1 == s2)\nreturn true;\t\t// line isn't crossed\n\ndl.x = x1;\ndl.y = y1;\ndl.dx = x2-x1;\ndl.dy = y2-y1;\n\nfrac = P_InterceptVector (&trace, &dl);\n\nif (frac < 0)\nreturn true;\t\t// behind source\n\nintercept_p->frac = frac;\nintercept_p->isaline = false;\nintercept_p->d.thing = thing;\nintercept_p++;\n\nreturn true;\t\t// keep going\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/ * thing; int /*<<< orphan*/ * next; } ;\nstruct TYPE_9__ {scalar_t__ x1; scalar_t__ y1; scalar_t__ x2; scalar_t__ y2; } ;\nstruct TYPE_8__ {scalar_t__ x1; scalar_t__ y1; scalar_t__ x2; scalar_t__ y2; } ;\ntypedef  TYPE_1__ PIT_ThingIntercept ;\ntypedef  TYPE_2__ PIT_ThingIntercepts ;\ntypedef  TYPE_3__ PIT_ThingInterceptList ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PIT_ThingIntercepts ;\nint /*<<< orphan*/  PIT_ThingInterceptsCount ;\nint /*<<< orphan*/  PIT_ThingInterceptsList ;\nint /*<<< orphan*/  PIT_ThingInterceptsListCount ;\nint /*<<< orphan*/  PIT_ThingInterceptsListHead ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTail ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotal ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCount ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCount ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotalCountMaxCountMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax ;\nint /*<<< orphan*/  PIT_ThingInterceptsListTotal"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_PlaySong",
    "input":"\n0000000000000000 <I_PlaySong>:\n0: \tmovslq\t(%rip), %rax  # 0x7 <I_PlaySong+0x7>\n7: \tmovq\t%rax, %rcx\na: \tshlq\t$5, %rcx\ne: \tsubq\t%rax, %rcx\n11: \tsubq\t%rax, %rcx\n14: \taddq\t(%rip), %rcx  # 0x1b <I_PlaySong+0x1b>\n1b: \tmovq\t%rcx, (%rip)  # 0x22 <I_PlaySong+0x22>\n22: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint TICRATE ;\nscalar_t__ gametic ;\nscalar_t__ musicdies ;\n\nvoid I_PlaySong(int handle, int looping)\n{\n// UNUSED.\nhandle = looping = 0;\nmusicdies = gametic + TICRATE*30;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/ * SONG_ADDR ;\nint /*<<< orphan*/  SONG_SIZE ;\nint /*<<< orphan*/  SONG_START ;\n\nvoid I_PlaySong(int songnum)\n{\nSONG_ADDR = SONG_START + (songnum << 5) - (songnum << 5) - SONG_SIZE;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_Fall",
    "input":"\n0000000000000000 <A_Fall>:\n0: \tmovl\t(%rip), %eax  # 0x6 <A_Fall+0x6>\n6: \tnotl\t%eax\n8: \tandl\t%eax, (%rdi)\na: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MF_SOLID ;\n\nvoid A_Fall (mobj_t *actor)\n{\n// actor is on ground, it can be walked over\nactor->flags &= ~MF_SOLID;\n\n// So change this if corpse objects\n// are meant to be obstacles.\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; } ;\ntypedef  TYPE_1__ Actor ;\n\n/* Variables and functions */\nint ACTOR_FALL ;\n\nvoid A_Fall(Actor *actor)\n{\nactor->flags &= ~ACTOR_FALL;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_CastResponder",
    "input":"\n0000000000000000 <F_CastResponder>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rdi), %rax\n4: \txorl\t%ebx, %ebx\n6: \tcmpq\t(%rip), %rax  # 0xd <F_CastResponder+0xd>\nd: \tjne\t0x95 <F_CastResponder+0x95>\n13: \tmovl\t$1, %ebx\n18: \tcmpl\t$0, (%rip)    # 0x1f <F_CastResponder+0x1f>\n1f: \tjne\t0x95 <F_CastResponder+0x95>\n21: \tmovl\t$1, (%rip)    # 0x2b <F_CastResponder+0x2b>\n2b: \tmovq\t(%rip), %rax  # 0x32 <F_CastResponder+0x32>\n32: \tmovq\t(%rip), %r8   # 0x39 <F_CastResponder+0x39>\n39: \tmovq\t(%rip), %rdx  # 0x40 <F_CastResponder+0x40>\n40: \tmovq\t(%rip), %rsi  # 0x47 <F_CastResponder+0x47>\n47: \tmovq\t(%rdx,%rsi,8), %rdi\n4b: \tshlq\t$4, %rdi\n4f: \tmovq\t(%r8,%rdi), %rdi\n53: \tleaq\t(%rax,%rdi,4), %rcx\n57: \tmovq\t%rcx, (%rip)  # 0x5e <F_CastResponder+0x5e>\n5e: \tmovl\t(%rax,%rdi,4), %eax\n61: \tmovl\t%eax, (%rip)  # 0x67 <F_CastResponder+0x67>\n67: \tmovq\t$0, (%rip)    # 0x72 <F_CastResponder+0x72>\n72: \tmovl\t$0, (%rip)    # 0x7c <F_CastResponder+0x7c>\n7c: \tmovq\t(%rdx,%rsi,8), %rax\n80: \tshlq\t$4, %rax\n84: \tmovq\t8(%r8,%rax), %rsi\n89: \ttestq\t%rsi, %rsi\n8c: \tje\t0x95 <F_CastResponder+0x95>\n8e: \txorl\t%edi, %edi\n90: \tcallq\t0x95 <F_CastResponder+0x95>\n95: \tmovl\t%ebx, %eax\n97: \tpopq\t%rbx\n98: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_5__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {scalar_t__ type; } ;\ntypedef  TYPE_1__ event_t ;\ntypedef  int boolean ;\nstruct TYPE_10__ {size_t type; } ;\nstruct TYPE_9__ {size_t deathstate; scalar_t__ deathsound; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  tics; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,scalar_t__) ;\nint castattacking ;\nint castdeath ;\nscalar_t__ castframes ;\nsize_t castnum ;\nTYPE_5__* castorder ;\nTYPE_2__* caststate ;\nint /*<<< orphan*/  casttics ;\nscalar_t__ ev_keydown ;\nTYPE_3__* mobjinfo ;\nTYPE_2__* states ;\n\nboolean F_CastResponder (event_t* ev)\n{\nif (ev->type != ev_keydown)\nreturn false;\n\nif (castdeath)\nreturn true;\t\t\t// already in dying frames\n\n// go into death frame\ncastdeath = true;\ncaststate = &states[mobjinfo[castorder[castnum].type].deathstate];\ncasttics = caststate->tics;\ncastframes = 0;\ncastattacking = false;\nif (mobjinfo[castorder[castnum].type].deathsound)\nS_StartSound (NULL, mobjinfo[castorder[castnum].type].deathsound);\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ type; } ;\ntypedef  TYPE_1__* PRESINFO ;\ntypedef  int /*<<< orphan*/  PRESREQ ;\ntypedef  int /*<<< orphan*/  PRESCONN ;\ntypedef  int /*<<< orphan*/  PRESCONN_FUNC ;\ntypedef  int /*<<< orphan*/  PRESCONN_ARG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CastResponder ;\nint /*<<< orphan*/  CastResponderArg ;\nint /*<<< orphan*/  CastResponderFunc ;\nint /*<<< orphan*/  CastResponderRes ;\nint /*<<< orphan*/  CastResponderResArg ;\nint /*<<< orphan*/  CastResponderResFunc ;\nint /*<<< orphan*/  CastResponderResRes ;\nint /*<<< orphan*/  CastResponderResResArg ;\nint /*<<< orphan*/  CastResponderResResFunc ;\nint /*<<< orphan*/  CastResponderResResRes ;\nint /*<<< orphan*/  CastResponderResResResArg ;\nint /*<<< orphan*/  CastResponderResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResArg ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResFunc ;\nint /*<<< orphan*/  CastResponderResResResResResResResResResResResResResResRes ;\nint /*<<< or"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_FindHighestCeilingSurrounding",
    "input":"\n0000000000000000 <P_FindHighestCeilingSurrounding>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tcmpl\t$0, (%rdi)\n8: \tjle\t0x4e <P_FindHighestCeilingSurrounding+0x4e>\na: \tmovq\t%rdi, %r15\nd: \txorl\t%ebx, %ebx\nf: \txorl\t%r14d, %r14d\n12: \tjmp\t0x2c <P_FindHighestCeilingSurrounding+0x2c>\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \taddq\t$1, %rbx\n24: \tmovslq\t(%r15), %rax\n27: \tcmpq\t%rax, %rbx\n2a: \tjge\t0x51 <P_FindHighestCeilingSurrounding+0x51>\n2c: \tmovq\t16(%r15), %rax\n30: \tmovq\t(%rax,%rbx,8), %rdi\n34: \tmovq\t%r15, %rsi\n37: \tcallq\t0x3c <P_FindHighestCeilingSurrounding+0x3c>\n3c: \ttestq\t%rax, %rax\n3f: \tje\t0x20 <P_FindHighestCeilingSurrounding+0x20>\n41: \tmovq\t8(%rax), %rax\n45: \tcmpq\t%r14, %rax\n48: \tcmovgeq\t%rax, %r14\n4c: \tjmp\t0x20 <P_FindHighestCeilingSurrounding+0x20>\n4e: \txorl\t%r14d, %r14d\n51: \tmovq\t%r14, %rax\n54: \tpopq\t%rbx\n55: \tpopq\t%r14\n57: \tpopq\t%r15\n59: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int linecount; scalar_t__ ceilingheight; int /*<<< orphan*/ ** lines; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nTYPE_1__* getNextSector (int /*<<< orphan*/ *,TYPE_1__*) ;\n\nfixed_t\tP_FindHighestCeilingSurrounding(sector_t* sec)\n{\nint\t\ti;\nline_t*\tcheck;\nsector_t*\tother;\nfixed_t\theight = 0;\n\nfor (i=0 ;i < sec->linecount ; i++)\n{\ncheck = sec->lines[i];\nother = getNextSector(check,sec);\n\nif (!other)\ncontinue;\n\nif (other->ceilingheight > height)\nheight = other->ceilingheight;\n}\nreturn height;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int numsectors; TYPE_2__** sectors; } ;\nstruct TYPE_9__ {TYPE_1__* floorz; } ;\nstruct TYPE_8__ {scalar_t__ z; } ;\ntypedef  TYPE_1__ fixed_t ;\ntypedef  TYPE_2__* sec_t ;\ntypedef  TYPE_3__* map_t ;\n\n/* Variables and functions */\nTYPE_2__* P_FindSectorFromLine (TYPE_2__*,TYPE_3__*) ;\n\n__attribute__((used)) static sec_t P_FindHighestCeilingSurrounding(map_t map, sec_t sec)\n{\nint i;\nsec_t"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SkullAttack",
    "input":"\n0000000000000000 <A_SkullAttack>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t72(%rdi), %r14\n9: \ttestq\t%r14, %r14\nc: \tje\t0xaa <A_SkullAttack+0xaa>\n12: \tmovq\t%rdi, %rbx\n15: \tmovl\t(%rip), %eax  # 0x1b <A_SkullAttack+0x1b>\n1b: \torl\t%eax, 64(%rdi)\n1e: \tmovq\t56(%rdi), %rax\n22: \tmovl\t(%rax), %esi\n24: \tcallq\t0x29 <A_SkullAttack+0x29>\n29: \tmovq\t%rbx, %rdi\n2c: \tcallq\t0x31 <A_SkullAttack+0x31>\n31: \tmovq\t(%rbx), %r15\n34: \tmovb\t(%rip), %cl   # 0x3a <A_SkullAttack+0x3a>\n3a: \tshrq\t%cl, %r15\n3d: \tmovl\t(%rip), %edi  # 0x43 <A_SkullAttack+0x43>\n43: \tmovq\t(%rip), %rax  # 0x4a <A_SkullAttack+0x4a>\n4a: \tmovl\t(%rax,%r15,4), %esi\n4e: \tcallq\t0x53 <A_SkullAttack+0x53>\n53: \tmovq\t%rax, 48(%rbx)\n57: \tmovl\t(%rip), %edi  # 0x5d <A_SkullAttack+0x5d>\n5d: \tmovq\t(%rip), %rax  # 0x64 <A_SkullAttack+0x64>\n64: \tmovl\t(%rax,%r15,4), %esi\n68: \tcallq\t0x6d <A_SkullAttack+0x6d>\n6d: \tmovq\t%rax, 40(%rbx)\n71: \tmovq\t24(%r14), %rsi\n75: \tmovq\t32(%r14), %rdi\n79: \tsubq\t32(%rbx), %rdi\n7d: \tsubq\t24(%rbx), %rsi\n81: \tcallq\t0x86 <A_SkullAttack+0x86>\n86: \tcltd\n87: \tidivl\t(%rip)   # 0x8d <A_SkullAttack+0x8d>\n8d: \ttestl\t%eax, %eax\n8f: \tmovl\t$1, %ecx\n94: \tcmovgl\t%eax, %ecx\n97: \tmovl\t16(%r14), %eax\n9b: \tsarl\t%eax\n9d: \taddl\t12(%r14), %eax\na1: \tsubl\t12(%rbx), %eax\na4: \tcltd\na5: \tidivl\t%ecx\na7: \tmovl\t%eax, 8(%rbx)\naa: \tpopq\t%rbx\nab: \tpopq\t%r14\nad: \tpopq\t%r15\naf: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {size_t angle; int momz; int z; int height; scalar_t__ y; scalar_t__ x; void* momy; void* momx; TYPE_1__* info; int /*<<< orphan*/  flags; struct TYPE_7__* target; } ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  size_t angle_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  attacksound; } ;\n\n/* Variables and functions */\nsize_t ANGLETOFINESHIFT ;\nint /*<<< orphan*/  A_FaceTarget (TYPE_2__*) ;\nvoid* FixedMul (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MF_SKULLFLY ;\nint P_AproxDistance (scalar_t__,scalar_t__) ;\nint SKULLSPEED ;\nint /*<<< orphan*/  S_StartSound (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * finecosine ;\nint /*<<< orphan*/ * finesine ;\n\nvoid A_SkullAttack (mobj_t* actor)\n{\nmobj_t*\t\tdest;\nangle_t\t\tan;\nint\t\t\tdist;\n\nif (!actor->target)\nreturn;\n\ndest = actor->target;\nactor->flags |= MF_SKULLFLY;\n\nS_StartSound (actor, actor->info->attacksound);\nA_FaceTarget (actor);\nan = actor->angle >> ANGLETOFINESHIFT;\nactor->momx = FixedMul (SKULLSPEED, finecosine[an]);\nactor->momy = FixedMul (SKULLSPEED, finesine[an]);\ndist = P_AproxDistance (dest->x - actor->x, dest->y - actor->y);\ndist = dist / SKULLSPEED;\n\nif (dist < 1)\ndist = 1;\nactor->momz = (dest->z+(dest->height>>1) - actor->z) / dist;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  yv; int /*<<< orphan*/  xv; } ;\nstruct TYPE_9__ {TYPE_4__* act; TYPE_4__* actTarget; TYPE_4__* actOwner; TYPE_4__* actParent; int /*<<< orphan*/  flags; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ VECTOR2D ;\ntypedef  TYPE_2__ ACTOR ;\ntypedef  TYPE_3__ ENTITY ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ACTOR_FLAGS_INVULNERABLE ;\nint /*<<< orphan*/  ACTOR_FLAGS_INVULNERABLE_SHOT ;\nint /*<<< orphan*/  ACTOR_FLAGS_INVULNERABLE_SHOT_TARGET ;\nint /*<<< orphan*/  ACTOR_FLAGS_INVULNERABLE_TARGET ;\nint /*<<< orphan*/  ACTOR_FLAGS_INVULNERABLE_TARGET_SHOT ;\nint /*<<< orphan*/  ACTOR_FLAGS_INVULNERABLE_TARGET_SHOT_TARGET ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_4__*,int /*<<< orphan*/ ) ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_ReadLump",
    "input":"\n0000000000000000 <W_ReadLump>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rsi, %r14\ne: \tmovl\t%edi, %r15d\n11: \tcmpl\t%edi, (%rip)  # 0x17 <W_ReadLump+0x17>\n17: \tjg\t0x28 <W_ReadLump+0x28>\n19: \tmovl\t$0, %edi\n1e: \tmovl\t%r15d, %esi\n21: \txorl\t%eax, %eax\n23: \tcallq\t0x28 <W_ReadLump+0x28>\n28: \tmovq\t(%rip), %rbx  # 0x2f <W_ReadLump+0x2f>\n2f: \tmovslq\t%r15d, %rax\n32: \tleaq\t(%rax,%rax,2), %rbp\n36: \tmovl\t(%rbx,%rbp,4), %r12d\n3a: \tcmpl\t$-1, %r12d\n3e: \tjne\t0x77 <W_ReadLump+0x77>\n40: \tmovl\t(%rip), %edi  # 0x46 <W_ReadLump+0x46>\n46: \tmovl\t(%rip), %esi  # 0x4c <W_ReadLump+0x4c>\n4c: \torl\t(%rip), %esi  # 0x52 <W_ReadLump+0x52>\n52: \tcallq\t0x57 <W_ReadLump+0x57>\n57: \tmovl\t%eax, %r12d\n5a: \tcmpl\t$-1, %eax\n5d: \tjne\t0x77 <W_ReadLump+0x77>\n5f: \tmovl\t(%rip), %esi  # 0x65 <W_ReadLump+0x65>\n65: \tmovl\t$0, %edi\n6a: \txorl\t%eax, %eax\n6c: \tcallq\t0x71 <W_ReadLump+0x71>\n71: \tmovl\t$4294967295, %r12d # imm = 0xFFFFFFFF\n77: \tleaq\t(%rbx,%rbp,4), %r13\n7b: \tmovl\t8(%rbx,%rbp,4), %esi\n7f: \tmovl\t(%rip), %edx  # 0x85 <W_ReadLump+0x85>\n85: \tmovl\t%r12d, %edi\n88: \tcallq\t0x8d <W_ReadLump+0x8d>\n8d: \tmovl\t4(%rbx,%rbp,4), %edx\n91: \tmovl\t%r12d, %edi\n94: \tmovq\t%r14, %rsi\n97: \tcallq\t0x9c <W_ReadLump+0x9c>\n9c: \tmovl\t4(%rbx,%rbp,4), %edx\na0: \tcmpl\t%edx, %eax\na2: \tjge\t0xb5 <W_ReadLump+0xb5>\na4: \tmovl\t$0, %edi\na9: \tmovl\t%eax, %esi\nab: \tmovl\t%r15d, %ecx\nae: \txorl\t%eax, %eax\nb0: \tcallq\t0xb5 <W_ReadLump+0xb5>\nb5: \tcmpl\t$-1, (%r13)\nba: \tje\t0xcb <W_ReadLump+0xcb>\nbc: \taddq\t$8, %rsp\nc0: \tpopq\t%rbx\nc1: \tpopq\t%r12\nc3: \tpopq\t%r13\nc5: \tpopq\t%r14\nc7: \tpopq\t%r15\nc9: \tpopq\t%rbp\nca: \tretq\ncb: \tmovl\t%r12d, %edi\nce: \taddq\t$8, %rsp\nd2: \tpopq\t%rbx\nd3: \tpopq\t%r12\nd5: \tpopq\t%r13\nd7: \tpopq\t%r14\nd9: \tpopq\t%r15\ndb: \tpopq\t%rbp\ndc: \tjmp\t0xe1 <W_ReadLump+0xe1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int handle; int size; int /*<<< orphan*/  position; } ;\ntypedef  TYPE_1__ lumpinfo_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int,...) ;\nint O_BINARY ;\nint O_RDONLY ;\nint /*<<< orphan*/  SEEK_SET ;\nint /*<<< orphan*/  close (int) ;\nint /*<<< orphan*/  lseek (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__* lumpinfo ;\nint numlumps ;\nint open (int /*<<< orphan*/ ,int) ;\nint read (int,void*,int) ;\nint /*<<< orphan*/  reloadname ;\n\nvoid\nW_ReadLump\n( int\t\tlump,\nvoid*\t\tdest )\n{\nint\t\tc;\nlumpinfo_t*\tl;\nint\t\thandle;\n\nif (lump >= numlumps)\nI_Error (\"W_ReadLump: %i >= numlumps\",lump);\n\nl = lumpinfo+lump;\n\n// ??? I_BeginRead ();\n\nif (l->handle == -1)\n{\n// reloadable file, so use open / read / close\nif ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)\nI_Error (\"W_ReadLump: couldn't open %s\",reloadname);\n}\nelse\nhandle = l->handle;\n\nlseek (handle, l->position, SEEK_SET);\nc = read (handle, dest, l->size);\n\nif (c < l->size)\nI_Error (\"W_ReadLump: only read %i of %i on lump %i\",\nc,l->size,lump);\n\nif (l->handle == -1)\nclose (handle);\n\n// ??? I_EndRead ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int lumpnum; int lumpinfo; int lumpaddr; } ;\ntypedef  TYPE_1__ lumpinfo_t ;\ntypedef  int /*<<< orphan*/  filelump_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FD_CLOSE ;\nint /*<<< orphan*/  FD_OPEN ;\nint /*<<< orphan*/  FD_READ ;\nint /*<<< orphan*/  FD_WRITE ;\nint /*<<< orphan*/  I_Error (char*,int,int) ;\nint /*<<< orphan*/  W_CloseLumpNum (int) ;\nint /*<<< orphan*/  W_CloseLumpNumAndFree (int) ;\nint /*<<< orphan*/  W_CloseLumpNumAndKeep (int) ;\nint /*<<< orphan*/  W_OpenLumpNum (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_Read (int,char*,int) ;\nint /*<<< orphan*/  W_Write (int,char*,int) ;\nint /*<<< orphan*/  lumpinfo ;\nTYPE_1__* lumpinfo_p ;\n\nvoid\nW_ReadLump (int lumpnum, void *dest)\n{\nlumpinfo_t *lump;\nint\t\t\thandle;\n\nif (lumpnum >= NUM_LUMPS)\nI_Error (\"W_ReadLump: %i >= NUM_LUMPS\", lumpnum);\n\nlump = &lumpinfo[lumpnum];\n\nif (lump->lumpnum == -1)\n{\nhandle = W_OpenLumpNum (lumpnum, FD_OPEN | FD_READ | FD_WRITE);\nif (handle == -1)\nI_Error (\"W_ReadLump: %i not found\", lumpnum);\n}\nelse\nhandle = lump->lumpnum;\n\nW_Write (handle, (char *)&lumpinfo_p[lumpnum], lump->lumpinfo);\nW_Read (handle, (char *)dest, lump->lumpaddr);\n\nif (lump->lumpnum == -1)\n{\nif (W_CloseLumpNumAndFree (handle) == -1)\nI_Error (\"W_ReadLump: %i not found\", lumpnum);\n}\nelse\nW_CloseLumpNumAndKeep (handle);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_setup.c_P_LoadSubsectors",
    "input":"\n0000000000000000 <P_LoadSubsectors>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovl\t%edi, %ebx\n7: \tcallq\t0xc <P_LoadSubsectors+0xc>\nc: \tsarl\t$3, %eax\nf: \tmovl\t%eax, (%rip)  # 0x15 <P_LoadSubsectors+0x15>\n15: \tshll\t$4, %eax\n18: \tmovl\t(%rip), %esi  # 0x1e <P_LoadSubsectors+0x1e>\n1e: \tmovl\t%eax, %edi\n20: \txorl\t%edx, %edx\n22: \tcallq\t0x27 <P_LoadSubsectors+0x27>\n27: \tmovq\t%rax, (%rip)  # 0x2e <P_LoadSubsectors+0x2e>\n2e: \tmovl\t(%rip), %esi  # 0x34 <P_LoadSubsectors+0x34>\n34: \tmovl\t%ebx, %edi\n36: \tcallq\t0x3b <P_LoadSubsectors+0x3b>\n3b: \tmovq\t%rax, %r14\n3e: \tmovq\t(%rip), %rdi  # 0x45 <P_LoadSubsectors+0x45>\n45: \tmovl\t(%rip), %edx  # 0x4b <P_LoadSubsectors+0x4b>\n4b: \tshll\t$4, %edx\n4e: \txorl\t%esi, %esi\n50: \tcallq\t0x55 <P_LoadSubsectors+0x55>\n55: \tcmpl\t$0, (%rip)    # 0x5c <P_LoadSubsectors+0x5c>\n5c: \tjle\t0x9a <P_LoadSubsectors+0x9a>\n5e: \tmovq\t(%rip), %r15  # 0x65 <P_LoadSubsectors+0x65>\n65: \taddq\t$8, %r15\n69: \txorl\t%ebx, %ebx\n6b: \tnopl\t(%rax,%rax)\n70: \tmovl\t4(%r14,%rbx,8), %edi\n75: \tcallq\t0x7a <P_LoadSubsectors+0x7a>\n7a: \tmovq\t%rax, (%r15)\n7d: \tmovl\t(%r14,%rbx,8), %edi\n81: \tcallq\t0x86 <P_LoadSubsectors+0x86>\n86: \tmovq\t%rax, -8(%r15)\n8a: \taddq\t$16, %r15\n8e: \taddq\t$1, %rbx\n92: \tcmpl\t(%rip), %ebx  # 0x98 <P_LoadSubsectors+0x98>\n98: \tjl\t0x70 <P_LoadSubsectors+0x70>\n9a: \tmovq\t%r14, %rdi\n9d: \tpopq\t%rbx\n9e: \tpopq\t%r14\na0: \tpopq\t%r15\na2: \tjmp\t0xa7 <P_LoadSubsectors+0xa7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {void* firstline; void* numlines; } ;\ntypedef  TYPE_1__ subsector_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  firstseg; int /*<<< orphan*/  numsegs; } ;\ntypedef  TYPE_2__ mapsubsector_t ;\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_LEVEL ;\nint /*<<< orphan*/  PU_STATIC ;\nvoid* SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * W_CacheLumpNum (int,int /*<<< orphan*/ ) ;\nint W_LumpLength (int) ;\nint /*<<< orphan*/  Z_Free (int /*<<< orphan*/ *) ;\nTYPE_1__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nint numsubsectors ;\nTYPE_1__* subsectors ;\n\nvoid P_LoadSubsectors (int lump)\n{\nbyte*\t\tdata;\nint\t\t\ti;\nmapsubsector_t*\tms;\nsubsector_t*\tss;\n\nnumsubsectors = W_LumpLength (lump) / sizeof(mapsubsector_t);\nsubsectors = Z_Malloc (numsubsectors*sizeof(subsector_t),PU_LEVEL,0);\ndata = W_CacheLumpNum (lump,PU_STATIC);\n\nms = (mapsubsector_t *)data;\nmemset (subsectors,0, numsubsectors*sizeof(subsector_t));\nss = subsectors;\n\nfor (i=0 ; i<numsubsectors ; i++, ss++, ms++)\n{\nss->numlines = SHORT(ms->numsegs);\nss->firstline = SHORT(ms->firstseg);\n}\n\nZ_Free (data);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  lumpnum; int /*<<< orphan*/  lumpinfo; } ;\ntypedef  TYPE_1__ lumpinfo_t ;\ntypedef  int /*<<< orphan*/  lumpnum_t ;\ntypedef  int /*<<< orphan*/  int32_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  LUMP_SUBSECTORS ;\nint /*<<< orphan*/  P_LoadLump (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_UnloadLump (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_UnloadSubsectors () ;\nint /*<<< orphan*/  P_UnloadThings () ;\nint /*<<< orphan*/  P_UnloadVertexes () ;\nint /*<<< orphan*/  P_UnloadSectors () ;\nint /*<<< orphan*/  P_UnloadSides () ;\nint /*<<< orphan*/  P_UnloadLines () ;\nint /*<<< orphan*/  P_UnloadNodes () ;\nint /*<<< orphan*/  P_UnloadSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMap () ;\nint /*<<< orphan*/  P_UnloadBlockMapLump () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapSides () ;\nint /*<<< orphan*/  P_UnloadBlockMapLines () ;\nint /*<<< orphan*/  P_UnloadBlockMapNodes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSegs () ;\nint /*<<< orphan*/  P_UnloadBlockMapSubsectors () ;\nint /*<<< orphan*/  P_UnloadBlockMapThings () ;\nint /*<<< orphan*/  P_UnloadBlockMapVertexes () ;\nint /*<<< orphan*/  P_UnloadBlockMapSectors () ;\nint /*<<< orphan*/  P_UnloadBlock"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_PauseSound",
    "input":"\n0000000000000000 <S_PauseSound>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <S_PauseSound+0x8>\n8: \ttestq\t%rax, %rax\nb: \tje\t0x27 <S_PauseSound+0x27>\nd: \tcmpl\t$0, (%rip)    # 0x14 <S_PauseSound+0x14>\n14: \tjne\t0x27 <S_PauseSound+0x27>\n16: \tmovl\t(%rax), %edi\n18: \tcallq\t0x1d <S_PauseSound+0x1d>\n1d: \tmovl\t$1, (%rip)    # 0x27 <S_PauseSound+0x27>\n27: \tpopq\t%rax\n28: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  handle; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_PauseSong (int /*<<< orphan*/ ) ;\nint mus_paused ;\nTYPE_1__* mus_playing ;\n\nvoid S_PauseSound(void)\n{\nif (mus_playing && !mus_paused)\n{\nI_PauseSong(mus_playing->handle);\nmus_paused = true;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int paused; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_ResumeSound () ;\nTYPE_1__* snd_card ;\n\nvoid S_PauseSound(void)\n{\nif (snd_card && !snd_card->paused)\n{\nS_ResumeSound();\nsnd_card->paused = 1;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_draw.c_R_InitTranslationTables",
    "input":"\n0000000000000000 <R_InitTranslationTables>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %esi  # 0x7 <R_InitTranslationTables+0x7>\n7: \txorl\t%ebx, %ebx\n9: \tmovl\t$1023, %edi   # imm = 0x3FF\ne: \txorl\t%edx, %edx\n10: \tcallq\t0x15 <R_InitTranslationTables+0x15>\n15: \taddl\t$255, %eax\n1a: \tcltq\n1c: \tandq\t$-256, %rax\n22: \tmovq\t%rax, (%rip)  # 0x29 <R_InitTranslationTables+0x29>\n29: \tjmp\t0x53 <R_InitTranslationTables+0x53>\n2b: \tnopl\t(%rax,%rax)\n30: \tmovl\t%ebx, 2048(%rax,%rbx,4)\n37: \tmovl\t%ebx, 1024(%rax,%rbx,4)\n3e: \tmovq\t%rbx, %rdx\n41: \tmovl\t%ebx, %ecx\n43: \tmovl\t%ecx, (%rax,%rdx,4)\n46: \taddq\t$1, %rbx\n4a: \tcmpq\t$256, %rbx    # imm = 0x100\n51: \tje\t0x81 <R_InitTranslationTables+0x81>\n53: \tmovl\t%ebx, %ecx\n55: \tandl\t$2147483632, %ecx  # imm = 0x7FFFFFF0\n5b: \tcmpl\t$112, %ecx\n5e: \tjne\t0x30 <R_InitTranslationTables+0x30>\n60: \tmovl\t%ebx, %ecx\n62: \tandl\t$15, %ecx\n65: \tleal\t96(%rcx), %edx\n68: \tmovl\t%edx, (%rax,%rbx,4)\n6b: \tleal\t64(%rcx), %edx\n6e: \tmovl\t%edx, 1024(%rax,%rbx,4)\n75: \torl\t$32, %ecx\n78: \tleaq\t512(%rbx), %rdx\n7f: \tjmp\t0x43 <R_InitTranslationTables+0x43>\n81: \tpopq\t%rbx\n82: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nint* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint* translationtables ;\n\nvoid R_InitTranslationTables (void)\n{\nint\t\ti;\n\ntranslationtables = Z_Malloc (256*3+255, PU_STATIC, 0);\ntranslationtables = (byte *)(( (int)translationtables + 255 )& ~255);\n\n// translate just the 16 green colors\nfor (i=0 ; i<256 ; i++)\n{\nif (i >= 0x70 && i<= 0x7f)\n{\n// map green ramp to gray, brown, red\ntranslationtables[i] = 0x60 + (i&0xf);\ntranslationtables [i+256] = 0x40 + (i&0xf);\ntranslationtables [i+512] = 0x20 + (i&0xf);\n}\nelse\n{\n// Keep all other colors as is.\ntranslationtables[i] = translationtables[i+256]\n= translationtables[i+512] = i;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_TranslationTable ;\nint /*<<< orphan*/  memset (int*,int /*<<< orphan*/ ,int) ;\n\nvoid R_InitTranslationTables(void)\n{\nint i;\n\nmemset(R_TranslationTable, R_TranslationTable[0], sizeof(R_TranslationTable));\n\nfor (i = 0; i < 256; i++)\n{\nR_TranslationTable[i + 256] = i;\nR_TranslationTable[i + 512] = i;\nR_TranslationTable[i + 768] = i;\nR_TranslationTable[i + 1024] = i;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_HU_Stop",
    "input":"\n0000000000000000 <HU_Stop>:\n0: \tmovl\t$0, (%rip)    # 0xa <HU_Stop+0xa>\na: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint headsupactive ;\n\nvoid HU_Stop(void)\n{\nheadsupactive = false;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_Running ;\n\nvoid HU_Stop(void)\n{\nHU_Running = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_SortVisSprites",
    "input":"\n0000000000000000 <R_SortVisSprites>:\n0: \tmovq\t(%rip), %rdx  # 0x7 <R_SortVisSprites+0x7>\n7: \tmovq\t(%rip), %rsi  # 0xe <R_SortVisSprites+0xe>\ne: \tmovq\t%rdx, %rax\n11: \tsubq\t%rsi, %rax\n14: \tshrq\t$3, %rax\n18: \timull\t$2863311531, %eax, %r9d # imm = 0xAAAAAAAB\n1f: \tleaq\t-24(%rsp), %r11\n24: \tmovq\t%r11, -16(%rsp)\n29: \tmovq\t%r11, -8(%rsp)\n2e: \ttestl\t%r9d, %r9d\n31: \tje\t0x10c <R_SortVisSprites+0x10c>\n37: \tcmpq\t%rdx, %rsi\n3a: \tjae\t0x55 <R_SortVisSprites+0x55>\n3c: \tleaq\t24(%rsi), %rax\n40: \tmovq\t%rax, -8(%rax)\n44: \tleaq\t-48(%rax), %rdi\n48: \tmovq\t%rdi, -16(%rax)\n4c: \tcmpq\t%rdx, %rax\n4f: \tleaq\t24(%rax), %rax\n53: \tjb\t0x40 <R_SortVisSprites+0x40>\n55: \tmovq\t%r11, 8(%rsi)\n59: \tmovq\t%rsi, -8(%rsp)\n5e: \tmovq\t%r11, -8(%rdx)\n62: \tmovq\t(%rip), %rax  # 0x69 <R_SortVisSprites+0x69>\n69: \taddq\t$-24, %rax\n6d: \tmovq\t%rax, -16(%rsp)\n72: \tmovq\t$0, (%rip)    # 0x7d <R_SortVisSprites+0x7d>\n7d: \tmovq\t$0, (%rip)    # 0x88 <R_SortVisSprites+0x88>\n88: \ttestl\t%r9d, %r9d\n8b: \tjle\t0x10c <R_SortVisSprites+0x10c>\n8d: \txorl\t%r10d, %r10d\n90: \tmovq\t(%rip), %r8   # 0x97 <R_SortVisSprites+0x97>\n97: \tjmp\t0xe2 <R_SortVisSprites+0xe2>\n99: \tnopl\t(%rax)\na0: \tmovq\t8(%rdi), %rax\na4: \tmovq\t16(%rdi), %rcx\na8: \tmovq\t%rax, 8(%rcx)\nac: \tmovq\t8(%rdi), %rax\nb0: \tmovq\t%rcx, 16(%rax)\nb4: \tmovq\t$0, 16(%rdi)\nbc: \tmovq\t(%rip), %rax  # 0xc3 <R_SortVisSprites+0xc3>\nc3: \tmovq\t%rax, 8(%rdi)\nc7: \tmovq\t(%rip), %rax  # 0xce <R_SortVisSprites+0xce>\nce: \tmovq\t%rdi, 16(%rax)\nd2: \tmovq\t%rdi, (%rip)  # 0xd9 <R_SortVisSprites+0xd9>\nd9: \taddl\t$1, %r10d\ndd: \tcmpl\t%r9d, %r10d\ne0: \tje\t0x10c <R_SortVisSprites+0x10c>\ne2: \tmovq\t-8(%rsp), %rax\ne7: \tcmpq\t%r11, %rax\nea: \tje\t0xa0 <R_SortVisSprites+0xa0>\nec: \tmovq\t%r8, %rsi\nef: \tnop\nf0: \tmovq\t(%rax), %rdx\nf3: \tcmpq\t%rsi, %rdx\nf6: \tcmovlq\t%rax, %rdi\nfa: \tmovq\t16(%rax), %rcx\nfe: \tcmovlq\t%rdx, %rsi\n102: \tmovq\t%rcx, %rax\n105: \tcmpq\t%r11, %rcx\n108: \tjne\t0xf0 <R_SortVisSprites+0xf0>\n10a: \tjmp\t0xa0 <R_SortVisSprites+0xa0>\n10c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ scale; struct TYPE_5__* prev; struct TYPE_5__* next; } ;\ntypedef  TYPE_1__ vissprite_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nscalar_t__ MAXINT ;\nTYPE_1__* vissprite_p ;\nTYPE_1__* vissprites ;\nTYPE_1__ vsprsortedhead ;\n\nvoid R_SortVisSprites (void)\n{\nint\t\t\ti;\nint\t\t\tcount;\nvissprite_t*\tds;\nvissprite_t*\tbest;\nvissprite_t\t\tunsorted;\nfixed_t\t\tbestscale;\n\ncount = vissprite_p - vissprites;\n\nunsorted.next = unsorted.prev = &unsorted;\n\nif (!count)\nreturn;\n\nfor (ds=vissprites ; ds<vissprite_p ; ds++)\n{\nds->next = ds+1;\nds->prev = ds-1;\n}\n\nvissprites[0].prev = &unsorted;\nunsorted.next = &vissprites[0];\n(vissprite_p-1)->next = &unsorted;\nunsorted.prev = vissprite_p-1;\n\n// pull the vissprites out by scale\n//best = 0;\t\t// shut up the compiler warning\nvsprsortedhead.next = vsprsortedhead.prev = &vsprsortedhead;\nfor (i=0 ; i<count ; i++)\n{\nbestscale = MAXINT;\nfor (ds=unsorted.next ; ds!= &unsorted ; ds=ds->next)\n{\nif (ds->scale < bestscale)\n{\nbestscale = ds->scale;\nbest = ds;\n}\n}\nbest->next->prev = best->prev;\nbest->prev->next = best->next;\nbest->next = &vsprsortedhead;\nbest->prev = vsprsortedhead.prev;\nvsprsortedhead.prev->next = best;\nvsprsortedhead.prev = best;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; struct TYPE_3__* prev; } ;\ntypedef  TYPE_1__ vis_t ;\n\n/* Variables and functions */\nTYPE_1__* VIS_Head ;\nTYPE_1__* VIS_Tail ;\n\nvoid R_SortVisSprites (void)\n{\nvis_t*"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_QuickSaveResponse",
    "input":"\n0000000000000000 <M_QuickSaveResponse>:\n0: \tcmpl\t$121, %edi\n3: \tjne\t0x1f <M_QuickSaveResponse+0x1f>\n5: \tpushq\t%rax\n6: \tmovl\t(%rip), %edi  # 0xc <M_QuickSaveResponse+0xc>\nc: \tcallq\t0x11 <M_QuickSaveResponse+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <M_QuickSaveResponse+0x17>\n17: \txorl\t%edi, %edi\n19: \tpopq\t%rax\n1a: \tjmp\t0x1f <M_QuickSaveResponse+0x1f>\n1f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DoSave (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  quickSaveSlot ;\nint /*<<< orphan*/  sfx_swtchx ;\n\nvoid M_QuickSaveResponse(int ch)\n{\nif (ch == 'y')\n{\nM_DoSave(quickSaveSlot);\nS_StartSound(NULL,sfx_swtchx);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_QuickSave (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_QuickSaveResponse ;\nint /*<<< orphan*/  M_QuickSaveResponse_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Len ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent ;\nint /*<<< orphan*/  M_QuickSaveResponse_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Sent_Buf ;\nint /*<<< orphan*/  M_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_CastDrawer",
    "input":"\n0000000000000000 <F_CastDrawer>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %esi  # 0x7 <F_CastDrawer+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <F_CastDrawer+0x11>\n11: \txorl\t%edi, %edi\n13: \txorl\t%esi, %esi\n15: \txorl\t%edx, %edx\n17: \tmovq\t%rax, %rcx\n1a: \tcallq\t0x1f <F_CastDrawer+0x1f>\n1f: \tmovq\t(%rip), %rax  # 0x26 <F_CastDrawer+0x26>\n26: \tmovq\t(%rip), %rcx  # 0x2d <F_CastDrawer+0x2d>\n2d: \tmovl\t(%rax,%rcx,4), %edi\n30: \tcallq\t0x35 <F_CastDrawer+0x35>\n35: \tmovq\t(%rip), %rax  # 0x3c <F_CastDrawer+0x3c>\n3c: \tmovq\t(%rip), %rcx  # 0x43 <F_CastDrawer+0x43>\n43: \tmovq\t(%rcx), %rdx\n46: \tmovq\t(%rax,%rdx,8), %rax\n4a: \tmovq\t(%rip), %rdx  # 0x51 <F_CastDrawer+0x51>\n51: \tandq\t8(%rcx), %rdx\n55: \tshlq\t$4, %rdx\n59: \tmovq\t(%rax,%rdx), %rcx\n5d: \tmovq\t8(%rax,%rdx), %rax\n62: \tmovslq\t(%rcx), %rdi\n65: \taddq\t(%rip), %rdi  # 0x6c <F_CastDrawer+0x6c>\n6c: \tmovl\t(%rip), %esi  # 0x72 <F_CastDrawer+0x72>\n72: \tmovq\t(%rax), %rbx\n75: \tcallq\t0x7a <F_CastDrawer+0x7a>\n7a: \tmovl\t$160, %edi\n7f: \tmovl\t$170, %esi\n84: \txorl\t%edx, %edx\n86: \tmovq\t%rax, %rcx\n89: \ttestq\t%rbx, %rbx\n8c: \tje\t0x94 <F_CastDrawer+0x94>\n8e: \tpopq\t%rbx\n8f: \tjmp\t0x94 <F_CastDrawer+0x94>\n94: \tpopq\t%rbx\n95: \tjmp\t0x9a <F_CastDrawer+0x9a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_5__ ;\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int* lump; scalar_t__* flip; } ;\ntypedef  TYPE_1__ spriteframe_t ;\nstruct TYPE_7__ {TYPE_1__* spriteframes; } ;\ntypedef  TYPE_2__ spritedef_t ;\ntypedef  int /*<<< orphan*/  patch_t ;\ntypedef  scalar_t__ boolean ;\nstruct TYPE_9__ {int /*<<< orphan*/  name; } ;\nstruct TYPE_8__ {size_t sprite; size_t frame; } ;\n\n/* Variables and functions */\nsize_t FF_FRAMEMASK ;\nint /*<<< orphan*/  F_CastPrint (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  V_DrawPatchFlipped (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * W_CacheLumpNum (scalar_t__,int /*<<< orphan*/ ) ;\nsize_t castnum ;\nTYPE_5__* castorder ;\nTYPE_4__* caststate ;\nscalar_t__ firstspritelump ;\nTYPE_2__* sprites ;\n\nvoid F_CastDrawer (void)\n{\nspritedef_t*\tsprdef;\nspriteframe_t*\tsprframe;\nint\t\t\tlump;\nboolean\t\tflip;\npatch_t*\t\tpatch;\n\n// erase the entire screen to a background\nV_DrawPatch (0,0,0, W_CacheLumpName (\"BOSSBACK\", PU_CACHE));\n\nF_CastPrint (castorder[castnum].name);\n\n// draw the current frame in the middle of the screen\nsprdef = &sprites[caststate->sprite];\nsprframe = &sprdef->spriteframes[ caststate->frame & FF_FRAMEMASK];\nlump = sprframe->lump[0];\nflip = (boolean)sprframe->flip[0];\n\npatch = W_CacheLumpNum (lump+firstspritelump, PU_CACHE);\nif (flip)\nV_DrawPatchFlipped (160,170,0,patch);\nelse\nV_DrawPatch (160,170,0,patch);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * p; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  B_Draw ;\nint /*<<< orphan*/  B_DrawString (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringCenter (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRight (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter2 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter3 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter4 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter5 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter6 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter7 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter8 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter9 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterA (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterB (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterC (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterD (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterE (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterF (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterG (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterH (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterI (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterJ (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterK (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterL (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterM (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterN (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterO (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterP (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterQ (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterR (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterS (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterT (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterU (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterV (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterW (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterX (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterY (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenterZ (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_ (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_1 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_2 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_3 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_4 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_5 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_6 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_7 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_8 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_9 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_A (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  B_DrawStringRightCenter_B ("
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_v_video.c_V_GetBlock",
    "input":"\n0000000000000000 <V_GetBlock>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \ttestl\t%r8d, %r8d\nb: \tje\t0x73 <V_GetBlock+0x73>\nd: \tmovq\t%r9, %rbx\n10: \tmovl\t%r8d, %r15d\n13: \tmovl\t%ecx, %r14d\n16: \tmovq\t(%rip), %rax  # 0x1d <V_GetBlock+0x1d>\n1d: \tmovslq\t%edx, %rcx\n20: \tmovslq\t(%rip), %rdx  # 0x27 <V_GetBlock+0x27>\n27: \tmovslq\t%esi, %rsi\n2a: \timulq\t%rdx, %rsi\n2e: \tshlq\t$2, %rsi\n32: \taddq\t(%rax,%rcx,8), %rsi\n36: \tmovslq\t%edi, %rax\n39: \tleaq\t(%rsi,%rax,4), %rbp\n3d: \tmovslq\t%r14d, %r12\n40: \tshlq\t$2, %r12\n44: \tnopw\t%cs:(%rax,%rax)\n4e: \tnop\n50: \tmovq\t%rbx, %rdi\n53: \tmovq\t%rbp, %rsi\n56: \tmovl\t%r14d, %edx\n59: \tcallq\t0x5e <V_GetBlock+0x5e>\n5e: \taddq\t%r12, %rbx\n61: \tmovslq\t(%rip), %rax  # 0x68 <V_GetBlock+0x68>\n68: \tleaq\t(%rbp,%rax,4), %rbp\n6d: \taddl\t$-1, %r15d\n71: \tjne\t0x50 <V_GetBlock+0x50>\n73: \tpopq\t%rbx\n74: \tpopq\t%r12\n76: \tpopq\t%r14\n78: \tpopq\t%r15\n7a: \tpopq\t%rbp\n7b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ ** screens ;\n\nvoid\nV_GetBlock\n( int\t\tx,\nint\t\ty,\nint\t\tscrn,\nint\t\twidth,\nint\t\theight,\nbyte*\t\tdest )\n{\nbyte*\tsrc;\n\n#ifdef RANGECHECK\nif (x<0\n||x+width >SCREENWIDTH\n|| y<0\n|| y+height>SCREENHEIGHT\n|| (unsigned)scrn>4 )\n{\nI_Error (\"Bad V_DrawBlock\");\n}\n#endif\n\nsrc = screens[scrn] + y*SCREENWIDTH+x;\n\nwhile (height--)\n{\nmemcpy (dest, src, width);\nsrc += SCREENWIDTH;\ndest += width;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * pV ;\nint /*<<< orphan*/  v ;\n\nVOID V_GetBlock(ULONG Block, ULONG Offset, ULONG Length, UCHAR *Buffer, ULONG Count)\n{\nULONG i;\n\nfor (i = 0; i < Count; i++)\n{\nmemcpy(Buffer, &pV[Block * v + Offset], Length);\nBuffer += Length;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_v_video.c_V_MarkRect",
    "input":"\n0000000000000000 <V_MarkRect>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovl\t%ecx, %r14d\nb: \tmovl\t%edx, %r15d\ne: \tmovl\t%esi, %r12d\n11: \tmovl\t%edi, %ebx\n13: \tmovl\t(%rip), %edi  # 0x19 <V_MarkRect+0x19>\n19: \tmovl\t%ebx, %esi\n1b: \tmovl\t%r12d, %edx\n1e: \tcallq\t0x23 <V_MarkRect+0x23>\n23: \tmovl\t(%rip), %edi  # 0x29 <V_MarkRect+0x29>\n29: \tleal\t(%rbx,%r15), %esi\n2d: \taddl\t$-1, %esi\n30: \tleal\t(%r12,%r14), %edx\n34: \taddl\t$-1, %edx\n37: \taddq\t$8, %rsp\n3b: \tpopq\t%rbx\n3c: \tpopq\t%r12\n3e: \tpopq\t%r14\n40: \tpopq\t%r15\n42: \tjmp\t0x47 <V_MarkRect+0x47>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_AddToBox (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  dirtybox ;\n\nvoid\nV_MarkRect\n( int\t\tx,\nint\t\ty,\nint\t\twidth,\nint\t\theight )\n{\nM_AddToBox (dirtybox, x, y);\nM_AddToBox (dirtybox, x+width-1, y+height-1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  PULONG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  V_MarkRect_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_X (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_X_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_X_Start (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_X_Step (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_X_Step_Y_Step_X_Step_End (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_MarkRect_Y_Step_X_Step_Y_Step_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_SetSfxVolume",
    "input":"\n0000000000000000 <S_SetSfxVolume>:\n0: \tpushq\t%rbx\n1: \tmovl\t%edi, %ebx\n3: \tcmpl\t$128, %edi\n9: \tjb\t0x17 <S_SetSfxVolume+0x17>\nb: \tmovl\t$0, %edi\n10: \tmovl\t%ebx, %esi\n12: \tcallq\t0x17 <S_SetSfxVolume+0x17>\n17: \tmovl\t%ebx, (%rip)  # 0x1d <S_SetSfxVolume+0x1d>\n1d: \tpopq\t%rbx\n1e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int) ;\nint snd_SfxVolume ;\n\nvoid S_SetSfxVolume(int volume)\n{\n\nif (volume < 0 || volume > 127)\nI_Error(\"Attempt to set sfx volume at %d\", volume);\n\nsnd_SfxVolume = volume;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint S_sfxVolume ;\nint /*<<< orphan*/  D_PANIC (char*,int) ;\n\nvoid S_SetSfxVolume(int volume)\n{\nif (volume < 0 || volume > 127)\nD_PANIC(\"S_SetSfxVolume: volume %d out of range\", volume);\nS_sfxVolume = volume;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ChooseSkill",
    "input":"\n0000000000000000 <M_ChooseSkill>:\n0: \tpushq\t%rax\n1: \tcmpl\t%edi, (%rip)  # 0x7 <M_ChooseSkill+0x7>\n7: \tjne\t0x20 <M_ChooseSkill+0x20>\n9: \tmovl\t(%rip), %edi  # 0xf <M_ChooseSkill+0xf>\nf: \tmovl\t(%rip), %esi  # 0x15 <M_ChooseSkill+0x15>\n15: \tmovl\t$1, %edx\n1a: \tpopq\t%rax\n1b: \tjmp\t0x20 <M_ChooseSkill+0x20>\n20: \tmovq\t(%rip), %rsi  # 0x27 <M_ChooseSkill+0x27>\n27: \taddq\t$1, %rsi\n2b: \tmovl\t$1, %edx\n30: \tcallq\t0x35 <M_ChooseSkill+0x35>\n35: \txorl\t%eax, %eax\n37: \tpopq\t%rcx\n38: \tjmp\t0x3d <M_ChooseSkill+0x3d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_DeferedInitNew (int,scalar_t__,int) ;\nint /*<<< orphan*/  M_ClearMenus () ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_VerifyNightmare ;\nint /*<<< orphan*/  NIGHTMARE ;\nscalar_t__ epi ;\nint nightmare ;\n\nvoid M_ChooseSkill(int choice)\n{\nif (choice == nightmare)\n{\nM_StartMessage(NIGHTMARE,M_VerifyNightmare,true);\nreturn;\n}\n\nG_DeferedInitNew(choice,epi+1,1);\nM_ClearMenus ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_ChooseSkill_1 ;\nint /*<<< orphan*/  M_ChooseSkill_2 ;\nint /*<<< orphan*/  M_ChooseSkill_3 ;\nint /*<<< orphan*/  M_ChooseSkill_4 ;\nint /*<<< orphan*/  M_ChooseSkill_5 ;\nint /*<<< orphan*/  M_ChooseSkill_6 ;\nint /*<<< orphan*/  M_ChooseSkill_7 ;\nint /*<<< orphan*/  M_ChooseSkill_8 ;\nint /*<<< orphan*/  M_ChooseSkill_9 ;\nint /*<<< orphan*/  M_ChooseSkill_A ;\nint /*<<< orphan*/  M_ChooseSkill_B ;\nint /*<<< orphan*/  M_ChooseSkill_C ;\nint /*<<< orphan*/  M_ChooseSkill_D ;\nint /*<<< orphan*/  M_ChooseSkill_E ;\nint /*<<< orphan*/  M_ChooseSkill_F ;\nint /*<<< orphan*/  M_ChooseSkill_G ;\nint /*<<< orphan*/  M_ChooseSkill_H ;\nint /*<<< orphan*/  M_ChooseSkill_I ;\nint /*<<< orphan*/  M_ChooseSkill_J ;\nint /*<<< orphan*/  M_ChooseSkill_K ;\nint /*<<< orphan*/  M_ChooseSkill_L ;\nint /*<<< orphan*/  M_ChooseSkill_M ;\nint /*<<< orphan*/  M_ChooseSkill_N ;\nint /*<<< orphan*/  M_ChooseSkill_O ;\nint /*<<< orphan*/  M_ChooseSkill_P ;\nint /*<<< orphan*/  M_ChooseSkill_Q ;\nint /*<<< orphan*/  M_ChooseSkill_R ;\nint /*<<< orphan*/  M_ChooseSkill_S ;\nint /*<<< orphan*/  M_ChooseSkill_T ;\nint /*<<< orphan*/  M_ChooseSkill_U ;\nint /*<<< orphan*/  M_ChooseSkill_V ;\nint /*<<< orphan*/  M_ChooseSkill_W ;\nint /*<<< orphan*/  M_ChooseSkill_X ;\nint /*<<< orphan*/  M_ChooseSkill_Y ;\nint /*<<< orphan*/  M_ChooseSkill_Z ;\nint /*<<< orphan*/  M_ChooseSkill_a ;\nint /*<<< orphan*/  M_ChooseSkill_b ;\nint /*<<< orphan*/  M_ChooseSkill_c ;\nint /*<<< orphan*/  M_ChooseSkill_d ;\nint /*<<< orphan*/  M_ChooseSkill_e ;\nint /*<<< orphan*/  M_ChooseSkill_f ;\nint /*<<< orphan*/  M_ChooseSkill_g ;\nint /*<<< orphan*/  M_ChooseSkill_h ;\nint /*<<< orphan*/  M_ChooseSkill_i ;\nint /*<<< orphan*/  M_ChooseSkill_j ;\nint /*<<< orphan*/  M_ChooseSkill_k ;\nint /*<<< orphan*/  M_ChooseSkill_l ;\nint /*<<< orphan*/  M_ChooseSkill_m ;\nint /*<<< orphan*/  M_ChooseSkill_n ;\nint /*<<< orphan*/  M_ChooseSkill_o ;\nint /*<<< orphan*/  M_ChooseSkill_p ;\nint /*<<< orphan*/  M_ChooseSkill_q ;\nint /*<<< orphan*/  M_ChooseSkill_r ;\nint /*<<< orphan*/  M_ChooseSkill_s ;\nint /*<<< orphan*/  M_ChooseSkill_t ;\nint /*<<< orphan*/  M_ChooseSkill_u ;\nint /*<<< orphan*/  M_ChooseSkill_v ;\nint /*<<< orphan*/  M_ChooseSkill_w ;\nint /*<<< orphan*/  M_ChooseSkill_x ;\nint /*<<< orphan*/  M_ChooseSkill_y ;\nint /*<<< orphan*/  M_ChooseSkill_z ;\nint /*<<< orphan*/  M_ChooseSkill_A ;\nint /*<<< orphan*/  M_ChooseSkill_B ;\nint /*<<< orphan*/  M_ChooseSkill_C ;\nint /*<<< orphan*/  M_ChooseSkill_D ;\nint /*<<< orphan*/  M_ChooseSkill_E ;\nint /*<<< orphan*/  M_ChooseSkill_F ;\nint /*<<< orphan*/  M_ChooseSkill_G ;\nint /*<<< orphan*/  M_ChooseSkill_H ;\nint /*<<< orphan*/  M_ChooseSkill_I ;\nint /*<<< orphan*/  M_ChooseSkill_J ;\nint /*<<< orphan*/  M_ChooseSkill_K ;\nint /*<<< orphan*/  M_ChooseSkill_L ;\nint /*<<< orphan*/  M_ChooseSkill_M ;\nint /*<<< orphan*/  M_ChooseSkill_N ;\nint /*<<< orphan*/  M_ChooseSkill_O ;\nint /*<<< orphan*/  M_ChooseSkill_P ;\nint /*<<< orphan*/  M_ChooseSkill_Q ;\nint /*<<< orphan*/  M_ChooseSkill_R ;\nint /*<<< orphan*/  M_ChooseSkill_S ;\nint /*<<< orphan*/  M_ChooseSkill_T ;\nint /*<<< orphan*/  M_ChooseSkill_U ;\nint /*<<< orphan*/  M_ChooseSkill_V ;\nint /*<<< orphan*/  M_ChooseSkill_W ;\nint /*<<< orphan*/  M_ChooseSkill_X ;\nint /*<<< orphan*/  M_ChooseSkill_Y ;\nint /*<<< orphan*/  M_ChooseSkill_Z ;\nint /*<<< orphan*/  M_ChooseSkill_a ;\nint /*<<< orphan*/  M_ChooseSkill_b ;\nint /*<<< orphan*/  M_ChooseSkill_c ;\nint /*<<< orphan*/  M_ChooseSkill_d ;\nint /*<<< orphan*/  M_ChooseSkill_e ;\nint /*<<< orphan*/  M_ChooseSkill_f ;\nint /*<<< orphan*/  M_ChooseSkill_g ;\nint /*<<< orphan*/  M_ChooseSkill_h ;\nint /*<<< orphan*/  M_ChooseSkill_i ;\nint /*<<< orphan*/  M_ChooseSkill_j ;\nint /*<<< orphan*/  M_ChooseSkill_k ;\nint /*<<< orphan*/  M_ChooseSkill_l ;\nint /*<<< orphan*/  M_ChooseSkill_m ;\nint /*<<< orphan*/  M_ChooseSkill_n ;\nint /*<<< orphan*/  M_ChooseSkill_o ;\nint /*<<< orphan*/  M_ChooseSkill_p ;\nint /*<<< orphan*/  M_ChooseSkill_q ;\nint /*<<< orphan*/  M_ChooseSkill_r ;\nint /*<<< orphan*/  M"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_sight.c_P_CrossBSPNode",
    "input":"\n0000000000000000 <P_CrossBSPNode>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t(%rip), %eax  # 0xe <P_CrossBSPNode+0xe>\ne: \ttestl\t%edi, %eax\n10: \tje\t0x1d <P_CrossBSPNode+0x1d>\n12: \tcmpl\t$-1, %edi\n15: \tje\t0x8e <P_CrossBSPNode+0x8e>\n17: \tnotl\t%eax\n19: \tandl\t%eax, %edi\n1b: \tjmp\t0x90 <P_CrossBSPNode+0x90>\n1d: \txorl\t%r14d, %r14d\n20: \tmovq\t(%rip), %r15  # 0x27 <P_CrossBSPNode+0x27>\n27: \tmovslq\t%edi, %r12\n2a: \tleaq\t(%r15,%r12,8), %rbx\n2e: \tmovl\t(%rip), %edi  # 0x34 <P_CrossBSPNode+0x34>\n34: \tmovl\t(%rip), %esi  # 0x3a <P_CrossBSPNode+0x3a>\n3a: \tmovq\t%rbx, %rdx\n3d: \tcallq\t0x42 <P_CrossBSPNode+0x42>\n42: \tmovl\t%eax, %ebp\n44: \tcmpl\t$2, %eax\n47: \tcmovel\t%r14d, %ebp\n4b: \tmovq\t(%r15,%r12,8), %rax\n4f: \tmovslq\t%ebp, %rcx\n52: \tmovl\t(%rax,%rcx,4), %edi\n55: \tcallq\t0x5a <P_CrossBSPNode+0x5a>\n5a: \ttestl\t%eax, %eax\n5c: \tje\t0xa3 <P_CrossBSPNode+0xa3>\n5e: \tmovl\t(%rip), %edi  # 0x64 <P_CrossBSPNode+0x64>\n64: \tmovl\t(%rip), %esi  # 0x6a <P_CrossBSPNode+0x6a>\n6a: \tmovq\t%rbx, %rdx\n6d: \tcallq\t0x72 <P_CrossBSPNode+0x72>\n72: \tcmpl\t%eax, %ebp\n74: \tje\t0x9d <P_CrossBSPNode+0x9d>\n76: \tmovq\t(%rbx), %rax\n79: \txorl\t$1, %ebp\n7c: \tmovslq\t%ebp, %rcx\n7f: \tmovl\t(%rax,%rcx,4), %edi\n82: \tmovl\t(%rip), %eax  # 0x88 <P_CrossBSPNode+0x88>\n88: \ttestl\t%edi, %eax\n8a: \tje\t0x20 <P_CrossBSPNode+0x20>\n8c: \tjmp\t0x12 <P_CrossBSPNode+0x12>\n8e: \txorl\t%edi, %edi\n90: \tpopq\t%rbx\n91: \tpopq\t%r12\n93: \tpopq\t%r14\n95: \tpopq\t%r15\n97: \tpopq\t%rbp\n98: \tjmp\t0x9d <P_CrossBSPNode+0x9d>\n9d: \tmovl\t$1, %r14d\na3: \tmovl\t%r14d, %eax\na6: \tpopq\t%rbx\na7: \tpopq\t%r12\na9: \tpopq\t%r14\nab: \tpopq\t%r15\nad: \tpopq\t%rbp\nae: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int* children; } ;\ntypedef  TYPE_1__ node_t ;\ntypedef  int /*<<< orphan*/  divline_t ;\ntypedef  int boolean ;\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint NF_SUBSECTOR ;\nint P_CrossSubsector (int) ;\nint P_DivlineSide (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nTYPE_1__* nodes ;\nTYPE_2__ strace ;\nint /*<<< orphan*/  t2x ;\nint /*<<< orphan*/  t2y ;\n\nboolean P_CrossBSPNode (int bspnum)\n{\nnode_t*\tbsp;\nint\t\tside;\n\nif (bspnum & NF_SUBSECTOR)\n{\nif (bspnum == -1)\nreturn P_CrossSubsector (0);\nelse\nreturn P_CrossSubsector (bspnum&(~NF_SUBSECTOR));\n}\n\nbsp = &nodes[bspnum];\n\n// decide which side the start point is on\nside = P_DivlineSide (strace.x, strace.y, (divline_t *)bsp);\nif (side == 2)\nside = 0;\t// an \"on\" should cross both sides\n\n// cross the starting side\nif (!P_CrossBSPNode (bsp->children[side]) )\nreturn false;\n\n// the partition plane is crossed here\nif (side == P_DivlineSide (t2x, t2y,(divline_t *)bsp))\n{\n// the line doesn't touch the other side\nreturn true;\n}\n\n// cross the ending side\nreturn P_CrossBSPNode (bsp->children[side^1]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* children; } ;\ntypedef  TYPE_1__ node_t ;\n\n/* Variables and functions */\nint BSP_NODE_LEAF ;\nint BSP_NODE_NORMAL ;\nint BSP_NODE_PLANE ;\nint BSP_NODE_PLANE_MASK ;\nint BSP_NODE_PLANE_SHIFT ;\nint BSP_NODE_TYPE_MASK ;\nint BSP_NODE_TYPE_SHIFT ;\nint /*<<< orphan*/  P_CrossBSPNode (int) ;\nint /*<<< orphan*/  P_CrossBSPNodePlane (int) ;\nint /*<<< orphan*/  P_CrossBSPNodePlaneSide (int) ;\nint /*<<< orphan*/  P_CrossBSPNodeSide (int) ;\nint /*<<< orphan*/  P_CrossBSPNodeType (int) ;\nTYPE_1__** bsp_nodes ;\n\nint P_CrossBSPNode(int node)\n{\nint\t\t\tside;\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MASK;\nside = P_CrossBSPNodeSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_PLANE_MASK)\n{\nnode &= ~BSP_NODE_PLANE_MASK;\nside = P_CrossBSPNodePlaneSide(node);\nif (!side)\nreturn 0;\nnode = bsp_nodes[node]->children[side];\n}\n\nif (node & BSP_NODE_TYPE_MASK)\n{\nnode &= ~BSP_NODE_TYPE_MA"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_eraseSText",
    "input":"\n0000000000000000 <HUlib_eraseSText>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r14\n8: \tcmpl\t$0, (%rdi)\nb: \tjle\t0x5b <HUlib_eraseSText+0x5b>\nd: \txorl\t%r15d, %r15d\n10: \txorl\t%ebx, %ebx\n12: \tjmp\t0x3c <HUlib_eraseSText+0x3c>\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tmovq\t24(%r14), %rdi\n24: \taddq\t%r15, %rdi\n27: \tcallq\t0x2c <HUlib_eraseSText+0x2c>\n2c: \taddq\t$1, %rbx\n30: \tmovslq\t(%r14), %rax\n33: \taddq\t$4, %r15\n37: \tcmpq\t%rax, %rbx\n3a: \tjge\t0x5b <HUlib_eraseSText+0x5b>\n3c: \tcmpq\t$0, 16(%r14)\n41: \tje\t0x20 <HUlib_eraseSText+0x20>\n43: \tmovq\t8(%r14), %rax\n47: \tcmpq\t$0, (%rax)\n4b: \tjne\t0x20 <HUlib_eraseSText+0x20>\n4d: \tmovq\t24(%r14), %rax\n51: \tmovl\t$4, (%rax,%r15)\n59: \tjmp\t0x20 <HUlib_eraseSText+0x20>\n5b: \tmovq\t8(%r14), %rax\n5f: \tmovq\t(%rax), %rax\n62: \tmovq\t%rax, 16(%r14)\n66: \tpopq\t%rbx\n67: \tpopq\t%r14\n69: \tpopq\t%r15\n6b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int h; scalar_t__* on; scalar_t__ laston; TYPE_2__* l; } ;\ntypedef  TYPE_1__ hu_stext_t ;\nstruct TYPE_5__ {int needsupdate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_eraseTextLine (TYPE_2__*) ;\n\nvoid HUlib_eraseSText(hu_stext_t* s)\n{\n\nint i;\n\nfor (i=0 ; i<s->h ; i++)\n{\nif (s->laston && !*s->on)\ns->l[i].needsupdate = 4;\nHUlib_eraseTextLine(&s->l[i]);\n}\ns->laston = *s->on;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * text; int /*<<< orphan*/ * font; TYPE_1__* stext; } ;\nstruct TYPE_4__ {int /*<<< orphan*/ * font; int /*<<< orphan*/ * text; } ;\ntypedef  TYPE_1__ SText ;\ntypedef  TYPE_2__ HUlib_Context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_eraseText (int /*<<< orphan*/ *) ;\n\nvoid HUlib_eraseSText(HUlib_Context *c)\n{\nint i;\n\nfor (i = 0; i < c->stext->num; i++)\n{\nif (c->stext->font[i] != NULL)\n{\nHU_eraseText(c->stext->text + i);\n}\nelse\n{\nc->stext->font[i] = c->font;\nc->stext->text[i] = 0;\n}\n}\n\nc->font = c->stext->font[0];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_bsp.c_R_RenderBSPNode",
    "input":"\n0000000000000000 <R_RenderBSPNode>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tnopl\t(%rax,%rax)\n10: \tmovl\t(%rip), %ecx  # 0x16 <R_RenderBSPNode+0x16>\n16: \ttestl\t%edi, %ecx\n18: \tjne\t0x6f <R_RenderBSPNode+0x6f>\n1a: \tmovq\t(%rip), %r15  # 0x21 <R_RenderBSPNode+0x21>\n21: \tmovslq\t%edi, %r12\n24: \tshlq\t$4, %r12\n28: \tleaq\t(%r15,%r12), %r14\n2c: \tmovl\t(%rip), %edi  # 0x32 <R_RenderBSPNode+0x32>\n32: \tmovl\t(%rip), %esi  # 0x38 <R_RenderBSPNode+0x38>\n38: \tmovq\t%r14, %rdx\n3b: \tcallq\t0x40 <R_RenderBSPNode+0x40>\n40: \tmovq\t(%r15,%r12), %rcx\n44: \tmovslq\t%eax, %rbx\n47: \tmovl\t(%rcx,%rbx,4), %edi\n4a: \tcallq\t0x4f <R_RenderBSPNode+0x4f>\n4f: \tmovq\t8(%r15,%r12), %rax\n54: \txorl\t$1, %ebx\n57: \tmovslq\t%ebx, %rbx\n5a: \tmovl\t(%rax,%rbx,4), %edi\n5d: \tcallq\t0x62 <R_RenderBSPNode+0x62>\n62: \ttestq\t%rax, %rax\n65: \tje\t0x8d <R_RenderBSPNode+0x8d>\n67: \tmovq\t(%r14), %rax\n6a: \tmovl\t(%rax,%rbx,4), %edi\n6d: \tjmp\t0x10 <R_RenderBSPNode+0x10>\n6f: \tnotl\t%ecx\n71: \tandl\t%edi, %ecx\n73: \txorl\t%eax, %eax\n75: \tcmpl\t$-1, %edi\n78: \tcmovnel\t%ecx, %eax\n7b: \tmovl\t%eax, %edi\n7d: \taddq\t$8, %rsp\n81: \tpopq\t%rbx\n82: \tpopq\t%r12\n84: \tpopq\t%r14\n86: \tpopq\t%r15\n88: \tjmp\t0x8d <R_RenderBSPNode+0x8d>\n8d: \taddq\t$8, %rsp\n91: \tpopq\t%rbx\n92: \tpopq\t%r12\n94: \tpopq\t%r14\n96: \tpopq\t%r15\n98: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int* children; int /*<<< orphan*/ * bbox; } ;\ntypedef  TYPE_1__ node_t ;\n\n/* Variables and functions */\nint NF_SUBSECTOR ;\nscalar_t__ R_CheckBBox (int /*<<< orphan*/ ) ;\nint R_PointOnSide (int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  R_Subsector (int) ;\nTYPE_1__* nodes ;\nint /*<<< orphan*/  viewx ;\nint /*<<< orphan*/  viewy ;\n\nvoid R_RenderBSPNode (int bspnum)\n{\nnode_t*\tbsp;\nint\t\tside;\n\n// Found a subsector?\nif (bspnum & NF_SUBSECTOR)\n{\nif (bspnum == -1)\nR_Subsector (0);\nelse\nR_Subsector (bspnum&(~NF_SUBSECTOR));\nreturn;\n}\n\nbsp = &nodes[bspnum];\n\n// Decide which side the view point is on.\nside = R_PointOnSide (viewx, viewy, bsp);\n\n// Recursively divide front space.\nR_RenderBSPNode (bsp->children[side]);\n\n// Possibly divide back space.\nif (R_CheckBBox (bsp->bbox[side^1]))\nR_RenderBSPNode (bsp->children[side^1]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  right; int /*<<< orphan*/  left; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  right; int /*<<< orphan*/  left; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  right; int /*<<< orphan*/  left; } ;\ntypedef  TYPE_1__ BSPNode ;\ntypedef  int /*<<< orphan*/  BSPLeaf ;\ntypedef  TYPE_2__ BSPLeaf_t ;\ntypedef  TYPE_3__ BSPNode_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BSP_NODE_MASK ;\nint /*<<< orphan*/  BSP_NODE_SHIFT ;\nint /*<<< orphan*/  BSP_NODE_TYPE ;\nint /*<<< orphan*/  BSP_NODE_TYPE_LEAF ;\nint /*<<< orphan*/  BSP_NODE_TYPE_NODE ;\nint /*<<< orphan*/  R_RenderBSPLeaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode (int) ;\nint /*<<< orphan*/  R_RenderBSPNode_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_RenderBSPNode_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Node_Leaf (int /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_eraseIText",
    "input":"\n0000000000000000 <HUlib_eraseIText>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcmpq\t$0, 8(%rdi)\n9: \tje\t0x1b <HUlib_eraseIText+0x1b>\nb: \tmovq\t(%rbx), %rax\ne: \tcmpq\t$0, (%rax)\n12: \tjne\t0x1b <HUlib_eraseIText+0x1b>\n14: \tmovl\t$4, 16(%rbx)\n1b: \tleaq\t16(%rbx), %rdi\n1f: \tcallq\t0x24 <HUlib_eraseIText+0x24>\n24: \tmovq\t(%rbx), %rax\n27: \tmovq\t(%rax), %rax\n2a: \tmovq\t%rax, 8(%rbx)\n2e: \tpopq\t%rbx\n2f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int needsupdate; } ;\nstruct TYPE_4__ {scalar_t__* on; scalar_t__ laston; TYPE_2__ l; } ;\ntypedef  TYPE_1__ hu_itext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_eraseTextLine (TYPE_2__*) ;\n\nvoid HUlib_eraseIText(hu_itext_t* it)\n{\nif (it->laston && !*it->on)\nit->l.needsupdate = 4;\nHUlib_eraseTextLine(&it->l);\nit->laston = *it->on;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__* text; int /*<<< orphan*/ * font; } ;\ntypedef  TYPE_1__ HU_IText ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_free (int /*<<< orphan*/ *) ;\n\nvoid HUlib_eraseIText(HU_IText *it)\n{\nif (it->font && !it->text[0])\n{\nit->font = NULL;\nit->font_size = 4;\n}\nHU_free(it->text);\nit->text = it->font;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_ExitLevel",
    "input":"\n0000000000000000 <G_ExitLevel>:\n0: \tmovl\t$0, (%rip)    # 0xa <G_ExitLevel+0xa>\na: \tmovl\t(%rip), %eax  # 0x10 <G_ExitLevel+0x10>\n10: \tmovl\t%eax, (%rip)  # 0x16 <G_ExitLevel+0x16>\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ga_completed ;\nint /*<<< orphan*/  gameaction ;\nint secretexit ;\n\nvoid G_ExitLevel (void)\n{\nsecretexit = false;\ngameaction = ga_completed;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_exitLevel ;\nint /*<<< orphan*/  G_level ;\n\nvoid G_ExitLevel(void)\n{\nG_exitLevel = G_level;\nG_level = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_T_LightFlash",
    "input":"\n0000000000000000 <T_LightFlash>:\n0: \tpushq\t%rbx\n1: \taddl\t$-1, (%rdi)\n4: \tje\t0x8 <T_LightFlash+0x8>\n6: \tpopq\t%rbx\n7: \tretq\n8: \tmovq\t%rdi, %rbx\nb: \tmovq\t8(%rdi), %rcx\nf: \tmovq\t32(%rdi), %rax\n13: \tcmpq\t%rcx, (%rax)\n16: \tjne\t0x2b <T_LightFlash+0x2b>\n18: \tmovq\t16(%rbx), %rcx\n1c: \tmovq\t%rcx, (%rax)\n1f: \txorl\t%eax, %eax\n21: \tcallq\t0x26 <T_LightFlash+0x26>\n26: \tandl\t24(%rbx), %eax\n29: \tjmp\t0x38 <T_LightFlash+0x38>\n2b: \tmovq\t%rcx, (%rax)\n2e: \txorl\t%eax, %eax\n30: \tcallq\t0x35 <T_LightFlash+0x35>\n35: \tandl\t28(%rbx), %eax\n38: \taddl\t$1, %eax\n3b: \tmovl\t%eax, (%rbx)\n3d: \tpopq\t%rbx\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int count; scalar_t__ maxlight; scalar_t__ minlight; int mintime; int maxtime; TYPE_1__* sector; } ;\ntypedef  TYPE_2__ lightflash_t ;\nstruct TYPE_4__ {scalar_t__ lightlevel; } ;\n\n/* Variables and functions */\nint P_Random () ;\n\nvoid T_LightFlash (lightflash_t* flash)\n{\nif (--flash->count)\nreturn;\n\nif (flash->sector->lightlevel == flash->maxlight)\n{\nflash-> sector->lightlevel = flash->minlight;\nflash->count = (P_Random()&flash->mintime)+1;\n}\nelse\n{\nflash-> sector->lightlevel = flash->maxlight;\nflash->count = (P_Random()&flash->maxtime)+1;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  flash_counter; int /*<<< orphan*/  flash_state; TYPE_1__* flash_light; } ;\nstruct TYPE_4__ {scalar_t__ color; } ;\ntypedef  TYPE_2__ Light ;\n\n/* Variables and functions */\nint /*<<< orphan*/  T_LightUpdate (TYPE_2__*) ;\n\nvoid T_LightFlash(Light *L)\n{\nL->flash_counter--;\nif (!L->flash_counter)\n{\nif (L->flash_light->color == L->flash_state)\n{\nL->flash_light->color = 0;\nT_LightUpdate(L);\nL->flash_state &= ~L->flash_counter;\n}\nelse\n{\nL->flash_light->color = L->flash_state;\nT_LightUpdate(L);\nL->flash_state |= L->flash_counter;\n}\nL->flash_counter++;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_VileStart",
    "input":"\n0000000000000000 <A_VileStart>:\n0: \tmovl\t(%rip), %esi  # 0x6 <A_VileStart+0x6>\n6: \tjmp\t0xb <A_VileStart+0xb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_vilatk ;\n\nvoid A_VileStart (mobj_t* actor)\n{\nS_StartSound (actor, sfx_vilatk);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Vile ;\nint /*<<< orphan*/  A_VileEnd (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nVOID A_VileStart(ULONG a)\n{\nA_VileEnd(a, A_Vile);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_CPosRefire",
    "input":"\n0000000000000000 <A_CPosRefire>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <A_CPosRefire+0x9>\n9: \txorl\t%eax, %eax\nb: \tcallq\t0x10 <A_CPosRefire+0x10>\n10: \tcmpl\t$40, %eax\n13: \tjge\t0x17 <A_CPosRefire+0x17>\n15: \tpopq\t%rbx\n16: \tretq\n17: \tmovq\t8(%rbx), %rsi\n1b: \ttestq\t%rsi, %rsi\n1e: \tje\t0x32 <A_CPosRefire+0x32>\n20: \tcmpq\t$0, (%rsi)\n24: \tjle\t0x32 <A_CPosRefire+0x32>\n26: \tmovq\t%rbx, %rdi\n29: \tcallq\t0x2e <A_CPosRefire+0x2e>\n2e: \ttestl\t%eax, %eax\n30: \tjne\t0x15 <A_CPosRefire+0x15>\n32: \tmovq\t(%rbx), %rax\n35: \tmovl\t(%rax), %esi\n37: \tmovq\t%rbx, %rdi\n3a: \tpopq\t%rbx\n3b: \tjmp\t0x40 <A_CPosRefire+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_5__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {TYPE_1__* info; TYPE_5__* target; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_10__ {scalar_t__ health; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  seestate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_2__*) ;\nint /*<<< orphan*/  P_CheckSight (TYPE_2__*,TYPE_5__*) ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_2__*,int /*<<< orphan*/ ) ;\n\nvoid A_CPosRefire (mobj_t* actor)\n{\n// keep firing unless target got out of sight\nA_FaceTarget (actor);\n\nif (P_Random () < 40)\nreturn;\n\nif (!actor->target\n|| actor->target->health <= 0\n|| !P_CheckSight (actor, actor->target) )\n{\nP_SetMobjState (actor, actor->info->seestate);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {TYPE_1__* cpos; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  cpos; } ;\ntypedef  TYPE_2__ Object ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_CPos (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_CPosRefire (TYPE_2__*) ;\nint /*<<< orphan*/  A_CPosSet (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_CPosSetTime (TYPE_2__*) ;\nint /*<<< orphan*/  A_CPosTime (TYPE_2__*) ;\n\nvoid A_CPosRefire(Object *o)\n{\nA_CPosRefire(o);\n\nif (o->cpos && o->cpos->cpos && A_CPosTime(o) >= 40)\n{\nA_CPosSet(o, o->cpos->cpos);\nif (!A_CPos(o, A_CPosSetTime(o)))\nA_CPosSet(o, A_CPosRefire(o));\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawThermo",
    "input":"\n0000000000000000 <M_DrawThermo>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t%ecx, %r14d\nb: \tmovl\t%edx, %ebp\nd: \tmovl\t%esi, %r12d\n10: \tmovl\t%edi, %r15d\n13: \tmovl\t(%rip), %esi  # 0x19 <M_DrawThermo+0x19>\n19: \tmovl\t$0, %edi\n1e: \tcallq\t0x23 <M_DrawThermo+0x23>\n23: \tmovl\t%r15d, %edi\n26: \tmovl\t%r12d, %esi\n29: \txorl\t%edx, %edx\n2b: \tmovl\t%eax, %ecx\n2d: \tcallq\t0x32 <M_DrawThermo+0x32>\n32: \taddl\t$8, %r15d\n36: \tmovl\t(%rip), %esi  # 0x3c <M_DrawThermo+0x3c>\n3c: \tmovl\t%r15d, %ebx\n3f: \ttestl\t%ebp, %ebp\n41: \tjle\t0x76 <M_DrawThermo+0x76>\n43: \tnopw\t%cs:(%rax,%rax)\n4d: \tnopl\t(%rax)\n50: \tmovl\t$0, %edi\n55: \tcallq\t0x5a <M_DrawThermo+0x5a>\n5a: \tmovl\t%ebx, %edi\n5c: \tmovl\t%r12d, %esi\n5f: \txorl\t%edx, %edx\n61: \tmovl\t%eax, %ecx\n63: \tcallq\t0x68 <M_DrawThermo+0x68>\n68: \taddl\t$8, %ebx\n6b: \tmovl\t(%rip), %esi  # 0x71 <M_DrawThermo+0x71>\n71: \taddl\t$-1, %ebp\n74: \tjne\t0x50 <M_DrawThermo+0x50>\n76: \tmovl\t$0, %edi\n7b: \tcallq\t0x80 <M_DrawThermo+0x80>\n80: \tmovl\t%ebx, %edi\n82: \tmovl\t%r12d, %esi\n85: \txorl\t%edx, %edx\n87: \tmovl\t%eax, %ecx\n89: \tcallq\t0x8e <M_DrawThermo+0x8e>\n8e: \tleal\t(%r15,%r14,8), %ebx\n92: \tmovl\t(%rip), %esi  # 0x98 <M_DrawThermo+0x98>\n98: \tmovl\t$0, %edi\n9d: \tcallq\t0xa2 <M_DrawThermo+0xa2>\na2: \tmovl\t%ebx, %edi\na4: \tmovl\t%r12d, %esi\na7: \txorl\t%edx, %edx\na9: \tmovl\t%eax, %ecx\nab: \tpopq\t%rbx\nac: \tpopq\t%r12\nae: \tpopq\t%r14\nb0: \tpopq\t%r15\nb2: \tpopq\t%rbp\nb3: \tjmp\t0xb8 <M_DrawThermo+0xb8>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid\nM_DrawThermo\n( int\tx,\nint\ty,\nint\tthermWidth,\nint\tthermDot )\n{\nint\t\txx;\nint\t\ti;\n\nxx = x;\nV_DrawPatchDirect (xx,y,0,W_CacheLumpName(\"M_THERML\",PU_CACHE));\nxx += 8;\nfor (i=0;i<thermWidth;i++)\n{\nV_DrawPatchDirect (xx,y,0,W_CacheLumpName(\"M_THERMM\",PU_CACHE));\nxx += 8;\n}\nV_DrawPatchDirect (xx,y,0,W_CacheLumpName(\"M_THERMR\",PU_CACHE));\n\nV_DrawPatchDirect ((x+8) + thermDot*8,y,\n0,W_CacheLumpName(\"M_THERMO\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BLACK ;\nint /*<<< orphan*/  BRIGHT ;\nint /*<<< orphan*/  GREEN ;\nint /*<<< orphan*/  M_DrawLine (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawRect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawText (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightRightCenter (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightRightLeft (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightRightRight (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawTextRightRightRightRightRightRightRightRightRightRightRightCenter (int"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_switch.c_P_InitSwitchList",
    "input":"\n0000000000000000 <P_InitSwitchList>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovq\t(%rip), %rax  # 0xf <P_InitSwitchList+0xf>\nf: \txorl\t%ecx, %ecx\n11: \tcmpq\t(%rip), %rax  # 0x18 <P_InitSwitchList+0x18>\n18: \tsete\t%cl\n1b: \tcmpq\t(%rip), %rax  # 0x22 <P_InitSwitchList+0x22>\n22: \tleal\t1(%rcx,%rcx), %eax\n26: \tmovl\t$2, %r14d\n2c: \tcmovnel\t%eax, %r14d\n30: \tmovl\t(%rip), %eax  # 0x36 <P_InitSwitchList+0x36>\n36: \ttestl\t%eax, %eax\n38: \tjle\t0xd5 <P_InitSwitchList+0xd5>\n3e: \txorl\t%ebx, %ebx\n40: \txorl\t%ebp, %ebp\n42: \txorl\t%r15d, %r15d\n45: \tjmp\t0x60 <P_InitSwitchList+0x60>\n47: \tnopw\t(%rax,%rax)\n50: \taddq\t$1, %rbp\n54: \tmovslq\t%eax, %rcx\n57: \taddq\t$12, %rbx\n5b: \tcmpq\t%rcx, %rbp\n5e: \tjge\t0xd5 <P_InitSwitchList+0xd5>\n60: \tmovq\t(%rip), %rcx  # 0x67 <P_InitSwitchList+0x67>\n67: \tmovl\t(%rcx,%rbx), %edx\n6a: \ttestl\t%edx, %edx\n6c: \tje\t0xb3 <P_InitSwitchList+0xb3>\n6e: \tcmpl\t%r14d, %edx\n71: \tjg\t0x50 <P_InitSwitchList+0x50>\n73: \tmovl\t8(%rcx,%rbx), %edi\n77: \tcallq\t0x7c <P_InitSwitchList+0x7c>\n7c: \tmovq\t(%rip), %rcx  # 0x83 <P_InitSwitchList+0x83>\n83: \tmovslq\t%r15d, %r12\n86: \tmovl\t%eax, (%rcx,%r12,4)\n8a: \tmovq\t(%rip), %rax  # 0x91 <P_InitSwitchList+0x91>\n91: \tmovl\t4(%rax,%rbx), %edi\n95: \tcallq\t0x9a <P_InitSwitchList+0x9a>\n9a: \tmovq\t(%rip), %rcx  # 0xa1 <P_InitSwitchList+0xa1>\na1: \tleal\t2(%r12), %r15d\na6: \tmovl\t%eax, 4(%rcx,%r12,4)\nab: \tmovl\t(%rip), %eax  # 0xb1 <P_InitSwitchList+0xb1>\nb1: \tjmp\t0x50 <P_InitSwitchList+0x50>\nb3: \tmovl\t%r15d, %eax\nb6: \tshrl\t$31, %eax\nb9: \taddl\t%r15d, %eax\nbc: \tsarl\t%eax\nbe: \tmovl\t%eax, (%rip)  # 0xc4 <P_InitSwitchList+0xc4>\nc4: \tmovq\t(%rip), %rax  # 0xcb <P_InitSwitchList+0xcb>\ncb: \tmovslq\t%r15d, %rcx\nce: \tmovl\t$4294967295, (%rax,%rcx,4) # imm = 0xFFFFFFFF\nd5: \tpopq\t%rbx\nd6: \tpopq\t%r12\nd8: \tpopq\t%r14\nda: \tpopq\t%r15\ndc: \tpopq\t%rbp\ndd: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int episode; int /*<<< orphan*/  name2; int /*<<< orphan*/  name1; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int /*<<< orphan*/ ) ;\nint MAXSWITCHES ;\nscalar_t__ R_CheckTextureNumForName (int /*<<< orphan*/ ) ;\nvoid* R_TextureNumForName (int /*<<< orphan*/ ) ;\nTYPE_1__* alphSwitchList ;\nscalar_t__ commercial ;\nscalar_t__ gamemode ;\nint numswitches ;\nscalar_t__ registered ;\nint* switchlist ;\n\nvoid P_InitSwitchList(void)\n{\nint\t\ti;\nint\t\tindex;\nint\t\tepisode;\n\nepisode = 1;\n\nif (gamemode == registered)\nepisode = 2;\nelse\nif ( gamemode == commercial )\nepisode = 3;\n\nfor (index = 0,i = 0;i < MAXSWITCHES;i++)\n{\nif (!alphSwitchList[i].episode)\n{\nnumswitches = index/2;\nswitchlist[index] = -1;\nbreak;\n}\n\nif (alphSwitchList[i].episode <= episode)\n{\n#if 0\t// UNUSED - debug?\nint\t\tvalue;\n\nif (R_CheckTextureNumForName(alphSwitchList[i].name1) < 0)\n{\nI_Error(\"Can't find switch texture '%s'!\",\nalphSwitchList[i].name1);\ncontinue;\n}\n\nvalue = R_TextureNumForName(alphSwitchList[i].name1);\n#endif\nswitchlist[index++] = R_TextureNumForName(alphSwitchList[i].name1);\nswitchlist[index++] = R_TextureNumForName(alphSwitchList[i].name2);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  switch_to; int /*<<< orphan*/  switch_from; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_SwitchTo (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck_NoCheck (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SwitchTo_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_InitSprites",
    "input":"\n0000000000000000 <R_InitSprites>:\n0: \tcmpl\t$0, (%rip)    # 0x7 <R_InitSprites+0x7>\n7: \tjle\t0x37 <R_InitSprites+0x37>\n9: \tmovq\t(%rip), %rax  # 0x10 <R_InitSprites+0x10>\n10: \txorl\t%ecx, %ecx\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \tmovl\t$4294967295, (%rax,%rcx,4) # imm = 0xFFFFFFFF\n27: \taddq\t$1, %rcx\n2b: \tmovslq\t(%rip), %rdx  # 0x32 <R_InitSprites+0x32>\n32: \tcmpq\t%rdx, %rcx\n35: \tjl\t0x20 <R_InitSprites+0x20>\n37: \tjmp\t0x3c <R_InitSprites+0x3c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_InitSpriteDefs (char**) ;\nint SCREENWIDTH ;\nint* negonearray ;\n\nvoid R_InitSprites (char** namelist)\n{\nint\t\ti;\n\nfor (i=0 ; i<SCREENWIDTH ; i++)\n{\nnegonearray[i] = -1;\n}\n\nR_InitSpriteDefs (namelist);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint MAXSPRITES ;\nint /*<<< orphan*/  R_InitSpritePalette () ;\nint /*<<< orphan*/ * sprite ;\n\nvoid R_InitSprites(void)\n{\nint i;\n\nfor (i=0; i<MAXSPRITES; i++)\n{\nsprite[i].x = -1;\n}\n\nR_InitSpritePalette();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_tick.c_P_RunThinkers",
    "input":"\n0000000000000000 <P_RunThinkers>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rip), %rbx  # 0xb <P_RunThinkers+0xb>\nb: \tmovl\t$0, %r14d\n11: \tcmpq\t%r14, %rbx\n14: \tjne\t0x42 <P_RunThinkers+0x42>\n16: \tjmp\t0x5f <P_RunThinkers+0x5f>\n18: \tnopl\t(%rax,%rax)\n20: \tmovq\t(%rbx), %rax\n23: \tmovq\t24(%rbx), %rcx\n27: \tmovq\t%rcx, 24(%rax)\n2b: \tmovq\t24(%rbx), %rcx\n2f: \tmovq\t%rax, (%rcx)\n32: \tmovq\t%rbx, %rdi\n35: \tcallq\t0x3a <P_RunThinkers+0x3a>\n3a: \tmovq\t(%rbx), %rbx\n3d: \tcmpq\t%r14, %rbx\n40: \tje\t0x5f <P_RunThinkers+0x5f>\n42: \tcmpq\t$-1, 8(%rbx)\n47: \tje\t0x20 <P_RunThinkers+0x20>\n49: \tmovq\t16(%rbx), %rax\n4d: \ttestq\t%rax, %rax\n50: \tje\t0x57 <P_RunThinkers+0x57>\n52: \tmovq\t%rbx, %rdi\n55: \tcallq\t*%rax\n57: \tmovq\t(%rbx), %rbx\n5a: \tcmpq\t%r14, %rbx\n5d: \tjne\t0x42 <P_RunThinkers+0x42>\n5f: \taddq\t$8, %rsp\n63: \tpopq\t%rbx\n64: \tpopq\t%r14\n66: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {scalar_t__ acv; int /*<<< orphan*/  (* acp1 ) (TYPE_3__*) ;} ;\nstruct TYPE_9__ {struct TYPE_9__* next; TYPE_1__ function; TYPE_2__* prev; } ;\ntypedef  TYPE_3__ thinker_t ;\ntypedef  scalar_t__ actionf_v ;\nstruct TYPE_8__ {TYPE_3__* next; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Z_Free (TYPE_3__*) ;\nint /*<<< orphan*/  stub1 (TYPE_3__*) ;\nTYPE_3__ thinkercap ;\n\nvoid P_RunThinkers (void)\n{\nthinker_t*\tcurrentthinker;\n\ncurrentthinker = thinkercap.next;\nwhile (currentthinker != &thinkercap)\n{\nif ( currentthinker->function.acv == (actionf_v)(-1) )\n{\n// time to remove it\ncurrentthinker->next->prev = currentthinker->prev;\ncurrentthinker->prev->next = currentthinker->next;\nZ_Free (currentthinker);\n}\nelse\n{\nif (currentthinker->function.acp1)\ncurrentthinker->function.acp1 (currentthinker);\n}\ncurrentthinker = currentthinker->next;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {struct TYPE_10__* next; struct TYPE_10__* prev; int /*<<< orphan*/  (* thinker_function ) (TYPE_3__*) ;} ;\nstruct TYPE_9__ {TYPE_3__* thinker; } ;\nstruct TYPE_8__ {TYPE_3__* thinker; } ;\n\n/* Variables and functions */\nTYPE_3__* thinker_head ;\nint /*<<< orphan*/  thinker_pause ;\nint /*<<< orphan*/  thinker_pause_end ;\nint /*<<< orphan*/  thinker_pause_start ;\nint /*<<< orphan*/  thinker_pause_time ;\nint /*<<< orphan*/  thinker_pause_time_end ;\nint /*<<< orphan*/  thinker_pause_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total ;\nint /*<<< orphan*/  thinker_pause_total ;\nint /*<<< orphan*/  thinker_pause_total_end ;\nint /*<<< orphan*/  thinker_pause_total_start ;\nint /*<<< orphan*/  thinker_pause_total_time ;\nint /*<<< orphan*/  thinker_pause_total_time_end ;\nint /*<<< orphan*/  thinker_pause_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_time ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_time_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_time_start ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_time_total ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_time_total_end ;\nint /*<<< orphan*/  thinker_pause_time_total_time_total_time_total_time_total_time_total_time_total_time_total_time_total_start ;\nint /*<<< orphan*/  thinker_pause"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_AllocLow",
    "input":"\n0000000000000000 <I_AllocLow>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%edi, %ebp\n5: \tcallq\t0xa <I_AllocLow+0xa>\na: \tmovq\t%rax, %rbx\nd: \tmovq\t%rax, %rdi\n10: \txorl\t%esi, %esi\n12: \tmovl\t%ebp, %edx\n14: \tcallq\t0x19 <I_AllocLow+0x19>\n19: \tmovq\t%rbx, %rax\n1c: \taddq\t$8, %rsp\n20: \tpopq\t%rbx\n21: \tpopq\t%rbp\n22: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nscalar_t__ malloc (int) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\n\nbyte*\tI_AllocLow(int length)\n{\nbyte*\tmem;\n\nmem = (byte *)malloc (length);\nmemset (mem,0,length);\nreturn mem;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  PVOID ;\n\n/* Variables and functions */\nint /*<<< orphan*/  RtlZeroMemory (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/ * VirtualAlloc (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\n\nPVOID I_AllocLow(int size)\n{\nPVOID p;\np = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\nRtlZeroMemory(p, size, size);\nreturn p;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawSelCell",
    "input":"\n0000000000000000 <M_DrawSelCell>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rdi), %rax\n7: \tmovq\t8(%rdi), %rbx\nb: \taddq\t$-10, %rbx\nf: \tmovslq\t(%rip), %rcx  # 0x16 <M_DrawSelCell+0x16>\n16: \tmovslq\t%esi, %rdx\n19: \timulq\t%rcx, %rdx\n1d: \tleaq\t(%rax,%rdx), %r14\n21: \taddq\t$-1, %r14\n25: \tmovl\t(%rip), %esi  # 0x2b <M_DrawSelCell+0x2b>\n2b: \tmovl\t$0, %edi\n30: \tcallq\t0x35 <M_DrawSelCell+0x35>\n35: \tmovq\t%rbx, %rdi\n38: \tmovq\t%r14, %rsi\n3b: \txorl\t%edx, %edx\n3d: \tmovl\t%eax, %ecx\n3f: \taddq\t$8, %rsp\n43: \tpopq\t%rbx\n44: \tpopq\t%r14\n46: \tjmp\t0x4b <M_DrawSelCell+0x4b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_1__ menu_t ;\n\n/* Variables and functions */\nint LINEHEIGHT ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (scalar_t__,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid\nM_DrawSelCell\n( menu_t*\tmenu,\nint\t\titem )\n{\nV_DrawPatchDirect (menu->x - 10,        menu->y+item*LINEHEIGHT - 1, 0,\nW_CacheLumpName(\"M_CELL2\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* pb; int* pb_end; } ;\ntypedef  TYPE_1__ M_Draw ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawCell (TYPE_1__*,int*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawSelCell_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG_BG ;\nint /*<<< orphan*/  M_DrawSelCell_FG_BG_BG_BG_BG_BG_BG_BG_B"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_plats.c_P_AddActivePlat",
    "input":"\n0000000000000000 <P_AddActivePlat>:\n0: \tmovl\t(%rip), %eax  # 0x6 <P_AddActivePlat+0x6>\n6: \ttestl\t%eax, %eax\n8: \tjle\t0x30 <P_AddActivePlat+0x30>\na: \tmovq\t(%rip), %rcx  # 0x11 <P_AddActivePlat+0x11>\n11: \txorl\t%edx, %edx\n13: \tnopw\t%cs:(%rax,%rax)\n1d: \tnopl\t(%rax)\n20: \tcmpq\t$0, (%rcx,%rdx,8)\n25: \tje\t0x3a <P_AddActivePlat+0x3a>\n27: \taddq\t$1, %rdx\n2b: \tcmpq\t%rax, %rdx\n2e: \tjb\t0x20 <P_AddActivePlat+0x20>\n30: \tmovl\t$0, %edi\n35: \tjmp\t0x3a <P_AddActivePlat+0x3a>\n3a: \tmovq\t%rdi, (%rcx,%rdx,8)\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  plat_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint MAXPLATS ;\nint /*<<< orphan*/ ** activeplats ;\n\nvoid P_AddActivePlat(plat_t* plat)\n{\nint\t\ti;\n\nfor (i = 0;i < MAXPLATS;i++)\nif (activeplats[i] == NULL)\n{\nactiveplats[i] = plat;\nreturn;\n}\nI_Error (\"P_AddActivePlat: no more plats!\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t UBYTE ;\n\n/* Variables and functions */\nsize_t MAX_PLATFORMS ;\nsize_t NumActivePlats ;\nsize_t* PlatActive ;\nint /*<<< orphan*/  Printf (char*,size_t) ;\n\nvoid P_AddActivePlat(UBYTE plat)\n{\nUBYTE i;\n\nfor(i=0;i<NumActivePlats;i++)\n{\nif(PlatActive[i]==0)\n{\nPlatActive[i]=plat;\nreturn;\n}\n}\n\nPrintf(\"P_AddActivePlat: too many active platforms (%d)\\n\",NumActivePlats);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_NewGame",
    "input":"\n0000000000000000 <M_NewGame>:\n0: \tcmpq\t$0, (%rip)    # 0x8 <M_NewGame+0x8>\n8: \tje\t0x22 <M_NewGame+0x22>\na: \tcmpl\t$0, (%rip)    # 0x11 <M_NewGame+0x11>\n11: \tjne\t0x22 <M_NewGame+0x22>\n13: \tmovl\t(%rip), %edi  # 0x19 <M_NewGame+0x19>\n19: \txorl\t%esi, %esi\n1b: \txorl\t%edx, %edx\n1d: \tjmp\t0x22 <M_NewGame+0x22>\n22: \tmovq\t(%rip), %rax  # 0x29 <M_NewGame+0x29>\n29: \tcmpq\t(%rip), %rax  # 0x30 <M_NewGame+0x30>\n30: \tjne\t0x3c <M_NewGame+0x3c>\n32: \tmovl\t$0, %edi\n37: \tjmp\t0x3c <M_NewGame+0x3c>\n3c: \tmovl\t$0, %edi\n41: \tjmp\t0x46 <M_NewGame+0x46>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  EpiDef ;\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  NEWGAME ;\nint /*<<< orphan*/  NewDef ;\nscalar_t__ commercial ;\nint /*<<< orphan*/  demoplayback ;\nscalar_t__ gamemode ;\nscalar_t__ netgame ;\n\nvoid M_NewGame(int choice)\n{\nif (netgame && !demoplayback)\n{\nM_StartMessage(NEWGAME,NULL,false);\nreturn;\n}\n\nif ( gamemode == commercial )\nM_SetupNextMenu(&NewDef);\nelse\nM_SetupNextMenu(&EpiDef);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_NewGame_Init () ;\nint /*<<< orphan*/  M_NewGame_Init_Brief () ;\nint /*<<< orphan*/  M_NewGame_Init_Full () ;\nscalar_t__ M_NewGame_Mode ;\nscalar_t__ M_NewGame_Mode_Brief ;\nscalar_t__ M_NewGame_Mode_Full ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Full_Brief () ;\nint /*<<< orphan*/  M_NewGame_Mode_Full_Init_Full_Full_Full"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_bsp.c_R_Subsector",
    "input":"\n0000000000000000 <R_Subsector>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \taddl\t$1, (%rip)    # 0xa <R_Subsector+0xa>\na: \tmovq\t(%rip), %rax  # 0x11 <R_Subsector+0x11>\n11: \tmovslq\t%edi, %rcx\n14: \tleaq\t(%rcx,%rcx,2), %rcx\n18: \tmovq\t16(%rax,%rcx,8), %rdi\n1d: \tmovq\t%rdi, (%rip)  # 0x24 <R_Subsector+0x24>\n24: \tmovq\t8(%rax,%rcx,8), %rbx\n29: \tshlq\t$2, %rbx\n2d: \taddq\t(%rip), %rbx  # 0x34 <R_Subsector+0x34>\n34: \tmovl\t(%rax,%rcx,8), %ebp\n37: \tmovq\t(%rdi), %rax\n3a: \tmovq\t(%rip), %rcx  # 0x41 <R_Subsector+0x41>\n41: \tcmpq\t%rcx, %rax\n44: \tjge\t0x65 <R_Subsector+0x65>\n46: \tmovq\t8(%rdi), %rsi\n4a: \tmovl\t32(%rdi), %edx\n4d: \tmovq\t%rax, %rdi\n50: \tcallq\t0x55 <R_Subsector+0x55>\n55: \tmovq\t(%rip), %rdi  # 0x5c <R_Subsector+0x5c>\n5c: \tmovq\t(%rip), %rcx  # 0x63 <R_Subsector+0x63>\n63: \tjmp\t0x67 <R_Subsector+0x67>\n65: \txorl\t%eax, %eax\n67: \tmovq\t%rax, (%rip)  # 0x6e <R_Subsector+0x6e>\n6e: \tmovq\t16(%rdi), %rax\n72: \tmovq\t24(%rdi), %rsi\n76: \tcmpq\t%rcx, %rax\n79: \tjg\t0x88 <R_Subsector+0x88>\n7b: \tcmpq\t(%rip), %rsi  # 0x82 <R_Subsector+0x82>\n82: \tje\t0x88 <R_Subsector+0x88>\n84: \txorl\t%eax, %eax\n86: \tjmp\t0x9a <R_Subsector+0x9a>\n88: \tmovl\t32(%rdi), %edx\n8b: \tmovq\t%rax, %rdi\n8e: \tcallq\t0x93 <R_Subsector+0x93>\n93: \tmovq\t(%rip), %rdi  # 0x9a <R_Subsector+0x9a>\n9a: \tmovq\t%rax, (%rip)  # 0xa1 <R_Subsector+0xa1>\na1: \tcallq\t0xa6 <R_Subsector+0xa6>\na6: \ttestl\t%ebp, %ebp\na8: \tje\t0xc1 <R_Subsector+0xc1>\naa: \tnopw\t(%rax,%rax)\nb0: \tmovq\t%rbx, %rdi\nb3: \tcallq\t0xb8 <R_Subsector+0xb8>\nb8: \taddq\t$4, %rbx\nbc: \taddl\t$-1, %ebp\nbf: \tjne\t0xb0 <R_Subsector+0xb0>\nc1: \taddq\t$8, %rsp\nc5: \tpopq\t%rbx\nc6: \tpopq\t%rbp\nc7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int numlines; size_t firstline; TYPE_3__* sector; } ;\ntypedef  TYPE_1__ subsector_t ;\ntypedef  int /*<<< orphan*/  seg_t ;\nstruct TYPE_6__ {scalar_t__ floorheight; scalar_t__ floorpic; scalar_t__ ceilingheight; scalar_t__ ceilingpic; int /*<<< orphan*/  lightlevel; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int,int) ;\nint /*<<< orphan*/  R_AddLine (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  R_AddSprites (TYPE_3__*) ;\nvoid* R_FindPlane (scalar_t__,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * ceilingplane ;\nint /*<<< orphan*/ * floorplane ;\nTYPE_3__* frontsector ;\nint numsubsectors ;\nint /*<<< orphan*/ * segs ;\nscalar_t__ skyflatnum ;\nint /*<<< orphan*/  sscount ;\nTYPE_1__* subsectors ;\nscalar_t__ viewz ;\n\nvoid R_Subsector (int num)\n{\nint\t\t\tcount;\nseg_t*\t\tline;\nsubsector_t*\tsub;\n\n#ifdef RANGECHECK\nif (num>=numsubsectors)\nI_Error (\"R_Subsector: ss %i with numss = %i\",\nnum,\nnumsubsectors);\n#endif\n\nsscount++;\nsub = &subsectors[num];\nfrontsector = sub->sector;\ncount = sub->numlines;\nline = &segs[sub->firstline];\n\nif (frontsector->floorheight < viewz)\n{\nfloorplane = R_FindPlane (frontsector->floorheight,\nfrontsector->floorpic,\nfrontsector->lightlevel);\n}\nelse\nfloorplane = NULL;\n\nif (frontsector->ceilingheight > viewz\n|| frontsector->ceilingpic == skyflatnum)\n{\nceilingplane = R_FindPlane (frontsector->ceilingheight,\nfrontsector->ceilingpic,\nfrontsector->lightlevel);\n}\nelse\nceilingplane = NULL;\n\nR_AddSprites (frontsector);\n\nwhile (count--)\n{\nR_AddLine (line);\nline++;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ floorheight; scalar_t__ ceilingheight; int /*<<< orphan*/  segnum; scalar_t__ firstline; scalar_t__ lastline; } ;\ntypedef  TYPE_1__ subsector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\n\n/* Variables and functions */\nint /*<<= orphan*/  R_DrawSubsector (TYPE_1__*) ;\nint /*<<< orphan*/  R_DrawWall (scalar_t__,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_SetPlane (scalar_t__,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_SetTexture (scalar_t__,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_SetWall (scalar_t__,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_SetWallTexture (scalar_t__,scalar_t__,int /*<<< orphan*/ ) ;\nscalar_t__ R_Subsector ;\nscalar_t__ R_Wallptr ;\nint /*<<< orphan*/  R_Wallptr_l ;\nint /*<<< orphan*/  R_Wallptr_t ;\nint /*<<< orphan*/  R_Wallptr_u ;\nint /*<<< orphan*/  R_Wallptr_v ;\nint /*<<< orphan*/  R_Wallptr_x ;\nint /*<<< orphan*/  R_Wallptr_y ;\nint /*<<< orphan*/  R_Wallptr_z ;\nint /*<<< orphan*/  R_Wallptr_z2 ;\nint /*<<< orphan*/  R_Wallptr_z3 ;\nint /*<<< orphan*/  R_Wallptr_z4 ;\nint /*<<< orphan*/  R_Wallptr_z5 ;\nint /*<<< orphan*/  R_Wallptr_z6 ;\nint /*<<< orphan*/  R_Wallptr_z7 ;\nint /*<<< orphan*/  R_Wallptr_z8 ;\nint /*<<< orphan*/  R_Wallptr_z9 ;\nint /*<<< orphan*/  R_Wallptr_zl ;\nint /*<<< orphan*/  R_Wallptr_zl2 ;\nint /*<<< orphan*/  R_Wallptr_zl3 ;\nint /*<<< orphan*/  R_Wallptr_zl4 ;\nint /*<<< orphan*/  R_Wallptr_zl5 ;\nint /*<<< orphan*/  R_Wallptr_zl6 ;\nint /*<<< orphan*/  R_Wallptr_zl7 ;\nint /*<<< orphan*/  R_Wallptr_zl8 ;\nint /*<<< orphan*/  R_Wallptr_zl9 ;\nint /*<<< orphan*/  R_Wallptr_zl_l ;\nint /*<<< orphan*/  R_Wallptr_zl_t ;\nint /*<<< orphan*/  R_Wallptr_zl_u ;\nint /*<<< orphan*/  R_Wallptr_zl_v ;\nint /*<<< orphan*/  R_Wallptr_zl_x ;\nint /*<<< orphan*/  R_Wallptr_zl_y ;\nint /*<<< orphan*/  R_Wallptr_zl_z ;\nint /*<<< orphan*/  R_Wallptr_zl_z2 ;\nint /*<<< orphan*/  R_Wallptr_zl_z3 ;\nint /*<<< orphan*/  R_Wallptr_zl_z4 ;\nint /*<<< orphan*/  R_Wallptr_zl_z5 ;\nint /*<<< orphan*/  R_Wallptr_zl_z6 ;\nint /*<<< orphan*/  R_Wallptr_zl_z7 ;\nint /*<<< orphan*/  R_Wallptr_zl_z8 ;\nint /*<<< orphan*/  R_Wallptr_zl_z9 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl ;\nint /*<<< orphan*/  R_Wallptr_zl_zl2 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl3 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl4 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl5 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl6 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl7 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl8 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl9 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_l ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_t ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_u ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_v ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_x ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_y ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z2 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z3 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z4 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z5 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z6 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z7 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z8 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_z9 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl2 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl3 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl4 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl5 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl6 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl7 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl8 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl9 ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl_l ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl_t ;\nint /*<<< orphan*/  R_Wallptr_zl_zl_zl_u ;\nint /*<<< orphan*/  R_W"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_unloadPics",
    "input":"\n0000000000000000 <AM_unloadPics>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <AM_unloadPics+0x8>\n8: \tmovl\t(%rax), %edi\na: \tmovl\t(%rip), %esi  # 0x10 <AM_unloadPics+0x10>\n10: \tcallq\t0x15 <AM_unloadPics+0x15>\n15: \tmovq\t(%rip), %rax  # 0x1c <AM_unloadPics+0x1c>\n1c: \tmovl\t4(%rax), %edi\n1f: \tmovl\t(%rip), %esi  # 0x25 <AM_unloadPics+0x25>\n25: \tcallq\t0x2a <AM_unloadPics+0x2a>\n2a: \tmovq\t(%rip), %rax  # 0x31 <AM_unloadPics+0x31>\n31: \tmovl\t8(%rax), %edi\n34: \tmovl\t(%rip), %esi  # 0x3a <AM_unloadPics+0x3a>\n3a: \tcallq\t0x3f <AM_unloadPics+0x3f>\n3f: \tmovq\t(%rip), %rax  # 0x46 <AM_unloadPics+0x46>\n46: \tmovl\t12(%rax), %edi\n49: \tmovl\t(%rip), %esi  # 0x4f <AM_unloadPics+0x4f>\n4f: \tcallq\t0x54 <AM_unloadPics+0x54>\n54: \tmovq\t(%rip), %rax  # 0x5b <AM_unloadPics+0x5b>\n5b: \tmovl\t16(%rax), %edi\n5e: \tmovl\t(%rip), %esi  # 0x64 <AM_unloadPics+0x64>\n64: \tcallq\t0x69 <AM_unloadPics+0x69>\n69: \tmovq\t(%rip), %rax  # 0x70 <AM_unloadPics+0x70>\n70: \tmovl\t20(%rax), %edi\n73: \tmovl\t(%rip), %esi  # 0x79 <AM_unloadPics+0x79>\n79: \tcallq\t0x7e <AM_unloadPics+0x7e>\n7e: \tmovq\t(%rip), %rax  # 0x85 <AM_unloadPics+0x85>\n85: \tmovl\t24(%rax), %edi\n88: \tmovl\t(%rip), %esi  # 0x8e <AM_unloadPics+0x8e>\n8e: \tcallq\t0x93 <AM_unloadPics+0x93>\n93: \tmovq\t(%rip), %rax  # 0x9a <AM_unloadPics+0x9a>\n9a: \tmovl\t28(%rax), %edi\n9d: \tmovl\t(%rip), %esi  # 0xa3 <AM_unloadPics+0xa3>\na3: \tcallq\t0xa8 <AM_unloadPics+0xa8>\na8: \tmovq\t(%rip), %rax  # 0xaf <AM_unloadPics+0xaf>\naf: \tmovl\t32(%rax), %edi\nb2: \tmovl\t(%rip), %esi  # 0xb8 <AM_unloadPics+0xb8>\nb8: \tcallq\t0xbd <AM_unloadPics+0xbd>\nbd: \tmovq\t(%rip), %rax  # 0xc4 <AM_unloadPics+0xc4>\nc4: \tmovl\t36(%rax), %edi\nc7: \tmovl\t(%rip), %esi  # 0xcd <AM_unloadPics+0xcd>\ncd: \tpopq\t%rax\nce: \tjmp\t0xd3 <AM_unloadPics+0xd3>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  Z_ChangeTag (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * marknums ;\n\nvoid AM_unloadPics(void)\n{\nint i;\n\nfor (i=0;i<10;i++)\nZ_ChangeTag(marknums[i], PU_CACHE);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  palette; int /*<<< orphan*/  palette_mask; int /*<<< orphan*/  palette_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask; int /*<<< orphan*/  palette_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_mask_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_NewVisSprite",
    "input":"\n0000000000000000 <R_NewVisSprite>:\n0: \tmovq\t(%rip), %rax  # 0x7 <R_NewVisSprite+0x7>\n7: \tmovq\t(%rip), %rcx  # 0xe <R_NewVisSprite+0xe>\ne: \tshlq\t$2, %rcx\n12: \taddq\t(%rip), %rcx  # 0x19 <R_NewVisSprite+0x19>\n19: \tcmpq\t%rcx, %rax\n1c: \tje\t0x2a <R_NewVisSprite+0x2a>\n1e: \tleaq\t4(%rax), %rcx\n22: \tmovq\t%rcx, (%rip)  # 0x29 <R_NewVisSprite+0x29>\n29: \tretq\n2a: \tmovl\t$0, %eax\n2f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  vissprite_t ;\n\n/* Variables and functions */\nsize_t MAXVISSPRITES ;\nint /*<<< orphan*/  overflowsprite ;\nint /*<<< orphan*/ * vissprite_p ;\nint /*<<< orphan*/ * vissprites ;\n\nvissprite_t* R_NewVisSprite (void)\n{\nif (vissprite_p == &vissprites[MAXVISSPRITES])\nreturn &overflowsprite;\n\nvissprite_p++;\nreturn vissprite_p-1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  vis_sprite_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * VIS_SPRITE_LIST ;\nsize_t VIS_SPRITE_LIST_SIZE ;\nsize_t VIS_SPRITE_LIST_TOP ;\n\nvis_sprite_t *R_NewVisSprite(void)\n{\nif (VIS_SPRITE_LIST_TOP == VIS_SPRITE_LIST_SIZE)\nreturn NULL;\n\nVIS_SPRITE_LIST_TOP++;\nreturn &VIS_SPRITE_LIST[VIS_SPRITE_LIST_TOP];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_ceilng.c_P_ActivateInStasisCeiling",
    "input":"\n0000000000000000 <P_ActivateInStasisCeiling>:\n0: \tmovl\t(%rip), %r9d  # 0x7 <P_ActivateInStasisCeiling+0x7>\n7: \ttestl\t%r9d, %r9d\na: \tjle\t0x4f <P_ActivateInStasisCeiling+0x4f>\nc: \tmovq\t(%rip), %rcx  # 0x13 <P_ActivateInStasisCeiling+0x13>\n13: \tmovq\t(%rip), %r8   # 0x1a <P_ActivateInStasisCeiling+0x1a>\n1a: \txorl\t%esi, %esi\n1c: \tjmp\t0x29 <P_ActivateInStasisCeiling+0x29>\n1e: \tnop\n20: \taddq\t$1, %rsi\n24: \tcmpq\t%r9, %rsi\n27: \tjae\t0x4f <P_ActivateInStasisCeiling+0x4f>\n29: \tmovq\t(%rcx,%rsi,8), %rdx\n2d: \ttestq\t%rdx, %rdx\n30: \tje\t0x20 <P_ActivateInStasisCeiling+0x20>\n32: \tmovq\t(%rdx), %rax\n35: \tcmpq\t(%rdi), %rax\n38: \tjne\t0x20 <P_ActivateInStasisCeiling+0x20>\n3a: \tcmpq\t$0, 8(%rdx)\n3f: \tjne\t0x20 <P_ActivateInStasisCeiling+0x20>\n41: \tmovq\t16(%rdx), %rax\n45: \tmovq\t%rax, 8(%rdx)\n49: \tmovq\t%r8, 24(%rdx)\n4d: \tjmp\t0x20 <P_ActivateInStasisCeiling+0x20>\n4f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ tag; } ;\ntypedef  TYPE_3__ line_t ;\ntypedef  scalar_t__ actionf_p1 ;\nstruct TYPE_6__ {scalar_t__ acp1; } ;\nstruct TYPE_7__ {TYPE_1__ function; } ;\nstruct TYPE_9__ {scalar_t__ tag; scalar_t__ direction; scalar_t__ olddirection; TYPE_2__ thinker; } ;\n\n/* Variables and functions */\nint MAXCEILINGS ;\nscalar_t__ T_MoveCeiling ;\nTYPE_4__** activeceilings ;\n\nvoid P_ActivateInStasisCeiling(line_t* line)\n{\nint\t\ti;\n\nfor (i = 0;i < MAXCEILINGS;i++)\n{\nif (activeceilings[i]\n&& (activeceilings[i]->tag == line->tag)\n&& (activeceilings[i]->direction == 0))\n{\nactiveceilings[i]->direction = activeceilings[i]->olddirection;\nactiveceilings[i]->thinker.function.acp1\n= (actionf_p1)T_MoveCeiling;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ ceilingpicnum; scalar_t__ ceilingz; scalar_t__ ceilingshade; } ;\nstruct TYPE_9__ {scalar_t__ ceilingpicnum; scalar-signed__ ceilingshade; scalar_t__ ceilingz; } ;\nstruct TYPE_8__ {scalar_t__ ceilingpicnum; } ;\ntypedef  TYPE_1__ ceiling_t ;\ntypedef  TYPE_2__ ceiling_data_t ;\ntypedef  TYPE_3__ D3DCEILING ;\n\n/* Variables and functions */\nint MAXCEILINGS ;\nTYPE_3__* ceiling_list ;\nTYPE_2__* ceilingdata ;\n\nvoid P_ActivateInStasisCeiling(D3DCEILING *ceiling)\n{\nint i;\n\nfor (i=0; i<MAXCEILINGS; i++)\n{\nceiling_t *c = &ceiling_list[i];\nceiling_data_t *cd = &ceilingdata[i];\n\nif (c->ceilingpicnum == ceiling->ceilingpicnum &&\ncd->ceilingshade == 0 &&\ncd->ceilingz == 0)\n{\ncd->ceilingshade = ceiling->ceilingshade;\ncd->ceilingz = ceiling->ceilingz;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_BFGsound",
    "input":"\n0000000000000000 <A_BFGsound>:\n0: \tmovl\t(%rdi), %edi\n2: \tmovl\t(%rip), %esi  # 0x8 <A_BFGsound+0x8>\n8: \tjmp\t0xd <A_BFGsound+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_3__ {int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_bfg ;\n\nvoid\nA_BFGsound\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nS_StartSound (player->mo, sfx_bfg);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  sound; } ;\ntypedef  TYPE_1__ actor_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Spawn (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sound_bfg ;\n\nvoid A_BFGsound(actor_t *actor)\n{\nA_Spawn(actor->sound, sound_bfg);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawEpisode",
    "input":"\n0000000000000000 <M_DrawEpisode>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <M_DrawEpisode+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <M_DrawEpisode+0x11>\n11: \tmovl\t$54, %edi\n16: \tmovl\t$38, %esi\n1b: \txorl\t%edx, %edx\n1d: \tmovl\t%eax, %ecx\n1f: \tpopq\t%rax\n20: \tjmp\t0x25 <M_DrawEpisode+0x25>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid M_DrawEpisode(void)\n{\nV_DrawPatchDirect (54,38,0,W_CacheLumpName(\"M_EPISOD\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawString (char*,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_Episode ;\nint /*<<< orphan*/  M_EpisodeNum ;\n\nvoid M_DrawEpisode(void)\n{\nM_DrawString(\"Episode:\", 54, 38, M_Episode);\nM_DrawString(M_EpisodeNum, 54, 38, 0);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_SoundIsPlaying",
    "input":"\n0000000000000000 <I_SoundIsPlaying>:\n0: \txorl\t%eax, %eax\n2: \tcmpl\t%edi, (%rip)  # 0x8 <I_SoundIsPlaying+0x8>\n8: \tsetl\t%al\nb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint gametic ;\n\nint I_SoundIsPlaying(int handle)\n{\n// Ouch.\nreturn gametic < handle;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint S_sfx_volume ;\n\nint I_SoundIsPlaying(int channel)\n{\nreturn channel < S_sfx_volume;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_Quit",
    "input":"\n0000000000000000 <I_Quit>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <I_Quit+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <I_Quit+0xf>\nf: \txorl\t%eax, %eax\n11: \tcallq\t0x16 <I_Quit+0x16>\n16: \txorl\t%eax, %eax\n18: \tcallq\t0x1d <I_Quit+0x1d>\n1d: \txorl\t%eax, %eax\n1f: \tcallq\t0x24 <I_Quit+0x24>\n24: \txorl\t%edi, %edi\n26: \tcallq\t0x2b <I_Quit+0x2b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_QuitNetGame () ;\nint /*<<< orphan*/  I_ShutdownGraphics () ;\nint /*<<< orphan*/  I_ShutdownMusic () ;\nint /*<<< orphan*/  I_ShutdownSound () ;\nint /*<<< orphan*/  M_SaveDefaults () ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\n\nvoid I_Quit (void)\n{\nD_QuitNetGame ();\nI_ShutdownSound();\nI_ShutdownMusic();\nM_SaveDefaults ();\nI_ShutdownGraphics();\nexit(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  DPRINT (char*) ;\nint /*<<< orphan*/  I_ShutdownMusic () ;\nint /*<<< orphan*/  I_ShutdownSound () ;\nint /*<<< orphan*/  I_ShutdownTimer () ;\nint /*<<< orphan*/  I_ShutdownVideo () ;\nint /*<<< orphan*/  I_ShutdownZDoom () ;\nint /*<<< orphan*/  I_ShutdownZDoomNet () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetServerTCP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetTCP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerTCP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDP () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServer () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerClient () ;\nint /*<<< orphan*/  I_ShutdownZDoomNetUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerUDPServerU"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_PosAttack",
    "input":"\n0000000000000000 <A_PosAttack>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tcmpl\t$0, 4(%rdi)\nb: \tje\t0x9e <A_PosAttack+0x9e>\n11: \tmovq\t%rdi, %rbx\n14: \tcallq\t0x19 <A_PosAttack+0x19>\n19: \tmovl\t(%rbx), %r15d\n1c: \tmovl\t(%rip), %edx  # 0x22 <A_PosAttack+0x22>\n22: \tmovq\t%rbx, %rdi\n25: \tmovl\t%r15d, %esi\n28: \tcallq\t0x2d <A_PosAttack+0x2d>\n2d: \tmovl\t%eax, %r14d\n30: \tmovl\t(%rip), %esi  # 0x36 <A_PosAttack+0x36>\n36: \tmovq\t%rbx, %rdi\n39: \tcallq\t0x3e <A_PosAttack+0x3e>\n3e: \txorl\t%eax, %eax\n40: \tcallq\t0x45 <A_PosAttack+0x45>\n45: \tmovl\t%eax, %ebp\n47: \txorl\t%eax, %eax\n49: \tcallq\t0x4e <A_PosAttack+0x4e>\n4e: \tsubl\t%eax, %ebp\n50: \tshll\t$20, %ebp\n53: \taddl\t%ebp, %r15d\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <A_PosAttack+0x5d>\n5d: \tcltq\n5f: \timulq\t$1717986919, %rax, %rcx # imm = 0x66666667\n66: \tmovq\t%rcx, %rdx\n69: \tshrq\t$63, %rdx\n6d: \tsarq\t$33, %rcx\n71: \taddl\t%edx, %ecx\n73: \tleal\t(%rcx,%rcx,4), %ecx\n76: \tsubl\t%ecx, %eax\n78: \tleal\t(%rax,%rax,2), %r8d\n7c: \taddl\t$3, %r8d\n80: \tmovl\t(%rip), %edx  # 0x86 <A_PosAttack+0x86>\n86: \tmovq\t%rbx, %rdi\n89: \tmovl\t%r15d, %esi\n8c: \tmovl\t%r14d, %ecx\n8f: \taddq\t$8, %rsp\n93: \tpopq\t%rbx\n94: \tpopq\t%r14\n96: \tpopq\t%r15\n98: \tpopq\t%rbp\n99: \tjmp\t0x9e <A_PosAttack+0x9e>\n9e: \taddq\t$8, %rsp\na2: \tpopq\t%rbx\na3: \tpopq\t%r14\na5: \tpopq\t%r15\na7: \tpopq\t%rbp\na8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int angle; int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  MISSILERANGE ;\nint P_AimLineAttack (TYPE_1__*,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_LineAttack (TYPE_1__*,int,int /*<<< orphan*/ ,int,int) ;\nint P_Random () ;\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_pistol ;\n\nvoid A_PosAttack (mobj_t* actor)\n{\nint\t\tangle;\nint\t\tdamage;\nint\t\tslope;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nangle = actor->angle;\nslope = P_AimLineAttack (actor, angle, MISSILERANGE);\n\nS_StartSound (actor, sfx_pistol);\nangle += (P_Random()-P_Random())<<20;\ndamage = ((P_Random()%5)+1)*3;\nP_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  attack; int /*<<< orphan*/  attack_time; } ;\ntypedef  TYPE_1__ user_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_PosAttack_End ;\nint /*<<< orphan*/  A_PosAttack_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait ;\nint /*<<< orphan*/  A_PosAttack_Wait_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_End ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Start ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time_Time ;\nint /*<<< orphan*/  A_PosAttack_Wait_Time_Time_Time_Time_Time_Time_Time_Time_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_initDeathmatchStats",
    "input":"\n0000000000000000 <WI_initDeathmatchStats>:\n0: \tmovl\t(%rip), %eax  # 0x6 <WI_initDeathmatchStats+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <WI_initDeathmatchStats+0xc>\nc: \tmovq\t$0, (%rip)    # 0x17 <WI_initDeathmatchStats+0x17>\n17: \tmovl\t$1, (%rip)    # 0x21 <WI_initDeathmatchStats+0x21>\n21: \tmovl\t(%rip), %eax  # 0x27 <WI_initDeathmatchStats+0x27>\n27: \tmovl\t%eax, (%rip)  # 0x2d <WI_initDeathmatchStats+0x2d>\n2d: \tmovl\t(%rip), %r10d # 0x34 <WI_initDeathmatchStats+0x34>\n34: \ttestl\t%r10d, %r10d\n37: \tjle\t0xe3 <WI_initDeathmatchStats+0xe3>\n3d: \tmovq\t(%rip), %rcx  # 0x44 <WI_initDeathmatchStats+0x44>\n44: \tmovq\t(%rip), %r8   # 0x4b <WI_initDeathmatchStats+0x4b>\n4b: \tmovl\t%r10d, %r9d\n4e: \tandl\t$1, %r9d\n52: \tmovl\t%r10d, %r11d\n55: \tandl\t$-2, %r11d\n59: \txorl\t%edx, %edx\n5b: \tjmp\t0x71 <WI_initDeathmatchStats+0x71>\n5d: \tnopl\t(%rax)\n60: \tmovq\t$0, (%r8,%rdx,8)\n68: \taddq\t$1, %rdx\n6c: \tcmpq\t%r10, %rdx\n6f: \tjae\t0xe3 <WI_initDeathmatchStats+0xe3>\n71: \tcmpq\t$0, (%rcx,%rdx,8)\n76: \tje\t0x68 <WI_initDeathmatchStats+0x68>\n78: \tmovq\t(%rip), %rsi  # 0x7f <WI_initDeathmatchStats+0x7f>\n7f: \txorl\t%eax, %eax\n81: \tcmpl\t$1, %r10d\n85: \tjne\t0xb9 <WI_initDeathmatchStats+0xb9>\n87: \ttestq\t%r9, %r9\n8a: \tje\t0x60 <WI_initDeathmatchStats+0x60>\n8c: \tcmpq\t$0, (%rcx,%rax,8)\n91: \tje\t0x60 <WI_initDeathmatchStats+0x60>\n93: \tmovq\t(%rsi,%rdx,8), %rsi\n97: \tmovq\t$0, (%rsi,%rax,8)\n9f: \tjmp\t0x60 <WI_initDeathmatchStats+0x60>\na1: \tnopw\t%cs:(%rax,%rax)\nab: \tnopl\t(%rax,%rax)\nb0: \taddq\t$2, %rax\nb4: \tcmpq\t%rax, %r11\nb7: \tje\t0x87 <WI_initDeathmatchStats+0x87>\nb9: \tcmpq\t$0, (%rcx,%rax,8)\nbe: \tje\t0xcc <WI_initDeathmatchStats+0xcc>\nc0: \tmovq\t(%rsi,%rdx,8), %rdi\nc4: \tmovq\t$0, (%rdi,%rax,8)\ncc: \tcmpq\t$0, 8(%rcx,%rax,8)\nd2: \tje\t0xb0 <WI_initDeathmatchStats+0xb0>\nd4: \tmovq\t(%rsi,%rdx,8), %rdi\nd8: \tmovq\t$0, 8(%rdi,%rax,8)\ne1: \tjmp\t0xb0 <WI_initDeathmatchStats+0xb0>\ne3: \txorl\t%eax, %eax\ne5: \tjmp\t0xea <WI_initDeathmatchStats+0xea>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint MAXPLAYERS ;\nint /*<<< orphan*/  StatCount ;\nint /*<<< orphan*/  TICRATE ;\nint /*<<< orphan*/  WI_initAnimatedBack () ;\nscalar_t__ acceleratestage ;\nint /*<<< orphan*/  cnt_pause ;\nscalar_t__** dm_frags ;\nint dm_state ;\nscalar_t__* dm_totals ;\nscalar_t__* playeringame ;\nint /*<<< orphan*/  state ;\n\nvoid WI_initDeathmatchStats(void)\n{\n\nint\t\ti;\nint\t\tj;\n\nstate = StatCount;\nacceleratestage = 0;\ndm_state = 1;\n\ncnt_pause = TICRATE;\n\nfor (i=0 ; i<MAXPLAYERS ; i++)\n{\nif (playeringame[i])\n{\nfor (j=0 ; j<MAXPLAYERS ; j++)\nif (playeringame[j])\ndm_frags[i][j] = 0;\n\ndm_totals[i] = 0;\n}\n}\n\nWI_initAnimatedBack();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ deathmatch_stats_kills; scalar_t__ deathmatch_stats_deaths; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_deathmatchStats ;\nint /*<<< orphan*/  WI_deathmatchStats_init ;\nTYPE_1__** WI_player ;\nint WI_player_count ;\nint WI_player_max ;\nint WI_player_min ;\n\nvoid WI_initDeathmatchStats(void)\n{\nWI_deathmatchStats = WI_deathmatchStats_init;\nWI_player_min = 1;\nWI_player_max = WI_player_count;\nint i;\nfor (i = 0; i < WI_player_max; i++)\n{\nWI_player[i]->deathmatch_stats_kills = 0;\nWI_player[i]->deathmatch_stats_deaths = 0;\n}\n\nfor (i = 0; i < WI_player_max; i++)\n{\nif (WI_player[i] != NULL)\n{\nif (i % 2 == 0)\n{\nWI_player[i]->deathmatch_stats_kills = 0;\n}\nif (i % 2 == 1)\n{\nWI_player[i]->deathmatch_stats_deaths = 0;\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_plats.c_P_RemoveActivePlat",
    "input":"\n0000000000000000 <P_RemoveActivePlat>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %eax  # 0x7 <P_RemoveActivePlat+0x7>\n7: \ttestl\t%eax, %eax\n9: \tjle\t0x2f <P_RemoveActivePlat+0x2f>\nb: \tmovq\t(%rip), %rcx  # 0x12 <P_RemoveActivePlat+0x12>\n12: \txorl\t%ebx, %ebx\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tcmpq\t%rdi, (%rcx,%rbx,8)\n24: \tje\t0x3a <P_RemoveActivePlat+0x3a>\n26: \taddq\t$1, %rbx\n2a: \tcmpq\t%rax, %rbx\n2d: \tjb\t0x20 <P_RemoveActivePlat+0x20>\n2f: \tmovl\t$0, %edi\n34: \tpopq\t%rbx\n35: \tjmp\t0x3a <P_RemoveActivePlat+0x3a>\n3a: \tmovq\t8(%rdi), %rax\n3e: \tmovq\t$0, (%rax)\n45: \tmovq\t(%rip), %rax  # 0x4c <P_RemoveActivePlat+0x4c>\n4c: \tmovq\t(%rax,%rbx,8), %rdi\n50: \tcallq\t0x55 <P_RemoveActivePlat+0x55>\n55: \tmovq\t(%rip), %rax  # 0x5c <P_RemoveActivePlat+0x5c>\n5c: \tmovq\t$0, (%rax,%rbx,8)\n64: \tpopq\t%rbx\n65: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  thinker; TYPE_1__* sector; } ;\ntypedef  TYPE_2__ plat_t ;\nstruct TYPE_5__ {int /*<<< orphan*/ * specialdata; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint MAXPLATS ;\nint /*<<< orphan*/  P_RemoveThinker (int /*<<< orphan*/ *) ;\nTYPE_2__** activeplats ;\n\nvoid P_RemoveActivePlat(plat_t* plat)\n{\nint\t\ti;\nfor (i = 0;i < MAXPLATS;i++)\nif (plat == activeplats[i])\n{\n(activeplats[i])->sector->specialdata = NULL;\nP_RemoveThinker(&(activeplats[i])->thinker);\nactiveplats[i] = NULL;\n\nreturn;\n}\nI_Error (\"P_RemoveActivePlat: can't find plat!\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ plat; } ;\ntypedef  TYPE_1__* PClassActor ;\n\n/* Variables and functions */\nint ActivePlats ;\nTYPE_1__** ActivePlatList ;\nint /*<<< orphan*/  DPrintf (char*,scalar_t__) ;\nint /*<<< orphan*/  Z_Free (TYPE_1__*) ;\n\nvoid P_RemoveActivePlat(PClassActor *plat)\n{\nint i;\n\nfor (i=0; i<ActivePlats; i++)\n{\nif (ActivePlatList[i] == plat)\n{\nActivePlatList[i]->plat = 0;\nZ_Free(ActivePlatList[i]);\nActivePlatList[i] = NULL;\nbreak;\n}\n}\n\nif (i == ActivePlats)\nDPrintf(\"P_RemoveActivePlat: plat not found\\n\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawReadThis2",
    "input":"\n0000000000000000 <M_DrawReadThis2>:\n0: \tpushq\t%rax\n1: \tmovl\t$1, (%rip)    # 0xb <M_DrawReadThis2+0xb>\nb: \tmovl\t(%rip), %eax  # 0x11 <M_DrawReadThis2+0x11>\n11: \taddl\t$-128, %eax\n14: \tcmpl\t$3, %eax\n17: \tja\t0x3c <M_DrawReadThis2+0x3c>\n19: \tcltq\n1b: \tmovq\t(,%rax,8), %rdi\n23: \tmovl\t(%rip), %esi  # 0x29 <M_DrawReadThis2+0x29>\n29: \tcallq\t0x2e <M_DrawReadThis2+0x2e>\n2e: \txorl\t%edi, %edi\n30: \txorl\t%esi, %esi\n32: \txorl\t%edx, %edx\n34: \tmovl\t%eax, %ecx\n36: \tpopq\t%rax\n37: \tjmp\t0x3c <M_DrawReadThis2+0x3c>\n3c: \tpopq\t%rax\n3d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n#define  commercial 131\nint gamemode ;\nint inhelpscreens ;\n#define  registered 130\n#define  retail 129\n#define  shareware 128\n\nvoid M_DrawReadThis2(void)\n{\ninhelpscreens = true;\nswitch ( gamemode )\n{\ncase retail:\ncase commercial:\n// This hack keeps us from having to change menus.\nV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"CREDIT\",PU_CACHE));\nbreak;\ncase shareware:\ncase registered:\nV_DrawPatchDirect (0,0,0,W_CacheLumpName(\"HELP2\",PU_CACHE));\nbreak;\ndefault:\nbreak;\n}\nreturn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawReadThis (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawReadThis2_1 ;\nint /*<<< orphan*/  M_DrawReadThis2_2 ;\nint /*<<< orphan*/  M_DrawReadThis2_3 ;\nint /*<<< orphan*/  M_DrawReadThis2_4 ;\nint /*<<< orphan*/  M_DrawReadThis2_5 ;\nint /*<<< orphan*/  M_DrawReadThis2_6 ;\nint /*<<< orphan*/  M_DrawReadThis2_7 ;\nint /*<<< orphan*/  M_DrawReadThis2_8 ;\nint /*<<< orphan*/  M_DrawReadThis2_9 ;\nint /*<<< orphan*/  M_DrawReadThis2_a ;\nint /*<<< orphan*/  M_DrawReadThis2_b ;\nint /*<<< orphan*/  M_DrawReadThis2_c ;\nint /*<<< orphan*/  M_DrawReadThis2_d ;\nint /*<<< orphan*/  M_DrawReadThis2_e ;\nint /*<<< orphan*/  M_DrawReadThis2_f ;\nint /*<<< orphan*/  M_DrawReadThis2_h ;\nint /*<<< orphan*/  M_DrawReadThis2_i ;\nint /*<<< orphan*/  M_DrawReadThis2_j ;\nint /*<<< orphan*/  M_DrawReadThis2_k ;\nint /*<<< orphan*/  M_DrawReadThis2_l ;\nint /*<<< orphan*/  M_DrawReadThis2_m ;\nint /*<<< orphan*/  M_DrawReadThis2_n ;\nint /*<<< orphan*/  M_DrawReadThis2_o ;\nint /*<<< orphan*/  M_DrawReadThis2_p ;\nint /*<<< orphan*/  M_DrawReadThis2_q ;\nint /*<<< orphan*/  M_DrawReadThis2_r ;\nint /*<<< orphan*/  M_DrawReadThis2_s ;\nint /*<<< orphan*/  M_DrawReadThis2_t ;\nint /*<<< orphan*/  M_DrawReadThis2_u ;\nint /*<<< orphan*/  M_DrawReadThis2_v ;\nint /*<<< orphan*/  M_DrawReadThis2_w ;\nint /*<<< orphan*/  M_DrawReadThis2_x ;\nint /*<<< orphan*/  M_DrawReadThis2_y ;\nint /*<<< orphan*/  M_DrawReadThis2_z ;\nint /*<<< orphan*/  M_DrawReadThis2_A ;\nint /*<<< orphan*/  M_DrawReadThis2_B ;\nint /*<<< orphan*/  M_DrawReadThis2_C ;\nint /*<<< orphan*/  M_DrawReadThis2_D ;\nint /*<<< orphan*/  M_DrawReadThis2_E ;\nint /*<<< orphan*/  M_DrawReadThis2_F ;\nint /*<<< orphan*/  M_DrawReadThis2_G ;\nint /*<<< orphan*/  M_DrawReadThis2_H ;\nint /*<<< orphan*/  M_DrawReadThis2_I ;\nint /*<<< orphan*/  M_DrawReadThis2_J ;\nint /*<<< orphan*/  M_DrawReadThis2_K ;\nint /*<<< orphan*/  M_DrawReadThis2_L ;\nint /*<<< orphan*/  M_DrawReadThis2_M ;\nint /*<<< orphan*/  M_DrawReadThis2_N ;\nint /*<<< orphan*/  M_DrawReadThis2_O ;\nint /*<<< orphan*/  M_DrawReadThis2_P ;\nint /*<<< orphan*/  M_DrawReadThis2_Q ;\nint /*<<< orphan*/  M_DrawReadThis2_R ;\nint /*<<< orphan*/  M_DrawReadThis2_S ;\nint /*<<< orphan*/  M_DrawReadThis2_T ;\nint /*<<< orphan*/  M_DrawReadThis2_U ;\nint /*<<< orphan*/  M_DrawReadThis2_V ;\nint /*<<< orphan*/  M_DrawReadThis2_W ;\nint /*<<< orphan*/  M_DrawReadThis2_X ;\nint /*<<< orphan*/  M_DrawReadThis2_Y ;\nint /*<<< orphan*/  M_DrawReadThis2_Z ;\nint /*<<< orphan*/  M_DrawReadThis2_a0 ;\nint /*<<< orphan*/  M_DrawReadThis2_a1 ;\nint /*<<< orphan*/  M_DrawReadThis2_a2 ;\nint /*<<< orphan*/  M_DrawReadThis2_a3 ;\nint /*<<< orphan*/  M_DrawReadThis2_a4 ;\nint /*<<< orphan*/  M_DrawReadThis2_a5 ;\nint /*<<< orphan*/  M_DrawReadThis2_a6 ;\nint /*<<< orphan*/  M_DrawReadThis2_a7 ;\nint /*<<< orphan*/  M_DrawReadThis2_a8 ;\nint /*<<< orphan*/  M_DrawReadThis2_a9 ;\nint /*<<< orphan*/  M_DrawReadThis2_aa ;\nint /*<<< orphan*/  M_DrawReadThis2_ab ;\nint /*<<< orphan*/  M_DrawReadThis2_ac ;\nint /*<<< orphan*/  M_DrawReadThis2_ad ;\nint /*<<< orphan*/  M_DrawReadThis2_ae ;\nint /*<<< orphan*/  M_DrawReadThis2_af ;\nint /*<<< orphan*/  M_DrawReadThis2_b0 ;\nint /*<<< orphan*/  M_DrawReadThis2_b1 ;\nint /*<<< orphan*/  M_DrawReadThis2_b2 ;\nint /*<<< orphan*/  M_DrawReadThis2_b3 ;\nint /*<<< orphan*/  M_DrawReadThis2_b4 ;\nint /*<<< orphan*/  M_DrawReadThis2_b5 ;\nint /*<<< orphan*/  M_DrawReadThis2_b6 ;\nint /*<<< orphan*/  M_DrawReadThis2_b7 ;\nint /*<<< orphan*/  M_DrawReadThis2_b8 ;\nint /*<<< orphan*/  M_DrawReadThis2_b9 ;\nint /*<<< orphan*/  M_DrawReadThis2_ba ;\nint /*<<< orphan*/  M_DrawReadThis2_bb ;\nint /*<<< orphan*/  M_DrawReadThis2_bc ;\nint /*<<< orphan*/  M_DrawReadThis2_bd ;\nint /*<<< orphan*/  M_DrawReadThis2_be ;\nint /*<<< orphan*/  M_DrawReadThis2_bf ;\nint /*<<< orphan*/  M_DrawReadThis2_c0 ;\nint /*<<< orphan*/  M_DrawReadThis2_c1 ;\nint /*<<< orphan*/  M_DrawReadThis2_c2 ;\nint /*<<< orphan*/  M_DrawReadThis2_c3 ;\nint /*<<< orphan*/  M_DrawReadThis2_c4 ;\nint /*<<< orphan*/  M_DrawReadThis2_c5 ;\nint /*<<< orphan*/  M_DrawReadThis2_c6 ;\nint /*<<< orphan*/  M_DrawReadThis2_c7 ;\nint /*<<< orphan*/  M_DrawReadThis2_c8 ;\nint /*<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_P_SpawnStrobeFlash",
    "input":"\n0000000000000000 <P_SpawnStrobeFlash>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t%edx, %r14d\nb: \tmovl\t%esi, %r15d\ne: \tmovq\t%rdi, %rbp\n11: \tmovl\t(%rip), %esi  # 0x17 <P_SpawnStrobeFlash+0x17>\n17: \txorl\t%r12d, %r12d\n1a: \tmovl\t$56, %edi\n1f: \txorl\t%edx, %edx\n21: \tcallq\t0x26 <P_SpawnStrobeFlash+0x26>\n26: \tmovq\t%rax, %rbx\n29: \tleaq\t32(%rax), %rdi\n2d: \tcallq\t0x32 <P_SpawnStrobeFlash+0x32>\n32: \tmovq\t%rbp, 48(%rbx)\n36: \tmovl\t%r15d, (%rbx)\n39: \tmovl\t(%rip), %eax  # 0x3f <P_SpawnStrobeFlash+0x3f>\n3f: \tmovl\t%eax, 40(%rbx)\n42: \tmovq\t(%rip), %rax  # 0x49 <P_SpawnStrobeFlash+0x49>\n49: \tmovq\t%rax, 32(%rbx)\n4d: \tmovq\t(%rbp), %rsi\n51: \tmovq\t%rsi, 8(%rbx)\n55: \tmovq\t%rbp, %rdi\n58: \tcallq\t0x5d <P_SpawnStrobeFlash+0x5d>\n5d: \tcmpq\t8(%rbx), %rax\n61: \tcmovneq\t%rax, %r12\n65: \tmovq\t%r12, 16(%rbx)\n69: \tmovq\t$0, 8(%rbp)\n71: \tmovl\t$1, %eax\n76: \ttestl\t%r14d, %r14d\n79: \tjne\t0x88 <P_SpawnStrobeFlash+0x88>\n7b: \txorl\t%eax, %eax\n7d: \tcallq\t0x82 <P_SpawnStrobeFlash+0x82>\n82: \tandl\t$7, %eax\n85: \taddl\t$1, %eax\n88: \tmovl\t%eax, 24(%rbx)\n8b: \tpopq\t%rbx\n8c: \tpopq\t%r12\n8e: \tpopq\t%r14\n90: \tpopq\t%r15\n92: \tpopq\t%rbp\n93: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_7__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ acp1; } ;\nstruct TYPE_11__ {TYPE_1__ function; } ;\nstruct TYPE_9__ {int darktime; scalar_t__ maxlight; scalar_t__ minlight; int count; TYPE_7__ thinker; int /*<<< orphan*/  brighttime; TYPE_3__* sector; } ;\ntypedef  TYPE_2__ strobe_t ;\nstruct TYPE_10__ {scalar_t__ lightlevel; scalar_t__ special; } ;\ntypedef  TYPE_3__ sector_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_LEVSPEC ;\nint /*<<< orphan*/  P_AddThinker (TYPE_7__*) ;\nscalar_t__ P_FindMinSurroundingLight (TYPE_3__*,scalar_t__) ;\nint P_Random () ;\nint /*<<< orphan*/  STROBEBRIGHT ;\nscalar_t__ T_StrobeFlash ;\nTYPE_2__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nP_SpawnStrobeFlash\n( sector_t*\tsector,\nint\t\tfastOrSlow,\nint\t\tinSync )\n{\nstrobe_t*\tflash;\n\nflash = Z_Malloc ( sizeof(*flash), PU_LEVSPEC, 0);\n\nP_AddThinker (&flash->thinker);\n\nflash->sector = sector;\nflash->darktime = fastOrSlow;\nflash->brighttime = STROBEBRIGHT;\nflash->thinker.function.acp1 = (actionf_p1) T_StrobeFlash;\nflash->maxlight = sector->lightlevel;\nflash->minlight = P_FindMinSurroundingLight(sector, sector->lightlevel);\n\nif (flash->minlight == flash->maxlight)\nflash->minlight = 0;\n\n// nothing special about it during gameplay\nsector->special = 0;\n\nif (!inSync)\nflash->count = (P_Random()&7)+1;\nelse\nflash->count = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; int /*<<< orphan*/  yrepeat; int /*<<< orphan*/  xrepeat; int /*<<< orphan*/  picnum; int /*<<< orphan*/  ang; int /*<<< orphan*/  owner; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_8__ {int /*<<< orphan*/ * next; } ;\ntypedef  TYPE_1__ actor_t ;\ntypedef  TYPE_2__ D3DVECTOR ;\ntypedef  TYPE_3__ flash_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_LightFlash ;\nint /*<<< orphan*/  A_LightFlash2 ;\nint /*<<< orphan*/  A_LightFlash3 ;\nint /*<<< orphan*/  A_LightFlash4 ;\nint /*<<< orphan*/  A_LightFlash5 ;\nint /*<<< orphan*/  A_LightFlash6 ;\nint /*<<< orphan*/  A_LightFlash7 ;\nint /*<<< orphan*/  A_LightFlash8 ;\nint /*<<< orphan*/  A_LightFlash9 ;\nint /*<<< orphan*/  A_LightFlash10 ;\nint /*<<< orphan*/  A_LightFlash11 ;\nint /*<<< orphan*/  A_LightFlash12 ;\nint /*<<< orphan*/  A_LightFlash13 ;\nint /*<<< orphan*/  A_LightFlash14 ;\nint /*<<< orphan*/  A_LightFlash15 ;\nint /*<<< orphan*/  A_LightFlash16 ;\nint /*<<< orphan*/  A_LightFlash17 ;\nint /*<<< orphan*/  A_LightFlash18 ;\nint /*<<< orphan*/  A_LightFlash19 ;\nint /*<<< orphan*/  A_LightFlash20 ;\nint /*<<< orphan*/  A_LightFlash21 ;\nint /*<<< orphan*/  A_LightFlash22 ;\nint /*<<< orphan*/  A_LightFlash23 ;\nint /*<<< orphan*/  A_LightFlash24 ;\nint /*<<< orphan*/  A_LightFlash25 ;\nint /*<<< orphan*/  A_LightFlash26 ;\nint /*<<< orphan*/  A_LightFlash27 ;\nint /*<<< orphan*/  A_LightFlash28 ;\nint /*<<< orphan*/  A_LightFlash29 ;\nint /*<<< orphan*/  A_LightFlash30 ;\nint /*<<< orphan*/  A_LightFlash31 ;\nint /*<<< orphan*/  A_LightFlash32 ;\nint /*<<< orphan*/  A_LightFlash33 ;\nint /*<<< orphan*/  A_LightFlash34 ;\nint /*<<< orphan*/  A_LightFlash35 ;\nint /*<<< orphan*/  A_LightFlash36 ;\nint /*<<< orphan*/  A_LightFlash37 ;\nint /*<<< orphan*/  A_LightFlash38 ;\nint /*<<< orphan*/  A_LightFlash39 ;\nint /*<<< orphan*/  A_LightFlash40 ;\nint /*<<< orphan*/  A_LightFlash41 ;\nint /*<<< orphan*/  A_LightFlash42 ;\nint /*<<< orphan*/  A_LightFlash43 ;\nint /*<<< orphan*/  A_LightFlash44 ;\nint /*<<< orphan*/  A_LightFlash45 ;\nint /*<<< orphan*/  A_LightFlash46 ;\nint /*<<< orphan*/  A_LightFlash47 ;\nint /*<<< orphan*/  A_LightFlash48 ;\nint /*<<< orphan*/  A_LightFlash49 ;\nint /*<<< orphan*/  A_LightFlash50 ;\nint /*<<< orphan*/  A_LightFlash51 ;\nint /*<<< orphan*/  A_LightFlash52 ;\nint /*<<< orphan*/  A_LightFlash53 ;\nint /*<<< orphan*/  A_LightFlash54 ;\nint /*<<< orphan*/  A_LightFlash55 ;\nint /*<<< orphan*/  A_LightFlash56 ;\nint /*<<< orphan*/  A_LightFlash57 ;\nint /*<<< orphan*/  A_LightFlash58 ;\nint /*<<< orphan*/  A_LightFlash59 ;\nint /*<<< orphan*/  A_LightFlash60 ;\nint /*<<< orphan*/  A_LightFlash61 ;\nint /*<<< orphan*/  A_LightFlash62 ;\nint /*<<< orphan*/  A_LightFlash63 ;\nint /*<<< orphan*/  A_LightFlash64 ;\nint /*<<< orphan*/  A_LightFlash65 ;\nint /*<<< orphan*/  A_LightFlash66 ;\nint /*<<< orphan*/  A_LightFlash67 ;\nint /*<<< orphan*/  A_LightFlash68 ;\nint /*<<< orphan*/  A_LightFlash69 ;\nint /*<<< orphan*/  A_LightFlash70 ;\nint /*<<< orphan*/  A_LightFlash71 ;\nint /*<<< orphan*/  A_LightFlash72 ;\nint /*<<< orphan*/  A_LightFlash73 ;\nint /*<<< orphan*/  A_LightFlash74 ;\nint /*<<< orphan*/  A_LightFlash75 ;\nint /*<<< orphan*/  A_LightFlash76 ;\nint /*<<< orphan*/  A_LightFlash77 ;\nint /*<<< orphan*/  A_LightFlash78 ;\nint /*<<< orphan*/  A_LightFlash79 ;\nint /*<<< orphan*/  A_LightFlash80 ;\nint /*<<< orphan*/  A_LightFlash81 ;\nint /*<<< orphan*/  A_LightFlash82 ;\nint /*<<< orphan*/  A_LightFlash83 ;\nint /*<<< orphan*/  A_LightFlash84 ;\nint /*<<< orphan*/  A_LightFlash85 ;\nint /*<<< orphan*/  A_LightFlash86 ;\nint /*<<< orphan*/  A_LightFlash87 ;\nint /*<<< orphan*/  A_LightFlash88 ;\nint /*<<< orphan*/  A_LightFlash89 ;\nint /*<<< orphan*/  A_LightFlash90 ;\nint /*<<< orphan*/  A_LightFlash91 ;\nint /*<<< orphan*/  A_LightFlash92 ;\nint /*<<< orphan*/  A_LightFlash93 ;\nint /*<<< orphan*/  A_LightFlash94 ;\nint /*<<< orphan*/  A_LightFlash95 ;\nint /*<<< orphan*/  A_LightFlash96 ;\nint /*<<< orphan*/  A_LightFlash97 ;\nint /*<<< orphan*/  A_LightFlash98 ;\nint /*<<< orphan*/  A_LightFlash99 ;\nint /*<<< orphan*/  A_LightFlash100 ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawSound",
    "input":"\n0000000000000000 <M_DrawSound>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <M_DrawSound+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <M_DrawSound+0x11>\n11: \tmovl\t$60, %edi\n16: \tmovl\t$38, %esi\n1b: \txorl\t%edx, %edx\n1d: \tmovl\t%eax, %ecx\n1f: \tcallq\t0x24 <M_DrawSound+0x24>\n24: \tmovl\t(%rip), %edi  # 0x2a <M_DrawSound+0x2a>\n2a: \tmovslq\t(%rip), %rax  # 0x31 <M_DrawSound+0x31>\n31: \tmovslq\t(%rip), %rsi  # 0x38 <M_DrawSound+0x38>\n38: \taddq\t$1, %rsi\n3c: \timulq\t%rax, %rsi\n40: \taddq\t(%rip), %rsi  # 0x47 <M_DrawSound+0x47>\n47: \tmovl\t(%rip), %ecx  # 0x4d <M_DrawSound+0x4d>\n4d: \tmovl\t$16, %edx\n52: \tcallq\t0x57 <M_DrawSound+0x57>\n57: \tmovl\t(%rip), %edi  # 0x5d <M_DrawSound+0x5d>\n5d: \tmovslq\t(%rip), %rax  # 0x64 <M_DrawSound+0x64>\n64: \tmovslq\t(%rip), %rsi  # 0x6b <M_DrawSound+0x6b>\n6b: \taddq\t$1, %rsi\n6f: \timulq\t%rax, %rsi\n73: \taddq\t(%rip), %rsi  # 0x7a <M_DrawSound+0x7a>\n7a: \tmovl\t(%rip), %ecx  # 0x80 <M_DrawSound+0x80>\n80: \tmovl\t$16, %edx\n85: \tpopq\t%rax\n86: \tjmp\t0x8b <M_DrawSound+0x8b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint LINEHEIGHT ;\nint /*<<< orphan*/  M_DrawThermo (int /*<<< orphan*/ ,scalar_t__,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PU_CACHE ;\nTYPE_1__ SoundDef ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint music_vol ;\nint sfx_vol ;\nint /*<<< orphan*/  snd_MusicVolume ;\nint /*<<< orphan*/  snd_SfxVolume ;\n\nvoid M_DrawSound(void)\n{\nV_DrawPatchDirect (60,38,0,W_CacheLumpName(\"M_SVOL\",PU_CACHE));\n\nM_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(sfx_vol+1),\n16,snd_SfxVolume);\n\nM_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(music_vol+1),\n16,snd_MusicVolume);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawPic (int,int,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_DrawPicScaled (int,int,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  M_Sound ;\nint /*<<< orphan*/  M_SoundPic ;\nint /*<<< orphan*/  M_SoundPic2 ;\nint /*<<< orphan*/  M_SoundPic3 ;\nint /*<<< orphan*/  M_SoundPic4 ;\nint /*<<< orphan*/  M_SoundPic5 ;\nint /*<<< orphan*/  M_SoundPic6 ;\nint /*<<< orphan*/  M_SoundPic7 ;\nint /*<<< orphan*/  M_SoundPic8 ;\nint /*<<< orphan*/  M_SoundPic9 ;\nint /*<<< orphan*/  M_SoundPic10 ;\nint /*<<< orphan*/  M_SoundPic11 ;\nint /*<<< orphan*/  M_SoundPic12 ;\nint /*<<< orphan*/  M_SoundPic13 ;\nint /*<<< orphan*/  M_SoundPic14 ;\nint /*<<< orphan*/  M_SoundPic15 ;\nint /*<<< orphan*/  M_SoundPic16 ;\nint /*<<< orphan*/  M_SoundPic17 ;\nint /*<<< orphan*/  M_SoundPic18 ;\nint /*<<< orphan*/  M_SoundPic19 ;\nint /*<<< orphan*/  M_SoundPic20 ;\nint /*<<< orphan*/  M_SoundPic21 ;\nint /*<<< orphan*/  M_SoundPic22 ;\nint /*<<< orphan*/  M_SoundPic23 ;\nint /*<<< orphan*/  M_SoundPic24 ;\nint /*<<< orphan*/  M_SoundPic25 ;\nint /*<<< orphan*/  M_SoundPic26 ;\nint /*<<< orphan*/  M_SoundPic27 ;\nint /*<<< orphan*/  M_SoundPic28 ;\nint /*<<< orphan*/  M_SoundPic29 ;\nint /*<<< orphan*/  M_SoundPic30 ;\nint /*<<< orphan*/  M_SoundPic31 ;\nint /*<<< orphan*/  M_SoundPic32 ;\nint /*<<< orphan*/  M_SoundPic33 ;\nint /*<<< orphan*/  M_SoundPic34 ;\nint /*<<< orphan*/  M_SoundPic35 ;\nint /*<<< orphan*/  M_SoundPic36 ;\nint /*<<< orphan*/  M_SoundPic37 ;\nint /*<<< orphan*/  M_SoundPic38 ;\nint /*<<< orphan*/  M_SoundPic39 ;\nint /*<<< orphan*/  M_SoundPic40 ;\nint /*<<< orphan*/  M_SoundPic41 ;\nint /*<<< orphan*/  M_SoundPic42 ;\nint /*<<< orphan*/  M_SoundPic43 ;\nint /*<<< orphan*/  M_SoundPic44 ;\nint /*<<< orphan*/  M_SoundPic45 ;\nint /*<<< orphan*/  M_SoundPic46 ;\nint /*<<< orphan*/  M_SoundPic47 ;\nint /*<<< orphan*/  M_SoundPic48 ;\nint /*<<< orphan*/  M_SoundPic49 ;\nint /*<<< orphan*/  M_SoundPic50 ;\nint /*<<< orphan*/  M_SoundPic51 ;\nint /*<<< orphan*/  M_SoundPic52 ;\nint /*<<< orphan*/  M_SoundPic53 ;\nint /*<<< orphan*/  M_SoundPic54 ;\nint /*<<< orphan*/  M_SoundPic55 ;\nint /*<<< orphan*/  M_SoundPic56 ;\nint /*<<< orphan*/  M_SoundPic57 ;\nint /*<<< orphan*/  M_SoundPic58 ;\nint /*<<< orphan*/  M_SoundPic59 ;\nint /*<<< orphan*/  M_SoundPic60 ;\nint /*<<< orphan*/  M_SoundPic61 ;\nint /*<<< orphan*/  M_SoundPic62 ;\nint /*<<< orphan*/  M_SoundPic63 ;\nint /*<<< orphan*/  M_SoundPic64 ;\nint /*<<< orphan*/  M_SoundPic65 ;\nint /*<<< orphan*/  M_SoundPic66 ;\nint /*<<< orphan*/  M_SoundPic67 ;\nint /*<<< orphan*/  M_SoundPic68 ;\nint /*<<< orphan*/  M_SoundPic69 ;\nint /*<<< orphan*/  M_SoundPic70 ;\nint /*<<< orphan*/  M_SoundPic71 ;\nint /*<<< orphan*/  M_SoundPic72 ;\nint /*<<< orphan*/  M_SoundPic73 ;\nint /*<<< orphan*/  M_SoundPic74 ;\nint /*<<< orphan*/  M_SoundPic75 ;\nint /*<<< orphan*/  M_SoundPic76 ;\nint /*<<< orphan*/  M_SoundPic77 ;\nint /*<<< orphan*/  M_SoundPic78 ;\nint /*<<< orphan*/  M_SoundPic79 ;\nint /*<<< orphan*/  M_SoundPic80 ;\nint /*<<< orphan*/  M_SoundPic81 ;\nint /*<<< orphan*/  M_SoundPic82 ;\nint /*<<< orphan*/  M_SoundPic83 ;\nint /*<<< orphan*/  M_SoundPic84 ;\nint /*<<< orphan*/  M_SoundPic85 ;\nint /*<<< orphan*/  M_SoundPic86 ;\nint /*<<< orphan*/  M_SoundPic87 ;\nint /*<<< orphan*/  M_SoundPic88 ;\nint /*<<< orphan*/  M_SoundPic89 ;\nint /*<<< orphan*/  M_SoundPic90 ;\nint /*<<< orphan*/  M_SoundPic91 ;\nint /*<<< orphan*/  M_SoundPic92 ;\nint /*<<< orphan*/  M_SoundPic93 ;\nint /*<<< orphan*/  M_SoundPic94 ;\nint /*<<< orphan*/  M_SoundPic95 ;\nint /*<<< orphan*/  M_SoundPic96 ;\nint /*<<< orphan*/  M_SoundPic97 ;\nint /*<<< orphan*/  M_SoundPic98 ;\nint /*<<< orphan*/  M_SoundPic99 ;\nint /*<<< orphan*/  M_SoundPic100 ;\nint /*<<< orphan*/  M_SoundPic101 ;\nint /*<<< orphan*/  M_SoundPic102 ;\nint /*<<< orphan*/  M_SoundPic103 ;\nint /*<<< orphan*/  M_SoundPic104 ;\nint /*<<< orphan*/  M_SoundPic105 ;\nint /*<<< orphan*/  M_SoundPic106 ;\nint /*<<< orphan*/  M_SoundPic107 ;\nint /*<<< orphan*/  M_SoundPic108 ;\nint /*<<< orphan*/  M_SoundPic109 ;\nint /*"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_MovePsprites",
    "input":"\n0000000000000000 <P_MovePsprites>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t(%rdi), %rbx\n7: \tcmpl\t$0, (%rip)    # 0xe <P_MovePsprites+0xe>\ne: \tjle\t0x57 <P_MovePsprites+0x57>\n10: \tmovq\t%rdi, %r14\n13: \txorl\t%ebp, %ebp\n15: \tjmp\t0x2f <P_MovePsprites+0x2f>\n17: \tnopw\t(%rax,%rax)\n20: \taddl\t$1, %ebp\n23: \taddq\t$24, %rbx\n27: \tcmpl\t(%rip), %ebp  # 0x2d <P_MovePsprites+0x2d>\n2d: \tjge\t0x54 <P_MovePsprites+0x54>\n2f: \tmovq\t16(%rbx), %rax\n33: \ttestq\t%rax, %rax\n36: \tje\t0x20 <P_MovePsprites+0x20>\n38: \tmovl\t(%rbx), %ecx\n3a: \tcmpl\t$-1, %ecx\n3d: \tje\t0x20 <P_MovePsprites+0x20>\n3f: \taddl\t$-1, %ecx\n42: \tmovl\t%ecx, (%rbx)\n44: \tjne\t0x20 <P_MovePsprites+0x20>\n46: \tmovl\t(%rax), %edx\n48: \tmovq\t%r14, %rdi\n4b: \tmovl\t%ebp, %esi\n4d: \tcallq\t0x52 <P_MovePsprites+0x52>\n52: \tjmp\t0x20 <P_MovePsprites+0x20>\n54: \tmovq\t(%r14), %rbx\n57: \tmovq\t(%rip), %rax  # 0x5e <P_MovePsprites+0x5e>\n5e: \tleaq\t(%rax,%rax,2), %rax\n62: \tmovl\t8(%rbx,%rax,8), %ecx\n66: \tmovq\t(%rip), %rdx  # 0x6d <P_MovePsprites+0x6d>\n6d: \tleaq\t(%rdx,%rdx,2), %rdx\n71: \tmovl\t%ecx, 8(%rbx,%rdx,8)\n75: \tmovl\t4(%rbx,%rax,8), %eax\n79: \tmovl\t%eax, 4(%rbx,%rdx,8)\n7d: \tpopq\t%rbx\n7e: \tpopq\t%r14\n80: \tpopq\t%rbp\n81: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  nextstate; } ;\ntypedef  TYPE_1__ state_t ;\nstruct TYPE_7__ {int tics; int /*<<< orphan*/  sy; int /*<<< orphan*/  sx; TYPE_1__* state; } ;\ntypedef  TYPE_2__ pspdef_t ;\nstruct TYPE_8__ {TYPE_2__* psprites; } ;\ntypedef  TYPE_3__ player_t ;\n\n/* Variables and functions */\nint NUMPSPRITES ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_3__*,int,int /*<<< orphan*/ ) ;\nsize_t ps_flash ;\nsize_t ps_weapon ;\n\nvoid P_MovePsprites (player_t* player)\n{\nint\t\ti;\npspdef_t*\tpsp;\nstate_t*\tstate;\n\npsp = &player->psprites[0];\nfor (i=0 ; i<NUMPSPRITES ; i++, psp++)\n{\n// a null state means not active\nif ( (state = psp->state) )\n{\n// drop tic count and possibly change state\n\n// a -1 tic count never changes\nif (psp->tics != -1)\n{\npsp->tics--;\nif (!psp->tics)\nP_SetPsprite (player, i, psp->state->nextstate);\n}\n}\n}\n\nplayer->psprites[ps_flash].sx = player->psprites[ps_weapon].sx;\nplayer->psprites[ps_flash].sy = player->psprites[ps_weapon].sy;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int* psprites; TYPE_2__* psprites_base; } ;\nstruct TYPE_9__ {int x; int y; TYPE_1__* next; } ;\nstruct TYPE_8__ {int x; int y; } ;\ntypedef  TYPE_2__ psprite_t ;\ntypedef  TYPE_3__ player_t ;\n\n/* Variables and functions */\nint MAXPLAYERS ;\nint P_MovePsprite (TYPE_3__*,int,int) ;\nint* psprite_tgt_x ;\nint* psprite_tgt_y ;\n\nvoid P_MovePsprites(player_t *p)\n{\nint\t\ti;\npsprite_t\t*psp;\n\nfor (i=0, psp=p->psprites_base; i<MAXPLAYERS; i++, psp++)\n{\nif (psp->next)\n{\nif (psp->x != -1)\n{\npsp->x--;\nif (psp->x == 0)\nP_MovePsprite(p, i, psp->next->x);\n}\n}\nelse\n{\npsprite_tgt_x[i] = psp->x;\npsprite_tgt_y[i] = psp->y;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_BaseTiccmd",
    "input":"\n0000000000000000 <I_BaseTiccmd>:\n0: \tmovl\t$0, %eax\n5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ticcmd_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  emptycmd ;\n\nticcmd_t*\tI_BaseTiccmd(void)\n{\nreturn &emptycmd;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ticcmd_t ;\n\n/* Variables and functions */\n\nticcmd_t* I_BaseTiccmd(void)\n{\nstatic ticcmd_t tcmd;\n\nreturn &tcmd;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_getNextSector",
    "input":"\n0000000000000000 <getNextSector>:\n0: \tmovl\t(%rip), %eax  # 0x6 <getNextSector+0x6>\n6: \ttestl\t%eax, (%rdi)\n8: \tje\t0x14 <getNextSector+0x14>\na: \tmovq\t8(%rdi), %rax\ne: \tcmpq\t%rsi, %rax\n11: \tje\t0x17 <getNextSector+0x17>\n13: \tretq\n14: \txorl\t%eax, %eax\n16: \tretq\n17: \tmovq\t16(%rdi), %rax\n1b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sector_t ;\nstruct TYPE_3__ {int flags; int /*<<< orphan*/ * frontsector; int /*<<< orphan*/ * backsector; } ;\ntypedef  TYPE_1__ line_t ;\n\n/* Variables and functions */\nint ML_TWOSIDED ;\n\nsector_t*\ngetNextSector\n( line_t*\tline,\nsector_t*\tsec )\n{\nif (!(line->flags & ML_TWOSIDED))\nreturn NULL;\n\nif (line->frontsector == sec)\nreturn line->backsector;\n\nreturn line->frontsector;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; scalar_t__ sector; scalar_t__ nextSector; } ;\ntypedef  TYPE_1__* PFILE_SECTOR ;\ntypedef  scalar_t__ ULONG ;\n\n/* Variables and functions */\nint SECTOR_FLAG_LAST ;\n\n__attribute__((used)) static ULONG getNextSector(PFILE_SECTOR pSector, ULONG sector)\n{\nif (pSector->flags & SECTOR_FLAG_LAST)\n{\nif (pSector->sector == sector)\n{\nreturn pSector->nextSector;\n}\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_MakeDivline",
    "input":"\n0000000000000000 <P_MakeDivline>:\n0: \tmovq\t8(%rdi), %rax\n4: \tmovl\t4(%rax), %ecx\n7: \tmovl\t%ecx, 12(%rsi)\na: \tmovl\t(%rax), %eax\nc: \tmovl\t%eax, 8(%rsi)\nf: \tmovl\t4(%rdi), %eax\n12: \tmovl\t%eax, 4(%rsi)\n15: \tmovl\t(%rdi), %eax\n17: \tmovl\t%eax, (%rsi)\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int /*<<< orphan*/  dy; int /*<<< orphan*/  dx; TYPE_1__* v1; } ;\ntypedef  TYPE_2__ line_t ;\nstruct TYPE_8__ {int /*<<< orphan*/  dy; int /*<<< orphan*/  dx; int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_3__ divline_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\n\nvoid\nP_MakeDivline\n( line_t*\tli,\ndivline_t*\tdl )\n{\ndl->x = li->v1->x;\ndl->y = li->v1->y;\ndl->dx = li->dx;\ndl->dy = li->dy;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  y2; int /*<<< orphan*/  x2; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ Pixel ;\ntypedef  TYPE_2__ P_Divline ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void\nP_MakeDivline(const Pixel *p, P_Divline *d)\n{\nd->x = p->x;\nd->y = p->y;\nd->x2 = p->x;\nd->y2 = p->y;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SkelFist",
    "input":"\n0000000000000000 <A_SkelFist>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tcmpl\t$0, (%rdi)\n6: \tje\t0x6d <A_SkelFist+0x6d>\n8: \tmovq\t%rdi, %rbx\nb: \tcallq\t0x10 <A_SkelFist+0x10>\n10: \tmovq\t%rbx, %rdi\n13: \tcallq\t0x18 <A_SkelFist+0x18>\n18: \ttestq\t%rax, %rax\n1b: \tje\t0x6d <A_SkelFist+0x6d>\n1d: \txorl\t%eax, %eax\n1f: \tcallq\t0x24 <A_SkelFist+0x24>\n24: \tcltq\n26: \timulq\t$1717986919, %rax, %rcx # imm = 0x66666667\n2d: \tmovq\t%rcx, %rdx\n30: \tshrq\t$63, %rdx\n34: \tsarq\t$34, %rcx\n38: \taddl\t%edx, %ecx\n3a: \taddl\t%ecx, %ecx\n3c: \tleal\t(%rcx,%rcx,4), %ecx\n3f: \tsubl\t%ecx, %eax\n41: \tleal\t(%rax,%rax,2), %eax\n44: \tleal\t(%rax,%rax), %ebp\n47: \taddl\t$6, %ebp\n4a: \tmovl\t(%rip), %esi  # 0x50 <A_SkelFist+0x50>\n50: \tmovq\t%rbx, %rdi\n53: \tcallq\t0x58 <A_SkelFist+0x58>\n58: \tmovl\t(%rbx), %edi\n5a: \tmovq\t%rbx, %rsi\n5d: \tmovq\t%rbx, %rdx\n60: \tmovl\t%ebp, %ecx\n62: \taddq\t$8, %rsp\n66: \tpopq\t%rbx\n67: \tpopq\t%rbp\n68: \tjmp\t0x6d <A_SkelFist+0x6d>\n6d: \taddq\t$8, %rsp\n71: \tpopq\t%rbx\n72: \tpopq\t%rbp\n73: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nscalar_t__ P_CheckMeleeRange (TYPE_1__*) ;\nint /*<<< orphan*/  P_DamageMobj (int /*<<< orphan*/ ,TYPE_1__*,TYPE_1__*,int) ;\nint P_Random () ;\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_skepch ;\n\nvoid A_SkelFist (mobj_t*\tactor)\n{\nint\t\tdamage;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\n\nif (P_CheckMeleeRange (actor))\n{\ndamage = ((P_Random()%10)+1)*6;\nS_StartSound (actor, sfx_skepch);\nP_DamageMobj (actor->target, actor, actor, damage);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  nAction; } ;\ntypedef  TYPE_1__* PLAYER ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SkelFistAttack ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ,TYPE_1__*,int) ;\nscalar_t__ FAF_Connect ;\nint /*<<< orphan*/  FAF_Fist ;\nint /*<<< orphan*/  FAF_Shoot ;\nint /*<<< orphan*/  FAF_ShootNoAttack ;\nint /*<<< orphan*/  FAF_ShootNoAttackNoRecoil ;\nint /*<<< orphan*/  FAF_ShootNoRecoil ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttack ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoil ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBloodNoBlood ;\nint /*<<< orphan*/  FAF_ShootNoRecoilNoAttackNoRecoilNoBloodNoBloodNoBloodNoBloodNoBlood"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_ClearSprites",
    "input":"\n0000000000000000 <R_ClearSprites>:\n0: \tmovl\t(%rip), %eax  # 0x6 <R_ClearSprites+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <R_ClearSprites+0xc>\nc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  vissprite_p ;\nint /*<<< orphan*/  vissprites ;\n\nvoid R_ClearSprites (void)\n{\nvissprite_p = vissprites;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  sprites ;\nint /*<<< orphan*/  sprites_end ;\n\nvoid R_ClearSprites(void)\n{\nsprites = sprites_end;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawAnimatedBack",
    "input":"\n0000000000000000 <WI_drawAnimatedBack>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tcmpq\t$0, (%rip)    # 0xc <WI_drawAnimatedBack+0xc>\nc: \tjne\t0x8c <WI_drawAnimatedBack+0x8c>\ne: \tmovq\t(%rip), %rax  # 0x15 <WI_drawAnimatedBack+0x15>\n15: \tmovslq\t(%rax), %rax\n18: \tcmpq\t$2, %rax\n1c: \tjg\t0x8c <WI_drawAnimatedBack+0x8c>\n1e: \tmovq\t(%rip), %rcx  # 0x25 <WI_drawAnimatedBack+0x25>\n25: \tcmpl\t$0, (%rcx,%rax,4)\n29: \tjle\t0x8c <WI_drawAnimatedBack+0x8c>\n2b: \tmovl\t$20, %ebx\n30: \txorl\t%r14d, %r14d\n33: \tnopw\t%cs:(%rax,%rax)\n3d: \tnopl\t(%rax)\n40: \tmovq\t(%rip), %rcx  # 0x47 <WI_drawAnimatedBack+0x47>\n47: \tmovq\t(%rcx,%rax,8), %rax\n4b: \tmovl\t(%rax,%rbx), %edi\n4e: \tmovl\t-4(%rax,%rbx), %esi\n52: \tmovl\t(%rip), %edx  # 0x58 <WI_drawAnimatedBack+0x58>\n58: \tmovq\t-20(%rax,%rbx), %rcx\n5d: \tmovq\t-12(%rax,%rbx), %rax\n62: \tmovl\t(%rax,%rcx,4), %ecx\n65: \tcallq\t0x6a <WI_drawAnimatedBack+0x6a>\n6a: \taddq\t$1, %r14\n6e: \tmovq\t(%rip), %rcx  # 0x75 <WI_drawAnimatedBack+0x75>\n75: \tmovq\t(%rip), %rax  # 0x7c <WI_drawAnimatedBack+0x7c>\n7c: \tmovslq\t(%rax), %rax\n7f: \tmovslq\t(%rcx,%rax,4), %rcx\n83: \taddq\t$24, %rbx\n87: \tcmpq\t%rcx, %r14\n8a: \tjl\t0x40 <WI_drawAnimatedBack+0x40>\n8c: \taddq\t$8, %rsp\n90: \tpopq\t%rbx\n91: \tpopq\t%r14\n93: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_6__ {size_t ctr; int /*<<< orphan*/ * p; TYPE_1__ loc; } ;\ntypedef  TYPE_2__ anim_t ;\nstruct TYPE_7__ {int epsd; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FB ;\nint* NUMANIMS ;\nint /*<<< orphan*/  V_DrawPatch (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_2__** anims ;\nscalar_t__ commercial ;\nTYPE_3__* wbs ;\n\nvoid WI_drawAnimatedBack(void)\n{\nint\t\t\ti;\nanim_t*\t\ta;\n\nif (commercial)\nreturn;\n\nif (wbs->epsd > 2)\nreturn;\n\nfor (i=0 ; i<NUMANIMS[wbs->epsd] ; i++)\n{\na = &anims[wbs->epsd][i];\n\nif (a->ctr >= 0)\nV_DrawPatch(a->loc.x, a->loc.y, FB, a->p[a->ctr]);\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  color; int /*<<< orphan*/ * data; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawPixel (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__* WI_animatedBack ;\nint WI_animatedBackSize ;\nint* WI_animatedBackX ;\nint /*<<< orphan*/ * WI_animatedBackY ;\nint /*<<< orphan*/  WI_backColor ;\nint /*<<< orphan*/ * WI_backData ;\nint /*<<< orphan*/  WI_backSize ;\n\nvoid WI_drawAnimatedBack(void)\n{\nint i;\n\nif (!WI_backData)\nreturn;\n\nif (WI_backSize < 2 || WI_animatedBackSize < 2 || WI_animatedBackX[0] <= 0)\nreturn;\n\nfor (i = 0; i < WI_animatedBackSize; i++)\n{\nWI_drawPixel(WI_animatedBack[i].x, WI_animatedBack[i].y, WI_animatedBack[i].color);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_drawMline",
    "input":"\n0000000000000000 <AM_drawMline>:\n0: \tpushq\t%rbx\n1: \tmovl\t%esi, %ebx\n3: \tmovl\t$0, %esi\n8: \tcallq\t0xd <AM_drawMline+0xd>\nd: \ttestq\t%rax, %rax\n10: \tje\t0x1f <AM_drawMline+0x1f>\n12: \tmovl\t$0, %edi\n17: \tmovl\t%ebx, %esi\n19: \tpopq\t%rbx\n1a: \tjmp\t0x1f <AM_drawMline+0x1f>\n1f: \tpopq\t%rbx\n20: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mline_t ;\ntypedef  int /*<<< orphan*/  fline_t ;\n\n/* Variables and functions */\nscalar_t__ AM_clipMline (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  AM_drawFline (int /*<<< orphan*/ *,int) ;\n\nvoid\nAM_drawMline\n( mline_t*\tml,\nint\t\tcolor )\n{\nstatic fline_t fl;\n\nif (AM_clipMline(ml, &fl))\nAM_drawFline(&fl, color); // draws it on frame buffer using fb coords\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nscalar_t__ AM_drawMline_ (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  AM_drawMline_ (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nvoid AM_drawMline(UBYTE *dst, UBYTE color)\n{\nif (AM_drawMline_(dst, \"0\"))\nAM_drawMline_(&dst[1], color);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_QuickLoadResponse",
    "input":"\n0000000000000000 <M_QuickLoadResponse>:\n0: \tcmpl\t$121, %edi\n3: \tjne\t0x1f <M_QuickLoadResponse+0x1f>\n5: \tpushq\t%rax\n6: \tmovl\t(%rip), %edi  # 0xc <M_QuickLoadResponse+0xc>\nc: \tcallq\t0x11 <M_QuickLoadResponse+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <M_QuickLoadResponse+0x17>\n17: \txorl\t%edi, %edi\n19: \tpopq\t%rax\n1a: \tjmp\t0x1f <M_QuickLoadResponse+0x1f>\n1f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_LoadSelect (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  quickSaveSlot ;\nint /*<<< orphan*/  sfx_swtchx ;\n\nvoid M_QuickLoadResponse(int ch)\n{\nif (ch == 'y')\n{\nM_LoadSelect(quickSaveSlot);\nS_StartSound(NULL,sfx_swtchx);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  PCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_QuickLoadResponse_121 ;\nint /*<<< orphan*/  M_QuickLoadResponse_122 ;\nint /*<<< orphan*/  M_QuickLoadResponse_123 ;\nint /*<<< orphan*/  M_QuickLoadResponse_124 ;\nint /*<<< orphan*/  M_QuickLoadResponse_125 ;\nint /*<<< orphan*/  M_QuickLoadResponse_126 ;\nint /*<<< orphan*/  M_QuickLoadResponse_127 ;\nint /*<<< orphan*/  M_QuickLoadResponse_128 ;\nint /*<<< orphan*/  M_QuickLoadResponse_129 ;\nint /*<<< orphan*/  M_QuickLoadResponse_130 ;\nint /*<<< orphan*/  M_QuickLoadResponse_131 ;\nint /*<<< orphan*/  M_QuickLoadResponse_132 ;\nint /*<<< orphan*/  M_QuickLoadResponse_133 ;\nint /*<<< orphan*/  M_QuickLoadResponse_134 ;\nint /*<<< orphan*/  M_QuickLoadResponse_135 ;\nint /*<<< orphan*/  M_QuickLoadResponse_136 ;\nint /*<<< orphan*/  M_QuickLoadResponse_137 ;\nint /*<<< orphan*/  M_QuickLoadResponse_138 ;\nint /*<<< orphan*/  M_QuickLoadResponse_139 ;\nint /*<<< orphan*/  M_QuickLoadResponse_140 ;\nint /*<<< orphan*/  M_QuickLoadResponse_141 ;\nint /*<<< orphan*/  M_QuickLoadResponse_142 ;\nint /*<<< orphan*/  M_QuickLoadResponse_143 ;\nint /*<<< orphan*/  M_QuickLoadResponse_144 ;\nint /*<<< orphan*/  M_QuickLoadResponse_145 ;\nint /*<<< orphan*/  M_QuickLoadResponse_146 ;\nint /*<<< orphan*/  M_QuickLoadResponse_147 ;\nint /*<<< orphan*/  M_QuickLoadResponse_148 ;\nint /*<<< orphan*/  M_QuickLoadResponse_149 ;\nint /*<<< orphan*/  M_QuickLoadResponse_150 ;\nint /*<<< orphan*/  M_QuickLoadResponse_151 ;\nint /*<<< orphan*/  M_QuickLoadResponse_152 ;\nint /*<<< orphan*/  M_QuickLoadResponse_153 ;\nint /*<<< orphan*/  M_QuickLoadResponse_154 ;\nint /*<<< orphan*/  M_QuickLoadResponse_155 ;\nint /*<<< orphan*/  M_QuickLoadResponse_156 ;\nint /*<<< orphan*/  M_QuickLoadResponse_157 ;\nint /*<<< orphan*/  M_QuickLoadResponse_158 ;\nint /*<<< orphan*/  M_QuickLoadResponse_159 ;\nint /*<<< orphan*/  M_QuickLoadResponse_160 ;\nint /*<<< orphan*/  M_QuickLoadResponse_161 ;\nint /*<<< orphan*/  M_QuickLoadResponse_162 ;\nint /*<<< orphan*/  M_QuickLoadResponse_163 ;\nint /*<<< orphan*/  M_QuickLoadResponse_164 ;\nint /*<<< orphan*/  M_QuickLoadResponse_165 ;\nint /*<<< orphan*/  M_QuickLoadResponse_166 ;\nint /*<<< orphan*/  M_QuickLoadResponse_167 ;\nint /*<<< orphan*/  M_QuickLoadResponse_168 ;\nint /*<<< orphan*/  M_QuickLoadResponse_169 ;\nint /*<<< orphan*/  M_QuickLoadResponse_170 ;\nint /*<<< orphan*/  M_QuickLoadResponse_171 ;\nint /*<<< orphan*/  M_QuickLoadResponse_172 ;\nint /*<<< orphan*/  M_QuickLoadResponse_173 ;\nint /*<<< orphan*/  M_QuickLoadResponse_174 ;\nint /*<<< orphan*/  M_QuickLoadResponse_175 ;\nint /*<<< orphan*/  M_QuickLoadResponse_176 ;\nint /*<<< orphan*/  M_QuickLoadResponse_177 ;\nint /*<<< orphan*/  M_QuickLoadResponse_178 ;\nint /*<<< orphan*/  M_QuickLoadResponse_179 ;\nint /*<<< orphan*/  M_QuickLoadResponse_180 ;\nint /*<<< orphan*/  M_QuickLoadResponse_181 ;\nint /*<<< orphan*/  M_QuickLoadResponse_182 ;\nint /*<<< orphan*/  M_QuickLoadResponse_183 ;\nint /*<<< orphan*/  M_QuickLoadResponse_184 ;\nint /*<<< orphan*/  M_QuickLoadResponse_185 ;\nint /*<<< orphan*/  M_QuickLoadResponse_186 ;\nint /*<<< orphan*/  M_QuickLoadResponse_187 ;\nint /*<<< orphan*/  M_QuickLoadResponse_188 ;\nint /*<<< orphan*/  M_QuickLoadResponse_189 ;\nint /*<<< orphan*/  M_QuickLoadResponse_190 ;\nint /*<<< orphan*/  M_QuickLoadResponse_191 ;\nint /*<<< orphan*/  M_QuickLoadResponse_192 ;\nint /*<<< orphan*/  M_QuickLoadResponse_193 ;\nint /*<<< orphan*/  M_QuickLoadResponse_194 ;\nint /*<<< orphan*/  M_QuickLoadResponse_195 ;\nint /*<<< orphan*/  M_QuickLoadResponse_196 ;\nint /*<<< orphan*/  M_QuickLoadResponse_197 ;\nint /*<<< orphan*/  M_QuickLoadResponse_198 ;\nint /*<<< orphan*/  M_QuickLoadResponse_199 ;\nint /*<<< orphan*/  M_QuickLoadResponse_200 ;\nint /*<<< orphan*/  M_QuickLoadResponse_201 ;\nint /*<<< orphan*/  M_QuickLoadResponse_202 ;\nint /*<<< orphan*/  M_QuickLoadResponse_203 ;\nint /*<<< orphan*/  M_QuickLoadResponse_204 ;\nint /*<<< orphan*/  M_QuickLoadResponse_205 ;\nint /*<<< orphan*/  M_QuickLoadResponse_206 ;\nint /*<<< orphan*/  M_QuickLoadResponse_207 ;\nint /*<<< orphan*/  M_QuickLoadResponse_208 ;\nint /*<<< orphan*/  M_QuickLoadResponse_209 ;\nint /*<<< orphan*/  M_QuickLoadResponse_210 ;\nint /*<<< orphan*/  M_QuickLoadResponse_211 ;\nint /*<<< orphan*/  M_QuickLoadResponse_212 ;\nint /*<<< orphan*/  M_QuickLoadResponse_213 ;\nint /*<<< orphan*/  M_QuickLoadResponse_214 ;\nint /*<<< orphan*/  M_QuickLoadResponse_215 ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_T_FireFlicker",
    "input":"\n0000000000000000 <T_FireFlicker>:\n0: \tpushq\t%rbx\n1: \taddl\t$-1, (%rdi)\n4: \tje\t0x8 <T_FireFlicker+0x8>\n6: \tpopq\t%rbx\n7: \tretq\n8: \tmovq\t%rdi, %rbx\nb: \txorl\t%eax, %eax\nd: \tcallq\t0x12 <T_FireFlicker+0x12>\n12: \tshll\t$4, %eax\n15: \tandl\t$48, %eax\n18: \tmovq\t16(%rbx), %rcx\n1c: \tmovl\t(%rcx), %esi\n1e: \tsubl\t%eax, %esi\n20: \tmovl\t4(%rbx), %edx\n23: \tcmpl\t%edx, %esi\n25: \tjl\t0x2c <T_FireFlicker+0x2c>\n27: \tmovl\t8(%rbx), %edx\n2a: \tsubl\t%eax, %edx\n2c: \tmovl\t%edx, (%rcx)\n2e: \tmovl\t$4, (%rbx)\n34: \tpopq\t%rbx\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int count; int minlight; int maxlight; TYPE_1__* sector; } ;\ntypedef  TYPE_2__ fireflicker_t ;\nstruct TYPE_4__ {int lightlevel; } ;\n\n/* Variables and functions */\nint P_Random () ;\n\nvoid T_FireFlicker (fireflicker_t* flick)\n{\nint\tamount;\n\nif (--flick->count)\nreturn;\n\namount = (P_Random()&3)*16;\n\nif (flick->sector->lightlevel - amount < flick->minlight)\nflick->sector->lightlevel = flick->minlight;\nelse\nflick->sector->lightlevel = flick->maxlight - amount;\n\nflick->count = 4;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int ticks; int y; int x; int /*<<< orphan*/ * p; } ;\ntypedef  TYPE_1__ TFlicker ;\n\n/* Variables and functions */\nint /*<<< orphan*/  RANDOM_RANGE (int) ;\n\nvoid T_FireFlicker(TFlicker *flicker)\n{\nflicker->ticks--;\nif (!flicker->ticks)\n{\nflicker->p->x = flicker->x - (RANDOM_RANGE(16) & 0x30);\nif (flicker->p->x < flicker->x)\nflicker->p->x = flicker->x;\nelse\nflicker->p->x = flicker->x - (RANDOM_RANGE(16) & 0x30);\nif (flicker->p->x > flicker->x)\nflicker->p->x = flicker->x;\nelse\nflicker->p->y = flicker->y - (RANDOM_RANGE(16) & 0x30);\nif (flicker->p->y < flicker->y)\nflicker->p->y = flicker->y;\nelse\nflicker->p->y = flicker->y - (RANDOM_RANGE(16) & 0x30);\nflicker->ticks = 4;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_AddPointToBox",
    "input":"\n0000000000000000 <R_AddPointToBox>:\n0: \tmovq\t(%rip), %rax  # 0x7 <R_AddPointToBox+0x7>\n7: \tcmpl\t%edi, (%rdx,%rax,4)\na: \tjle\t0xf <R_AddPointToBox+0xf>\nc: \tmovl\t%edi, (%rdx,%rax,4)\nf: \tmovq\t(%rip), %rax  # 0x16 <R_AddPointToBox+0x16>\n16: \tcmpl\t%edi, (%rdx,%rax,4)\n19: \tjge\t0x1e <R_AddPointToBox+0x1e>\n1b: \tmovl\t%edi, (%rdx,%rax,4)\n1e: \tmovq\t(%rip), %rax  # 0x25 <R_AddPointToBox+0x25>\n25: \tcmpl\t%esi, (%rdx,%rax,4)\n28: \tjle\t0x2d <R_AddPointToBox+0x2d>\n2a: \tmovl\t%esi, (%rdx,%rax,4)\n2d: \tmovq\t(%rip), %rax  # 0x34 <R_AddPointToBox+0x34>\n34: \tcmpl\t%esi, (%rdx,%rax,4)\n37: \tjge\t0x3c <R_AddPointToBox+0x3c>\n39: \tmovl\t%esi, (%rdx,%rax,4)\n3c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nsize_t BOXBOTTOM ;\nsize_t BOXLEFT ;\nsize_t BOXRIGHT ;\nsize_t BOXTOP ;\n\nvoid\nR_AddPointToBox\n( int\t\tx,\nint\t\ty,\nfixed_t*\tbox )\n{\nif (x< box[BOXLEFT])\nbox[BOXLEFT] = x;\nif (x> box[BOXRIGHT])\nbox[BOXRIGHT] = x;\nif (y< box[BOXBOTTOM])\nbox[BOXBOTTOM] = y;\nif (y> box[BOXTOP])\nbox[BOXTOP] = y;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  R_Box ;\n\n/* Variables and functions */\nsize_t R_Box_Bottom ;\nsize_t R_Box_Left ;\nsize_t R_Box_Right ;\nsize_t R_Box_Top ;\n\nvoid R_AddPointToBox(int x, int y, R_Box *box)\n{\nif (x < box->left)\nbox->left = x;\nif (x > box->right)\nbox->right = x;\nif (y < box->top)\nbox->top = y;\nif (y > box->bottom)\nbox->bottom = y;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_P_UseLines",
    "input":"\n0000000000000000 <P_UseLines>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t%rax, (%rip)  # 0xa <P_UseLines+0xa>\na: \tmovq\t(%rdi), %rax\nd: \tmovl\t(%rax), %edx\nf: \tmovb\t(%rip), %cl   # 0x15 <P_UseLines+0x15>\n15: \tsarl\t%cl, %edx\n17: \tmovq\t16(%rax), %rdi\n1b: \tmovq\t8(%rax), %rsi\n1f: \tmovl\t(%rip), %eax  # 0x25 <P_UseLines+0x25>\n25: \tmovb\t(%rip), %cl   # 0x2b <P_UseLines+0x2b>\n2b: \tsarl\t%cl, %eax\n2d: \tmovq\t(%rip), %r8   # 0x34 <P_UseLines+0x34>\n34: \tmovslq\t%edx, %rcx\n37: \tmovslq\t(%r8,%rcx,4), %rdx\n3b: \tmovslq\t%eax, %r8\n3e: \timulq\t%r8, %rdx\n42: \taddq\t%rdi, %rdx\n45: \tmovq\t(%rip), %rax  # 0x4c <P_UseLines+0x4c>\n4c: \tmovslq\t(%rax,%rcx,4), %rcx\n50: \timulq\t%r8, %rcx\n54: \taddq\t%rsi, %rcx\n57: \tmovl\t(%rip), %r8d  # 0x5e <P_UseLines+0x5e>\n5e: \tmovl\t(%rip), %r9d  # 0x65 <P_UseLines+0x65>\n65: \tjmp\t0x6a <P_UseLines+0x6a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {TYPE_2__* mo; } ;\ntypedef  TYPE_1__ player_t ;\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_5__ {int angle; scalar_t__ y; scalar_t__ x; } ;\n\n/* Variables and functions */\nint ANGLETOFINESHIFT ;\nint FRACBITS ;\nint /*<<< orphan*/  PTR_UseTraverse ;\nint /*<<< orphan*/  PT_ADDLINES ;\nint /*<<< orphan*/  P_PathTraverse (scalar_t__,scalar_t__,scalar_t__,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint USERANGE ;\nint* finecosine ;\nint* finesine ;\nTYPE_2__* usething ;\n\nvoid P_UseLines (player_t*\tplayer)\n{\nint\t\tangle;\nfixed_t\tx1;\nfixed_t\ty1;\nfixed_t\tx2;\nfixed_t\ty2;\n\nusething = player->mo;\n\nangle = player->mo->angle >> ANGLETOFINESHIFT;\n\nx1 = player->mo->x;\ny1 = player->mo->y;\nx2 = x1 + (USERANGE>>FRACBITS)*finecosine[angle];\ny2 = y1 + (USERANGE>>FRACBITS)*finesine[angle];\n\nP_PathTraverse ( x1, y1, x2, y2, PT_ADDLINES, PTR_UseTraverse );\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* p; } ;\ntypedef  TYPE_1__* Pixel ;\n\n/* Variables and functions */\nint* P_Line ;\nint P_Line_Size ;\nint P_Line_Size_Shift ;\nint P_Line_Size_Shift_Mask ;\nint P_Line_Size_Shift_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask ;\nint P_Line_Size_Shift_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_Mask_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_HU_Erase",
    "input":"\n0000000000000000 <HU_Erase>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, %edi\n6: \tcallq\t0xb <HU_Erase+0xb>\nb: \tmovl\t$0, %edi\n10: \tcallq\t0x15 <HU_Erase+0x15>\n15: \tmovl\t$0, %edi\n1a: \tpopq\t%rax\n1b: \tjmp\t0x20 <HU_Erase+0x20>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_eraseIText (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  HUlib_eraseSText (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  HUlib_eraseTextLine (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  w_chat ;\nint /*<<< orphan*/  w_message ;\nint /*<<< orphan*/  w_title ;\n\nvoid HU_Erase(void)\n{\n\nHUlib_eraseSText(&w_message);\nHUlib_eraseIText(&w_chat);\nHUlib_eraseTextLine(&w_title);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_Erase_BG () ;\nint /*<<< orphan*/  HU_Erase_FG () ;\nint /*<<< orphan*/  HU_Erase_P () ;\n\nvoid HU_Erase(void)\n{\nHU_Erase_BG();\nHU_Erase_FG();\nHU_Erase_P();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_StartMusic",
    "input":"\n0000000000000000 <S_StartMusic>:\n0: \txorl\t%esi, %esi\n2: \tjmp\t0x7 <S_StartMusic+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  S_ChangeMusic (int,int) ;\n\nvoid S_StartMusic(int m_id)\n{\nS_ChangeMusic(m_id, false);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  int8_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartMusicInternal (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid S_StartMusic(int8_t *song)\n{\nS_StartMusicInternal(song, 0);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_RenderPlayerView",
    "input":"\n0000000000000000 <R_RenderPlayerView>:\n0: \tpushq\t%rax\n1: \tcallq\t0x6 <R_RenderPlayerView+0x6>\n6: \txorl\t%eax, %eax\n8: \tcallq\t0xd <R_RenderPlayerView+0xd>\nd: \txorl\t%eax, %eax\nf: \tcallq\t0x14 <R_RenderPlayerView+0x14>\n14: \txorl\t%eax, %eax\n16: \tcallq\t0x1b <R_RenderPlayerView+0x1b>\n1b: \txorl\t%eax, %eax\n1d: \tcallq\t0x22 <R_RenderPlayerView+0x22>\n22: \txorl\t%eax, %eax\n24: \tcallq\t0x29 <R_RenderPlayerView+0x29>\n29: \tmovq\t(%rip), %rdi  # 0x30 <R_RenderPlayerView+0x30>\n30: \taddq\t$-1, %rdi\n34: \tcallq\t0x39 <R_RenderPlayerView+0x39>\n39: \txorl\t%eax, %eax\n3b: \tcallq\t0x40 <R_RenderPlayerView+0x40>\n40: \txorl\t%eax, %eax\n42: \tcallq\t0x47 <R_RenderPlayerView+0x47>\n47: \txorl\t%eax, %eax\n49: \tcallq\t0x4e <R_RenderPlayerView+0x4e>\n4e: \txorl\t%eax, %eax\n50: \tcallq\t0x55 <R_RenderPlayerView+0x55>\n55: \txorl\t%eax, %eax\n57: \tpopq\t%rcx\n58: \tjmp\t0x5d <R_RenderPlayerView+0x5d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  NetUpdate () ;\nint /*<<< orphan*/  R_ClearClipSegs () ;\nint /*<<< orphan*/  R_ClearDrawSegs () ;\nint /*<<< orphan*/  R_ClearPlanes () ;\nint /*<<< orphan*/  R_ClearSprites () ;\nint /*<<< orphan*/  R_DrawMasked () ;\nint /*<<< orphan*/  R_DrawPlanes () ;\nint /*<<< orphan*/  R_RenderBSPNode (scalar_t__) ;\nint /*<<< orphan*/  R_SetupFrame (int /*<<< orphan*/ *) ;\nscalar_t__ numnodes ;\n\nvoid R_RenderPlayerView (player_t* player)\n{\nR_SetupFrame (player);\n\n// Clear buffers.\nR_ClearClipSegs ();\nR_ClearDrawSegs ();\nR_ClearPlanes ();\nR_ClearSprites ();\n\n// check for new console commands.\nNetUpdate ();\n\n// The head node is the last node output.\nR_RenderBSPNode (numnodes-1);\n\n// Check for new console commands.\nNetUpdate ();\n\nR_DrawPlanes ();\n\n// Check for new console commands.\nNetUpdate ();\n\nR_DrawMasked ();\n\n// Check for new console commands.\nNetUpdate ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DrawColumnLights () ;\nint /*<<< orphan*/  R_DrawColumnSprites () ;\nint /*<<< orphan*/  R_DrawColumnTextures () ;\nint /*<<< orphan*/  R_DrawColumnVerts () ;\nint /*<<< orphan*/  R_DrawColumnWalls () ;\nint /*<<< orphan*/  R_DrawColumnZones () ;\nint /*<<< orphan*/  R_DrawFlatTextures () ;\nint /*<<< orphan*/  R_DrawFlatVerts () ;\nint /*<<< orphan*/  R_DrawFlatWalls () ;\nint /*<<< orphan*/  R_DrawFlatZones () ;\nint /*<<< orphan*/  R_DrawSpriteTextures () ;\nint /*<<< orphan*/  R_DrawSpriteVerts () ;\nint /*<<< orphan*/  R_DrawSpriteWalls () ;\nint /*<<< orphan*/  R_DrawSpriteZones () ;\nint /*<<< orphan*/  R_DrawSprites () ;\nint /*<<< orphan*/  R_DrawTextures () ;\nint /*<<< orphan*/  R_DrawVerts () ;\nint /*<<< orphan*/  R_DrawWalls () ;\nint /*<<< orphan*/  R_DrawZones () ;\nint /*<<< orphan*/  R_EndFrame () ;\nint /*<<< orphan*/  R_InitFrame () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawFlat () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawSprite () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawWall () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones () ;\nint /*<<< orphan*/  R_RenderPlayerView_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZones_DrawZ"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_Punch",
    "input":"\n0000000000000000 <A_Punch>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdi, %r14\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <A_Punch+0x11>\n11: \tcltq\n13: \timulq\t$1717986919, %rax, %rcx # imm = 0x66666667\n1a: \tmovq\t%rcx, %rdx\n1d: \tshrq\t$63, %rdx\n21: \tsarq\t$34, %rcx\n25: \taddl\t%edx, %ecx\n27: \taddl\t%ecx, %ecx\n29: \tleal\t(%rcx,%rcx,4), %ecx\n2c: \tsubl\t%ecx, %eax\n2e: \tleal\t(%rax,%rax), %ecx\n31: \taddl\t$2, %ecx\n34: \taddl\t%eax, %eax\n36: \tmovq\t(%r14), %rdx\n39: \tmovq\t8(%r14), %rsi\n3d: \tmovq\t(%rip), %rdi  # 0x44 <A_Punch+0x44>\n44: \tcmpq\t$0, (%rsi,%rdi,8)\n49: \tleal\t4(%rax,%rax), %eax\n4d: \tleal\t(%rax,%rax,4), %ebp\n50: \tcmovel\t%ecx, %ebp\n53: \tmovl\t(%rdx), %r15d\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <A_Punch+0x5d>\n5d: \tmovl\t%eax, %ebx\n5f: \txorl\t%eax, %eax\n61: \tcallq\t0x66 <A_Punch+0x66>\n66: \tsubl\t%eax, %ebx\n68: \tshll\t$18, %ebx\n6b: \taddl\t%r15d, %ebx\n6e: \tmovq\t(%r14), %rdi\n71: \tmovl\t(%rip), %edx  # 0x77 <A_Punch+0x77>\n77: \tmovl\t%ebx, %esi\n79: \tcallq\t0x7e <A_Punch+0x7e>\n7e: \tmovq\t(%r14), %rdi\n81: \tmovl\t(%rip), %edx  # 0x87 <A_Punch+0x87>\n87: \tmovl\t%ebx, %esi\n89: \tmovl\t%eax, %ecx\n8b: \tmovl\t%ebp, %r8d\n8e: \tcallq\t0x93 <A_Punch+0x93>\n93: \tcmpq\t$0, (%rip)    # 0x9b <A_Punch+0x9b>\n9b: \tje\t0xca <A_Punch+0xca>\n9d: \tmovq\t(%r14), %rdi\na0: \tmovl\t(%rip), %esi  # 0xa6 <A_Punch+0xa6>\na6: \tcallq\t0xab <A_Punch+0xab>\nab: \tmovq\t(%r14), %rax\nae: \tmovl\t4(%rax), %esi\nb1: \tmovl\t8(%rax), %edi\nb4: \tmovq\t(%rip), %rax  # 0xbb <A_Punch+0xbb>\nbb: \tmovl\t(%rax), %ecx\nbd: \tmovl\t4(%rax), %edx\nc0: \tcallq\t0xc5 <A_Punch+0xc5>\nc5: \tmovq\t(%r14), %rcx\nc8: \tmovl\t%eax, (%rcx)\nca: \taddq\t$8, %rsp\nce: \tpopq\t%rbx\ncf: \tpopq\t%r14\nd1: \tpopq\t%r15\nd3: \tpopq\t%rbp\nd4: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_7__ {TYPE_3__* mo; scalar_t__* powers; } ;\ntypedef  TYPE_1__ player_t ;\ntypedef  int angle_t ;\nstruct TYPE_9__ {int angle; int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MELEERANGE ;\nint P_AimLineAttack (TYPE_3__*,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_LineAttack (TYPE_3__*,int,int /*<<< orphan*/ ,int,int) ;\nint P_Random () ;\nint R_PointToAngle2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (TYPE_3__*,int /*<<< orphan*/ ) ;\nTYPE_2__* linetarget ;\nsize_t pw_strength ;\nint /*<<< orphan*/  sfx_punch ;\n\nvoid\nA_Punch\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nangle_t\tangle;\nint\t\tdamage;\nint\t\tslope;\n\ndamage = (P_Random ()%10+1)<<1;\n\nif (player->powers[pw_strength])\ndamage *= 10;\n\nangle = player->mo->angle;\nangle += (P_Random()-P_Random())<<18;\nslope = P_AimLineAttack (player->mo, angle, MELEERANGE);\nP_LineAttack (player->mo, angle, MELEERANGE, slope, damage);\n\n// turn to face target\nif (linetarget)\n{\nS_StartSound (player->mo, sfx_punch);\nplayer->mo->angle = R_PointToAngle2 (player->mo->x,\nplayer->mo->y,\nlinetarget->x,\nlinetarget->y);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * p; int /*<<< orphan*/ * q; } ;\ntypedef  TYPE_1__ A_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Punch_D ;\nint /*<<< orphan*/  A_Punch_H ;\nint /*<<< orphan*/  A_Punch_L ;\nint /*<<< orphan*/  A_Punch_M ;\nint /*<<< orphan*/  A_Punch_X ;\nint /*<<< orphan*/  A_Punch_Y ;\nint /*<<< orphan*/  A_Punch_Z ;\nint /*<<< orphan*/  A_Punch_a ;\nint /*<<< orphan*/  A_Punch_b ;\nint /*<<< orphan*/  A_Punch_c ;\nint /*<<< orphan*/  A_Punch_d ;\nint /*<<< orphan*/  A_Punch_e ;\nint /*<<< orphan*/  A_Punch_f ;\nint /*<<< orphan*/  A_Punch_g ;\nint /*<<< orphan*/  A_Punch_h ;\nint /*<<< orphan*/  A_Punch_i ;\nint /*<<< orphan*/  A_Punch_j ;\nint /*<<< orphan*/  A_Punch_k ;\nint /*<<< orphan*/  A_Punch_l ;\nint /*<<< orphan*/  A_Punch_m ;\nint /*<<< orphan*/  A_Punch_n ;\nint /*<<< orphan*/  A_Punch_o ;\nint /*<<< orphan*/  A_Punch_p ;\nint /*<<< orphan*/  A_Punch_q ;\nint /*<<< orphan*/  A_Punch_r ;\nint /*<<< orphan*/  A_Punch_s ;\nint /*<<< orphan*/  A_Punch_t ;\nint /*<<< orphan*/  A_Punch_u ;\nint /*<<< orphan*/  A_Punch_v ;\nint /*<<< orphan*/  A_Punch_w ;\nint /*<<< orphan*/  A_Punch_x ;\nint /*<<< orphan*/  A_Punch_y ;\nint /*<<< orphan*/  A_Punch_z ;\nint /*<<< orphan*/  A_Punch_z_ ;\nint /*<<< orphan*/  A_Punch_z_2 ;\nint /*<<< orphan*/  A_Punch_z_3 ;\nint /*<<< orphan*/  A_Punch_z_4 ;\nint /*<<< orphan*/  A_Punch_z_5 ;\nint /*<<< orphan*/  A_Punch_z_6 ;\nint /*<<< orphan*/  A_Punch_z_7 ;\nint /*<<< orphan*/  A_Punch_z_8 ;\nint /*<<< orphan*/  A_Punch_z_9 ;\nint /*<<< orphan*/  A_Punch_z_a ;\nint /*<<< orphan*/  A_Punch_z_b ;\nint /*<<< orphan*/  A_Punch_z_c ;\nint /*<<< orphan*/  A_Punch_z_d ;\nint /*<<< orphan*/  A_Punch_z_e ;\nint /*<<< orphan*/  A_Punch_z_f ;\nint /*<<< orphan*/  A_Punch_z_g ;\nint /*<<< orphan*/  A_Punch_z_h ;\nint /*<<< orphan*/  A_Punch_z_i ;\nint /*<<< orphan*/  A_Punch_z_j ;\nint /*<<< orphan*/  A_Punch_z_k ;\nint /*<<< orphan*/  A_Punch_z_l ;\nint /*<<< orphan*/  A_Punch_z_m ;\nint /*<<< orphan*/  A_Punch_z_n ;\nint /*<<< orphan*/  A_Punch_z_o ;\nint /*<<< orphan*/  A_Punch_z_p ;\nint /*<<< orphan*/  A_Punch_z_q ;\nint /*<<< orphan*/  A_Punch_z_r ;\nint /*<<< orphan*/  A_Punch_z_s ;\nint /*<<< orphan*/  A_Punch_z_t ;\nint /*<<< orphan*/  A_Punch_z_u ;\nint /*<<< orphan*/  A_Punch_z_v ;\nint /*<<< orphan*/  A_Punch_z_w ;\nint /*<<< orphan*/  A_Punch_z_x ;\nint /*<<< orphan*/  A_Punch_z_y ;\nint /*<<< orphan*/  A_Punch_z_z ;\nint /*<<< orphan*/  A_Punch_z_z_ ;\nint /*<<< orphan*/  A_Punch_z_z_2 ;\nint /*<<< orphan*/  A_Punch_z_z_3 ;\nint /*<<< orphan*/  A_Punch_z_z_4 ;\nint /*<<< orphan*/  A_Punch_z_z_5 ;\nint /*<<< orphan*/  A_Punch_z_z_6 ;\nint /*<<< orphan*/  A_Punch_z_z_7 ;\nint /*<<< orphan*/  A_Punch_z_z_8 ;\nint /*<<< orphan*/  A_Punch_z_z_9 ;\nint /*<<< orphan*/  A_Punch_z_z_a ;\nint /*<<< orphan*/  A_Punch_z_z_b ;\nint /*<<< orphan*/  A_Punch_z_z_c ;\nint /*<<< orphan*/  A_Punch_z_z_d ;\nint /*<<< orphan*/  A_Punch_z_z_e ;\nint /*<<< orphan*/  A_Punch_z_z_f ;\nint /*<<< orphan*/  A_Punch_z_z_g ;\nint /*<<< orphan*/  A_Punch_z_z_h ;\nint /*<<< orphan*/  A_Punch_z_z_i ;\nint /*<<< orphan*/  A_Punch_z_z_j ;\nint /*<<< orphan*/  A_Punch_z_z_k ;\nint /*<<< orphan*/  A_Punch_z_z_l ;\nint /*<<< orphan*/  A_Punch_z_z_m ;\nint /*<<< orphan*/  A_Punch_z_z_n ;\nint /*<<< orphan*/  A_Punch_z_z_o ;\nint /*<<< orphan*/  A_Punch_z_z_p ;\nint /*<<< orphan*/  A_Punch_z_z_q ;\nint /*<<< orphan*/  A_Punch_z_z_r ;\nint /*<<< orphan*/  A_Punch_z_z_s ;\nint /*<<< orphan*/  A_Punch_z_z_t ;\nint /*<<< orphan*/  A_Punch_z_z_u ;\nint /*<<< orphan*/  A_Punch_z_z_v ;\nint /*<<< orphan*/  A_Punch_z_z_w ;\nint /*<<< orphan*/  A_Punch_z_z_x ;\nint /*<<< orphan*/  A_Punch_z_z_y ;\nint /*<<< orphan*/  A_Punch_z_z_z ;\nint /*<<< orphan*/  A_Punch_z"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_HeadAttack",
    "input":"\n0000000000000000 <A_HeadAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x56 <A_HeadAttack+0x56>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_HeadAttack+0xe>\ne: \tmovq\t%rbx, %rdi\n11: \tcallq\t0x16 <A_HeadAttack+0x16>\n16: \ttestq\t%rax, %rax\n19: \tje\t0x58 <A_HeadAttack+0x58>\n1b: \txorl\t%eax, %eax\n1d: \tcallq\t0x22 <A_HeadAttack+0x22>\n22: \tcltq\n24: \timulq\t$715827883, %rax, %rcx  # imm = 0x2AAAAAAB\n2b: \tmovq\t%rcx, %rdx\n2e: \tshrq\t$63, %rdx\n32: \tshrq\t$32, %rcx\n36: \taddl\t%edx, %ecx\n38: \taddl\t%ecx, %ecx\n3a: \tleal\t(%rcx,%rcx,2), %ecx\n3d: \tsubl\t%ecx, %eax\n3f: \tleal\t(%rax,%rax,4), %eax\n42: \tleal\t(%rax,%rax), %ecx\n45: \taddl\t$10, %ecx\n48: \tmovl\t(%rbx), %edi\n4a: \tmovq\t%rbx, %rsi\n4d: \tmovq\t%rbx, %rdx\n50: \tpopq\t%rbx\n51: \tjmp\t0x56 <A_HeadAttack+0x56>\n56: \tpopq\t%rbx\n57: \tretq\n58: \tmovl\t(%rbx), %esi\n5a: \tmovl\t(%rip), %edx  # 0x60 <A_HeadAttack+0x60>\n60: \tmovq\t%rbx, %rdi\n63: \tpopq\t%rbx\n64: \tjmp\t0x69 <A_HeadAttack+0x69>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  MT_HEADSHOT ;\nscalar_t__ P_CheckMeleeRange (TYPE_1__*) ;\nint /*<<< orphan*/  P_DamageMobj (int /*<<< orphan*/ ,TYPE_1__*,TYPE_1__*,int) ;\nint P_Random () ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_HeadAttack (mobj_t* actor)\n{\nint\t\tdamage;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nif (P_CheckMeleeRange (actor))\n{\ndamage = (P_Random()%6+1)*10;\nP_DamageMobj (actor->target, actor, actor, damage);\nreturn;\n}\n\n// launch a missile\nP_SpawnMissile (actor, actor->target, MT_HEADSHOT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  en_obj; } ;\ntypedef  TYPE_1__ Enemy ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_HeadAttack2 ;\nscalar_t__ E_CheckEnemy (TYPE_1__*) ;\nint /*<<< orphan*/  E_SetAnim (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimFast (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed2 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed3 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed4 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed5 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed6 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed7 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed8 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed9 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed10 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed11 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed12 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed13 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed14 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed15 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed16 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed17 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed18 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed19 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed20 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed21 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed22 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed23 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed24 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed25 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed26 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed27 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed28 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed29 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed30 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed31 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed32 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed33 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed34 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed35 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed36 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed37 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed38 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed39 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed40 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed41 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed42 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed43 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed44 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed45 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  E_SetAnimSpeed46 (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< or"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_eraseTextLine",
    "input":"\n0000000000000000 <HUlib_eraseTextLine>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdi, %r15\na: \tcmpl\t$0, (%rip)    # 0x11 <HUlib_eraseTextLine+0x11>\n11: \tjne\t0xae <HUlib_eraseTextLine+0xae>\n17: \tcmpl\t$0, (%rip)    # 0x1e <HUlib_eraseTextLine+0x1e>\n1e: \tje\t0xae <HUlib_eraseTextLine+0xae>\n24: \tcmpq\t$0, 8(%r15)\n29: \tje\t0xae <HUlib_eraseTextLine+0xae>\n2f: \tmovq\t16(%r15), %rax\n33: \tmovq\t(%rax), %rax\n36: \tmovl\t(%rax), %edi\n38: \tcallq\t0x3d <HUlib_eraseTextLine+0x3d>\n3d: \ttestl\t%eax, %eax\n3f: \tjs\t0xae <HUlib_eraseTextLine+0xae>\n41: \tmovl\t%eax, %r14d\n44: \taddl\t$1, %r14d\n48: \tmovl\t(%r15), %ebx\n4b: \tmovl\t(%rip), %esi  # 0x51 <HUlib_eraseTextLine+0x51>\n51: \tmovl\t%esi, %ebp\n53: \timull\t%ebx, %ebp\n56: \tjmp\t0x7c <HUlib_eraseTextLine+0x7c>\n58: \tnopl\t(%rax,%rax)\n60: \tmovl\t%ebp, %edi\n62: \tcallq\t0x67 <HUlib_eraseTextLine+0x67>\n67: \taddl\t$1, %ebx\n6a: \tmovl\t(%rip), %esi  # 0x70 <HUlib_eraseTextLine+0x70>\n70: \taddl\t%esi, %ebp\n72: \tmovl\t(%r15), %eax\n75: \taddl\t%r14d, %eax\n78: \tcmpl\t%eax, %ebx\n7a: \tjge\t0xae <HUlib_eraseTextLine+0xae>\n7c: \tmovl\t(%rip), %eax  # 0x82 <HUlib_eraseTextLine+0x82>\n82: \tcmpl\t%eax, %ebx\n84: \tjl\t0x60 <HUlib_eraseTextLine+0x60>\n86: \taddl\t(%rip), %eax  # 0x8c <HUlib_eraseTextLine+0x8c>\n8c: \tcmpl\t%eax, %ebx\n8e: \tjge\t0x60 <HUlib_eraseTextLine+0x60>\n90: \tmovl\t(%rip), %esi  # 0x96 <HUlib_eraseTextLine+0x96>\n96: \tmovl\t%ebp, %edi\n98: \tcallq\t0x9d <HUlib_eraseTextLine+0x9d>\n9d: \tmovl\t(%rip), %esi  # 0xa3 <HUlib_eraseTextLine+0xa3>\na3: \tleal\t(%rsi,%rbp), %edi\na6: \taddl\t(%rip), %edi  # 0xac <HUlib_eraseTextLine+0xac>\nac: \tjmp\t0x62 <HUlib_eraseTextLine+0x62>\nae: \tmovq\t8(%r15), %rax\nb2: \ttestq\t%rax, %rax\nb5: \tje\t0xbf <HUlib_eraseTextLine+0xbf>\nb7: \taddq\t$-1, %rax\nbb: \tmovq\t%rax, 8(%r15)\nbf: \taddq\t$8, %rsp\nc3: \tpopq\t%rbx\nc4: \tpopq\t%r14\nc6: \tpopq\t%r15\nc8: \tpopq\t%rbp\nc9: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int y; scalar_t__ needsupdate; TYPE_1__** f; } ;\ntypedef  TYPE_2__ hu_textline_t ;\ntypedef  int boolean ;\nstruct TYPE_4__ {int /*<<< orphan*/  height; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_VideoErase (int,int) ;\nint SCREENWIDTH ;\nint SHORT (int /*<<< orphan*/ ) ;\nint automapactive ;\nint viewheight ;\nint viewwidth ;\nint viewwindowx ;\nint viewwindowy ;\n\nvoid HUlib_eraseTextLine(hu_textline_t* l)\n{\nint\t\t\tlh;\nint\t\t\ty;\nint\t\t\tyoffset;\nstatic boolean\tlastautomapactive = true;\n\n// Only erases when NOT in automap and the screen is reduced,\n// and the text must either need updating or refreshing\n// (because of a recent change back from the automap)\n\nif (!automapactive &&\nviewwindowx && l->needsupdate)\n{\nlh = SHORT(l->f[0]->height) + 1;\nfor (y=l->y,yoffset=y*SCREENWIDTH ; y<l->y+lh ; y++,yoffset+=SCREENWIDTH)\n{\nif (y < viewwindowy || y >= viewwindowy + viewheight)\nR_VideoErase(yoffset, SCREENWIDTH); // erase entire line\nelse\n{\nR_VideoErase(yoffset, viewwindowx); // erase left border\nR_VideoErase(yoffset + viewwindowx + viewwidth, viewwindowx);\n// erase right border\n}\n}\n}\n\nlastautomapactive = automapactive;\nif (l->needsupdate) l->needsupdate--;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int y; int /*<<< orphan*/ * hwnd; int /*<<< orphan*/ * hdc; } ;\ntypedef  TYPE_1__ HUCHAR_INFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_BACKGROUND ;\nint /*<<< orphan*/  HU_BORDER ;\nint /*<<< orphan*/  HU_CHAR_HEIGHT ;\nint /*<<< orphan*/  HU_CHAR_WIDTH ;\nint /*<<< orphan*/  HU_CHAR_X ;\nint /*<<< orphan*/  HU_CHAR_Y ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM ;\nint /*<<< orphan*/  HU_CHAR_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ChangeSensitivity",
    "input":"\n0000000000000000 <M_ChangeSensitivity>:\n0: \tcmpl\t$1, %edi\n3: \tje\t0x18 <M_ChangeSensitivity+0x18>\n5: \ttestl\t%edi, %edi\n7: \tjne\t0x2c <M_ChangeSensitivity+0x2c>\n9: \tmovl\t(%rip), %eax  # 0xf <M_ChangeSensitivity+0xf>\nf: \ttestl\t%eax, %eax\n11: \tje\t0x2c <M_ChangeSensitivity+0x2c>\n13: \taddl\t$-1, %eax\n16: \tjmp\t0x26 <M_ChangeSensitivity+0x26>\n18: \tmovl\t(%rip), %eax  # 0x1e <M_ChangeSensitivity+0x1e>\n1e: \tcmpl\t$8, %eax\n21: \tjg\t0x2c <M_ChangeSensitivity+0x2c>\n23: \taddl\t$1, %eax\n26: \tmovl\t%eax, (%rip)  # 0x2c <M_ChangeSensitivity+0x2c>\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint mouseSensitivity ;\n\nvoid M_ChangeSensitivity(int choice)\n{\nswitch(choice)\n{\ncase 0:\nif (mouseSensitivity)\nmouseSensitivity--;\nbreak;\ncase 1:\nif (mouseSensitivity < 9)\nmouseSensitivity++;\nbreak;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Sensitivity ;\nint /*<<< orphan*/  M_Sensitivity_Max ;\nint /*<<< orphan*/  M_Sensitivity_Min ;\n\nvoid M_ChangeSensitivity(int delta)\n{\nif (delta == 1)\n{\nif (M_Sensitivity < M_Sensitivity_Max)\nM_Sensitivity++;\n}\nelse if (delta == -1)\n{\nif (M_Sensitivity > M_Sensitivity_Min)\nM_Sensitivity--;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_plats.c_P_ActivateInStasis",
    "input":"\n0000000000000000 <P_ActivateInStasis>:\n0: \tmovl\t(%rip), %r10d # 0x7 <P_ActivateInStasis+0x7>\n7: \ttestl\t%r10d, %r10d\na: \tjle\t0x5a <P_ActivateInStasis+0x5a>\nc: \tmovq\t(%rip), %rcx  # 0x13 <P_ActivateInStasis+0x13>\n13: \tmovq\t(%rip), %r9   # 0x1a <P_ActivateInStasis+0x1a>\n1a: \tmovq\t(%rip), %r8   # 0x21 <P_ActivateInStasis+0x21>\n21: \txorl\t%esi, %esi\n23: \tjmp\t0x39 <P_ActivateInStasis+0x39>\n25: \tnopw\t%cs:(%rax,%rax)\n2f: \tnop\n30: \taddq\t$1, %rsi\n34: \tcmpq\t%r10, %rsi\n37: \tjae\t0x5a <P_ActivateInStasis+0x5a>\n39: \tmovq\t(%rcx,%rsi,8), %rdx\n3d: \ttestq\t%rdx, %rdx\n40: \tje\t0x30 <P_ActivateInStasis+0x30>\n42: \tcmpl\t%edi, (%rdx)\n44: \tjne\t0x30 <P_ActivateInStasis+0x30>\n46: \tcmpq\t%r9, 8(%rdx)\n4a: \tjne\t0x30 <P_ActivateInStasis+0x30>\n4c: \tmovq\t16(%rdx), %rax\n50: \tmovq\t%rax, 8(%rdx)\n54: \tmovq\t%r8, 24(%rdx)\n58: \tjmp\t0x30 <P_ActivateInStasis+0x30>\n5a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ actionf_p1 ;\nstruct TYPE_4__ {scalar_t__ acp1; } ;\nstruct TYPE_5__ {TYPE_1__ function; } ;\nstruct TYPE_6__ {int tag; scalar_t__ status; scalar_t__ oldstatus; TYPE_2__ thinker; } ;\n\n/* Variables and functions */\nint MAXPLATS ;\nscalar_t__ T_PlatRaise ;\nTYPE_3__** activeplats ;\nscalar_t__ in_stasis ;\n\nvoid P_ActivateInStasis(int tag)\n{\nint\t\ti;\n\nfor (i = 0;i < MAXPLATS;i++)\nif (activeplats[i]\n&& (activeplats[i])->tag == tag\n&& (activeplats[i])->status == in_stasis)\n{\n(activeplats[i])->status = (activeplats[i])->oldstatus;\n(activeplats[i])->thinker.function.acp1\n= (actionf_p1) T_PlatRaise;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  i; scalar_t__ iStasis; scalar_t__ iStasis2; scalar_t__ iStasis3; } ;\ntypedef  TYPE_1__ PgHdr ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PGHDRS_IN_STASIS ;\nTYPE_1__** aPgHdr ;\nscalar_t__ nPgHdr ;\nscalar_t__ nPgHdrAlloc ;\nscalar_t__ nPgHdrInStasis ;\n\nvoid P_ActivateInStasis(int iDb){\nint i;\nfor(i=0; i<nPgHdr; i++){\nPgHdr *pPg = aPgHdr[i];\nif( pPg && pPg->iStasis==iDb ){\npPg->iStasis = 0;\npPg->iStasis2 = nPgHdrInStasis;\npPg->iStasis3 = nPgHdrAlloc;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_I_ReadScreen",
    "input":"\n0000000000000000 <I_ReadScreen>:\n0: \tmovq\t(%rip), %rax  # 0x7 <I_ReadScreen+0x7>\n7: \tmovl\t(%rax), %esi\n9: \tmovl\t(%rip), %edx  # 0xf <I_ReadScreen+0xf>\nf: \timull\t(%rip), %edx  # 0x16 <I_ReadScreen+0x16>\n16: \tjmp\t0x1b <I_ReadScreen+0x1b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/ * screens ;\n\nvoid I_ReadScreen (byte* scr)\n{\nmemcpy (scr, screens[0], SCREENWIDTH*SCREENHEIGHT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  screen; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ReadScreenBuffer (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nTYPE_1__* screen ;\nint screen_height ;\n\nvoid I_ReadScreen(void)\n{\nI_ReadScreenBuffer(&screen->screen, screen->screen, screen_height*8);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_HandleSoundTimer",
    "input":"\n0000000000000000 <I_HandleSoundTimer>:\n0: \tpushq\t%rax\n1: \tcmpq\t$0, (%rip)    # 0x9 <I_HandleSoundTimer+0x9>\n9: \tje\t0x34 <I_HandleSoundTimer+0x34>\nb: \tmovl\t(%rip), %edi  # 0x11 <I_HandleSoundTimer+0x11>\n11: \tmovl\t(%rip), %esi  # 0x17 <I_HandleSoundTimer+0x17>\n17: \tmovl\t(%rip), %edx  # 0x1d <I_HandleSoundTimer+0x1d>\n1d: \timull\t(%rip), %edx  # 0x24 <I_HandleSoundTimer+0x24>\n24: \tcallq\t0x29 <I_HandleSoundTimer+0x29>\n29: \tmovq\t$0, (%rip)    # 0x34 <I_HandleSoundTimer+0x34>\n34: \tpopq\t%rax\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint BUFMUL ;\nint SAMPLECOUNT ;\nint /*<<< orphan*/  audio_fd ;\nscalar_t__ flag ;\nint /*<<< orphan*/  mixbuffer ;\nint /*<<< orphan*/  write (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n\nvoid I_HandleSoundTimer( int ignore )\n{\n// Debug.\n//fprintf( stderr, \"%c\", '+' ); fflush( stderr );\n\n// Feed sound device if necesary.\nif ( flag )\n{\n// See I_SubmitSound().\n// Write it to DSP device.\nwrite(audio_fd, mixbuffer, SAMPLECOUNT*BUFMUL);\n\n// Reset flag counter.\nflag = 0;\n}\nelse\nreturn;\n\n// UNUSED, but required.\nignore = 0;\nreturn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SetTimer (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  I_SoundOff () ;\nint /*<<< orphan*/  I_SoundTimer ;\nint /*<<< orphan*/  I_SoundTimerCallback ;\nint /*<<< orphan*/  I_SoundTimerInterval ;\nscalar_t__ I_SoundTimerPending ;\n\nvoid I_HandleSoundTimer(void)\n{\nif (I_SoundTimerPending)\n{\nI_SetTimer(I_SoundTimer, I_SoundTimerCallback,\nI_SoundTimerInterval * I_SoundTimer);\nI_SoundTimerPending = 0;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_FindMinSurroundingLight",
    "input":"\n0000000000000000 <P_FindMinSurroundingLight>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%esi, %r14d\n7: \tcmpl\t$0, (%rdi)\na: \tjle\t0x4d <P_FindMinSurroundingLight+0x4d>\nc: \tmovq\t%rdi, %rbx\nf: \txorl\t%ebp, %ebp\n11: \tjmp\t0x2c <P_FindMinSurroundingLight+0x2c>\n13: \tnopw\t%cs:(%rax,%rax)\n1d: \tnopl\t(%rax)\n20: \taddq\t$1, %rbp\n24: \tmovslq\t(%rbx), %rax\n27: \tcmpq\t%rax, %rbp\n2a: \tjge\t0x4d <P_FindMinSurroundingLight+0x4d>\n2c: \tmovq\t8(%rbx), %rax\n30: \tmovq\t(%rax,%rbp,8), %rdi\n34: \tmovq\t%rbx, %rsi\n37: \tcallq\t0x3c <P_FindMinSurroundingLight+0x3c>\n3c: \ttestq\t%rax, %rax\n3f: \tje\t0x20 <P_FindMinSurroundingLight+0x20>\n41: \tmovl\t4(%rax), %eax\n44: \tcmpl\t%r14d, %eax\n47: \tcmovlel\t%eax, %r14d\n4b: \tjmp\t0x20 <P_FindMinSurroundingLight+0x20>\n4d: \tmovl\t%r14d, %eax\n50: \tpopq\t%rbx\n51: \tpopq\t%r14\n53: \tpopq\t%rbp\n54: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int linecount; int lightlevel; int /*<<< orphan*/ ** lines; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\n\n/* Variables and functions */\nTYPE_1__* getNextSector (int /*<<< orphan*/ *,TYPE_1__*) ;\n\nint\nP_FindMinSurroundingLight\n( sector_t*\tsector,\nint\t\tmax )\n{\nint\t\ti;\nint\t\tmin;\nline_t*\tline;\nsector_t*\tcheck;\n\nmin = max;\nfor (i=0 ; i < sector->linecount ; i++)\n{\nline = sector->lines[i];\ncheck = getNextSector(line,sector);\n\nif (!check)\ncontinue;\n\nif (check->lightlevel < min)\nmin = check->lightlevel;\n}\nreturn min;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int numsectors; TYPE_2__** sectors; } ;\nstruct TYPE_9__ {TYPE_1__* floorz; } ;\nstruct TYPE_8__ {int lightlevel; } ;\ntypedef  TYPE_3__ sector_t ;\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nTYPE_3__* P_FindSectorFromLineTag (TYPE_3__*,TYPE_3__*) ;\n\nfixed_t P_FindMinSurroundingLight(sector_t *sec, fixed_t lightlevel)\n{\nint i;\n\nfor (i=0;i<sec->numsectors;i++)\n{\nsector_t *check = P_FindSectorFromLineTag(sec,sec->sectors[i]);\n\nif (check)\n{\nlightlevel = (lightlevel < check->floorz[0].lightlevel) ?\nlightlevel : check->floorz[0].lightlevel;\n}\n}\n\nreturn lightlevel;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_AddSprites",
    "input":"\n0000000000000000 <R_AddSprites>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rip), %rax  # 0x8 <R_AddSprites+0x8>\n8: \tcmpq\t%rax, (%rdi)\nb: \tjne\t0xf <R_AddSprites+0xf>\nd: \tpopq\t%rbx\ne: \tretq\nf: \tmovq\t%rax, (%rdi)\n12: \tmovl\t8(%rdi), %eax\n15: \tmovb\t(%rip), %cl   # 0x1b <R_AddSprites+0x1b>\n1b: \tsarl\t%cl, %eax\n1d: \taddl\t(%rip), %eax  # 0x23 <R_AddSprites+0x23>\n23: \tjs\t0x3f <R_AddSprites+0x3f>\n25: \tmovslq\t(%rip), %rdx  # 0x2c <R_AddSprites+0x2c>\n2c: \tmovq\t(%rip), %rcx  # 0x33 <R_AddSprites+0x33>\n33: \tcmpl\t%edx, %eax\n35: \tjge\t0x48 <R_AddSprites+0x48>\n37: \tmovl\t%eax, %eax\n39: \tleaq\t(%rcx,%rax,4), %rax\n3d: \tjmp\t0x50 <R_AddSprites+0x50>\n3f: \tmovq\t(%rip), %rax  # 0x46 <R_AddSprites+0x46>\n46: \tjmp\t0x50 <R_AddSprites+0x50>\n48: \tleaq\t(%rcx,%rdx,4), %rax\n4c: \taddq\t$-4, %rax\n50: \tmovl\t(%rax), %eax\n52: \tmovl\t%eax, (%rip)  # 0x58 <R_AddSprites+0x58>\n58: \tmovq\t16(%rdi), %rbx\n5c: \ttestq\t%rbx, %rbx\n5f: \tje\t0xd <R_AddSprites+0xd>\n61: \tnopw\t%cs:(%rax,%rax)\n6b: \tnopl\t(%rax,%rax)\n70: \tmovq\t%rbx, %rdi\n73: \tcallq\t0x78 <R_AddSprites+0x78>\n78: \tmovq\t(%rbx), %rbx\n7b: \ttestq\t%rbx, %rbx\n7e: \tjne\t0x70 <R_AddSprites+0x70>\n80: \tjmp\t0xd <R_AddSprites+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ validcount; int lightlevel; TYPE_2__* thinglist; } ;\ntypedef  TYPE_1__ sector_t ;\nstruct TYPE_6__ {struct TYPE_6__* snext; } ;\ntypedef  TYPE_2__ mobj_t ;\n\n/* Variables and functions */\nint LIGHTLEVELS ;\nint LIGHTSEGSHIFT ;\nint /*<<< orphan*/  R_ProjectSprite (TYPE_2__*) ;\nint extralight ;\nint /*<<< orphan*/ * scalelight ;\nint /*<<< orphan*/  spritelights ;\nscalar_t__ validcount ;\n\nvoid R_AddSprites (sector_t* sec)\n{\nmobj_t*\t\tthing;\nint\t\t\tlightnum;\n\n// BSP is traversed by subsector.\n// A sector might have been split into several\n//  subsectors during BSP building.\n// Thus we check whether its already added.\nif (sec->validcount == validcount)\nreturn;\n\n// Well, now it will be done.\nsec->validcount = validcount;\n\nlightnum = (sec->lightlevel >> LIGHTSEGSHIFT)+extralight;\n\nif (lightnum < 0)\nspritelights = scalelight[0];\nelse if (lightnum >= LIGHTLEVELS)\nspritelights = scalelight[LIGHTLEVELS-1];\nelse\nspritelights = scalelight[lightnum];\n\n// Handle all things in sector.\nfor (thing = sec->thinglist ; thing ; thing = thing->snext)\nR_ProjectSprite (thing);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  next; int /*<<< orphan*/  sprite; } ;\ntypedef  TYPE_1__ SPRITE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_AddSprite (TYPE_1__*) ;\nint /*<<< orphan*/  R_Sprite ;\nint /*<<< orphan*/  R_SpriteList ;\nint /*<<< orphan*/  R_SpriteListTail ;\nint /*<<< orphan*/ * R_SpriteListTailPtr ;\nint /*<<< orphan*/ * R_SpriteListTailPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNext ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtrNextPtr ;\nint /*<<< orphan*/  R_SpriteListTailPtrNextPtrNextPtrNextPtrNextPtrNextPtr"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_I_StartTic",
    "input":"\n0000000000000000 <I_StartTic>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %edi  # 0x7 <I_StartTic+0x7>\n7: \ttestl\t%edi, %edi\n9: \tjne\t0x1d <I_StartTic+0x1d>\nb: \tpopq\t%rax\nc: \tretq\nd: \tnopl\t(%rax)\n10: \txorl\t%eax, %eax\n12: \tcallq\t0x17 <I_StartTic+0x17>\n17: \tmovl\t(%rip), %edi  # 0x1d <I_StartTic+0x1d>\n1d: \tcallq\t0x22 <I_StartTic+0x22>\n22: \ttestq\t%rax, %rax\n25: \tjne\t0x10 <I_StartTic+0x10>\n27: \tcmpq\t$0, (%rip)    # 0x2f <I_StartTic+0x2f>\n2f: \tje\t0xa0 <I_StartTic+0xa0>\n31: \taddq\t$-1, (%rip)   # 0x39 <I_StartTic+0x39>\n39: \tjne\t0xa0 <I_StartTic+0xa0>\n3b: \tmovl\t(%rip), %edi  # 0x41 <I_StartTic+0x41>\n41: \tmovl\t(%rip), %esi  # 0x47 <I_StartTic+0x47>\n47: \tmovl\t(%rip), %edx  # 0x4d <I_StartTic+0x4d>\n4d: \tmovl\t(%rip), %ecx  # 0x53 <I_StartTic+0x53>\n53: \tmovl\t%ecx, %r10d\n56: \tshrl\t$31, %r10d\n5a: \taddl\t%ecx, %r10d\n5d: \tsarl\t%r10d\n60: \tmovl\t(%rip), %ecx  # 0x66 <I_StartTic+0x66>\n66: \tmovl\t%ecx, %eax\n68: \tshrl\t$31, %eax\n6b: \taddl\t%ecx, %eax\n6d: \tsarl\t%eax\n6f: \tsubq\t$8, %rsp\n73: \tmovl\t$0, %ecx\n78: \tmovl\t$0, %r8d\n7e: \tmovl\t$0, %r9d\n84: \tpushq\t%rax\n85: \tpushq\t%r10\n87: \tpushq\t$0\n89: \tcallq\t0x8e <I_StartTic+0x8e>\n8e: \taddq\t$32, %rsp\n92: \tmovq\t(%rip), %rax  # 0x99 <I_StartTic+0x99>\n99: \tmovq\t%rax, (%rip)  # 0xa0 <I_StartTic+0xa0>\na0: \tmovl\t$0, (%rip)    # 0xaa <I_StartTic+0xaa>\naa: \tpopq\t%rax\nab: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_GetEvent () ;\nint /*<<< orphan*/  None ;\nscalar_t__ POINTER_WARP_COUNTDOWN ;\nscalar_t__ XPending (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  XWarpPointer (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  X_display ;\nint X_height ;\nint /*<<< orphan*/  X_mainWindow ;\nint X_width ;\nscalar_t__ doPointerWarp ;\nscalar_t__ grabMouse ;\nint mousemoved ;\n\nvoid I_StartTic (void)\n{\n\nif (!X_display)\nreturn;\n\nwhile (XPending(X_display))\nI_GetEvent();\n\n// Warp the pointer back to the middle of the window\n//  or it will wander off - that is, the game will\n//  loose input focus within X11.\nif (grabMouse)\n{\nif (!--doPointerWarp)\n{\nXWarpPointer( X_display,\nNone,\nX_mainWindow,\n0, 0,\n0, 0,\nX_width/2, X_height/2);\n\ndoPointerWarp = POINTER_WARP_COUNTDOWN;\n}\n}\n\nmousemoved = false;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  C_Ticker () ;\nint /*<<< orphan*/  C_UpdateSounds () ;\nint /*<<< orphan*/  C_UpdateViewports () ;\nint /*<<< orphan*/  C_UpdateWalls () ;\nint /*<<< orphan*/  C_UpdateZones () ;\nint /*<<< orphan*/  C_UpdateZones2 () ;\nint /*<<< orphan*/  C_UpdateZones3 () ;\nint /*<<< orphan*/  C_UpdateZones4 () ;\nint /*<<< orphan*/  C_UpdateZones5 () ;\nint /*<<< orphan*/  C_UpdateZones6 () ;\nint /*<<< orphan*/  C_UpdateZones7 () ;\nint /*<<< orphan*/  C_UpdateZones8 () ;\nint /*<<< orphan*/  C_UpdateZones9 () ;\nint /*<<< orphan*/  C_UpdateZonesA () ;\nint /*<<< orphan*/  C_UpdateZonesB () ;\nint /*<<< orphan*/  C_UpdateZonesC () ;\nint /*<<< orphan*/  C_UpdateZonesD () ;\nint /*<<< orphan*/  C_UpdateZonesE () ;\nint /*<<< orphan*/  C_UpdateZonesF () ;\nint /*<<< orphan*/  C_UpdateZonesG () ;\nint /*<<< orphan*/  C_UpdateZonesH () ;\nint /*<<< orphan*/  C_UpdateZonesI () ;\nint /*<<< orphan*/  C_UpdateZonesJ () ;\nint /*<<< orphan*/  C_UpdateZonesK () ;\nint /*<<< orphan*/  C_UpdateZonesL () ;\nint /*<<< orphan*/  C_UpdateZonesM () ;\nint /*<<< orphan*/  C_UpdateZonesN () ;\nint /*<<< orphan*/  C_UpdateZonesO () ;\nint /*<<< orphan*/  C_UpdateZonesP () ;\nint /*<<< orphan*/  C_UpdateZonesQ () ;\nint /*<<< orphan*/  C_UpdateZonesR () ;\nint /*<<< orphan*/  C_UpdateZonesS () ;\nint /*<<< orphan*/  C_UpdateZonesT () ;\nint /*<<< orphan*/  C_UpdateZonesU () ;\nint /*<<< orphan*/  C_UpdateZonesV () ;\nint /*<<< orphan*/  C_UpdateZonesW () ;\nint /*<<< orphan*/  C_UpdateZonesX () ;\nint /*<<< orphan*/  C_UpdateZonesY () ;\nint /*<<< orphan*/  C_UpdateZonesZ () ;\nint /*<<< orphan*/  C_UpdateZonesa () ;\nint /*<<< orphan*/  C_UpdateZonesb () ;\nint /*<<< orphan*/  C_UpdateZonesc () ;\nint /*<<< orphan*/  C_UpdateZonesd () ;\nint /*<<< orphan*/  C_UpdateZonese () ;\nint /*<<< orphan*/  C_UpdateZonesf () ;\nint /*<<< orphan*/  C_UpdateZonesg () ;\nint /*<<< orphan*/  C_UpdateZonesh () ;\nint /*<<< orphan*/  C_UpdateZonesi () ;\nint /*<<< orphan*/  C_UpdateZonesj () ;\nint /*<<< orphan*/  C_UpdateZonesk () ;\nint /*<<< orphan*/  C_UpdateZonesl () ;\nint /*<<< orphan*/  C_UpdateZonesm () ;\nint /*<<< orphan*/  C_UpdateZonesn () ;\nint /*<<< orphan*/  C_UpdateZoneso () ;\nint /*<<< orphan*/  C_UpdateZonesp () ;\nint /*<<< orphan*/  C_UpdateZonesq () ;\nint /*<<< orphan*/  C_UpdateZonest () ;\nint /*<<< orphan*/  C_UpdateZonesu () ;\nint /*<<< orphan*/  C_UpdateZonesv () ;\nint /*<<< orphan*/  C_UpdateZonesw () ;\nint /*<<< orphan*/  C_UpdateZonesx () ;\nint /*<<< orphan*/  C_UpdateZonesy () ;\nint /*<<< orphan*/  C_UpdateZonesz () ;\nint /*<<< orphan*/  C_UpdateZonesza () ;\nint /*<<< orphan*/  C_UpdateZoneszb () ;\nint /*<<< orphan*/  C_UpdateZoneszc () ;\nint /*<<< orphan*/  C_UpdateZoneszd () ;\nint /*<<< orphan*/  C_UpdateZonesze () ;\nint /*<<< orphan*/  C_UpdateZoneszf () ;\nint /*<<< orphan*/  C_UpdateZoneszg () ;\nint /*<<< orphan*/  C_UpdateZoneszh () ;\nint /*<<< orphan*/  C_UpdateZoneszi () ;\nint /*<<< orphan*/  C_UpdateZoneszj () ;\nint /*<<< orphan*/  C_UpdateZoneszk () ;\nint /*<<< orphan*/  C_UpdateZoneszl () ;\nint /*<<< orphan*/  C_UpdateZoneszm () ;\nint /*<<< orphan*/  C_UpdateZoneszn () ;\nint /*<<< orphan*/  C_UpdateZoneszo () ;\nint /*<<< orphan*/  C_UpdateZoneszp () ;\nint /*<<< orphan*/  C_UpdateZoneszq () ;\nint /*<<< orphan*/  C_UpdateZoneszt () ;\nint /*<<< orphan*/  C_UpdateZoneszu () ;\nint /*<<< orphan*/  C_UpdateZoneszv () ;\nint /*<<< orphan*/  C_UpdateZoneszw () ;\nint /*<<< orphan*/  C_UpdateZoneszx () ;\nint /*<<< orphan*/  C_UpdateZoneszy () ;\nint /*<<< orphan*/  C_UpdateZoneszz () ;\nint /*<<< orphan*/  C_UpdateZoneszzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzzzzzzz () ;\nint /*<<< orphan*/  C_UpdateZoneszzzzzzzzzzzzzzzzzzzzzz () ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_I_StartFrame",
    "input":"\n0000000000000000 <I_StartFrame>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_StartFrame (void)\n{\n// er?\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_StartFrame(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_NumLumps",
    "input":"\n0000000000000000 <W_NumLumps>:\n0: \tmovl\t(%rip), %eax  # 0x6 <W_NumLumps+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint numlumps ;\n\nint W_NumLumps (void)\n{\nreturn numlumps;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint numlumps ;\n\nint W_NumLumps(void)\n{\nreturn numlumps;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_GetTime",
    "input":"\n0000000000000000 <I_GetTime>:\n0: \tsubq\t$24, %rsp\n4: \tleaq\t8(%rsp), %rdi\n9: \tleaq\t16(%rsp), %rsi\ne: \tcallq\t0x13 <I_GetTime+0x13>\n13: \tmovl\t(%rip), %eax  # 0x19 <I_GetTime+0x19>\n19: \tmovl\t8(%rsp), %ecx\n1d: \ttestl\t%eax, %eax\n1f: \tjne\t0x29 <I_GetTime+0x29>\n21: \tmovl\t%ecx, (%rip)  # 0x27 <I_GetTime+0x27>\n27: \tmovl\t%ecx, %eax\n29: \tsubl\t%eax, %ecx\n2b: \tmovl\t(%rip), %eax  # 0x31 <I_GetTime+0x31>\n31: \timull\t%eax, %ecx\n34: \timull\t12(%rsp), %eax\n39: \tcltq\n3b: \timulq\t$1125899907, %rax, %rax # imm = 0x431BDE83\n42: \tmovq\t%rax, %rdx\n45: \tshrq\t$63, %rdx\n49: \tsarq\t$50, %rax\n4d: \taddl\t%edx, %eax\n4f: \taddl\t%ecx, %eax\n51: \taddq\t$24, %rsp\n55: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct timezone {int dummy; } ;\nstruct timeval {int tv_sec; int tv_usec; } ;\n\n/* Variables and functions */\nint TICRATE ;\nint /*<<< orphan*/  gettimeofday (struct timeval*,struct timezone*) ;\n\nint  I_GetTime (void)\n{\nstruct timeval\ttp;\nstruct timezone\ttzp;\nint\t\t\tnewtics;\nstatic int\t\tbasetime=0;\n\ngettimeofday(&tp, &tzp);\nif (!basetime)\nbasetime = tp.tv_sec;\nnewtics = (tp.tv_sec-basetime)*TICRATE + tp.tv_usec*TICRATE/1000000;\nreturn newtics;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  time_t ;\ntypedef  int /*<<< orphan*/  tm ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_GetLocalTime (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  I_GetTimeZone (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  I_GetUTC (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  I_LocalTimeZone ;\nint /*<<< orphan*/  I_UTC ;\n\nint I_GetTime(void)\n{\ntime_t t;\ntm tm;\n\nI_GetLocalTime(&t, &tm);\nif (!I_GetTimeZone(I_LocalTimeZone, tm))\nI_LocalTimeZone = tm;\n\nt -= I_GetTimeZone(I_UTC, tm);\nreturn (int)(((long)t * 1125899907L) / 10000000L);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_SetupPsprites",
    "input":"\n0000000000000000 <P_SetupPsprites>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %edx  # 0xa <P_SetupPsprites+0xa>\na: \ttestl\t%edx, %edx\nc: \tjle\t0x1d <P_SetupPsprites+0x1d>\ne: \tmovq\t8(%rbx), %rdi\n12: \tshlq\t$3, %rdx\n16: \txorl\t%esi, %esi\n18: \tcallq\t0x1d <P_SetupPsprites+0x1d>\n1d: \tmovl\t(%rbx), %eax\n1f: \tmovl\t%eax, 4(%rbx)\n22: \tmovq\t%rbx, %rdi\n25: \tpopq\t%rbx\n26: \tjmp\t0x2b <P_SetupPsprites+0x2b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  readyweapon; int /*<<< orphan*/  pendingweapon; TYPE_1__* psprites; } ;\ntypedef  TYPE_2__ player_t ;\nstruct TYPE_5__ {int /*<<< orphan*/ * state; } ;\n\n/* Variables and functions */\nint NUMPSPRITES ;\nint /*<<< orphan*/  P_BringUpWeapon (TYPE_2__*) ;\n\nvoid P_SetupPsprites (player_t* player)\n{\nint\ti;\n\n// remove all psprites\nfor (i=0 ; i<NUMPSPRITES ; i++)\nplayer->psprites[i].state = NULL;\n\n// spawn the gun\nplayer->pendingweapon = player->readyweapon;\nP_BringUpWeapon (player);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int numpsprites; int /*<<< orphan*/  psprites; int /*<<< orphan*/  psprites_base; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint MAXPLAYERSPRITES ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  P_SetupPsprite (TYPE_1__*) ;\n\nvoid P_SetupPsprites(player_t *player)\n{\nint i;\n\nif (MAXPLAYERSPRITES > 0)\n{\nmemset(player->psprites_base, 0, MAXPLAYERSPRITES * sizeof(pspdef_t));\n}\n\nplayer->numpsprites = player->numpsprites;\nP_SetupPsprite(player);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_QuickLoad",
    "input":"\n0000000000000000 <M_QuickLoad>:\n0: \tpushq\t%rax\n1: \tcmpq\t$0, (%rip)    # 0x9 <M_QuickLoad+0x9>\n9: \tje\t0x1b <M_QuickLoad+0x1b>\nb: \tmovl\t(%rip), %edi  # 0x11 <M_QuickLoad+0x11>\n11: \txorl\t%esi, %esi\n13: \txorl\t%edx, %edx\n15: \tpopq\t%rax\n16: \tjmp\t0x1b <M_QuickLoad+0x1b>\n1b: \tmovq\t(%rip), %rax  # 0x22 <M_QuickLoad+0x22>\n22: \tmovl\t(%rip), %edi  # 0x28 <M_QuickLoad+0x28>\n28: \tmovq\t(%rip), %rsi  # 0x2f <M_QuickLoad+0x2f>\n2f: \tmovq\t(%rip), %rcx  # 0x36 <M_QuickLoad+0x36>\n36: \tmovl\t(%rcx,%rax,4), %edx\n39: \tcallq\t0x3e <M_QuickLoad+0x3e>\n3e: \tmovl\t(%rip), %edi  # 0x44 <M_QuickLoad+0x44>\n44: \tmovq\t(%rip), %rsi  # 0x4b <M_QuickLoad+0x4b>\n4b: \tmovl\t$1, %edx\n50: \tpopq\t%rax\n51: \tjmp\t0x56 <M_QuickLoad+0x56>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/ * M_QuickLoadResponse ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  QLOADNET ;\nchar* QLPROMPT ;\nint /*<<< orphan*/  QSAVESPOT ;\nscalar_t__ netgame ;\nsize_t quickSaveSlot ;\nint /*<<< orphan*/ * savegamestrings ;\nint /*<<< orphan*/  sprintf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  tempstring ;\n\nvoid M_QuickLoad(void)\n{\nif (netgame)\n{\nM_StartMessage(QLOADNET,NULL,false);\nreturn;\n}\n\nif (quickSaveSlot < 0)\n{\nM_StartMessage(QSAVESPOT,NULL,false);\nreturn;\n}\nsprintf(tempstring,QLPROMPT,savegamestrings[quickSaveSlot]);\nM_StartMessage(tempstring,M_QuickLoadResponse,true);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Load (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  M_LoadBank (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  M_LoadBank_Bank ;\nint /*<<< orphan*/  M_Load_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank ;\nint /*<<< orphan*/  M_Load_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_Bank_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_P_TryWalk",
    "input":"\n0000000000000000 <P_TryWalk>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <P_TryWalk+0x9>\n9: \ttestl\t%eax, %eax\nb: \tje\t0x20 <P_TryWalk+0x20>\nd: \txorl\t%eax, %eax\nf: \tcallq\t0x14 <P_TryWalk+0x14>\n14: \tandl\t$15, %eax\n17: \tmovl\t%eax, (%rbx)\n19: \tmovl\t$1, %eax\n1e: \tpopq\t%rbx\n1f: \tretq\n20: \txorl\t%eax, %eax\n22: \tpopq\t%rbx\n23: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int movecount; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_Move (TYPE_1__*) ;\nint P_Random () ;\n\nboolean P_TryWalk (mobj_t* actor)\n{\nif (!P_Move (actor))\n{\nreturn false;\n}\n\nactor->movecount = P_Random()&15;\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ Player ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckWalk (TYPE_1__*) ;\nint /*<<< orphan*/  P_Move (TYPE_1__*) ;\n\n__attribute__((used)) static int P_TryWalk(Player *player)\n{\nif (!P_CheckWalk(player))\n{\nreturn 0;\n}\n\nplayer->x &= 0xF;\nP_Move(player);\nreturn 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_drawCrosshair",
    "input":"\n0000000000000000 <AM_drawCrosshair>:\n0: \tmovq\t(%rip), %rax  # 0x7 <AM_drawCrosshair+0x7>\n7: \tmovl\t(%rip), %ecx  # 0xd <AM_drawCrosshair+0xd>\nd: \taddl\t$1, %ecx\n10: \timull\t(%rip), %ecx  # 0x17 <AM_drawCrosshair+0x17>\n17: \tmovl\t%ecx, %edx\n19: \tshrl\t$31, %edx\n1c: \taddl\t%ecx, %edx\n1e: \tsarl\t%edx\n20: \tmovslq\t%edx, %rcx\n23: \tmovl\t%edi, (%rax,%rcx,4)\n26: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint f_h ;\nint f_w ;\nint* fb ;\n\nvoid AM_drawCrosshair(int color)\n{\nfb[(f_w*(f_h+1))/2] = color; // single point for now\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint AM_CROSSHAIR_HEIGHT ;\nint AM_CROSSHAIR_WIDTH ;\nint AM_CROSSHAIR_X ;\nint AM_CROSSHAIR_Y ;\nint /*<<< orphan*/ * AM_buffer ;\n\nvoid AM_drawCrosshair(UBYTE color)\n{\nAM_buffer[AM_CROSSHAIR_X + (AM_CROSSHAIR_Y * AM_CROSSHAIR_WIDTH)] = color;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_GetHeapSize",
    "input":"\n0000000000000000 <I_GetHeapSize>:\n0: \tmovl\t(%rip), %eax  # 0x6 <I_GetHeapSize+0x6>\n6: \tshll\t$20, %eax\n9: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint mb_used ;\n\nint  I_GetHeapSize (void)\n{\nreturn mb_used*1024*1024;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint _heapsize ;\n\nint I_GetHeapSize(void)\n{\nreturn _heapsize << 20;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_P_SpawnGlowingLight",
    "input":"\n0000000000000000 <P_SpawnGlowingLight>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t(%rip), %esi  # 0xd <P_SpawnGlowingLight+0xd>\nd: \tmovl\t$32, %edi\n12: \txorl\t%edx, %edx\n14: \tcallq\t0x19 <P_SpawnGlowingLight+0x19>\n19: \tmovq\t%rax, %rbx\n1c: \tleaq\t8(%rax), %rdi\n20: \tcallq\t0x25 <P_SpawnGlowingLight+0x25>\n25: \tmovq\t%r14, 24(%rbx)\n29: \tmovl\t8(%r14), %esi\n2d: \tmovq\t%r14, %rdi\n30: \tcallq\t0x35 <P_SpawnGlowingLight+0x35>\n35: \tmovl\t%eax, 20(%rbx)\n38: \tmovl\t8(%r14), %eax\n3c: \tmovl\t%eax, 16(%rbx)\n3f: \tmovq\t(%rip), %rax  # 0x46 <P_SpawnGlowingLight+0x46>\n46: \tmovq\t%rax, 8(%rbx)\n4a: \tmovl\t$4294967295, (%rbx)# imm = 0xFFFFFFFF\n50: \tmovq\t$0, (%r14)\n57: \taddq\t$8, %rsp\n5b: \tpopq\t%rbx\n5c: \tpopq\t%r14\n5e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_7__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {scalar_t__ special; int /*<<< orphan*/  lightlevel; } ;\ntypedef  TYPE_2__ sector_t ;\nstruct TYPE_8__ {scalar_t__ acp1; } ;\nstruct TYPE_11__ {TYPE_1__ function; } ;\nstruct TYPE_10__ {int direction; TYPE_7__ thinker; int /*<<< orphan*/  maxlight; int /*<<< orphan*/  minlight; TYPE_2__* sector; } ;\ntypedef  TYPE_3__ glow_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_LEVSPEC ;\nint /*<<< orphan*/  P_AddThinker (TYPE_7__*) ;\nint /*<<< orphan*/  P_FindMinSurroundingLight (TYPE_2__*,int /*<<< orphan*/ ) ;\nscalar_t__ T_Glow ;\nTYPE_3__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid P_SpawnGlowingLight(sector_t*\tsector)\n{\nglow_t*\tg;\n\ng = Z_Malloc( sizeof(*g), PU_LEVSPEC, 0);\n\nP_AddThinker(&g->thinker);\n\ng->sector = sector;\ng->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel);\ng->maxlight = sector->lightlevel;\ng->thinker.function.acp1 = (actionf_p1) T_Glow;\ng->direction = -1;\n\nsector->special = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; int /*<<< orphan*/  z; int /*<<< orphan*/  radius; int /*<<< orphan*/  radius2; int /*<<< orphan*/  radius3; int /*<<< orphan*/  radius4; int /*<<< orphan*/  radius5; int /*<<< orphan*/  radius6; int /*<<< orphan*/  radius7; int /*<<< orphan*/  radius8; int /*<<< orphan*/  radius9; int /*<<< orphan*/  radius10; int /*<<< orphan*/  radius11; int /*<<< orphan*/  radius12; int /*<<< orphan*/  radius13; int /*<<< orphan*/  radius14; int /*<<< orphan*/  radius15; int /*<<< orphan*/  radius16; int /*<<< orphan*/  radius17; int /*<<< orphan*/  radius18; int /*<<< orphan*/  radius19; int /*<<< orphan*/  radius20; int /*<<< orphan*/  radius21; int /*<<< orphan*/  radius22; int /*<<< orphan*/  radius23; int /*<<< orphan*/  radius24; int /*<<< orphan*/  radius25; int /*<<< orphan*/  radius26; int /*<<< orphan*/  radius27; int /*<<< orphan*/  radius28; int /*<<< orphan*/  radius29; int /*<<< orphan*/  radius30; int /*<<< orphan*/  radius31; int /*<<< orphan*/  radius32; int /*<<< orphan*/  radius33; int /*<<< orphan*/  radius34; int /*<<< orphan*/  radius35; int /*<<< orphan*/  radius36; int /*<<< orphan*/  radius37; int /*<<< orphan*/  radius38; int /*<<< orphan*/  radius39; int /*<<< orphan*/  radius40; int /*<<< orphan*/  radius41; int /*<<< orphan*/  radius42; int /*<<< orphan*/  radius43; int /*<<< orphan*/  radius44; int /*<<< orphan*/  radius45; int /*<<< orphan*/  radius46; int /*<<< orphan*/  radius47; int /*<<< orphan*/  radius48; int /*<<< orphan*/  radius49; int /*<<< orphan*/  radius50; int /*<<< orphan*/  radius51; int /*<<< orphan*/  radius52; int /*<<< orphan*/  radius53; int /*<<< orphan*/  radius54; int /*<<< orphan*/  radius55; int /*<<< orphan*/  radius56; int /*<<< orphan*/  radius57; int /*<<< orphan*/  radius58; int /*<<< orphan*/  radius59; int /*<<< orphan*/  radius60; int /*<<< orphan*/  radius61; int /*<<< orphan*/  radius62; int /*<<< orphan*/  radius63; int /*<<< orphan*/  radius64; int /*<<< orphan*/  radius65; int /*<<< orphan*/  radius66; int /*<<< orphan*/  radius67; int /*<<< orphan*/  radius68; int /*<<< orphan*/  radius69; int /*<<< orphan*/  radius70; int /*<<< orphan*/  radius71; int /*<<< orphan*/  radius72; int /*<<< orphan*/  radius73; int /*<<< orphan*/  radius74; int /*<<< orphan*/  radius75; int /*<<< orphan*/  radius76; int /*<<< orphan*/  radius77; int /*<<< orphan*/  radius78; int /*<<< orphan*/  radius79; int /*<<< orphan*/  radius80; int /*<<< orphan*/  radius81; int /*<<< orphan*/  radius82; int /*<<< orphan*/  radius83; int /*<<< orphan*/  radius84; int /*<<< orphan*/  radius85; int /*<<< orphan*/  radius86; int /*<<< orphan*/  radius87; int /*<<< orphan*/  radius88; int /*<<< orphan*/  radius89; int /*<<< orphan*/  radius90; int /*<<< orphan*/  radius91; int /*<<< orphan*/  radius92; int /*<<< orphan*/  radius93; int /*<<< orphan*/  radius94; int /*<<< orphan*/  radius95; int /*<<< orphan*/  radius96; int /*<<< orphan*/  radius97; int /*<<< orphan*/  radius98; int /*<<< orphan*/  radius99; int /*<<< orphan*/  radius100; int /*<<< orphan*/  radius101; int /*<<< orphan*/  radius102; int /*<<< orphan*/  radius103; int /*<<< orphan*/  radius104; int /*<<< orphan*/  radius105; int /*<<< orphan*/  radius106; int /*<<< orphan*/  radius107; int /*<<< orphan*/  radius108; int /*<<< orphan*/  radius109; int /*<<< orphan*/  radius110; int /*<<< orphan*/  radius111; int /*<<< orphan*/  radius112; int /*<<< orphan*/  radius113; int /*<<< orphan*/  radius114; int /*<<< orphan*/  radius115; int /*<<< orphan*/  radius116; int /*<<< orphan*/  radius117; int /*<<< orphan*/  radius118; int /*<<< orphan*/  radius119; int /*<<< orphan*/  radius120; int /*<<< orphan*/  radius121; int /*<<< orphan*/  radius122; int /*<<< orphan*/  radius123; int /*<<< orphan*/  radius124; int /*<<< orphan*/  radius125; int /*<<< orphan*/  radius126; int /*<<< orphan*/  radius127; int /*<<< orphan*/  radius128; int /*<<< orphan*/  radius129; int /*<<< orphan*/  radius130; int /*<<< orphan*/  radius131; int /*<<< orphan*/  radius132; int /*<<< orphan*/  radius133; int /*<<< orphan*/  radius134; int /*<<< orphan*/  radius135; int /*<<< orphan*/  radius136; int /*<<< orphan*/  radius137; int /*<<< orphan*/  radius138; int /*<<< orphan*/  radius139; int /*<<< orphan*/  radius140; int /*<<< orphan*/  radius141; int /*<<< orphan*/  radius142; int /*<<< orphan*/  radius143; int /*<<< orphan*/  radius144; int /*<<< orphan*/  radius145; int /*<<< orphan*/  radius146; int /*<<< orphan*/  radius147; int /*<<< orphan*/  radius148; int /*<<< orphan*/  radius149; int /*<<< orphan*/  radius150; int /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_PointOnSegSide",
    "input":"\n0000000000000000 <R_PointOnSegSide>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %rsi\nb: \tmovq\t(%rdx), %rdi\ne: \tmovq\t8(%rdx), %rax\n12: \tmovq\t(%rax), %rcx\n15: \tmovq\t8(%rax), %rax\n19: \tmovq\t(%rdi), %rbx\n1c: \tmovq\t8(%rdi), %rdi\n20: \tsubq\t%rax, %rdi\n23: \tsubq\t%rcx, %rbx\n26: \tje\t0x73 <R_PointOnSegSide+0x73>\n28: \ttestq\t%rdi, %rdi\n2b: \tje\t0x80 <R_PointOnSegSide+0x80>\n2d: \tsubq\t%rcx, %rsi\n30: \tsubq\t%rax, %r14\n33: \tmovq\t%rdi, %rax\n36: \txorq\t%rsi, %rax\n39: \tmovl\t%eax, %ecx\n3b: \txorl\t%r14d, %ecx\n3e: \tmovl\t%ebx, %edx\n40: \txorl\t%ecx, %edx\n42: \tjs\t0x9b <R_PointOnSegSide+0x9b>\n44: \tmovb\t(%rip), %cl   # 0x4a <R_PointOnSegSide+0x4a>\n4a: \tsarq\t%cl, %rdi\n4d: \tcallq\t0x52 <R_PointOnSegSide+0x52>\n52: \tmovq\t%rax, %r15\n55: \tmovb\t(%rip), %cl   # 0x5b <R_PointOnSegSide+0x5b>\n5b: \tsarq\t%cl, %rbx\n5e: \tmovq\t%r14, %rdi\n61: \tmovq\t%rbx, %rsi\n64: \tcallq\t0x69 <R_PointOnSegSide+0x69>\n69: \txorl\t%ebx, %ebx\n6b: \tcmpq\t%r15, %rax\n6e: \tsetge\t%bl\n71: \tjmp\t0xa6 <R_PointOnSegSide+0xa6>\n73: \tcmpq\t%rsi, %rcx\n76: \tjge\t0x91 <R_PointOnSegSide+0x91>\n78: \tshrq\t$63, %rdi\n7c: \tmovl\t%edi, %ebx\n7e: \tjmp\t0xa6 <R_PointOnSegSide+0xa6>\n80: \tcmpq\t%r14, %rax\n83: \tjge\t0xa2 <R_PointOnSegSide+0xa2>\n85: \txorl\t%eax, %eax\n87: \ttestq\t%rbx, %rbx\n8a: \tsetg\t%al\n8d: \tmovl\t%eax, %ebx\n8f: \tjmp\t0xa6 <R_PointOnSegSide+0xa6>\n91: \txorl\t%ebx, %ebx\n93: \ttestq\t%rdi, %rdi\n96: \tsetg\t%bl\n99: \tjmp\t0xa6 <R_PointOnSegSide+0xa6>\n9b: \tshrl\t$31, %eax\n9e: \tmovl\t%eax, %ebx\na0: \tjmp\t0xa6 <R_PointOnSegSide+0xa6>\na2: \tshrq\t$63, %rbx\na6: \tmovl\t%ebx, %eax\na8: \tpopq\t%rbx\na9: \tpopq\t%r14\nab: \tpopq\t%r15\nad: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {TYPE_2__* v2; TYPE_1__* v1; } ;\ntypedef  TYPE_3__ seg_t ;\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_6__ {scalar_t__ x; scalar_t__ y; } ;\nstruct TYPE_5__ {scalar_t__ x; scalar_t__ y; } ;\n\n/* Variables and functions */\nscalar_t__ FRACBITS ;\nscalar_t__ FixedMul (scalar_t__,scalar_t__) ;\n\nint\nR_PointOnSegSide\n( fixed_t\tx,\nfixed_t\ty,\nseg_t*\tline )\n{\nfixed_t\tlx;\nfixed_t\tly;\nfixed_t\tldx;\nfixed_t\tldy;\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\n\nlx = line->v1->x;\nly = line->v1->y;\n\nldx = line->v2->x - lx;\nldy = line->v2->y - ly;\n\nif (!ldx)\n{\nif (x <= lx)\nreturn ldy > 0;\n\nreturn ldy < 0;\n}\nif (!ldy)\n{\nif (y <= ly)\nreturn ldx < 0;\n\nreturn ldx > 0;\n}\n\ndx = (x - lx);\ndy = (y - ly);\n\n// Try to quickly decide by looking at sign bits.\nif ( (ldy ^ ldx ^ dx ^ dy)&0x80000000 )\n{\nif  ( (ldy ^ dx) & 0x80000000 )\n{\n// (left is negative)\nreturn 1;\n}\nreturn 0;\n}\n\nleft = FixedMul ( ldy>>FRACBITS , dx );\nright = FixedMul ( dy , ldx>>FRACBITS );\n\nif (right < left)\n{\n// front side\nreturn 0;\n}\n// back side\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ FT_Int64 ;\nstruct TYPE_4__ {scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_1__ FT_Vector ;\ntypedef  scalar_t__ FT_Pos ;\ntypedef  int FT_Bool ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FT_ABS (scalar_t__) ;\nscalar_t__ FT_MulDiv (scalar_t__,scalar_t__,scalar_t__) ;\n\n__attribute__((used)) static FT_Bool\nR_PointOnSegSide( FT_Pos  x,\nFT_Pos  y,\nFT_Vector*  seg )\n{\nFT_Int64  dx, dy;\nFT_Int64  cross;\nFT_Pos    len;\n\n\ndx = seg->x - x;\ndy = seg->y - y;\n\nif ( dx == 0 && dy == 0 )\nreturn 0;\n\nif ( dy == 0 )\nreturn ( dx >= 0 ) ? 1 : 0;\n\nif ( dx == 0 )\nreturn ( dy >= 0 ) ? 1 : 0;\n\nlen = FT_MulDiv( dx, dy, FT_ABS( dy ) );\ncross = FT_MulDiv( dx, dy, FT_ABS( dx ) );\n\nreturn ( cross >= len ) ? 1 : 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_misc.c_M_SaveDefaults",
    "input":"\n0000000000000000 <M_SaveDefaults>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t(%rip), %edi  # 0xd <M_SaveDefaults+0xd>\nd: \tmovl\t$0, %esi\n12: \tcallq\t0x17 <M_SaveDefaults+0x17>\n17: \ttestq\t%rax, %rax\n1a: \tje\t0xb3 <M_SaveDefaults+0xb3>\n20: \tmovq\t%rax, %r14\n23: \tcmpl\t$0, (%rip)    # 0x2a <M_SaveDefaults+0x2a>\n2a: \tjle\t0xa1 <M_SaveDefaults+0xa1>\n2c: \tmovl\t$16, %ebx\n31: \tmovl\t$4094, %r15d  # imm = 0xFFE\n37: \txorl\t%ebp, %ebp\n39: \tjmp\t0x6f <M_SaveDefaults+0x6f>\n3b: \tnopl\t(%rax,%rax)\n40: \tmovq\t-8(%rax,%rbx), %rcx\n45: \tmovq\t(%rax,%rbx), %rdx\n49: \tmovq\t(%rcx), %rcx\n4c: \tmovl\t$0, %esi\n51: \tmovq\t%r14, %rdi\n54: \txorl\t%eax, %eax\n56: \tcallq\t0x5b <M_SaveDefaults+0x5b>\n5b: \taddq\t$1, %rbp\n5f: \tmovslq\t(%rip), %rax  # 0x66 <M_SaveDefaults+0x66>\n66: \taddq\t$24, %rbx\n6a: \tcmpq\t%rax, %rbp\n6d: \tjge\t0xa1 <M_SaveDefaults+0xa1>\n6f: \tmovq\t(%rip), %rax  # 0x76 <M_SaveDefaults+0x76>\n76: \tmovl\t-16(%rax,%rbx), %ecx\n7a: \taddl\t%r15d, %ecx\n7d: \tcmpl\t$8188, %ecx   # imm = 0x1FFC\n83: \tja\t0x40 <M_SaveDefaults+0x40>\n85: \tmovq\t-8(%rax,%rbx), %rcx\n8a: \tmovq\t(%rax,%rbx), %rdx\n8e: \tmovl\t(%rcx), %ecx\n90: \tmovl\t$0, %esi\n95: \tmovq\t%r14, %rdi\n98: \txorl\t%eax, %eax\n9a: \tcallq\t0x9f <M_SaveDefaults+0x9f>\n9f: \tjmp\t0x5b <M_SaveDefaults+0x5b>\na1: \tmovq\t%r14, %rdi\na4: \taddq\t$8, %rsp\na8: \tpopq\t%rbx\na9: \tpopq\t%r14\nab: \tpopq\t%r15\nad: \tpopq\t%rbp\nae: \tjmp\t0xb3 <M_SaveDefaults+0xb3>\nb3: \taddq\t$8, %rsp\nb7: \tpopq\t%rbx\nb8: \tpopq\t%r14\nba: \tpopq\t%r15\nbc: \tpopq\t%rbp\nbd: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int defaultvalue; int* location; char* name; } ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  defaultfile ;\nTYPE_1__* defaults ;\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*,char*,...) ;\nint numdefaults ;\n\nvoid M_SaveDefaults (void)\n{\nint\t\ti;\nint\t\tv;\nFILE*\tf;\n\nf = fopen (defaultfile, \"w\");\nif (!f)\nreturn; // can't write the file, but don't complain\n\nfor (i=0 ; i<numdefaults ; i++)\n{\nif (defaults[i].defaultvalue > -0xfff\n&& defaults[i].defaultvalue < 0xfff)\n{\nv = *defaults[i].location;\nfprintf (f,\"%s\\t\\t%i\\n\",defaults[i].name,v);\n} else {\nfprintf (f,\"%s\\t\\t\\\"%s\\\"\\n\",defaults[i].name,\n* (char **) (defaults[i].location));\n}\n}\n\nfclose (f);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * name; int /*<<< orphan*/ * def; } ;\ntypedef  TYPE_1__ M_Option ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*,...) ;\nint /*<<< orphan*/  fputs (char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strlen (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  strncpy (char*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  strncat (char*,char*,int) ;\nint /*<<< orphan*/ * options ;\nint /*<<< orphan*/  options_count ;\n\nvoid M_SaveDefaults(FILE *fp)\n{\nint i;\nchar buf[4096];\n\nif (!fp)\nfp = stderr;\n\nfor (i = 0; i < options_count; i++)\n{\nM_Option *opt = &options[i];\n\nstrncpy(buf, opt->name, sizeof(buf));\nstrncat(buf, \"=\", sizeof(buf));\nstrncat(buf, opt->def, sizeof(buf));\nfputs(buf, fp);\nfputs(\"\\n\", fp);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_InitMusic",
    "input":"\n0000000000000000 <I_InitMusic>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_InitMusic(void)\t\t{ }",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_InitMusic(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ReadThis",
    "input":"\n0000000000000000 <M_ReadThis>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <M_ReadThis+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ReadDef1 ;\n\nvoid M_ReadThis(int choice)\n{\nchoice = 0;\nM_SetupNextMenu(&ReadDef1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Fatal (char*) ;\n\n__attribute__((used)) static var M_ReadThis(void)\n{\nM_Fatal(\"M_ReadThis() should not be called\");\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_MusicVol",
    "input":"\n0000000000000000 <M_MusicVol>:\n0: \ttestl\t%edi, %edi\n2: \tje\t0x19 <M_MusicVol+0x19>\n4: \tcmpl\t$1, %edi\n7: \tjne\t0x31 <M_MusicVol+0x31>\n9: \tmovl\t(%rip), %edi  # 0xf <M_MusicVol+0xf>\nf: \tcmpl\t$14, %edi\n12: \tjg\t0x2c <M_MusicVol+0x2c>\n14: \taddl\t$1, %edi\n17: \tjmp\t0x26 <M_MusicVol+0x26>\n19: \tmovl\t(%rip), %edi  # 0x1f <M_MusicVol+0x1f>\n1f: \ttestl\t%edi, %edi\n21: \tje\t0x3c <M_MusicVol+0x3c>\n23: \taddl\t$-1, %edi\n26: \tmovl\t%edi, (%rip)  # 0x2c <M_MusicVol+0x2c>\n2c: \tjmp\t0x31 <M_MusicVol+0x31>\n31: \tmovl\t(%rip), %edi  # 0x37 <M_MusicVol+0x37>\n37: \tjmp\t0x3c <M_MusicVol+0x3c>\n3c: \txorl\t%edi, %edi\n3e: \tjmp\t0x43 <M_MusicVol+0x43>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  S_SetMusicVolume (int) ;\nint snd_MusicVolume ;\n\nvoid M_MusicVol(int choice)\n{\nswitch(choice)\n{\ncase 0:\nif (snd_MusicVolume)\nsnd_MusicVolume--;\nbreak;\ncase 1:\nif (snd_MusicVolume < 15)\nsnd_MusicVolume++;\nbreak;\n}\n\nS_SetMusicVolume(snd_MusicVolume /* *8 */);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_MusicVol_Set (int) ;\nint /*<<< orphan*/  M_MusicVol_Stop () ;\nint /*<<< orphan*/  M_MusicVol_Stop_Set (int) ;\nint music_vol ;\n\nvoid M_MusicVol(int vol)\n{\nif (vol)\n{\nif (vol != 1)\n{\nif (vol < 15)\n{\nvol++;\n}\nmusic_vol = vol;\n}\nelse\n{\nM_MusicVol_Stop();\n}\n}\nelse\n{\nM_MusicVol_Stop_Set(0);\n}\nM_MusicVol_Set(music_vol);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_ReadDemoTiccmd",
    "input":"\n0000000000000000 <G_ReadDemoTiccmd>:\n0: \tmovq\t(%rip), %rax  # 0x7 <G_ReadDemoTiccmd+0x7>\n7: \tmovq\t(%rax), %rcx\na: \tcmpq\t(%rip), %rcx  # 0x11 <G_ReadDemoTiccmd+0x11>\n11: \tjne\t0x1a <G_ReadDemoTiccmd+0x1a>\n13: \txorl\t%eax, %eax\n15: \tjmp\t0x1a <G_ReadDemoTiccmd+0x1a>\n1a: \tmovb\t%cl, (%rdi)\n1c: \tmovb\t8(%rax), %cl\n1f: \tmovb\t%cl, 1(%rdi)\n22: \tmovb\t$0, 2(%rdi)\n26: \tleaq\t32(%rax), %rcx\n2a: \tmovq\t%rcx, (%rip)  # 0x31 <G_ReadDemoTiccmd+0x31>\n31: \tmovb\t24(%rax), %al\n34: \tmovb\t%al, 3(%rdi)\n37: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {char forwardmove; char sidemove; unsigned char angleturn; unsigned char buttons; } ;\ntypedef  TYPE_1__ ticcmd_t ;\n\n/* Variables and functions */\nscalar_t__ DEMOMARKER ;\nint /*<<< orphan*/  G_CheckDemoStatus () ;\nscalar_t__* demo_p ;\n\nvoid G_ReadDemoTiccmd (ticcmd_t* cmd)\n{\nif (*demo_p == DEMOMARKER)\n{\n// end of demo data stream\nG_CheckDemoStatus ();\nreturn;\n}\ncmd->forwardmove = ((signed char)*demo_p++);\ncmd->sidemove = ((signed char)*demo_p++);\ncmd->angleturn = ((unsigned char)*demo_p++)<<8;\ncmd->buttons = (unsigned char)*demo_p++;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct ticcmd {int dummy; } ;\nstruct TYPE_2__ {scalar_t__ demo_p; int /*<<< orphan*/  demo_buffer; } ;\n\n/* Variables and functions */\nscalar_t__ DEMO_EOF ;\nTYPE_1__* demo_buffer ;\n\nvoid G_ReadDemoTiccmd(struct ticcmd *cmd)\n{\nif (demo_buffer->demo_p == DEMO_EOF)\n{\ncmd->ticcmd_t = 0;\nreturn;\n}\n\ncmd->ticcmd_t = demo_buffer->demo_buffer[demo_buffer->demo_p++];\ncmd->ticcmd_x = demo_buffer->demo_buffer[demo_buffer->demo_p++];\ncmd->ticcmd_y = demo_buffer->demo_buffer[demo_buffer->demo_p++];\ncmd->ticcmd_angle = demo_buffer->demo_buffer[demo_buffer->demo_p++];\ncmd->ticcmd_buttons = demo_buffer->demo_buffer[demo_buffer->demo_p++];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SargAttack",
    "input":"\n0000000000000000 <A_SargAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x54 <A_SargAttack+0x54>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_SargAttack+0xe>\ne: \tmovq\t%rbx, %rdi\n11: \tcallq\t0x16 <A_SargAttack+0x16>\n16: \ttestq\t%rax, %rax\n19: \tje\t0x54 <A_SargAttack+0x54>\n1b: \txorl\t%eax, %eax\n1d: \tcallq\t0x22 <A_SargAttack+0x22>\n22: \tcltq\n24: \timulq\t$1717986919, %rax, %rcx # imm = 0x66666667\n2b: \tmovq\t%rcx, %rdx\n2e: \tshrq\t$63, %rdx\n32: \tshrq\t$34, %rcx\n36: \taddl\t%edx, %ecx\n38: \taddl\t%ecx, %ecx\n3a: \tleal\t(%rcx,%rcx,4), %ecx\n3d: \tsubl\t%ecx, %eax\n3f: \tleal\t4(,%rax,4), %ecx\n46: \tmovl\t(%rbx), %edi\n48: \tmovq\t%rbx, %rsi\n4b: \tmovq\t%rbx, %rdx\n4e: \tpopq\t%rbx\n4f: \tjmp\t0x54 <A_SargAttack+0x54>\n54: \tpopq\t%rbx\n55: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nscalar_t__ P_CheckMeleeRange (TYPE_1__*) ;\nint /*<<< orphan*/  P_DamageMobj (int /*<<< orphan*/ ,TYPE_1__*,TYPE_1__*,int) ;\nint P_Random () ;\n\nvoid A_SargAttack (mobj_t* actor)\n{\nint\t\tdamage;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nif (P_CheckMeleeRange (actor))\n{\ndamage = ((P_Random()%10)+1)*4;\nP_DamageMobj (actor->target, actor, actor, damage);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  en_attack; } ;\ntypedef  TYPE_1__ Enemy ;\n\n/* Variables and functions */\nscalar_t__ A_CheckEnemy (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSound (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSoundEnemy (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSoundPlayer (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSoundSector (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSector (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSectorEnemy (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSectorPlayer (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSectorSector (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSectorSprite (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSprite (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSpriteEnemy (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSpritePlayer (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSpriteSector (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSpriteSprite (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckSpriteWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallEnemy (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallPlayer (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallSector (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallSprite (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<< orphan*/  A_CheckWallWall (TYPE_1__*) ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_Start",
    "input":"\n0000000000000000 <ST_Start>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <ST_Start+0x8>\n8: \tjne\t0x11 <ST_Start+0x11>\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <ST_Start+0x11>\n11: \txorl\t%eax, %eax\n13: \tcallq\t0x18 <ST_Start+0x18>\n18: \txorl\t%eax, %eax\n1a: \tcallq\t0x1f <ST_Start+0x1f>\n1f: \tmovl\t$0, (%rip)    # 0x29 <ST_Start+0x29>\n29: \tpopq\t%rax\n2a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_Stop () ;\nint /*<<< orphan*/  ST_createWidgets () ;\nint /*<<< orphan*/  ST_initData () ;\nint st_stopped ;\n\nvoid ST_Start (void)\n{\n\nif (!st_stopped)\nST_Stop();\n\nST_initData();\nST_createWidgets();\nst_stopped = false;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_Stop () ;\nint /*<<< orphan*/  ST_Start_Init () ;\nint /*<<< orphan*/  ST_Start_Reset () ;\nint /*<<< orphan*/  ST_Start_Start () ;\nint /*<<< orphan*/  st_started ;\n\nvoid ST_Start(void)\n{\nif (!st_started)\n{\nST_Start_Init();\nST_Start_Reset();\nST_Start_Start();\nst_started = 0;\n}\nST_Stop();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_I_SetPalette",
    "input":"\n0000000000000000 <I_SetPalette>:\n0: \tmovq\t%rdi, %rsi\n3: \tmovl\t(%rip), %edi  # 0x9 <I_SetPalette+0x9>\n9: \tjmp\t0xe <I_SetPalette+0xe>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  UploadNewPalette (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  X_cmap ;\n\nvoid I_SetPalette (byte* palette)\n{\nUploadNewPalette(X_cmap, palette);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SetPalette_ ;\nint /*<<< orphan*/  stub1 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\nVOID I_SetPalette(UBYTE *palette)\n{\n(*I_SetPalette_)(palette);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_CloseShotgun2",
    "input":"\n0000000000000000 <A_CloseShotgun2>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovl\t(%rdi), %edi\nc: \tmovl\t(%rip), %esi  # 0x12 <A_CloseShotgun2+0x12>\n12: \tcallq\t0x17 <A_CloseShotgun2+0x17>\n17: \tmovq\t%rbx, %rdi\n1a: \tmovq\t%r14, %rsi\n1d: \taddq\t$8, %rsp\n21: \tpopq\t%rbx\n22: \tpopq\t%r14\n24: \tjmp\t0x29 <A_CloseShotgun2+0x29>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_4__ {int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_ReFire (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_dbcls ;\n\nvoid\nA_CloseShotgun2\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nS_StartSound (player->mo, sfx_dbcls);\nA_ReFire(player,psp);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  npc; } ;\ntypedef  TYPE_1__ action_t ;\ntypedef  int /*<<< orphan*/  VARIANT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ACT_CloseShotgun2 ;\nint /*<<< orphan*/  ExecuteAction (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SetNPC (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void A_CloseShotgun2(action_t *act, VARIANT *arg)\n{\nSetNPC(act->npc, ACT_CloseShotgun2);\nExecuteAction(act, arg);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_delCharFromTextLine",
    "input":"\n0000000000000000 <HUlib_delCharFromTextLine>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0x29 <HUlib_delCharFromTextLine+0x29>\n8: \tmovq\t16(%rdi), %rcx\nc: \tleaq\t-1(%rax), %rdx\n10: \tmovq\t%rdx, (%rdi)\n13: \tmovq\t$0, -8(%rcx,%rax,8)\n1c: \tmovl\t$4, 8(%rdi)\n23: \tmovl\t$1, %eax\n28: \tretq\n29: \txorl\t%eax, %eax\n2b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t len; int needsupdate; scalar_t__* l; } ;\ntypedef  TYPE_1__ hu_textline_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\n\nboolean HUlib_delCharFromTextLine(hu_textline_t* t)\n{\n\nif (!t->len) return false;\nelse\n{\nt->l[--t->len] = 0;\nt->needsupdate = 4;\nreturn true;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t textLinePos; int /*<<< orphan*/ * textLine; int /*<<< orphan*/  textLineLen; } ;\ntypedef  TYPE_1__ HUCHAR_INFO ;\n\n/* Variables and functions */\n\nint HUlib_delCharFromTextLine(HUCHAR_INFO *charInfo)\n{\nif (charInfo->textLinePos == 0)\nreturn 0;\n\ncharInfo->textLinePos--;\ncharInfo->textLine[charInfo->textLinePos] = 0;\ncharInfo->textLineLen = 4;\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawOptions",
    "input":"\n0000000000000000 <M_DrawOptions>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t(%rip), %esi  # 0x9 <M_DrawOptions+0x9>\n9: \tmovl\t$0, %edi\ne: \tcallq\t0x13 <M_DrawOptions+0x13>\n13: \tmovl\t$108, %edi\n18: \tmovl\t$15, %esi\n1d: \txorl\t%edx, %edx\n1f: \tmovl\t%eax, %ecx\n21: \tcallq\t0x26 <M_DrawOptions+0x26>\n26: \tmovl\t$175, %ebx\n2b: \taddl\t(%rip), %ebx  # 0x31 <M_DrawOptions+0x31>\n31: \tmovl\t(%rip), %ebp  # 0x37 <M_DrawOptions+0x37>\n37: \timull\t(%rip), %ebp  # 0x3e <M_DrawOptions+0x3e>\n3e: \taddl\t(%rip), %ebp  # 0x44 <M_DrawOptions+0x44>\n44: \tmovq\t(%rip), %rax  # 0x4b <M_DrawOptions+0x4b>\n4b: \tmovq\t(%rip), %rcx  # 0x52 <M_DrawOptions+0x52>\n52: \tmovq\t(%rax,%rcx,8), %rdi\n56: \tmovl\t(%rip), %esi  # 0x5c <M_DrawOptions+0x5c>\n5c: \tcallq\t0x61 <M_DrawOptions+0x61>\n61: \tmovl\t%ebx, %edi\n63: \tmovl\t%ebp, %esi\n65: \txorl\t%edx, %edx\n67: \tmovl\t%eax, %ecx\n69: \tcallq\t0x6e <M_DrawOptions+0x6e>\n6e: \tmovl\t(%rip), %ebx  # 0x74 <M_DrawOptions+0x74>\n74: \taddl\t$120, %ebx\n77: \tmovl\t(%rip), %ebp  # 0x7d <M_DrawOptions+0x7d>\n7d: \timull\t(%rip), %ebp  # 0x84 <M_DrawOptions+0x84>\n84: \taddl\t(%rip), %ebp  # 0x8a <M_DrawOptions+0x8a>\n8a: \tmovq\t(%rip), %rax  # 0x91 <M_DrawOptions+0x91>\n91: \tmovq\t(%rip), %rcx  # 0x98 <M_DrawOptions+0x98>\n98: \tmovq\t(%rax,%rcx,8), %rdi\n9c: \tmovl\t(%rip), %esi  # 0xa2 <M_DrawOptions+0xa2>\na2: \tcallq\t0xa7 <M_DrawOptions+0xa7>\na7: \tmovl\t%ebx, %edi\na9: \tmovl\t%ebp, %esi\nab: \txorl\t%edx, %edx\nad: \tmovl\t%eax, %ecx\naf: \tcallq\t0xb4 <M_DrawOptions+0xb4>\nb4: \tmovl\t(%rip), %esi  # 0xba <M_DrawOptions+0xba>\nba: \taddl\t$1, %esi\nbd: \timull\t(%rip), %esi  # 0xc4 <M_DrawOptions+0xc4>\nc4: \tmovl\t(%rip), %edi  # 0xca <M_DrawOptions+0xca>\nca: \taddl\t(%rip), %esi  # 0xd0 <M_DrawOptions+0xd0>\nd0: \tmovl\t(%rip), %ecx  # 0xd6 <M_DrawOptions+0xd6>\nd6: \tmovl\t$10, %edx\ndb: \tcallq\t0xe0 <M_DrawOptions+0xe0>\ne0: \tmovl\t(%rip), %edi  # 0xe6 <M_DrawOptions+0xe6>\ne6: \tmovl\t(%rip), %esi  # 0xec <M_DrawOptions+0xec>\nec: \taddl\t$1, %esi\nef: \timull\t(%rip), %esi  # 0xf6 <M_DrawOptions+0xf6>\nf6: \taddl\t(%rip), %esi  # 0xfc <M_DrawOptions+0xfc>\nfc: \tmovl\t(%rip), %ecx  # 0x102 <M_DrawOptions+0x102>\n102: \tmovl\t$9, %edx\n107: \taddq\t$8, %rsp\n10b: \tpopq\t%rbx\n10c: \tpopq\t%rbp\n10d: \tjmp\t0x112 <M_DrawOptions+0x112>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int x; int y; } ;\n\n/* Variables and functions */\nint LINEHEIGHT ;\nint /*<<< orphan*/  M_DrawThermo (int,int,int,int /*<<< orphan*/ ) ;\nTYPE_1__ OptionsDef ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint detail ;\nsize_t detailLevel ;\nchar** detailNames ;\nint messages ;\nint /*<<< orphan*/  mouseSensitivity ;\nint mousesens ;\nchar** msgNames ;\nint /*<<< orphan*/  screenSize ;\nint scrnsize ;\nsize_t showMessages ;\n\nvoid M_DrawOptions(void)\n{\nV_DrawPatchDirect (108,15,0,W_CacheLumpName(\"M_OPTTTL\",PU_CACHE));\n\nV_DrawPatchDirect (OptionsDef.x + 175,OptionsDef.y+LINEHEIGHT*detail,0,\nW_CacheLumpName(detailNames[detailLevel],PU_CACHE));\n\nV_DrawPatchDirect (OptionsDef.x + 120,OptionsDef.y+LINEHEIGHT*messages,0,\nW_CacheLumpName(msgNames[showMessages],PU_CACHE));\n\nM_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(mousesens+1),\n10,mouseSensitivity);\n\nM_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(scrnsize+1),\n9,screenSize);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  PCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BLACK ;\nint /*<<< orphan*/  BLUE ;\nint /*<<< orphan*/  BRIGHT ;\nint /*<<< orphan*/  COLOR_WHITE ;\nint /*<<< orphan*/  DRAW_OPTIONS ;\nint /*<<< orphan*/  DRAW_OPTIONS_X ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_2 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_3 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_4 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_5 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_6 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_7 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_8 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_9 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_10 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_11 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_12 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_13 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_14 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_15 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_16 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_17 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_18 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_19 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_20 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_21 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_22 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_23 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_24 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_25 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_26 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_27 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_28 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_29 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_30 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_31 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_32 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_33 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_34 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_35 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_36 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_37 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_38 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_39 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_40 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_41 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_42 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_43 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_44 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_45 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_46 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_47 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_48 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_49 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_50 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_51 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_52 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_53 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_54 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_55 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_56 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_57 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_58 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_59 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_60 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_61 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_62 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_63 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_64 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_65 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_66 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_67 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_68 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_69 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_70 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_71 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_72 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_73 ;\nint /*<<< orphan*/  DRAW_OPTIONS_Y_OFFSET_74 ;\nint /*<<< orphan*/  DRAW"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_SoundDelTimer",
    "input":"\n0000000000000000 <I_SoundDelTimer>:\n0: \tpushq\t%rax\n1: \txorl\t%edi, %edi\n3: \tcallq\t0x8 <I_SoundDelTimer+0x8>\n8: \tcmpl\t$-1, %eax\nb: \tje\t0xf <I_SoundDelTimer+0xf>\nd: \tpopq\t%rax\ne: \tretq\nf: \tmovl\t(%rip), %edi  # 0x15 <I_SoundDelTimer+0x15>\n15: \tmovl\t$0, %esi\n1a: \tpopq\t%rax\n1b: \tjmp\t0x20 <I_SoundDelTimer+0x20>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint I_SoundSetTimer (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid I_SoundDelTimer()\n{\n// Debug.\nif ( I_SoundSetTimer( 0 ) == -1)\nfprintf( stderr, \"I_SoundDelTimer: failed to remove interrupt. Doh!\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_PANIC (int /*<<< orphan*/ ,char*) ;\nint I_SoundDelTimer_ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sound_timer ;\n\nvoid I_SoundDelTimer(void)\n{\nint rc;\n\nrc = I_SoundDelTimer_ (sound_timer);\nif (rc == -1)\nD_PANIC(\"I_SoundDelTimer: timer not found\\n\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_EV_LightTurnOn",
    "input":"\n0000000000000000 <EV_LightTurnOn>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t(%rip), %eax  # 0xe <EV_LightTurnOn+0xe>\ne: \ttestl\t%eax, %eax\n10: \tjle\t0x93 <EV_LightTurnOn+0x93>\n16: \tmovl\t%esi, %r12d\n19: \tmovq\t%rdi, %r14\n1c: \txorl\t%r15d, %r15d\n1f: \tmovq\t(%rip), %rbx  # 0x26 <EV_LightTurnOn+0x26>\n26: \tjmp\t0x3f <EV_LightTurnOn+0x3f>\n28: \tmovl\t(%rip), %eax  # 0x2e <EV_LightTurnOn+0x2e>\n2e: \tmovl\t%r12d, 12(%rbx)\n32: \taddl\t$1, %r15d\n36: \taddq\t$24, %rbx\n3a: \tcmpl\t%eax, %r15d\n3d: \tjge\t0x93 <EV_LightTurnOn+0x93>\n3f: \tmovq\t(%rbx), %rcx\n42: \tcmpq\t(%r14), %rcx\n45: \tjne\t0x32 <EV_LightTurnOn+0x32>\n47: \ttestl\t%r12d, %r12d\n4a: \tjne\t0x2e <EV_LightTurnOn+0x2e>\n4c: \tcmpl\t$0, 8(%rbx)\n50: \tjle\t0x8e <EV_LightTurnOn+0x8e>\n52: \txorl\t%ebp, %ebp\n54: \txorl\t%r12d, %r12d\n57: \tjmp\t0x6d <EV_LightTurnOn+0x6d>\n59: \tnopl\t(%rax)\n60: \taddq\t$1, %rbp\n64: \tmovslq\t8(%rbx), %rax\n68: \tcmpq\t%rax, %rbp\n6b: \tjge\t0x28 <EV_LightTurnOn+0x28>\n6d: \tmovq\t16(%rbx), %rax\n71: \tmovq\t(%rax,%rbp,8), %rdi\n75: \tmovq\t%rbx, %rsi\n78: \tcallq\t0x7d <EV_LightTurnOn+0x7d>\n7d: \ttestq\t%rax, %rax\n80: \tje\t0x60 <EV_LightTurnOn+0x60>\n82: \tmovl\t12(%rax), %eax\n85: \tcmpl\t%r12d, %eax\n88: \tcmovgel\t%eax, %r12d\n8c: \tjmp\t0x60 <EV_LightTurnOn+0x60>\n8e: \txorl\t%r12d, %r12d\n91: \tjmp\t0x2e <EV_LightTurnOn+0x2e>\n93: \tpopq\t%rbx\n94: \tpopq\t%r12\n96: \tpopq\t%r14\n98: \tpopq\t%r15\n9a: \tpopq\t%rbp\n9b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ tag; int linecount; int lightlevel; TYPE_2__** lines; } ;\ntypedef  TYPE_1__ sector_t ;\nstruct TYPE_9__ {scalar_t__ tag; } ;\ntypedef  TYPE_2__ line_t ;\n\n/* Variables and functions */\nTYPE_1__* getNextSector (TYPE_2__*,TYPE_1__*) ;\nint numsectors ;\nTYPE_1__* sectors ;\n\nvoid\nEV_LightTurnOn\n( line_t*\tline,\nint\t\tbright )\n{\nint\t\ti;\nint\t\tj;\nsector_t*\tsector;\nsector_t*\ttemp;\nline_t*\ttempline;\n\nsector = sectors;\n\nfor (i=0;i<numsectors;i++, sector++)\n{\nif (sector->tag == line->tag)\n{\n// bright = 0 means to search\n// for highest light level\n// surrounding sector\nif (!bright)\n{\nfor (j = 0;j < sector->linecount; j++)\n{\ntempline = sector->lines[j];\ntemp = getNextSector(templine,sector);\n\nif (!temp)\ncontinue;\n\nif (temp->lightlevel > bright)\nbright = temp->lightlevel;\n}\n}\nsector-> lightlevel = bright;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ id; int /*<<< orphan*/  state; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  state; } ;\nstruct TYPE_8__ {scalar_t__ id; int /*<<< orphan*/  state; TYPE_2__* light; } ;\ntypedef  TYPE_1__ EV_Light ;\ntypedef  TYPE_2__ Light ;\ntypedef  TYPE_3__ EV_LightState ;\n\n/* Variables and functions */\nint EV_Light_MAX ;\nTYPE_1__* ev_light ;\nTYPE_3__* ev_light_state ;\nTYPE_3__* find_light_state (TYPE_3__*,TYPE_1__*) ;\n\nvoid EV_LightTurnOn(EV_LightState *state, int on) {\nint i;\nfor (i = 0; i < EV_Light_MAX; i++) {\nif (ev_light_state[i].id == state->id) {\nif (on) {\nif (!ev_light_state[i].state) {\nev_light_state[i].state = 1;\n}\n} else {\nif (ev_light_state[i].state) {\nev_light_state[i].state = 0;\n}\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_initNum",
    "input":"\n0000000000000000 <STlib_initNum>:\n0: \tmovl\t8(%rsp), %eax\n4: \tmovl\t%esi, (%rdi)\n6: \tmovl\t%edx, 4(%rdi)\n9: \tmovq\t$0, 40(%rdi)\n11: \tmovl\t%eax, 8(%rdi)\n14: \tmovq\t%r8, 16(%rdi)\n18: \tmovq\t%r9, 32(%rdi)\n1c: \tmovq\t%rcx, 24(%rdi)\n20: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int width; int* num; int /*<<< orphan*/ ** p; int /*<<< orphan*/ * on; scalar_t__ oldnum; } ;\ntypedef  TYPE_1__ st_number_t ;\ntypedef  int /*<<< orphan*/  patch_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\n\nvoid\nSTlib_initNum\n( st_number_t*\t\tn,\nint\t\t\tx,\nint\t\t\ty,\npatch_t**\t\tpl,\nint*\t\t\tnum,\nboolean*\t\ton,\nint\t\t\twidth )\n{\nn->x\t= x;\nn->y\t= y;\nn->oldnum\t= 0;\nn->width\t= width;\nn->num\t= num;\nn->on\t= on;\nn->p\t= pl;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  flags; int /*<<< orphan*/  precision; int /*<<< orphan*/  base; int /*<<< orphan*/  sign; int /*<<< orphan*/ * format; int /*<<< orphan*/ * buffer; } ;\ntypedef  TYPE_1__ STLIB_NUM ;\n\n/* Variables and functions */\n\nvoid STlib_initNum(STLIB_NUM *num, int sign, int precision, int base,\nint flags, char *buffer, char *format)\n{\nnum->sign = sign;\nnum->precision = precision;\nnum->base = base;\nnum->flags = flags;\nnum->buffer = buffer;\nnum->format = format;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_StartTitle",
    "input":"\n0000000000000000 <D_StartTitle>:\n0: \tmovl\t(%rip), %eax  # 0x6 <D_StartTitle+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <D_StartTitle+0xc>\nc: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0x16 <D_StartTitle+0x16>\n16: \txorl\t%eax, %eax\n18: \tjmp\t0x1d <D_StartTitle+0x1d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_AdvanceDemo () ;\nint demosequence ;\nint /*<<< orphan*/  ga_nothing ;\nint /*<<< orphan*/  gameaction ;\n\nvoid D_StartTitle (void)\n{\ngameaction = ga_nothing;\ndemosequence = -1;\nD_AdvanceDemo ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_EndTitle () ;\nint /*<<< orphan*/  D_StartTitle_old ;\nint /*<<< orphan*/  D_StartTitle_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  D_StartTitle_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_Episode",
    "input":"\n0000000000000000 <M_Episode>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <M_Episode+0x8>\n8: \ttestl\t%edi, %edi\na: \tje\t0x2f <M_Episode+0x2f>\nc: \tcmpq\t(%rip), %rax  # 0x13 <M_Episode+0x13>\n13: \tjne\t0x2f <M_Episode+0x2f>\n15: \tmovl\t(%rip), %edi  # 0x1b <M_Episode+0x1b>\n1b: \txorl\t%esi, %esi\n1d: \txorl\t%edx, %edx\n1f: \tcallq\t0x24 <M_Episode+0x24>\n24: \tmovl\t$0, %edi\n29: \tpopq\t%rax\n2a: \tjmp\t0x2f <M_Episode+0x2f>\n2f: \tcmpl\t$3, %edi\n32: \tjl\t0x4f <M_Episode+0x4f>\n34: \tcmpq\t(%rip), %rax  # 0x3b <M_Episode+0x3b>\n3b: \tjne\t0x4f <M_Episode+0x4f>\n3d: \tmovl\t(%rip), %edi  # 0x43 <M_Episode+0x43>\n43: \tmovl\t$0, %esi\n48: \tcallq\t0x4d <M_Episode+0x4d>\n4d: \txorl\t%edi, %edi\n4f: \tmovl\t%edi, (%rip)  # 0x55 <M_Episode+0x55>\n55: \tmovl\t$0, %edi\n5a: \tpopq\t%rax\n5b: \tjmp\t0x60 <M_Episode+0x60>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  NewDef ;\nint /*<<< orphan*/  ReadDef1 ;\nint /*<<< orphan*/  SWSTRING ;\nint epi ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nscalar_t__ gamemode ;\nscalar_t__ registered ;\nscalar_t__ shareware ;\nint /*<<< orphan*/  stderr ;\n\nvoid M_Episode(int choice)\n{\nif ( (gamemode == shareware)\n&& choice)\n{\nM_StartMessage(SWSTRING,NULL,false);\nM_SetupNextMenu(&ReadDef1);\nreturn;\n}\n\n// Yet another hack...\nif ( (gamemode == registered)\n&& (choice > 2))\n{\nfprintf( stderr,\n\"M_Episode: 4th episode requires UltimateDOOM\\n\");\nchoice = 0;\n}\n\nepi = choice;\nM_SetupNextMenu(&NewDef);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Episode_ ;\nint /*<<< orphan*/  M_Episode_2 ;\nint /*<<< orphan*/  M_Episode_3 ;\nint /*<<< orphan*/  M_Episode_4 ;\nint /*<<< orphan*/  M_Episode_5 ;\nint /*<<< orphan*/  M_Episode_6 ;\nint /*<<< orphan*/  M_Episode_7 ;\nint /*<<< orphan*/  M_Episode_8 ;\nint /*<<< orphan*/  M_Episode_9 ;\nint /*<<< orphan*/  M_Episode_A ;\nint /*<<< orphan*/  M_Episode_B ;\nint /*<<< orphan*/  M_Episode_C ;\nint /*<<< orphan*/  M_Episode_D ;\nint /*<<< orphan*/  M_Episode_E ;\nint /*<<< orphan*/  M_Episode_F ;\nint /*<<< orphan*/  M_Episode_G ;\nint /*<<< orphan*/  M_Episode_H ;\nint /*<<< orphan*/  M_Episode_I ;\nint /*<<< orphan*/  M_Episode_J ;\nint /*<<< orphan*/  M_Episode_K ;\nint /*<<< orphan*/  M_Episode_L ;\nint /*<<< orphan*/  M_Episode_M ;\nint /*<<< orphan*/  M_Episode_N ;\nint /*<<< orphan*/  M_Episode_O ;\nint /*<<< orphan*/  M_Episode_P ;\nint /*<<< orphan*/  M_Episode_Q ;\nint /*<<< orphan*/  M_Episode_R ;\nint /*<<< orphan*/  M_Episode_S ;\nint /*<<< orphan*/  M_Episode_T ;\nint /*<<< orphan*/  M_Episode_U ;\nint /*<<< orphan*/  M_Episode_V ;\nint /*<<< orphan*/  M_Episode_W ;\nint /*<<< orphan*/  M_Episode_X ;\nint /*<<< orphan*/  M_Episode_Y ;\nint /*<<< orphan*/  M_Episode_Z ;\nint /*<<< orphan*/  M_Episode_a ;\nint /*<<< orphan*/  M_Episode_b ;\nint /*<<< orphan*/  M_Episode_c ;\nint /*<<< orphan*/  M_Episode_d ;\nint /*<<< orphan*/  M_Episode_e ;\nint /*<<< orphan*/  M_Episode_f ;\nint /*<<< orphan*/  M_Episode_g ;\nint /*<<< orphan*/  M_Episode_h ;\nint /*<<< orphan*/  M_Episode_i ;\nint /*<<< orphan*/  M_Episode_j ;\nint /*<<< orphan*/  M_Episode_k ;\nint /*<<< orphan*/  M_Episode_l ;\nint /*<<< orphan*/  M_Episode_m ;\nint /*<<< orphan*/  M_Episode_n ;\nint /*<<< orphan*/  M_Episode_o ;\nint /*<<< orphan*/  M_Episode_p ;\nint /*<<< orphan*/  M_Episode_q ;\nint /*<<< orphan*/  M_Episode_r ;\nint /*<<< orphan*/  M_Episode_s ;\nint /*<<< orphan*/  M_Episode_t ;\nint /*<<< orphan*/  M_Episode_u ;\nint /*<<< orphan*/  M_Episode_v ;\nint /*<<< orphan*/  M_Episode_w ;\nint /*<<< orphan*/  M_Episode_x ;\nint /*<<< orphan*/  M_Episode_y ;\nint /*<<< orphan*/  M_Episode_z ;\nint /*<<< orphan*/  M_Episode_z_ ;\nint /*<<< orphan*/  M_Episode_z_2 ;\nint /*<<< orphan*/  M_Episode_z_3 ;\nint /*<<< orphan*/  M_Episode_z_4 ;\nint /*<<< orphan*/  M_Episode_z_5 ;\nint /*<<< orphan*/  M_Episode_z_6 ;\nint /*<<< orphan*/  M_Episode_z_7 ;\nint /*<<< orphan*/  M_Episode_z_8 ;\nint /*<<< orphan*/  M_Episode_z_9 ;\nint /*<<< orphan*/  M_Episode_z_A ;\nint /*<<< orphan*/  M_Episode_z_B ;\nint /*<<< orphan*/  M_Episode_z_C ;\nint /*<<< orphan*/  M_Episode_z_D ;\nint /*<<< orphan*/  M_Episode_z_E ;\nint /*<<< orphan*/  M_Episode_z_F ;\nint /*<<< orphan*/  M_Episode_z_G ;\nint /*<<< orphan*/  M_Episode_z_H ;\nint /*<<< orphan*/  M_Episode_z_I ;\nint /*<<< orphan*/  M_Episode_z_J ;\nint /*<<< orphan*/  M_Episode_z_K ;\nint /*<<< orphan*/  M_Episode_z_L ;\nint /*<<< orphan*/  M_Episode_z_M ;\nint /*<<< orphan*/  M_Episode_z_N ;\nint /*<<< orphan*/  M_Episode_z_O ;\nint /*<<< orphan*/  M_Episode_z_P ;\nint /*<<< orphan*/  M_Episode_z_Q ;\nint /*<<< orphan*/  M_Episode_z_R ;\nint /*<<< orphan*/  M_Episode_z_S ;\nint /*<<< orphan*/  M_Episode_z_T ;\nint /*<<< orphan*/  M_Episode_z_U ;\nint /*<<< orphan*/  M_Episode_z_V ;\nint /*<<< orphan*/  M_Episode_z_W ;\nint /*<<< orphan*/  M_Episode_z_X ;\nint /*<<< orphan*/  M_Episode_z_Y ;\nint /*<<< orphan*/  M_Episode_z_Z ;\nint /*<<< orphan*/  M_Episode_z_a ;\nint /*<<< orphan*/  M_Episode_z_b ;\nint /*<<< orphan*/  M_Episode_z_c ;\nint /*<<< orphan*/  M_Episode_z_d ;\nint /*<<< orphan*/  M_Episode_z_e ;\nint /*<<< orphan*/  M_Episode_z_f ;\nint /*<<< orphan*/  M_Episode_z_g ;\nint /*<<< orphan*/  M_Episode_z_h ;\nint /*<<< orphan*/  M_Episode_z_i ;\nint /*<<< orphan*/  M_Episode_z_j ;\nint /*<<< orphan*/  M_Episode_z_k ;\nint /*<<< orphan*/  M_Episode_z_l ;\nint /*<<< orphan*/  M_Episode_z_m ;\nint /*<<< orphan*/  M_Episode_z_n ;\nint /*<<< orphan*/  M_Episode_z_o ;\nint /*<<< orphan*/  M_Episode_z_p ;\nint /*<<< orphan*/  M_Episode_z_q ;\nint /*<<< orphan*/  M_Episode_z_r ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_LoadGame",
    "input":"\n0000000000000000 <G_LoadGame>:\n0: \tpushq\t%rax\n1: \tmovq\t%rdi, %rsi\n4: \tmovl\t(%rip), %edi  # 0xa <G_LoadGame+0xa>\na: \tcallq\t0xf <G_LoadGame+0xf>\nf: \tmovl\t(%rip), %eax  # 0x15 <G_LoadGame+0x15>\n15: \tmovl\t%eax, (%rip)  # 0x1b <G_LoadGame+0x1b>\n1b: \tpopq\t%rax\n1c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ga_loadgame ;\nint /*<<< orphan*/  gameaction ;\nint /*<<< orphan*/  savename ;\nint /*<<< orphan*/  strcpy (int /*<<< orphan*/ ,char*) ;\n\nvoid G_LoadGame (char* name)\n{\nstrcpy (savename, name);\ngameaction = ga_loadgame;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  char ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_LoadGameFile (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  G_LoadGameFile_W (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  G_LoadGame_W ;\nint /*<<< orphan*/  G_LoadGame_X ;\nint /*<<< orphan*/  G_LoadGame_Y ;\nint /*<<< orphan*/  G_LoadGame_Z ;\nint /*<<< orphan*/  G_LoadGame_Z2 ;\nint /*<<< orphan*/  G_LoadGame_Z3 ;\nint /*<<< orphan*/  G_LoadGame_Z4 ;\nint /*<<< orphan*/  G_LoadGame_Z5 ;\nint /*<<< orphan*/  G_LoadGame_Z6 ;\nint /*<<< orphan*/  G_LoadGame_Z7 ;\nint /*<<< orphan*/  G_LoadGame_Z8 ;\nint /*<<< orphan*/  G_LoadGame_Z9 ;\nint /*<<< orphan*/  G_LoadGame_ZA ;\nint /*<<< orphan*/  G_LoadGame_ZB ;\nint /*<<< orphan*/  G_LoadGame_ZC ;\nint /*<<< orphan*/  G_LoadGame_ZD ;\nint /*<<< orphan*/  G_LoadGame_ZE ;\nint /*<<< orphan*/  G_LoadGame_ZF ;\nint /*<<< orphan*/  G_LoadGame_ZG ;\nint /*<<< orphan*/  G_LoadGame_ZH ;\nint /*<<< orphan*/  G_LoadGame_ZI ;\nint /*<<< orphan*/  G_LoadGame_ZJ ;\nint /*<<< orphan*/  G_LoadGame_ZK ;\nint /*<<< orphan*/  G_LoadGame_ZL ;\nint /*<<< orphan*/  G_LoadGame_ZM ;\nint /*<<< orphan*/  G_LoadGame_ZN ;\nint /*<<< orphan*/  G_LoadGame_ZO ;\nint /*<<< orphan*/  G_LoadGame_ZP ;\nint /*<<< orphan*/  G_LoadGame_ZQ ;\nint /*<<< orphan*/  G_LoadGame_ZR ;\nint /*<<< orphan*/  G_LoadGame_ZS ;\nint /*<<< orphan*/  G_LoadGame_ZT ;\nint /*<<< orphan*/  G_LoadGame_ZU ;\nint /*<<< orphan*/  G_LoadGame_ZV ;\nint /*<<< orphan*/  G_LoadGame_ZW ;\nint /*<<< orphan*/  G_LoadGame_ZX ;\nint /*<<< orphan*/  G_LoadGame_ZY ;\nint /*<<< orphan*/  G_LoadGame_ZZ ;\nint /*<<< orphan*/  G_LoadGame_Za ;\nint /*<<< orphan*/  G_LoadGame_Zb ;\nint /*<<< orphan*/  G_LoadGame_Zc ;\nint /*<<< orphan*/  G_LoadGame_Zd ;\nint /*<<< orphan*/  G_LoadGame_Ze ;\nint /*<<< orphan*/  G_LoadGame_Zf ;\nint /*<<< orphan*/  G_LoadGame_Zg ;\nint /*<<< orphan*/  G_LoadGame_Zh ;\nint /*<<< orphan*/  G_LoadGame_Zi ;\nint /*<<< orphan*/  G_LoadGame_Zj ;\nint /*<<< orphan*/  G_LoadGame_Zk ;\nint /*<<< orphan*/  G_LoadGame_Zl ;\nint /*<<< orphan*/  G_LoadGame_Zm ;\nint /*<<< orphan*/  G_LoadGame_Zn ;\nint /*<<< orphan*/  G_LoadGame_Zo ;\nint /*<<< orphan*/  G_LoadGame_Zp ;\nint /*<<< orphan*/  G_LoadGame_Zq ;\nint /*<<< orphan*/  G_LoadGame_Zr ;\nint /*<<< orphan*/  G_LoadGame_Zs ;\nint /*<<< orphan*/  G_LoadGame_Zt ;\nint /*<<< orphan*/  G_LoadGame_Zu ;\nint /*<<< orphan*/  G_LoadGame_Zv ;\nint /*<<< orphan*/  G_LoadGame_Zw ;\nint /*<<< orphan*/  G_LoadGame_Zx ;\nint /*<<< orphan*/  G_LoadGame_Zy ;\nint /*<<< orphan*/  G_LoadGame_Zz ;\nint /*<<< orphan*/  G_LoadGame_a ;\nint /*<<< orphan*/  G_LoadGame_b ;\nint /*<<< orphan*/  G_LoadGame_c ;\nint /*<<< orphan*/  G_LoadGame_d ;\nint /*<<< orphan*/  G_LoadGame_e ;\nint /*<<< orphan*/  G_LoadGame_f ;\nint /*<<< orphan*/  G_LoadGame_g ;\nint /*<<< orphan*/  G_LoadGame_h ;\nint /*<<< orphan*/  G_LoadGame_i ;\nint /*<<< orphan*/  G_LoadGame_j ;\nint /*<<< orphan*/  G_LoadGame_k ;\nint /*<<< orphan*/  G_LoadGame_l ;\nint /*<<< orphan*/  G_LoadGame_m ;\nint /*<<< orphan*/  G_LoadGame_n ;\nint /*<<< orphan*/  G_LoadGame_o ;\nint /*<<< orphan*/  G_LoadGame_p ;\nint /*<<< orphan*/  G_LoadGame_q ;\nint /*<<< orphan*/  G_LoadGame_r ;\nint /*<<< orphan*/  G_LoadGame_s ;\nint /*<<< orphan*/  G_LoadGame_t ;\nint /*<<< orphan*/  G_LoadGame_u ;\nint /*<<< orphan*/  G_LoadGame_v ;\nint /*<<< orphan*/  G_LoadGame_w ;\nint /*<<< orphan*/  G_LoadGame_x ;\nint /*<<< orphan*/  G_LoadGame_y ;\nint /*<<< orphan*/  G_LoadGame_z ;\nint /*<<< orphan*/  G_LoadGame_z2 ;\nint /*<<< orphan*/  G_LoadGame_z3 ;\nint /*<<< orphan*/  G_LoadGame_z4 ;\nint /*<<< orphan*/  G_LoadGame_z5 ;\nint /*<<< orphan*/  G_LoadGame_z6 ;\nint /*<<< orphan*/  G_LoadGame_z7 ;\nint /*<<< orphan*/  G_LoadGame_z8 ;\nint /*<<< orphan*/  G_LoadGame_z9 ;\nint /*<<< orphan*/  G_LoadGame_za ;\nint /*<<< orphan*/  G_LoadGame_zb ;\nint /*<<< orphan*/  G_LoadGame_zc ;\nint /*<<< orphan*/  G_LoadGame_zd ;\nint /*<<< orphan*/  G_LoadGame_ze ;\nint /*<<< orphan*/  G_LoadGame_zf ;\nint /*<<< orphan*/  G_LoadGame_zg ;\nint /*<<< orphan*/  G_LoadGame_zh ;\nint /*<<< orphan*/  G_LoadGame_zi ;\nint /*<<< orphan*/  G_LoadGame_zj ;\nint /*<<< orphan*/  G_LoadGame_zk ;\nint /*<<< orphan*/  G_LoadGame_zl ;\nint /*<<< orphan*/  G_LoadGame_zm ;\nint /*<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_resetIText",
    "input":"\n0000000000000000 <HUlib_resetIText>:\n0: \tmovq\t$0, 8(%rdi)\n8: \tjmp\t0xd <HUlib_resetIText+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  l; scalar_t__ lm; } ;\ntypedef  TYPE_1__ hu_itext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_clearTextLine (int /*<<< orphan*/ *) ;\n\nvoid HUlib_resetIText(hu_itext_t* it)\n{\nit->lm = 0;\nHUlib_clearTextLine(&it->l);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; } ;\ntypedef  TYPE_1__ IText ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_resetText (TYPE_1__*) ;\n\nvoid HUlib_resetIText(IText *it)\n{\nit->x = 0;\nit->y = 0;\nHU_resetText(it);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_myioctl",
    "input":"\n0000000000000000 <myioctl>:\n0: \tpushq\t%rbx\n1: \tmovl\t%esi, %ebx\n3: \tcallq\t0x8 <myioctl+0x8>\n8: \ttestl\t%eax, %eax\na: \tjs\t0xe <myioctl+0xe>\nc: \tpopq\t%rbx\nd: \tretq\ne: \tmovl\t(%rip), %edi  # 0x14 <myioctl+0x14>\n14: \tmovl\t$0, %esi\n19: \tmovl\t%ebx, %edx\n1b: \tcallq\t0x20 <myioctl+0x20>\n20: \tmovl\t(%rip), %edi  # 0x26 <myioctl+0x26>\n26: \tmovl\t(%rip), %edx  # 0x2c <myioctl+0x2c>\n2c: \tmovl\t$0, %esi\n31: \tcallq\t0x36 <myioctl+0x36>\n36: \tmovl\t$4294967295, %edi  # imm = 0xFFFFFFFF\n3b: \tcallq\t0x40 <myioctl+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int) ;\nint ioctl (int,int,int*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid\nmyioctl\n( int\tfd,\nint\tcommand,\nint*\targ )\n{\nint\t\trc;\nextern int\terrno;\n\nrc = ioctl(fd, command, arg);\nif (rc < 0)\n{\nfprintf(stderr, \"ioctl(dsp,%d,arg) failed\\n\", command);\nfprintf(stderr, \"errno=%d\\n\", errno);\nexit(-1);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  u_long ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EXIT_FAILURE ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\nint syscall (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nint myioctl(int fd, u_long cmd)\n{\nif (syscall(fd, cmd, 0) < 0) {\nperror(\"syscall\");\nfprintf(stderr, \"ioctl(%d, %ld) failed\\n\", fd, cmd);\nexit(EXIT_FAILURE);\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_Drawer",
    "input":"\n0000000000000000 <F_Drawer>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %eax  # 0x7 <F_Drawer+0x7>\n7: \ttestl\t%eax, %eax\n9: \tje\t0x18 <F_Drawer+0x18>\nb: \tcmpl\t$2, %eax\ne: \tjne\t0x20 <F_Drawer+0x20>\n10: \txorl\t%eax, %eax\n12: \tpopq\t%rcx\n13: \tjmp\t0x18 <F_Drawer+0x18>\n18: \txorl\t%eax, %eax\n1a: \tpopq\t%rcx\n1b: \tjmp\t0x20 <F_Drawer+0x20>\n20: \tmovl\t(%rip), %eax  # 0x26 <F_Drawer+0x26>\n26: \taddl\t$-1, %eax\n29: \tcmpl\t$3, %eax\n2c: \tja\t0x65 <F_Drawer+0x65>\n2e: \tjmpq\t*(,%rax,8)\n35: \tmovl\t(%rip), %eax  # 0x3b <F_Drawer+0x3b>\n3b: \tmovl\t(%rip), %esi  # 0x41 <F_Drawer+0x41>\n41: \tcmpl\t(%rip), %eax  # 0x47 <F_Drawer+0x47>\n47: \tjne\t0x74 <F_Drawer+0x74>\n49: \tmovl\t$0, %edi\n4e: \tjmp\t0x79 <F_Drawer+0x79>\n50: \txorl\t%eax, %eax\n52: \tpopq\t%rcx\n53: \tjmp\t0x58 <F_Drawer+0x58>\n58: \tmovl\t(%rip), %esi  # 0x5e <F_Drawer+0x5e>\n5e: \tmovl\t$0, %edi\n63: \tjmp\t0x79 <F_Drawer+0x79>\n65: \tpopq\t%rax\n66: \tretq\n67: \tmovl\t(%rip), %esi  # 0x6d <F_Drawer+0x6d>\n6d: \tmovl\t$0, %edi\n72: \tjmp\t0x79 <F_Drawer+0x79>\n74: \tmovl\t$0, %edi\n79: \tcallq\t0x7e <F_Drawer+0x7e>\n7e: \txorl\t%edi, %edi\n80: \txorl\t%esi, %esi\n82: \txorl\t%edx, %edx\n84: \tmovl\t%eax, %ecx\n86: \tpopq\t%rax\n87: \tjmp\t0x8c <F_Drawer+0x8c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_BunnyScroll () ;\nint /*<<< orphan*/  F_CastDrawer () ;\nint /*<<< orphan*/  F_TextWrite () ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatch (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint finalestage ;\nint gameepisode ;\nint /*<<< orphan*/  gamemode ;\nint /*<<< orphan*/  retail ;\n\nvoid F_Drawer (void)\n{\nif (finalestage == 2)\n{\nF_CastDrawer ();\nreturn;\n}\n\nif (!finalestage)\nF_TextWrite ();\nelse\n{\nswitch (gameepisode)\n{\ncase 1:\nif ( gamemode == retail )\nV_DrawPatch (0,0,0,\nW_CacheLumpName(\"CREDIT\",PU_CACHE));\nelse\nV_DrawPatch (0,0,0,\nW_CacheLumpName(\"HELP2\",PU_CACHE));\nbreak;\ncase 2:\nV_DrawPatch(0,0,0,\nW_CacheLumpName(\"VICTORY2\",PU_CACHE));\nbreak;\ncase 3:\nF_BunnyScroll ();\nbreak;\ncase 4:\nV_DrawPatch (0,0,0,\nW_CacheLumpName(\"ENDPIC\",PU_CACHE));\nbreak;\n}\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DPRINT (char*,...) ;\nint /*<<< orphan*/  F_Drawer_1 () ;\nint /*<<< orphan*/  F_Drawer_2 () ;\nint /*<<< orphan*/  F_Drawer_3 () ;\nint /*<<< orphan*/  F_Drawer_4 () ;\nint /*<<< orphan*/  F_Drawer_5 () ;\nint /*<<< orphan*/  F_Drawer_6 () ;\nint /*<<< orphan*/  F_Drawer_7 () ;\nint /*<<< orphan*/  F_Drawer_8 () ;\nint /*<<< orphan*/  F_Drawer_9 () ;\nint /*<<< orphan*/  F_Drawer_A () ;\nint /*<<< orphan*/  F_Drawer_B () ;\nint /*<<< orphan*/  F_Drawer_C () ;\nint /*<<< orphan*/  F_Drawer_D () ;\nint /*<<< orphan*/  F_Drawer_E () ;\nint /*<<< orphan*/  F_Drawer_F () ;\nint /*<<< orphan*/  F_Drawer_G () ;\nint /*<<< orphan*/  F_Drawer_H () ;\nint /*<<< orphan*/  F_Drawer_I () ;\nint /*<<< orphan*/  F_Drawer_J () ;\nint /*<<< orphan*/  F_Drawer_K () ;\nint /*<<< orphan*/  F_Drawer_L () ;\nint /*<<< orphan*/  F_Drawer_M () ;\nint /*<<< orphan*/  F_Drawer_N () ;\nint /*<<< orphan*/  F_Drawer_O () ;\nint /*<<< orphan*/  F_Drawer_P () ;\nint /*<<< orphan*/  F_Drawer_Q () ;\nint /*<<< orphan*/  F_Drawer_R () ;\nint /*<<< orphan*/  F_Drawer_S () ;\nint /*<<< orphan*/  F_Drawer_T () ;\nint /*<<< orphan*/  F_Drawer_U () ;\nint /*<<< orphan*/  F_Drawer_V () ;\nint /*<<< orphan*/  F_Drawer_W () ;\nint /*<<< orphan*/  F_Drawer_X () ;\nint /*<<< orphan*/  F_Drawer_Y () ;\nint /*<<< orphan*/  F_Drawer_Z () ;\nint /*<<< orphan*/  F_Drawer_a () ;\nint /*<<< orphan*/  F_Drawer_b () ;\nint /*<<< orphan*/  F_Drawer_c () ;\nint /*<<< orphan*/  F_Drawer_d () ;\nint /*<<< orphan*/  F_Drawer_e () ;\nint /*<<< orphan*/  F_Drawer_f () ;\nint /*<<< orphan*/  F_Drawer_g () ;\nint /*<<< orphan*/  F_Drawer_h () ;\nint /*<<< orphan*/  F_Drawer_i () ;\nint /*<<< orphan*/  F_Drawer_j () ;\nint /*<<< orphan*/  F_Drawer_k () ;\nint /*<<< orphan*/  F_Drawer_l () ;\nint /*<<< orphan*/  F_Drawer_m () ;\nint /*<<< orphan*/  F_Drawer_n () ;\nint /*<<< orphan*/  F_Drawer_o () ;\nint /*<<< orphan*/  F_Drawer_p () ;\nint /*<<< orphan*/  F_Drawer_q () ;\nint /*<<< orphan*/  F_Drawer_r () ;\nint /*<<< orphan*/  F_Drawer_s () ;\nint /*<<< orphan*/  F_Drawer_t () ;\nint /*<<< orphan*/  F_Drawer_u () ;\nint /*<<< orphan*/  F_Drawer_v () ;\nint /*<<< orphan*/  F_Drawer_w () ;\nint /*<<< orphan*/  F_Drawer_x () ;\nint /*<<< orphan*/  F_Drawer_y () ;\nint /*<<< orphan*/  F_Drawer_z () ;\nint /*<<< orphan*/  F_Drawer_A () ;\nint /*<<< orphan*/  F_Drawer_B () ;\nint /*<<< orphan*/  F_Drawer_C () ;\nint /*<<< orphan*/  F_Drawer_D () ;\nint /*<<< orphan*/  F_Drawer_E () ;\nint /*<<< orphan*/  F_Drawer_F () ;\nint /*<<< orphan*/  F_Drawer_G () ;\nint /*<<< orphan*/  F_Drawer_H () ;\nint /*<<< orphan*/  F_Drawer_I () ;\nint /*<<< orphan*/  F_Drawer_J () ;\nint /*<<< orphan*/  F_Drawer_K () ;\nint /*<<< orphan*/  F_Drawer_L () ;\nint /*<<< orphan*/  F_Drawer_M () ;\nint /*<<< orphan*/  F_Drawer_N () ;\nint /*<<< orphan*/  F_Drawer_O () ;\nint /*<<< orphan*/  F_Drawer_P () ;\nint /*<<< orphan*/  F_Drawer_Q () ;\nint /*<<< orphan*/  F_Drawer_R () ;\nint /*<<< orphan*/  F_Drawer_S () ;\nint /*<<< orphan*/  F_Drawer_T () ;\nint /*<<< orphan*/  F_Drawer_U () ;\nint /*<<< orphan*/  F_Drawer_V () ;\nint /*<<< orphan*/  F_Drawer_W () ;\nint /*<<< orphan*/  F_Drawer_X () ;\nint /*<<< orphan*/  F_Drawer_Y () ;\nint /*<<< orphan*/  F_Drawer_Z () ;\nint /*<<< orphan*/  F_Drawer_a () ;\nint /*<<< orphan*/  F_Drawer_b () ;\nint /*<<< orphan*/  F_Drawer_c () ;\nint /*<<< orphan*/  F_Drawer_d () ;\nint /*<<< orphan*/  F_Drawer_e () ;\nint /*<<< orphan*/  F_Drawer_f () ;\nint /*<<< orphan*/  F_Drawer_g () ;\nint /*<<< orphan*/  F_Drawer_h () ;\nint /*<<< orphan*/  F_Drawer_i () ;\nint /*<<< orphan*/  F_Drawer_j () ;\nint /*<<< orphan*/  F_Drawer_k () ;\nint /*<<< orphan*/  F_Drawer_l () ;\nint /*<<< orphan*/  F_Drawer_m () ;\nint /*<<< orphan*/  F_Drawer_n () ;\nint /*<<< orphan*/  F_Drawer_o () ;\nint /*<<< orphan*/  F_Drawer_p () ;\nint /*<<< orphan*/  F_Drawer_q () ;\nint /*<<< orphan*/  F_Drawer_r () ;\nint /*<<< orphan*/  F_Drawer_s () ;\nint /*<<< orphan*/  F_Drawer_t () ;\nint /*<<< orphan*/  F_Drawer_u () ;\nint /*<<< orphan*/  F_Drawer_v () ;\nint /*<<< orphan*/  F_Drawer_w () ;\nint /*<<< orphan*/  F_Drawer_x () ;\nint /*<<< orphan*/  F_Drawer_y () ;\nint /*<<< orphan*/  F_Drawer_z () ;\nint /*<<< orphan*/  F_Drawer_A () ;\nint /*<<< orphan*/  F_Drawer_B () ;\nint /*<<< orphan*/  F_Drawer_C () ;\nint /*<<< orphan*/  F_Drawer_D () ;\nint /*<<< orphan*/  F_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_random.c_M_Random",
    "input":"\n0000000000000000 <M_Random>:\n0: \tmovl\t(%rip), %eax  # 0x6 <M_Random+0x6>\n6: \taddl\t$1, %eax\n9: \tmovzbl\t%al, %eax\nc: \tmovl\t%eax, (%rip)  # 0x12 <M_Random+0x12>\n12: \tmovq\t(%rip), %rcx  # 0x19 <M_Random+0x19>\n19: \tmovl\t(%rcx,%rax,4), %eax\n1c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint rndindex ;\nint* rndtable ;\n\nint M_Random (void)\n{\nrndindex = (rndindex+1)&0xff;\nreturn rndtable[rndindex];\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint M_RandomSeed ;\nint* M_RandomTable ;\n\nint M_Random(void)\n{\nM_RandomSeed = (M_RandomSeed + 1) & 0xff;\nreturn M_RandomTable[M_RandomSeed];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_TimeDemo",
    "input":"\n0000000000000000 <G_TimeDemo>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t$0, %edi\n9: \tcallq\t0xe <G_TimeDemo+0xe>\ne: \tmovq\t%rax, (%rip)  # 0x15 <G_TimeDemo+0x15>\n15: \tmovl\t$0, %edi\n1a: \tcallq\t0x1f <G_TimeDemo+0x1f>\n1f: \tmovq\t%rax, (%rip)  # 0x26 <G_TimeDemo+0x26>\n26: \tmovl\t$1, (%rip)    # 0x30 <G_TimeDemo+0x30>\n30: \tmovl\t$1, (%rip)    # 0x3a <G_TimeDemo+0x3a>\n3a: \tmovq\t%rbx, (%rip)  # 0x41 <G_TimeDemo+0x41>\n41: \tmovl\t(%rip), %eax  # 0x47 <G_TimeDemo+0x47>\n47: \tmovl\t%eax, (%rip)  # 0x4d <G_TimeDemo+0x4d>\n4d: \tpopq\t%rbx\n4e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nvoid* M_CheckParm (char*) ;\nchar* defdemoname ;\nint /*<<< orphan*/  ga_playdemo ;\nint /*<<< orphan*/  gameaction ;\nvoid* noblit ;\nvoid* nodrawers ;\nint singletics ;\nint timingdemo ;\n\nvoid G_TimeDemo (char* name)\n{\nnodrawers = M_CheckParm (\"-nodraw\");\nnoblit = M_CheckParm (\"-noblit\");\ntimingdemo = true;\nsingletics = true;\n\ndefdemoname = name;\ngameaction = ga_playdemo;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_TimeDemo_End ;\nint /*<<< orphan*/  G_TimeDemo_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Start ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_End ;\nint /*<<< orphan*/  G_TimeDemo_Ticks_Total_Total_Total_Total_Total_Total_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_PointOnLineSide",
    "input":"\n0000000000000000 <P_PointOnLineSide>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %rbx\n8: \tmovq\t%rsi, %r14\nb: \tmovq\t%rdi, %rsi\ne: \tmovq\t(%rdx), %rax\n11: \ttestq\t%rax, %rax\n14: \tje\t0x5c <P_PointOnLineSide+0x5c>\n16: \tmovq\t8(%rbx), %rdi\n1a: \tmovq\t16(%rbx), %rcx\n1e: \ttestq\t%rdi, %rdi\n21: \tje\t0x71 <P_PointOnLineSide+0x71>\n23: \tsubq\t(%rcx), %rsi\n26: \tsubq\t8(%rcx), %r14\n2a: \tmovb\t(%rip), %cl   # 0x30 <P_PointOnLineSide+0x30>\n30: \tsarq\t%cl, %rdi\n33: \tcallq\t0x38 <P_PointOnLineSide+0x38>\n38: \tmovq\t%rax, %r15\n3b: \tmovq\t(%rbx), %rsi\n3e: \tmovb\t(%rip), %cl   # 0x44 <P_PointOnLineSide+0x44>\n44: \tsarq\t%cl, %rsi\n47: \tmovq\t%r14, %rdi\n4a: \tcallq\t0x4f <P_PointOnLineSide+0x4f>\n4f: \tmovq\t%rax, %rcx\n52: \txorl\t%eax, %eax\n54: \tcmpq\t%r15, %rcx\n57: \tsetge\t%al\n5a: \tjmp\t0x91 <P_PointOnLineSide+0x91>\n5c: \tmovq\t8(%rbx), %rcx\n60: \tmovq\t16(%rbx), %rax\n64: \tcmpq\t%rsi, (%rax)\n67: \tjge\t0x83 <P_PointOnLineSide+0x83>\n69: \tshrq\t$63, %rcx\n6d: \tmovl\t%ecx, %eax\n6f: \tjmp\t0x91 <P_PointOnLineSide+0x91>\n71: \tcmpq\t%r14, 8(%rcx)\n75: \tjge\t0x8d <P_PointOnLineSide+0x8d>\n77: \txorl\t%ecx, %ecx\n79: \ttestq\t%rax, %rax\n7c: \tsetg\t%cl\n7f: \tmovl\t%ecx, %eax\n81: \tjmp\t0x91 <P_PointOnLineSide+0x91>\n83: \txorl\t%eax, %eax\n85: \ttestq\t%rcx, %rcx\n88: \tsetg\t%al\n8b: \tjmp\t0x91 <P_PointOnLineSide+0x91>\n8d: \tshrq\t$63, %rax\n91: \tpopq\t%rbx\n92: \tpopq\t%r14\n94: \tpopq\t%r15\n96: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ dx; scalar_t__ dy; TYPE_1__* v1; } ;\ntypedef  TYPE_2__ line_t ;\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_4__ {scalar_t__ x; scalar_t__ y; } ;\n\n/* Variables and functions */\nscalar_t__ FRACBITS ;\nscalar_t__ FixedMul (scalar_t__,scalar_t__) ;\n\nint\nP_PointOnLineSide\n( fixed_t\tx,\nfixed_t\ty,\nline_t*\tline )\n{\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\n\nif (!line->dx)\n{\nif (x <= line->v1->x)\nreturn line->dy > 0;\n\nreturn line->dy < 0;\n}\nif (!line->dy)\n{\nif (y <= line->v1->y)\nreturn line->dx < 0;\n\nreturn line->dx > 0;\n}\n\ndx = (x - line->v1->x);\ndy = (y - line->v1->y);\n\nleft = FixedMul ( line->dy>>FRACBITS , dx );\nright = FixedMul ( dy , line->dx>>FRACBITS );\n\nif (right < left)\nreturn 0;\t\t// front side\nreturn 1;\t\t\t// back side\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ cmsUInt32Number ;\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; } ;\ntypedef  TYPE_1__ cmsCIEXYZ ;\ntypedef  int cmsBool ;\ntypedef  scalar_t__ cmsFloat64Number ;\ntypedef  int /*<<< orphan*/  cmsContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FLT_EPSILON ;\nscalar_t__ _cmsAbs (scalar_t__) ;\n\n__attribute__((used)) static\ncmsBool P_PointOnLineSide(cmsContext ContextID, cmsFloat64Number x, cmsFloat64Number y, const cmsCIEXYZ* p)\n{\ncmsFloat64Number dx, dy;\n\nif (p->x == 0 && p->y == 0) return 0;\n\ndx = x - p->x;\ndy = y - p->y;\n\nif (p->x == 0) {\nreturn dy >= 0 ? 1 : 0;\n}\n\nif (p->y == 0) {\nreturn dx >= 0 ? 1 : 0;\n}\n\ndx /= p->x;\ndy /= p->y;\n\nreturn _cmsAbs(dx - dy) < FLT_EPSILON;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_Init",
    "input":"\n0000000000000000 <M_Init>:\n0: \tmovq\t$0, (%rip)    # 0xb <M_Init+0xb>\nb: \tmovq\t$0, (%rip)    # 0x16 <M_Init+0x16>\n16: \tmovl\t(%rip), %eax  # 0x1c <M_Init+0x1c>\n1c: \tmovl\t%eax, (%rip)  # 0x22 <M_Init+0x22>\n22: \tmovq\t$0, (%rip)    # 0x2d <M_Init+0x2d>\n2d: \tmovl\t$10, (%rip)   # 0x37 <M_Init+0x37>\n37: \tmovq\t(%rip), %rax  # 0x3e <M_Init+0x3e>\n3e: \taddq\t$-3, %rax\n42: \tmovq\t%rax, (%rip)  # 0x49 <M_Init+0x49>\n49: \tmovq\t$0, (%rip)    # 0x54 <M_Init+0x54>\n54: \tmovq\t$0, (%rip)    # 0x5f <M_Init+0x5f>\n5f: \tmovq\t$0, (%rip)    # 0x6a <M_Init+0x6a>\n6a: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0x74 <M_Init+0x74>\n74: \tmovl\t(%rip), %eax  # 0x7a <M_Init+0x7a>\n7a: \tcmpl\t$128, %eax\n7f: \tje\t0xf0 <M_Init+0xf0>\n81: \tcmpl\t$130, %eax\n86: \tje\t0xf0 <M_Init+0xf0>\n88: \tcmpl\t$131, %eax\n8d: \tjne\t0xf7 <M_Init+0xf7>\n8f: \tmovq\t(%rip), %rax  # 0x96 <M_Init+0x96>\n96: \tmovq\t(%rip), %rcx  # 0x9d <M_Init+0x9d>\n9d: \tmovl\t(%rax,%rcx,4), %ecx\na0: \tmovq\t(%rip), %rdx  # 0xa7 <M_Init+0xa7>\na7: \tmovl\t%ecx, (%rax,%rdx,4)\naa: \taddl\t$-1, (%rip)   # 0xb1 <M_Init+0xb1>\nb1: \taddl\t$8, (%rip)    # 0xb8 <M_Init+0xb8>\nb8: \tmovq\t$0, (%rip)    # 0xc3 <M_Init+0xc3>\nc3: \tmovl\t(%rip), %eax  # 0xc9 <M_Init+0xc9>\nc9: \tmovl\t%eax, (%rip)  # 0xcf <M_Init+0xcf>\ncf: \tmovabsq\t$708669604170, %rax# imm = 0xA50000014A\nd9: \tmovq\t%rax, (%rip)  # 0xe0 <M_Init+0xe0>\ne0: \tmovl\t(%rip), %eax  # 0xe6 <M_Init+0xe6>\ne6: \tmovq\t(%rip), %rcx  # 0xed <M_Init+0xed>\ned: \tmovl\t%eax, (%rcx)\nef: \tretq\nf0: \taddl\t$-1, (%rip)   # 0xf7 <M_Init+0xf7>\nf7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_6__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {int /*<<< orphan*/  numitems; } ;\nstruct TYPE_10__ {TYPE_1__* prevMenu; } ;\nstruct TYPE_9__ {int x; int y; int /*<<< orphan*/  routine; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  routine; } ;\nstruct TYPE_7__ {int y; int /*<<< orphan*/  numitems; int /*<<< orphan*/  lastOn; } ;\n\n/* Variables and functions */\nTYPE_6__ EpiDef ;\nint /*<<< orphan*/  M_DrawReadThis1 ;\nint /*<<< orphan*/  M_FinishReadThis ;\nTYPE_1__ MainDef ;\nint /*<<< orphan*/ * MainMenu ;\nTYPE_4__ NewDef ;\nTYPE_3__ ReadDef1 ;\nTYPE_2__* ReadMenu1 ;\n#define  commercial 131\nTYPE_1__* currentMenu ;\nint gamemode ;\nint /*<<< orphan*/  itemOn ;\nscalar_t__ menuactive ;\nscalar_t__ messageLastMenuActive ;\nint /*<<< orphan*/ * messageString ;\nscalar_t__ messageToPrint ;\nint quickSaveSlot ;\nsize_t quitdoom ;\nsize_t readthis ;\n#define  registered 130\n#define  retail 129\nscalar_t__ screenSize ;\nscalar_t__ screenblocks ;\n#define  shareware 128\nint skullAnimCounter ;\nscalar_t__ whichSkull ;\n\nvoid M_Init (void)\n{\ncurrentMenu = &MainDef;\nmenuactive = 0;\nitemOn = currentMenu->lastOn;\nwhichSkull = 0;\nskullAnimCounter = 10;\nscreenSize = screenblocks - 3;\nmessageToPrint = 0;\nmessageString = NULL;\nmessageLastMenuActive = menuactive;\nquickSaveSlot = -1;\n\n// Here we could catch other version dependencies,\n//  like HELP1/2, and four episodes.\n\n\nswitch ( gamemode )\n{\ncase commercial:\n// This is used because DOOM 2 had only one HELP\n//  page. I use CREDIT as second page now, but\n//  kept this hack for educational purposes.\nMainMenu[readthis] = MainMenu[quitdoom];\nMainDef.numitems--;\nMainDef.y += 8;\nNewDef.prevMenu = &MainDef;\nReadDef1.routine = M_DrawReadThis1;\nReadDef1.x = 330;\nReadDef1.y = 165;\nReadMenu1[0].routine = M_FinishReadThis;\nbreak;\ncase shareware:\n// Episode 2 and 3 are handled,\n//  branching to an ad screen.\ncase registered:\n// We need to remove the fourth episode.\nEpiDef.numitems--;\nbreak;\ncase retail:\n// We are fine.\ndefault:\nbreak;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Buf ;\nint /*<<< orphan*/  M_Buf_Size ;\nint /*<<< orphan*/  M_Buf_Used ;\nint /*<<< orphan*/  M_Buf_Used_L ;\nint /*<<< orphan*/  M_Buf_Used_R ;\nint /*<<< orphan*/  M_Buf_Used_T ;\nint /*<<< orphan*/  M_Buf_Used_W ;\nint /*<<< orphan*/  M_Buf_Used_X ;\nint /*<<< orphan*/  M_Buf_Used_Y ;\nint /*<<< orphan*/  M_Buf_Used_Z ;\nint /*<<< orphan*/  M_Buf_Used_a ;\nint /*<<< orphan*/  M_Buf_Used_b ;\nint /*<<< orphan*/  M_Buf_Used_c ;\nint /*<<< orphan*/  M_Buf_Used_d ;\nint /*<<< orphan*/  M_Buf_Used_e ;\nint /*<<< orphan*/  M_Buf_Used_f ;\nint /*<<< orphan*/  M_Buf_Used_g ;\nint /*<<< orphan*/  M_Buf_Used_h ;\nint /*<<< orphan*/  M_Buf_Used_i ;\nint /*<<< orphan*/  M_Buf_Used_j ;\nint /*<<< orphan*/  M_Buf_Used_k ;\nint /*<<< orphan*/  M_Buf_Used_l ;\nint /*<<< orphan*/  M_Buf_Used_m ;\nint /*<<< orphan*/  M_Buf_Used_n ;\nint /*<<< orphan*/  M_Buf_Used_o ;\nint /*<<< orphan*/  M_Buf_Used_p ;\nint /*<<< orphan*/  M_Buf_Used_q ;\nint /*<<< orphan*/  M_Buf_Used_r ;\nint /*<<< orphan*/  M_Buf_Used_s ;\nint /*<<< orphan*/  M_Buf_Used_t ;\nint /*<<< orphan*/  M_Buf_Used_u ;\nint /*<<< orphan*/  M_Buf_Used_v ;\nint /*<<< orphan*/  M_Buf_Used_w ;\nint /*<<< orphan*/  M_Buf_Used_x ;\nint /*<<< orphan*/  M_Buf_Used_y ;\nint /*<<< orphan*/  M_Buf_Used_z ;\nint /*<<< orphan*/  M_Buf_Used_A ;\nint /*<<< orphan*/  M_Buf_Used_B ;\nint /*<<< orphan*/  M_Buf_Used_C ;\nint /*<<< orphan*/  M_Buf_Used_D ;\nint /*<<< orphan*/  M_Buf_Used_E ;\nint /*<<< orphan*/  M_Buf_Used_F ;\nint /*<<< orphan*/  M_Buf_Used_G ;\nint /*<<< orphan*/  M_Buf_Used_H ;\nint /*<<< orphan*/  M_Buf_Used_I ;\nint /*<<< orphan*/  M_Buf_Used_J ;\nint /*<<< orphan*/  M_Buf_Used_K ;\nint /*<<< orphan*/  M_Buf_Used_L ;\nint /*<<< orphan*/  M_Buf_Used_M ;\nint /*<<< orphan*/  M_Buf_Used_N ;\nint /*<<< orphan*/  M_Buf_Used_O ;\nint /*<<< orphan*/  M_Buf_Used_P ;\nint /*<<< orphan*/  M_Buf_Used_Q ;\nint /*<<< orphan*/  M_Buf_Used_R ;\nint /*<<< orphan*/  M_Buf_Used_S ;\nint /*<<< orphan*/  M_Buf_Used_T ;\nint /*<<< orphan*/  M_Buf_Used_U ;\nint /*<<< orphan*/  M_Buf_Used_V ;\nint /*<<< orphan*/  M_Buf_Used_W ;\nint /*<<< orphan*/  M_Buf_Used_X ;\nint /*<<< orphan*/  M_Buf_Used_Y ;\nint /*<<< orphan*/  M_Buf_Used_Z ;\nint /*<<< orphan*/  M_Buf_Used_a ;\nint /*<<< orphan*/  M_Buf_Used_b ;\nint /*<<< orphan*/  M_Buf_Used_c ;\nint /*<<< orphan*/  M_Buf_Used_d ;\nint /*<<< orphan*/  M_Buf_Used_e ;\nint /*<<< orphan*/  M_Buf_Used_f ;\nint /*<<< orphan*/  M_Buf_Used_g ;\nint /*<<< orphan*/  M_Buf_Used_h ;\nint /*<<< orphan*/  M_Buf_Used_i ;\nint /*<<< orphan*/  M_Buf_Used_j ;\nint /*<<< orphan*/  M_Buf_Used_k ;\nint /*<<< orphan*/  M_Buf_Used_l ;\nint /*<<< orphan*/  M_Buf_Used_m ;\nint /*<<< orphan*/  M_Buf_Used_n ;\nint /*<<< orphan*/  M_Buf_Used_o ;\nint /*<<< orphan*/  M_Buf_Used_p ;\nint /*<<< orphan*/  M_Buf_Used_q ;\nint /*<<< orphan*/  M_Buf_Used_r ;\nint /*<<< orphan*/  M_Buf_Used_s ;\nint /*<<< orphan*/  M_Buf_Used_t ;\nint /*<<< orphan*/  M_Buf_Used_u ;\nint /*<<< orphan*/  M_Buf_Used_v ;\nint /*<<< orphan*/  M_Buf_Used_w ;\nint /*<<< orphan*/  M_Buf_Used_x ;\nint /*<<< orphan*/  M_Buf_Used_y ;\nint /*<<< orphan*/  M_Buf_Used_z ;\nint /*<<< orphan*/  M_Buf_Used_A ;\nint /*<<< orphan*/  M_Buf_Used_B ;\nint /*<<< orphan*/  M_Buf_Used_C ;\nint /*<<< orphan*/  M_Buf_Used_D ;\nint /*<<< orphan*/  M_Buf_Used_E ;\nint /*<<< orphan*/  M_Buf_Used_F ;\nint /*<<< orphan*/  M_Buf_Used_G ;\nint /*<<< orphan*/  M_Buf_Used_H ;\nint /*<<< orphan*/  M_Buf_Used_I ;\nint /*<<< orphan*/  M_Buf_Used_J ;\nint /*<<< orphan*/  M_Buf_Used_K ;\nint /*<<< orphan*/  M_Buf_Used_L ;\nint /*<<< orphan*/  M_Buf_Used_M ;\nint /*<<< orphan*/  M_Buf_Used_N ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_P_CheckMeleeRange",
    "input":"\n0000000000000000 <P_CheckMeleeRange>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t(%rdi), %rbp\n7: \txorl\t%r14d, %r14d\na: \ttestq\t%rbp, %rbp\nd: \tje\t0x59 <P_CheckMeleeRange+0x59>\nf: \tmovq\t%rdi, %rbx\n12: \tmovq\t16(%rbp), %rsi\n16: \tmovq\t24(%rbp), %rdi\n1a: \tsubq\t24(%rbx), %rdi\n1e: \tsubq\t16(%rbx), %rsi\n22: \tcallq\t0x27 <P_CheckMeleeRange+0x27>\n27: \tmovl\t(%rip), %ecx  # 0x2d <P_CheckMeleeRange+0x2d>\n2d: \tmovl\t(%rip), %edx  # 0x33 <P_CheckMeleeRange+0x33>\n33: \tshll\t$2, %edx\n36: \tleal\t(%rdx,%rdx,4), %edx\n39: \tsubl\t%edx, %ecx\n3b: \tmovq\t8(%rbp), %rdx\n3f: \taddl\t(%rdx), %ecx\n41: \tcmpl\t%ecx, %eax\n43: \tjge\t0x59 <P_CheckMeleeRange+0x59>\n45: \tmovq\t(%rbx), %rsi\n48: \tmovq\t%rbx, %rdi\n4b: \tcallq\t0x50 <P_CheckMeleeRange+0x50>\n50: \txorl\t%r14d, %r14d\n53: \ttestl\t%eax, %eax\n55: \tsetne\t%r14b\n59: \tmovl\t%r14d, %eax\n5c: \tpopq\t%rbx\n5d: \tpopq\t%r14\n5f: \tpopq\t%rbp\n60: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {struct TYPE_7__* target; TYPE_1__* info; scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  int fixed_t ;\ntypedef  int boolean ;\nstruct TYPE_6__ {int radius; } ;\n\n/* Variables and functions */\nint FRACUNIT ;\nint MELEERANGE ;\nint P_AproxDistance (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  P_CheckSight (TYPE_2__*,TYPE_2__*) ;\n\nboolean P_CheckMeleeRange (mobj_t*\tactor)\n{\nmobj_t*\tpl;\nfixed_t\tdist;\n\nif (!actor->target)\nreturn false;\n\npl = actor->target;\ndist = P_AproxDistance (pl->x-actor->x, pl->y-actor->y);\n\nif (dist >= MELEERANGE-20*FRACUNIT+pl->info->radius)\nreturn false;\n\nif (! P_CheckSight (actor, actor->target) )\nreturn false;\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* player; } ;\nstruct TYPE_9__ {TYPE_1__* mo; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  TYPE_2__ player_t ;\ntypedef  TYPE_3__ pspdef_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckMeleeRange2 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange3 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange4 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange5 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange6 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange7 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange8 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange9 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange10 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange11 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange12 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange13 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange14 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange15 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange16 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange17 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange18 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange19 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange20 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange21 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange22 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange23 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange24 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange25 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange26 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange27 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange28 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange29 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange30 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange31 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange32 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange33 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange34 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange35 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange36 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange37 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange38 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange39 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange40 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange41 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange42 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange43 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange44 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange45 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange46 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange47 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange48 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange49 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange50 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange51 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange52 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange53 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange54 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange55 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange56 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange57 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange58 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange59 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< orphan*/  P_CheckMeleeRange60 (TYPE_3__*,TYPE_1__*) ;\nint /*<<< or"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_saveg.c_P_ArchivePlayers",
    "input":"\n0000000000000000 <P_ArchivePlayers>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tcmpl\t$0, (%rip)    # 0xb <P_ArchivePlayers+0xb>\nb: \tjle\t0xef <P_ArchivePlayers+0xef>\n11: \txorl\t%ebx, %ebx\n13: \tjmp\t0x34 <P_ArchivePlayers+0x34>\n15: \tnopw\t%cs:(%rax,%rax)\n1f: \tnop\n20: \taddq\t$1, %rbx\n24: \tmovslq\t(%rip), %rax  # 0x2b <P_ArchivePlayers+0x2b>\n2b: \tcmpq\t%rax, %rbx\n2e: \tjge\t0xef <P_ArchivePlayers+0xef>\n34: \tmovq\t(%rip), %rax  # 0x3b <P_ArchivePlayers+0x3b>\n3b: \tcmpl\t$0, (%rax,%rbx,4)\n3f: \tje\t0x20 <P_ArchivePlayers+0x20>\n41: \txorl\t%eax, %eax\n43: \tcallq\t0x48 <P_ArchivePlayers+0x48>\n48: \tmovq\t(%rip), %r14  # 0x4f <P_ArchivePlayers+0x4f>\n4f: \tleaq\t(,%rbx,4), %rsi\n57: \taddq\t(%rip), %rsi  # 0x5e <P_ArchivePlayers+0x5e>\n5e: \tmovq\t%r14, %rdi\n61: \tmovl\t$8, %edx\n66: \tcallq\t0x6b <P_ArchivePlayers+0x6b>\n6b: \taddq\t$8, (%rip)    # 0x73 <P_ArchivePlayers+0x73>\n73: \tmovl\t(%rip), %edx  # 0x79 <P_ArchivePlayers+0x79>\n79: \ttestl\t%edx, %edx\n7b: \tjle\t0x20 <P_ArchivePlayers+0x20>\n7d: \tmovq\t(%r14), %rax\n80: \tmovslq\t(%rip), %rcx  # 0x87 <P_ArchivePlayers+0x87>\n87: \tnegq\t%rcx\n8a: \tmovl\t%edx, %r8d\n8d: \tandl\t$1, %r8d\n91: \tcmpl\t$1, %edx\n94: \tjne\t0xb7 <P_ArchivePlayers+0xb7>\n96: \txorl\t%edi, %edi\n98: \ttestq\t%r8, %r8\n9b: \tje\t0x20 <P_ArchivePlayers+0x20>\n9d: \tmovq\t(%rax,%rdi,8), %rdx\na1: \ttestq\t%rdx, %rdx\na4: \tje\t0x20 <P_ArchivePlayers+0x20>\naa: \tleaq\t(%rdx,%rcx,4), %rcx\nae: \tmovq\t%rcx, (%rax,%rdi,8)\nb2: \tjmp\t0x20 <P_ArchivePlayers+0x20>\nb7: \tsubq\t%r8, %rdx\nba: \txorl\t%edi, %edi\nbc: \tjmp\t0xc9 <P_ArchivePlayers+0xc9>\nbe: \tnop\nc0: \taddq\t$2, %rdi\nc4: \tcmpq\t%rdi, %rdx\nc7: \tje\t0x98 <P_ArchivePlayers+0x98>\nc9: \tmovq\t(%rax,%rdi,8), %rsi\ncd: \ttestq\t%rsi, %rsi\nd0: \tje\t0xda <P_ArchivePlayers+0xda>\nd2: \tleaq\t(%rsi,%rcx,4), %rsi\nd6: \tmovq\t%rsi, (%rax,%rdi,8)\nda: \tmovq\t8(%rax,%rdi,8), %rsi\ndf: \ttestq\t%rsi, %rsi\ne2: \tje\t0xc0 <P_ArchivePlayers+0xc0>\ne4: \tleaq\t(%rsi,%rcx,4), %rsi\ne8: \tmovq\t%rsi, 8(%rax,%rdi,8)\ned: \tjmp\t0xc0 <P_ArchivePlayers+0xc0>\nef: \taddq\t$8, %rsp\nf3: \tpopq\t%rbx\nf4: \tpopq\t%r14\nf6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  state_t ;\nstruct TYPE_5__ {TYPE_1__* psprites; } ;\ntypedef  TYPE_2__ player_t ;\nstruct TYPE_4__ {int /*<<< orphan*/ * state; } ;\n\n/* Variables and functions */\nint MAXPLAYERS ;\nint NUMPSPRITES ;\nint /*<<< orphan*/  PADSAVEP () ;\nint /*<<< orphan*/  memcpy (TYPE_2__*,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ * playeringame ;\nint /*<<< orphan*/ * players ;\nscalar_t__ save_p ;\nint states ;\n\nvoid P_ArchivePlayers (void)\n{\nint\t\ti;\nint\t\tj;\nplayer_t*\tdest;\n\nfor (i=0 ; i<MAXPLAYERS ; i++)\n{\nif (!playeringame[i])\ncontinue;\n\nPADSAVEP();\n\ndest = (player_t *)save_p;\nmemcpy (dest,&players[i],sizeof(player_t));\nsave_p += sizeof(player_t);\nfor (j=0 ; j<NUMPSPRITES ; j++)\n{\nif (dest->psprites[j].state)\n{\ndest->psprites[j].state\n= (state_t *)(dest->psprites[j].state-states);\n}\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* player; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (TYPE_1__*,int*,int) ;\nint numplayers ;\nint* players ;\nint* players_to_archive ;\nsize_t players_to_archive_index ;\n\nvoid P_ArchivePlayers (void)\n{\nint i;\n\nfor (i=0; i<numplayers; ++i)\n{\nif (!players_to_archive[i])\ncontinue;\n\nmemcpy (&players[players_to_archive_index], &players[i], sizeof(players[0]));\nplayers_to_archive_index += sizeof(players[0]);\n\nif (numplayers & 1)\n{\nif (players[i].player[0])\nplayers[i].player[0] += players_to_archive_index;\nif (players[i].player[1])\nplayers[i].player[1] += players_to_archive_index;\n}\nelse\n{\nint j;\n\nfor (j=0; j<numplayers; j+=2)\n{\nif (players[i].player[j])\nplayers[i].player[j] += players_to_archive_index;\nif (players[i].player[j+1])\nplayers[i].player[j+1] += players_to_archive_index;\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_addPrefixToIText",
    "input":"\n0000000000000000 <HUlib_addPrefixToIText>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovb\t(%rsi), %al\n9: \ttestb\t%al, %al\nb: \tje\t0x36 <HUlib_addPrefixToIText+0x36>\nd: \tmovq\t%rsi, %rbx\n10: \taddq\t$1, %rbx\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tmovsbl\t%al, %esi\n23: \tmovq\t%r14, %rdi\n26: \tcallq\t0x2b <HUlib_addPrefixToIText+0x2b>\n2b: \tmovzbl\t(%rbx), %eax\n2e: \taddq\t$1, %rbx\n32: \ttestb\t%al, %al\n34: \tjne\t0x20 <HUlib_addPrefixToIText+0x20>\n36: \tmovl\t(%r14), %eax\n39: \tmovl\t%eax, 4(%r14)\n3d: \taddq\t$8, %rsp\n41: \tpopq\t%rbx\n42: \tpopq\t%r14\n44: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  len; } ;\nstruct TYPE_4__ {TYPE_3__ l; int /*<<< orphan*/  lm; } ;\ntypedef  TYPE_1__ hu_itext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_addCharToTextLine (TYPE_3__*,int /*<<< orphan*/ ) ;\n\nvoid\nHUlib_addPrefixToIText\n( hu_itext_t*\tit,\nchar*\t\tstr )\n{\nwhile (*str)\nHUlib_addCharToTextLine(&it->l, *(str++));\nit->lm = it->l.len;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  len; int /*<<< orphan*/  text; } ;\ntypedef  TYPE_1__ HUCharIText ;\ntypedef  char HUChar ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_addCharToIText (TYPE_1__*,char) ;\n\nvoid HUlib_addPrefixToIText(HUCharIText *it, const HUChar *prefix)\n{\nwhile (*prefix)\n{\nHUlib_addCharToIText(it, *prefix);\nprefix++;\n}\nit->len = it->text;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_initData",
    "input":"\n0000000000000000 <ST_initData>:\n0: \tmovq\t(%rip), %rax  # 0x7 <ST_initData+0x7>\n7: \tshlq\t$3, %rax\nb: \taddq\t(%rip), %rax  # 0x12 <ST_initData+0x12>\n12: \tmovl\t$1, (%rip)    # 0x1c <ST_initData+0x1c>\n1c: \tmovq\t%rax, (%rip)  # 0x23 <ST_initData+0x23>\n23: \tmovq\t$0, (%rip)    # 0x2e <ST_initData+0x2e>\n2e: \tmovl\t(%rip), %ecx  # 0x34 <ST_initData+0x34>\n34: \tmovl\t%ecx, (%rip)  # 0x3a <ST_initData+0x3a>\n3a: \tmovl\t(%rip), %ecx  # 0x40 <ST_initData+0x40>\n40: \tmovl\t%ecx, (%rip)  # 0x46 <ST_initData+0x46>\n46: \tmovl\t$1, (%rip)    # 0x50 <ST_initData+0x50>\n50: \tmovl\t$0, (%rip)    # 0x5a <ST_initData+0x5a>\n5a: \tmovl\t$0, (%rip)    # 0x64 <ST_initData+0x64>\n64: \tmovl\t$0, (%rip)    # 0x6e <ST_initData+0x6e>\n6e: \tmovq\t$0, (%rip)    # 0x79 <ST_initData+0x79>\n79: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0x83 <ST_initData+0x83>\n83: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0x8d <ST_initData+0x8d>\n8d: \tcmpl\t$0, (%rip)    # 0x94 <ST_initData+0x94>\n94: \tjle\t0xc6 <ST_initData+0xc6>\n96: \tmovq\t(%rax), %rax\n99: \tmovq\t(%rip), %rcx  # 0xa0 <ST_initData+0xa0>\na0: \txorl\t%edx, %edx\na2: \tnopw\t%cs:(%rax,%rax)\nac: \tnopl\t(%rax)\nb0: \tmovl\t(%rax,%rdx,4), %esi\nb3: \tmovl\t%esi, (%rcx,%rdx,4)\nb6: \taddq\t$1, %rdx\nba: \tmovslq\t(%rip), %rsi  # 0xc1 <ST_initData+0xc1>\nc1: \tcmpq\t%rsi, %rdx\nc4: \tjl\t0xb0 <ST_initData+0xb0>\nc6: \tmovq\t(%rip), %rax  # 0xcd <ST_initData+0xcd>\ncd: \tmovl\t$4294967295, 8(%rax)    # imm = 0xFFFFFFFF\nd4: \tmovq\t$-1, (%rax)\ndb: \txorl\t%eax, %eax\ndd: \tjmp\t0xe2 <ST_initData+0xe2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * weaponowned; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FirstPersonState ;\nint NUMWEAPONS ;\nint /*<<< orphan*/  STlib_init () ;\nint /*<<< orphan*/  StartChatState ;\nsize_t consoleplayer ;\nint* keyboxes ;\nint /*<<< orphan*/ * oldweaponsowned ;\nTYPE_1__* players ;\nTYPE_1__* plyr ;\nint st_chat ;\nint /*<<< orphan*/  st_chatstate ;\nscalar_t__ st_clock ;\nint st_cursoron ;\nscalar_t__ st_faceindex ;\nint st_firsttime ;\nint /*<<< orphan*/  st_gamestate ;\nint st_oldchat ;\nint st_oldhealth ;\nint st_palette ;\nint st_statusbaron ;\n\nvoid ST_initData(void)\n{\n\nint\t\ti;\n\nst_firsttime = true;\nplyr = &players[consoleplayer];\n\nst_clock = 0;\nst_chatstate = StartChatState;\nst_gamestate = FirstPersonState;\n\nst_statusbaron = true;\nst_oldchat = st_chat = false;\nst_cursoron = false;\n\nst_faceindex = 0;\nst_palette = -1;\n\nst_oldhealth = -1;\n\nfor (i=0;i<NUMWEAPONS;i++)\noldweaponsowned[i] = plyr->weaponowned[i];\n\nfor (i=0;i<3;i++)\nkeyboxes[i] = -1;\n\nSTlib_init();\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * data; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_data ;\nint /*<<< orphan*/  ST_data_len ;\nint /*<<< orphan*/  ST_data_pos ;\nint /*<<< orphan*/  ST_data_pos_end ;\nint /*<<< orphan*/  ST_data_pos_start ;\nint /*<<< orphan*/  ST_data_pos_start_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig ;\nint /*<<< orphan*/  ST_data_pos_start_orig_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_orig_len_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_ExtractFileBase",
    "input":"\n0000000000000000 <ExtractFileBase>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rsi, %r14\nb: \tmovq\t%rdi, %r15\ne: \tcallq\t0x13 <ExtractFileBase+0x13>\n13: \tmovslq\t%eax, %r12\n16: \tnopw\t%cs:(%rax,%rax)\n20: \tcmpq\t$1, %r12\n24: \tje\t0x3d <ExtractFileBase+0x3d>\n26: \tmovzbl\t-2(%r15,%r12), %eax\n2c: \taddq\t$-1, %r12\n30: \tcmpb\t$92, %al\n32: \tje\t0x38 <ExtractFileBase+0x38>\n34: \tcmpb\t$47, %al\n36: \tjne\t0x20 <ExtractFileBase+0x20>\n38: \taddq\t%r15, %r12\n3b: \tjmp\t0x40 <ExtractFileBase+0x40>\n3d: \tmovq\t%r15, %r12\n40: \txorl\t%ebx, %ebx\n42: \tmovq\t%r14, %rdi\n45: \txorl\t%esi, %esi\n47: \tmovl\t$8, %edx\n4c: \tcallq\t0x51 <ExtractFileBase+0x51>\n51: \tjmp\t0x70 <ExtractFileBase+0x70>\n53: \tnopw\t%cs:(%rax,%rax)\n5d: \tnopl\t(%rax)\n60: \tmovsbl\t%al, %edi\n63: \tcallq\t0x68 <ExtractFileBase+0x68>\n68: \tmovb\t%al, (%r14,%rbx)\n6c: \taddq\t$1, %rbx\n70: \tmovzbl\t(%r12,%rbx), %eax\n75: \ttestb\t%al, %al\n77: \tje\t0x96 <ExtractFileBase+0x96>\n79: \tcmpb\t$46, %al\n7b: \tje\t0x96 <ExtractFileBase+0x96>\n7d: \tcmpl\t$8, %ebx\n80: \tjne\t0x60 <ExtractFileBase+0x60>\n82: \tmovl\t$0, %edi\n87: \tmovq\t%r15, %rsi\n8a: \tcallq\t0x8f <ExtractFileBase+0x8f>\n8f: \tmovzbl\t(%r12,%rbx), %eax\n94: \tjmp\t0x60 <ExtractFileBase+0x60>\n96: \taddq\t$8, %rsp\n9a: \tpopq\t%rbx\n9b: \tpopq\t%r12\n9d: \tpopq\t%r14\n9f: \tpopq\t%r15\na1: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,char*) ;\nint /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ;\nint strlen (char*) ;\nint /*<<< orphan*/  toupper (int) ;\n\nvoid\nExtractFileBase\n( char*\t\tpath,\nchar*\t\tdest )\n{\nchar*\tsrc;\nint\t\tlength;\n\nsrc = path + strlen(path) - 1;\n\n// back up until a \\ or the start\nwhile (src != path\n&& *(src-1) != '\\\\'\n&& *(src-1) != '/')\n{\nsrc--;\n}\n\n// copy up to eight characters\nmemset (dest,0,8);\nlength = 0;\n\nwhile (*src && *src != '.')\n{\nif (++length == 9)\nI_Error (\"Filename base of %s >8 chars\",path);\n\n*dest++ = toupper((int)*src++);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WCHAR ;\ntypedef  int /*<<< orphan*/  LPCWSTR ;\ntypedef  int /*<<< orphan*/  LPWSTR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FIXME (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int) ;\nint strlenW (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  tolowerW (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void ExtractFileBase(LPCWSTR path, LPWSTR base)\n{\nLPCWSTR ptr;\nint len;\n\nptr = path + strlenW(path);\nwhile (ptr > path && *ptr != '\\\\' && *ptr != '/')\nptr--;\n\nmemset(base, 0, sizeof(WCHAR) * 8);\nlen = 0;\nwhile (*ptr && len < 8)\n{\nbase[len++] = tolowerW(*ptr++);\n}\nif (len == 8)\n{\nFIXME(\"Path %s is too long\\n\", path);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_LumpLength",
    "input":"\n0000000000000000 <W_LumpLength>:\n0: \tpushq\t%rbx\n1: \tmovl\t%edi, %ebx\n3: \tcmpl\t%edi, (%rip)  # 0x9 <W_LumpLength+0x9>\n9: \tjg\t0x17 <W_LumpLength+0x17>\nb: \tmovl\t$0, %edi\n10: \tmovl\t%ebx, %esi\n12: \tcallq\t0x17 <W_LumpLength+0x17>\n17: \tmovq\t(%rip), %rax  # 0x1e <W_LumpLength+0x1e>\n1e: \tmovslq\t%ebx, %rcx\n21: \tmovl\t(%rax,%rcx,4), %eax\n24: \tpopq\t%rbx\n25: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int) ;\nTYPE_1__* lumpinfo ;\nint numlumps ;\n\nint W_LumpLength (int lump)\n{\nif (lump >= numlumps)\nI_Error (\"W_LumpLength: %i >= numlumps\",lump);\n\nreturn lumpinfo[lump].size;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  int32_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int) ;\nint NUM_LUMPS ;\nint /*<<< orphan*/ * lumpinfo ;\n\nint32_t\nW_LumpLength(int lump)\n{\nif (lump >= NUM_LUMPS)\nI_Error(\"W_LumpLength: %i >= NUM_LUMPS\", lump);\nreturn lumpinfo[lump];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_bbox.c_M_AddToBox",
    "input":"\n0000000000000000 <M_AddToBox>:\n0: \tmovq\t(%rip), %rax  # 0x7 <M_AddToBox+0x7>\n7: \tcmpq\t%rsi, (%rdi,%rax,8)\nb: \tjg\t0x1a <M_AddToBox+0x1a>\nd: \tmovq\t(%rip), %rax  # 0x14 <M_AddToBox+0x14>\n14: \tcmpq\t%rsi, (%rdi,%rax,8)\n18: \tjge\t0x21 <M_AddToBox+0x21>\n1a: \tleaq\t(%rdi,%rax,8), %rax\n1e: \tmovq\t%rsi, (%rax)\n21: \tmovq\t(%rip), %rax  # 0x28 <M_AddToBox+0x28>\n28: \tcmpq\t%rdx, (%rdi,%rax,8)\n2c: \tjg\t0x3b <M_AddToBox+0x3b>\n2e: \tmovq\t(%rip), %rax  # 0x35 <M_AddToBox+0x35>\n35: \tcmpq\t%rdx, (%rdi,%rax,8)\n39: \tjge\t0x42 <M_AddToBox+0x42>\n3b: \tleaq\t(%rdi,%rax,8), %rax\n3f: \tmovq\t%rdx, (%rax)\n42: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nsize_t BOXBOTTOM ;\nsize_t BOXLEFT ;\nsize_t BOXRIGHT ;\nsize_t BOXTOP ;\n\nvoid\nM_AddToBox\n( fixed_t*\tbox,\nfixed_t\tx,\nfixed_t\ty )\n{\nif (x<box[BOXLEFT])\nbox[BOXLEFT] = x;\nelse if (x>box[BOXRIGHT])\nbox[BOXRIGHT] = x;\nif (y<box[BOXBOTTOM])\nbox[BOXBOTTOM] = y;\nelse if (y>box[BOXTOP])\nbox[BOXTOP] = y;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x1; scalar_t__ y1; } ;\ntypedef  TYPE_1__ M_Box ;\n\n/* Variables and functions */\nsize_t M_Box_X1 ;\nsize_t M_Box_Y1 ;\n\n__attribute__((used)) static void\nM_AddToBox(M_Box *box, scalar_t x, scalar_t y)\n{\nif (x < box->x1)\nbox->x1 = x;\nelse if (x > box->x1)\nbox->x1 = x;\n\nif (y < box->y1)\nbox->y1 = y;\nelse if (y > box->y1)\nbox->y1 = y;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_doors.c_P_SpawnDoorCloseIn30",
    "input":"\n0000000000000000 <P_SpawnDoorCloseIn30>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t(%rip), %esi  # 0xd <P_SpawnDoorCloseIn30+0xd>\nd: \tmovl\t$40, %edi\n12: \txorl\t%edx, %edx\n14: \tcallq\t0x19 <P_SpawnDoorCloseIn30+0x19>\n19: \tmovq\t%rax, %rbx\n1c: \tleaq\t32(%rax), %rdi\n20: \tcallq\t0x25 <P_SpawnDoorCloseIn30+0x25>\n25: \tmovq\t%rbx, 8(%r14)\n29: \tmovq\t$0, (%r14)\n30: \tmovq\t(%rip), %rax  # 0x37 <P_SpawnDoorCloseIn30+0x37>\n37: \tmovq\t%rax, 32(%rbx)\n3b: \tmovq\t%r14, 24(%rbx)\n3f: \tmovq\t$0, 16(%rbx)\n47: \tmovl\t(%rip), %eax  # 0x4d <P_SpawnDoorCloseIn30+0x4d>\n4d: \tmovl\t%eax, 8(%rbx)\n50: \tmovl\t(%rip), %eax  # 0x56 <P_SpawnDoorCloseIn30+0x56>\n56: \tmovl\t%eax, 4(%rbx)\n59: \tmovl\t$1050, (%rbx) # imm = 0x41A\n5f: \taddq\t$8, %rsp\n63: \tpopq\t%rbx\n64: \tpopq\t%r14\n66: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_6__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {scalar_t__ acp1; } ;\nstruct TYPE_10__ {TYPE_1__ function; } ;\nstruct TYPE_8__ {int topcountdown; int /*<<< orphan*/  speed; int /*<<< orphan*/  type; scalar_t__ direction; TYPE_3__* sector; TYPE_6__ thinker; } ;\ntypedef  TYPE_2__ vldoor_t ;\nstruct TYPE_9__ {scalar_t__ special; TYPE_2__* specialdata; } ;\ntypedef  TYPE_3__ sector_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_LEVSPEC ;\nint /*<<< orphan*/  P_AddThinker (TYPE_6__*) ;\nscalar_t__ T_VerticalDoor ;\nint /*<<< orphan*/  VDOORSPEED ;\nTYPE_2__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  normal ;\n\nvoid P_SpawnDoorCloseIn30 (sector_t* sec)\n{\nvldoor_t*\tdoor;\n\ndoor = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\nP_AddThinker (&door->thinker);\n\nsec->specialdata = door;\nsec->special = 0;\n\ndoor->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\ndoor->sector = sec;\ndoor->direction = 0;\ndoor->type = normal;\ndoor->speed = VDOORSPEED;\ndoor->topcountdown = 30 * 35;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/ * next; TYPE_2__* spawn; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  spawn_id; int /*<<< orphan*/  spawn_type; int /*<<< orphan*/  spawn_flags; int /*<<< orphan*/ * spawn_data; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  next; TYPE_3__* spawn; } ;\ntypedef  TYPE_1__* Pspawn_t ;\ntypedef  TYPE_2__* Spawn_t ;\ntypedef  TYPE_3__* Pspawn_t_DoorCloseIn30 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_SpawnDoorCloseIn30_Spawn ;\nint /*<<< orphan*/  P_SpawnDoorCloseIn30_SpawnFlags ;\nint /*<<< orphan*/  P_SpawnDoorCloseIn30_SpawnType ;\nint /*<<< orphan*/  P_SpawnDoorCloseIn30_SpawnUser ;\nTYPE_1__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_3__*,int /*<<< orphan*/ ,int) ;\n\nvoid P_SpawnDoorCloseIn30(Pspawn_t *psp)\n{\nPspawn_t_DoorCloseIn30 *sp;\n\nsp = (Pspawn_t_DoorCloseIn30 *)Z_Malloc(sizeof(*sp), P_SpawnDoorCloseIn30_Spawn, 0);\nmemset(sp, 0, sizeof(*sp));\n\npsp->spawn = (Spawn_t *)sp;\npsp->next = NULL;\n\nsp->spawn_id = P_SpawnDoorCloseIn30_SpawnUser;\nsp->spawn_type = P_SpawnDoorCloseIn30_SpawnType;\nsp->spawn_flags = P_SpawnDoorCloseIn30_SpawnFlags;\nsp->spawn_data = NULL;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_swap.c_SwapLONG",
    "input":"\n0000000000000000 <SwapLONG>:\n0: \tmovq\t%rdi, %rcx\n3: \tshrq\t$24, %rcx\n7: \tmovq\t%rdi, %rdx\na: \tshrq\t$8, %rdx\ne: \tandl\t$65280, %edx  # imm = 0xFF00\n14: \tmovl\t%edi, %eax\n16: \tshll\t$8, %eax\n19: \tandl\t$16711680, %eax    # imm = 0xFF0000\n1e: \tshlq\t$24, %rdi\n22: \torq\t%rcx, %rdi\n25: \torq\t%rdx, %rdi\n28: \torq\t%rdi, %rax\n2b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nunsigned long SwapLONG( unsigned long x)\n{\nreturn\n(x>>24)\n| ((x>>8) & 0xff00)\n| ((x<<8) & 0xff0000)\n| (x<<24);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ DWORD ;\n\n/* Variables and functions */\n\n__attribute__((used)) static DWORD SwapLONG(DWORD dw)\n{\nreturn (dw >> 24) | ((dw >> 8) & 0xff00) | ((dw << 8) & 0xff0000) | (dw << 24);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_clearTextLine",
    "input":"\n0000000000000000 <HUlib_clearTextLine>:\n0: \tmovq\t$0, 16(%rdi)\n8: \tmovq\t8(%rdi), %rax\nc: \tmovq\t$0, (%rax)\n13: \tmovl\t$1, (%rdi)\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int needsupdate; scalar_t__* l; scalar_t__ len; } ;\ntypedef  TYPE_1__ hu_textline_t ;\n\n/* Variables and functions */\n\nvoid HUlib_clearTextLine(hu_textline_t* t)\n{\nt->len = 0;\nt->l[0] = 0;\nt->needsupdate = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  dirty; scalar_t__* text; scalar_t__* text_end; } ;\ntypedef  TYPE_1__ HUCHAR_INFO ;\n\n/* Variables and functions */\n\nvoid HUlib_clearTextLine(HUCHAR_INFO *info)\n{\ninfo->text = info->text_end = info->text + 1;\ninfo->dirty = 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_TroopAttack",
    "input":"\n0000000000000000 <A_TroopAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x51 <A_TroopAttack+0x51>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_TroopAttack+0xe>\ne: \tmovq\t%rbx, %rdi\n11: \tcallq\t0x16 <A_TroopAttack+0x16>\n16: \ttestq\t%rax, %rax\n19: \tje\t0x53 <A_TroopAttack+0x53>\n1b: \tmovl\t(%rip), %esi  # 0x21 <A_TroopAttack+0x21>\n21: \tmovq\t%rbx, %rdi\n24: \tcallq\t0x29 <A_TroopAttack+0x29>\n29: \txorl\t%eax, %eax\n2b: \tcallq\t0x30 <A_TroopAttack+0x30>\n30: \tleal\t7(%rax), %ecx\n33: \ttestl\t%eax, %eax\n35: \tcmovnsl\t%eax, %ecx\n38: \tandl\t$-8, %ecx\n3b: \tsubl\t%ecx, %eax\n3d: \tleal\t(%rax,%rax,2), %ecx\n40: \taddl\t$3, %ecx\n43: \tmovl\t(%rbx), %edi\n45: \tmovq\t%rbx, %rsi\n48: \tmovq\t%rbx, %rdx\n4b: \tpopq\t%rbx\n4c: \tjmp\t0x51 <A_TroopAttack+0x51>\n51: \tpopq\t%rbx\n52: \tretq\n53: \tmovl\t(%rbx), %esi\n55: \tmovl\t(%rip), %edx  # 0x5b <A_TroopAttack+0x5b>\n5b: \tmovq\t%rbx, %rdi\n5e: \tpopq\t%rbx\n5f: \tjmp\t0x64 <A_TroopAttack+0x64>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  MT_TROOPSHOT ;\nscalar_t__ P_CheckMeleeRange (TYPE_1__*) ;\nint /*<<< orphan*/  P_DamageMobj (int /*<<< orphan*/ ,TYPE_1__*,TYPE_1__*,int) ;\nint P_Random () ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_claw ;\n\nvoid A_TroopAttack (mobj_t* actor)\n{\nint\t\tdamage;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nif (P_CheckMeleeRange (actor))\n{\nS_StartSound (actor, sfx_claw);\ndamage = (P_Random()%8+1)*3;\nP_DamageMobj (actor->target, actor, actor, damage);\nreturn;\n}\n\n\n// launch a missile\nP_SpawnMissile (actor, actor->target, MT_TROOPSHOT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  boss; } ;\ntypedef  TYPE_1__ Enemy ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_BossAttack (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_BossDie (TYPE_1__*) ;\nint /*<<< orphan*/  A_BossMove (TYPE_1__*) ;\nint /*<<< orphan*/  A_BossSpawn (TYPE_1__*) ;\nint /*<<< orphan*/  BOSS_TROOP ;\nscalar_t__ BOSS_TROOP_SPAWN_TIME ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_X ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Y ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z2 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z3 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z4 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z5 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z6 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z7 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z8 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z9 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z10 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z11 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z12 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z13 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z14 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z15 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z16 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z17 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z18 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z19 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z20 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z21 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z22 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z23 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z24 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z25 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z26 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z27 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z28 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z29 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z30 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z31 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z32 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z33 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z34 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z35 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z36 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z37 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z38 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z39 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z40 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z41 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z42 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z43 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z44 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z45 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z46 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z47 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z48 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z49 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z50 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z51 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z52 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z53 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z54 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z55 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z56 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z57 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z58 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z59 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z60 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z61 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z62 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z63 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z64 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z65 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z66 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z67 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z68 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z69 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z70 ;\nint /*<<< orphan*/  BOSS_TROOP_SPAWN_Z71 ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_user.c_P_Thrust",
    "input":"\n0000000000000000 <P_Thrust>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %rbx\n7: \tmovb\t(%rip), %cl   # 0xd <P_Thrust+0xd>\nd: \tshrq\t%cl, %rbx\n10: \tmovl\t%edx, %ebp\n12: \tmovq\t%rdi, %r14\n15: \tmovq\t(%rip), %rax  # 0x1c <P_Thrust+0x1c>\n1c: \tmovl\t(%rax,%rbx,4), %esi\n1f: \tmovl\t%edx, %edi\n21: \tcallq\t0x26 <P_Thrust+0x26>\n26: \tmovq\t(%r14), %rcx\n29: \taddl\t%eax, 4(%rcx)\n2c: \tmovq\t(%rip), %rax  # 0x33 <P_Thrust+0x33>\n33: \tmovl\t(%rax,%rbx,4), %esi\n36: \tmovl\t%ebp, %edi\n38: \tcallq\t0x3d <P_Thrust+0x3d>\n3d: \tmovq\t(%r14), %rcx\n40: \taddl\t%eax, (%rcx)\n42: \tpopq\t%rbx\n43: \tpopq\t%r14\n45: \tpopq\t%rbp\n46: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* mo; } ;\ntypedef  TYPE_2__ player_t ;\ntypedef  int /*<<< orphan*/  fixed_t ;\ntypedef  size_t angle_t ;\nstruct TYPE_4__ {int /*<<< orphan*/  momy; int /*<<< orphan*/  momx; } ;\n\n/* Variables and functions */\nsize_t ANGLETOFINESHIFT ;\nscalar_t__ FixedMul (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * finecosine ;\nint /*<<< orphan*/ * finesine ;\n\nvoid\nP_Thrust\n( player_t*\tplayer,\nangle_t\tangle,\nfixed_t\tmove )\n{\nangle >>= ANGLETOFINESHIFT;\n\nplayer->mo->momx += FixedMul(move,finecosine[angle]);\nplayer->mo->momy += FixedMul(move,finesine[angle]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* thrust; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint P_ThrustTable ;\nint* P_ThrustTable_X ;\nint P_ThrustTable_Y ;\nint P_ThrustTable_Z ;\nint P_ThrustTable_Z2 ;\nint P_ThrustTable_Z3 ;\nint P_ThrustTable_Z4 ;\nint P_ThrustTable_Z5 ;\nint P_ThrustTable_Z6 ;\nint P_ThrustTable_Z7 ;\nint P_ThrustTable_Z8 ;\nint P_ThrustTable_Z9 ;\n\nvoid P_Thrust(player_t *player, int thrust, int thrust_dir)\n{\nint i;\n\ni = thrust >> P_ThrustTable;\nplayer->thrust[0] += P_ThrustTable_X[i];\nplayer->thrust[1] += P_ThrustTable_Y[i];\nplayer->thrust[2] += P_ThrustTable_Z[i];\nplayer->thrust[3] += P_ThrustTable_Z2[i];\nplayer->thrust[4] += P_ThrustTable_Z3[i];\nplayer->thrust[5] += P_ThrustTable_Z4[i];\nplayer->thrust[6] += P_ThrustTable_Z5[i];\nplayer->thrust[7] += P_ThrustTable_Z6[i];\nplayer->thrust[8] += P_ThrustTable_Z7[i];\nplayer->thrust[9] += P_ThrustTable_Z8[i];\nplayer->thrust[10] += P_ThrustTable_Z9[i];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_CyberAttack",
    "input":"\n0000000000000000 <A_CyberAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x1f <A_CyberAttack+0x1f>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_CyberAttack+0xe>\ne: \tmovl\t(%rbx), %esi\n10: \tmovl\t(%rip), %edx  # 0x16 <A_CyberAttack+0x16>\n16: \tmovq\t%rbx, %rdi\n19: \tpopq\t%rbx\n1a: \tjmp\t0x1f <A_CyberAttack+0x1f>\n1f: \tpopq\t%rbx\n20: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  MT_ROCKET ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_CyberAttack (mobj_t* actor)\n{\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nP_SpawnMissile (actor, actor->target, MT_ROCKET);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  boss; } ;\ntypedef  TYPE_1__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_CyberAttack_Boss ;\nint /*<<< orphan*/  A_SpawnCyber (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nvoid A_CyberAttack(Actor *actor)\n{\nif (!actor->boss)\n{\nA_SetAnim(actor, A_CyberAttack_Boss);\nA_SpawnCyber(actor, actor->boss, A_CyberAttack_Boss);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawPercent",
    "input":"\n0000000000000000 <WI_drawPercent>:\n0: \ttestl\t%edx, %edx\n2: \tjs\t0x35 <WI_drawPercent+0x35>\n4: \tpushq\t%rbp\n5: \tpushq\t%r14\n7: \tpushq\t%rbx\n8: \tmovl\t%edx, %ebx\na: \tmovl\t%esi, %r14d\nd: \tmovl\t%edi, %ebp\nf: \tmovl\t(%rip), %edx  # 0x15 <WI_drawPercent+0x15>\n15: \tmovl\t(%rip), %ecx  # 0x1b <WI_drawPercent+0x1b>\n1b: \tcallq\t0x20 <WI_drawPercent+0x20>\n20: \tmovl\t%ebp, %edi\n22: \tmovl\t%r14d, %esi\n25: \tmovl\t%ebx, %edx\n27: \tmovl\t$4294967295, %ecx  # imm = 0xFFFFFFFF\n2c: \tpopq\t%rbx\n2d: \tpopq\t%r14\n2f: \tpopq\t%rbp\n30: \tjmp\t0x35 <WI_drawPercent+0x35>\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  FB ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WI_drawNum (int,int,int,int) ;\nint /*<<< orphan*/  percent ;\n\nvoid\nWI_drawPercent\n( int\t\tx,\nint\t\ty,\nint\t\tp )\n{\nif (p < 0)\nreturn;\n\nV_DrawPatch(x, y, FB, percent);\nWI_drawNum(x, y, p, -1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\ntypedef  int /*<<< orphan*/  UWORD ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawBar (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  WI_fg ;\nint /*<<< orphan*/  WI_getX () ;\nint /*<<< orphan*/  WI_getY () ;\n\nvoid WI_drawPercent(UBYTE percent, UWORD x, UWORD y)\n{\nif (percent < 0)\nreturn;\n\nWI_drawBar(WI_getX(), WI_getY(), WI_fg, percent);\nWI_drawBar(x, y, WI_fg, 0xFFFF);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BruisAttack",
    "input":"\n0000000000000000 <A_BruisAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x4c <A_BruisAttack+0x4c>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_BruisAttack+0xe>\ne: \ttestq\t%rax, %rax\n11: \tje\t0x4e <A_BruisAttack+0x4e>\n13: \tmovl\t(%rip), %esi  # 0x19 <A_BruisAttack+0x19>\n19: \tmovq\t%rbx, %rdi\n1c: \tcallq\t0x21 <A_BruisAttack+0x21>\n21: \txorl\t%eax, %eax\n23: \tcallq\t0x28 <A_BruisAttack+0x28>\n28: \tleal\t7(%rax), %ecx\n2b: \ttestl\t%eax, %eax\n2d: \tcmovnsl\t%eax, %ecx\n30: \tandl\t$-8, %ecx\n33: \tsubl\t%ecx, %eax\n35: \tleal\t(%rax,%rax,4), %eax\n38: \tleal\t(%rax,%rax), %ecx\n3b: \taddl\t$10, %ecx\n3e: \tmovl\t(%rbx), %edi\n40: \tmovq\t%rbx, %rsi\n43: \tmovq\t%rbx, %rdx\n46: \tpopq\t%rbx\n47: \tjmp\t0x4c <A_BruisAttack+0x4c>\n4c: \tpopq\t%rbx\n4d: \tretq\n4e: \tmovl\t(%rbx), %esi\n50: \tmovl\t(%rip), %edx  # 0x56 <A_BruisAttack+0x56>\n56: \tmovq\t%rbx, %rdi\n59: \tpopq\t%rbx\n5a: \tjmp\t0x5f <A_BruisAttack+0x5f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MT_BRUISERSHOT ;\nscalar_t__ P_CheckMeleeRange (TYPE_1__*) ;\nint /*<<< orphan*/  P_DamageMobj (int /*<<< orphan*/ ,TYPE_1__*,TYPE_1__*,int) ;\nint P_Random () ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_claw ;\n\nvoid A_BruisAttack (mobj_t* actor)\n{\nint\t\tdamage;\n\nif (!actor->target)\nreturn;\n\nif (P_CheckMeleeRange (actor))\n{\nS_StartSound (actor, sfx_claw);\ndamage = (P_Random()%8+1)*10;\nP_DamageMobj (actor->target, actor, actor, damage);\nreturn;\n}\n\n// launch a missile\nP_SpawnMissile (actor, actor->target, MT_BRUISERSHOT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  en_attack; } ;\ntypedef  TYPE_1__ Enemy ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_BruisAttack2 ;\nint /*<<< orphan*/  A_BruisAttack3 ;\nint /*<<< orphan*/  A_BruisAttack4 ;\nint /*<<< orphan*/  A_BruisAttack5 ;\nint /*<<< orphan*/  A_BruisAttack6 ;\nint /*<<< orphan*/  A_BruisAttack7 ;\nint /*<<< orphan*/  A_BruisAttack8 ;\nint /*<<< orphan*/  A_BruisAttack9 ;\nint /*<<< orphan*/  A_BruisAttack10 ;\nint /*<<< orphan*/  A_BruisAttack11 ;\nint /*<<< orphan*/  A_BruisAttack12 ;\nint /*<<< orphan*/  A_BruisAttack13 ;\nint /*<<< orphan*/  A_BruisAttack14 ;\nint /*<<< orphan*/  A_BruisAttack15 ;\nint /*<<< orphan*/  A_BruisAttack16 ;\nint /*<<< orphan*/  A_BruisAttack17 ;\nint /*<<< orphan*/  A_BruisAttack18 ;\nint /*<<< orphan*/  A_BruisAttack19 ;\nint /*<<< orphan*/  A_BruisAttack20 ;\nint /*<<< orphan*/  A_BruisAttack21 ;\nint /*<<< orphan*/  A_BruisAttack22 ;\nint /*<<< orphan*/  A_BruisAttack23 ;\nint /*<<< orphan*/  A_BruisAttack24 ;\nint /*<<< orphan*/  A_BruisAttack25 ;\nint /*<<< orphan*/  A_BruisAttack26 ;\nint /*<<< orphan*/  A_BruisAttack27 ;\nint /*<<< orphan*/  A_BruisAttack28 ;\nint /*<<< orphan*/  A_BruisAttack29 ;\nint /*<<< orphan*/  A_BruisAttack30 ;\nint /*<<< orphan*/  A_BruisAttack31 ;\nint /*<<< orphan*/  A_BruisAttack32 ;\nint /*<<< orphan*/  A_BruisAttack33 ;\nint /*<<< orphan*/  A_BruisAttack34 ;\nint /*<<< orphan*/  A_BruisAttack35 ;\nint /*<<< orphan*/  A_BruisAttack36 ;\nint /*<<< orphan*/  A_BruisAttack37 ;\nint /*<<< orphan*/  A_BruisAttack38 ;\nint /*<<< orphan*/  A_BruisAttack39 ;\nint /*<<< orphan*/  A_BruisAttack40 ;\nint /*<<< orphan*/  A_BruisAttack41 ;\nint /*<<< orphan*/  A_BruisAttack42 ;\nint /*<<< orphan*/  A_BruisAttack43 ;\nint /*<<< orphan*/  A_BruisAttack44 ;\nint /*<<< orphan*/  A_BruisAttack45 ;\nint /*<<< orphan*/  A_BruisAttack46 ;\nint /*<<< orphan*/  A_BruisAttack47 ;\nint /*<<< orphan*/  A_BruisAttack48 ;\nint /*<<< orphan*/  A_BruisAttack49 ;\nint /*<<< orphan*/  A_BruisAttack50 ;\nint /*<<< orphan*/  A_BruisAttack51 ;\nint /*<<< orphan*/  A_BruisAttack52 ;\nint /*<<< orphan*/  A_BruisAttack53 ;\nint /*<<< orphan*/  A_BruisAttack54 ;\nint /*<<< orphan*/  A_BruisAttack55 ;\nint /*<<< orphan*/  A_BruisAttack56 ;\nint /*<<< orphan*/  A_BruisAttack57 ;\nint /*<<< orphan*/  A_BruisAttack58 ;\nint /*<<< orphan*/  A_BruisAttack59 ;\nint /*<<< orphan*/  A_BruisAttack60 ;\nint /*<<< orphan*/  A_BruisAttack61 ;\nint /*<<< orphan*/  A_BruisAttack62 ;\nint /*<<< orphan*/  A_BruisAttack63 ;\nint /*<<< orphan*/  A_BruisAttack64 ;\nint /*<<< orphan*/  A_BruisAttack65 ;\nint /*<<< orphan*/  A_BruisAttack66 ;\nint /*<<< orphan*/  A_BruisAttack67 ;\nint /*<<< orphan*/  A_BruisAttack68 ;\nint /*<<< orphan*/  A_BruisAttack69 ;\nint /*<<< orphan*/  A_BruisAttack70 ;\nint /*<<< orphan*/  A_BruisAttack71 ;\nint /*<<< orphan*/  A_BruisAttack72 ;\nint /*<<< orphan*/  A_BruisAttack73 ;\nint /*<<< orphan*/  A_BruisAttack74 ;\nint /*<<< orphan*/  A_BruisAttack75 ;\nint /*<<< orphan*/  A_BruisAttack76 ;\nint /*<<< orphan*/  A_BruisAttack77 ;\nint /*<<< orphan*/  A_BruisAttack78 ;\nint /*<<< orphan*/  A_BruisAttack79 ;\nint /*<<< orphan*/  A_BruisAttack80 ;\nint /*<<< orphan*/  A_BruisAttack81 ;\nint /*<<< orphan*/  A_BruisAttack82 ;\nint /*<<< orphan*/  A_BruisAttack83 ;\nint /*<<< orphan*/  A_BruisAttack84 ;\nint /*<<< orphan*/  A_BruisAttack85 ;\nint /*<<< orphan*/  A_BruisAttack86 ;\nint /*<<< orphan*/  A_BruisAttack87 ;\nint /*<<< orphan*/  A_BruisAttack88 ;\nint /*<<< orphan*/  A_BruisAttack89 ;\nint /*<<< orphan*/  A_BruisAttack90 ;\nint /*<<< orphan*/  A_BruisAttack91 ;\nint /*<<< orphan*/  A_BruisAttack92 ;\nint /*<<< orphan*/  A_BruisAttack93 ;\nint /*<<< orphan*/  A_BruisAttack94 ;\nint /*<<< orphan*/  A_BruisAttack95 ;\nint /*<<< orphan*/  A_BruisAttack96 ;\nint /*<<< orphan*/  A_BruisAttack97 ;\nint /*<<< orphan*/  A_BruisAttack98 ;\nint /*<<< orphan*/  A_BruisAttack99 ;\nint /*<<< orphan*/  A_BruisAttack100 ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_PostEvent",
    "input":"\n0000000000000000 <D_PostEvent>:\n0: \tmovl\t(%rdi), %eax\n2: \tmovq\t(%rip), %rcx  # 0x9 <D_PostEvent+0x9>\n9: \tmovq\t(%rip), %rdx  # 0x10 <D_PostEvent+0x10>\n10: \tmovl\t%eax, (%rcx,%rdx,4)\n13: \taddq\t$1, %rdx\n17: \tmovslq\t(%rip), %rax  # 0x1e <D_PostEvent+0x1e>\n1e: \taddq\t$-1, %rax\n22: \tandq\t%rdx, %rax\n25: \tmovq\t%rax, (%rip)  # 0x2c <D_PostEvent+0x2c>\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  event_t ;\n\n/* Variables and functions */\nint MAXEVENTS ;\nsize_t eventhead ;\nint /*<<< orphan*/ * events ;\n\nvoid D_PostEvent (event_t* ev)\n{\nevents[eventhead] = *ev;\neventhead = (++eventhead)&(MAXEVENTS-1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  Event; } ;\ntypedef  TYPE_1__ D_Event ;\n\n/* Variables and functions */\nsize_t D_Event_Count ;\nsize_t D_Event_Head ;\nint /*<<< orphan*/ * D_Event_Queue ;\n\nvoid D_PostEvent(D_Event *Event)\n{\nD_Event_Queue[D_Event_Head] = Event->Event;\nD_Event_Head = (D_Event_Head + 1) & (D_Event_Count - 1);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_Light0",
    "input":"\n0000000000000000 <A_Light0>:\n0: \tmovq\t$0, (%rdi)\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_3__ {scalar_t__ extralight; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\n\nvoid A_Light0 (player_t *player, pspdef_t *psp)\n{\nplayer->extralight = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct _cms_typehandler_struct {int dummy; } ;\ntypedef  int /*<<< orphan*/  cmsContext ;\ntypedef  int /*<<< orphan*/  cmsUInt32Number ;\ntypedef  int /*<<< orphan*/  cmsInt32Number ;\ntypedef  int /*<<< orphan*/  cmsColor ;\ntypedef  int /*<<< orphan*/  cmsColorSpace ;\n\n/* Variables and functions */\n\n__attribute__((used)) static\nvoid A_Light0(cmsContext ContextID, struct _cms_typehandler_struct* self, cmsColorSpace* csp, void* Ptr, cmsUInt32Number n)\n{\ncmsUNUSED_PARAMETER(csp);\ncmsUNUSED_PARAMETER(n);\n\n*(cmsInt32Number*) Ptr = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_Light1",
    "input":"\n0000000000000000 <A_Light1>:\n0: \tmovl\t$1, (%rdi)\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_3__ {int extralight; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\n\nvoid A_Light1 (player_t *player, pspdef_t *psp)\n{\nplayer->extralight = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int light1; } ;\ntypedef  TYPE_1__ A_Context ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void A_Light1(A_Context* self)\n{\nself->light1 = 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_Init",
    "input":"\n0000000000000000 <ST_Init>:\n0: \tpushq\t%rax\n1: \tmovq\t$0, (%rip)    # 0xc <ST_Init+0xc>\nc: \txorl\t%eax, %eax\ne: \tcallq\t0x13 <ST_Init+0x13>\n13: \tmovl\t(%rip), %edi  # 0x19 <ST_Init+0x19>\n19: \timull\t(%rip), %edi  # 0x20 <ST_Init+0x20>\n20: \tmovl\t(%rip), %esi  # 0x26 <ST_Init+0x26>\n26: \txorl\t%edx, %edx\n28: \tcallq\t0x2d <ST_Init+0x2d>\n2d: \tmovq\t(%rip), %rcx  # 0x34 <ST_Init+0x34>\n34: \tmovq\t%rax, 32(%rcx)\n38: \tpopq\t%rax\n39: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nint ST_HEIGHT ;\nint ST_WIDTH ;\nint /*<<< orphan*/  ST_loadData () ;\nscalar_t__ Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ ** screens ;\nscalar_t__ veryfirsttime ;\n\nvoid ST_Init (void)\n{\nveryfirsttime = 0;\nST_loadData();\nscreens[4] = (byte *) Z_Malloc(ST_WIDTH*ST_HEIGHT, PU_STATIC, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * p; int /*<<< orphan*/ * q; } ;\ntypedef  TYPE_1__ STACK ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ST_Init_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_DoNewGame",
    "input":"\n0000000000000000 <G_DoNewGame>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, (%rip)    # 0xb <G_DoNewGame+0xb>\nb: \tmovl\t$0, (%rip)    # 0x15 <G_DoNewGame+0x15>\n15: \tmovl\t$0, (%rip)    # 0x1f <G_DoNewGame+0x1f>\n1f: \tmovl\t$0, (%rip)    # 0x29 <G_DoNewGame+0x29>\n29: \tmovq\t(%rip), %rax  # 0x30 <G_DoNewGame+0x30>\n30: \txorps\t%xmm0, %xmm0\n33: \tmovups\t%xmm0, 8(%rax)\n37: \tmovq\t$0, 24(%rax)\n3f: \tmovl\t$0, (%rip)    # 0x49 <G_DoNewGame+0x49>\n49: \tmovl\t$0, (%rip)    # 0x53 <G_DoNewGame+0x53>\n53: \tmovl\t$0, (%rip)    # 0x5d <G_DoNewGame+0x5d>\n5d: \tmovq\t$0, (%rip)    # 0x68 <G_DoNewGame+0x68>\n68: \tmovl\t(%rip), %edi  # 0x6e <G_DoNewGame+0x6e>\n6e: \tmovl\t(%rip), %esi  # 0x74 <G_DoNewGame+0x74>\n74: \tmovl\t(%rip), %edx  # 0x7a <G_DoNewGame+0x7a>\n7a: \tcallq\t0x7f <G_DoNewGame+0x7f>\n7f: \tmovl\t(%rip), %eax  # 0x85 <G_DoNewGame+0x85>\n85: \tmovl\t%eax, (%rip)  # 0x8b <G_DoNewGame+0x8b>\n8b: \tpopq\t%rax\n8c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_InitNew (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nscalar_t__ consoleplayer ;\nint /*<<< orphan*/  d_episode ;\nint /*<<< orphan*/  d_map ;\nint /*<<< orphan*/  d_skill ;\nint deathmatch ;\nint demoplayback ;\nint fastparm ;\nint /*<<< orphan*/  ga_nothing ;\nint /*<<< orphan*/  gameaction ;\nint netdemo ;\nint netgame ;\nint nomonsters ;\nscalar_t__* playeringame ;\nint respawnparm ;\n\nvoid G_DoNewGame (void)\n{\ndemoplayback = false;\nnetdemo = false;\nnetgame = false;\ndeathmatch = false;\nplayeringame[1] = playeringame[2] = playeringame[3] = 0;\nrespawnparm = false;\nfastparm = false;\nnomonsters = false;\nconsoleplayer = 0;\nG_InitNew (d_skill, d_episode, d_map);\ngameaction = ga_nothing;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * palette; int /*<<< orphan*/ * palette_bright; int /*<<< orphan*/ * palette_dark; int /*<<< orphan*/ * palette_black; int /*<<< orphan*/ * palette_white; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_FadeOut (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  G_FadeOutDone ;\nint /*<<< orphan*/  G_FadeOutPalette ;\nint /*<<< orphan*/  G_FadeOutPaletteDone ;\nint /*<<< orphan*/  G_FadeOutPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStart ;\nint /*<<< orphan*/  G_FadeOutStartDone ;\nint /*<<< orphan*/  G_FadeOutStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartStartDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartStartPalette ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartStartPaletteDone ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartStartPaletteStart ;\nint /*<<< orphan*/  G_FadeOutStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_T_StrobeFlash",
    "input":"\n0000000000000000 <T_StrobeFlash>:\n0: \taddq\t$-1, 24(%rdi)\n5: \tje\t0x8 <T_StrobeFlash+0x8>\n7: \tretq\n8: \tmovq\t(%rdi), %rcx\nb: \tmovq\t32(%rdi), %rax\nf: \tcmpq\t%rcx, (%rax)\n12: \tjne\t0x21 <T_StrobeFlash+0x21>\n14: \tmovq\t8(%rdi), %rcx\n18: \tmovq\t%rcx, (%rax)\n1b: \tleaq\t40(%rdi), %rax\n1f: \tjmp\t0x28 <T_StrobeFlash+0x28>\n21: \tmovq\t%rcx, (%rax)\n24: \tleaq\t16(%rdi), %rax\n28: \tmovq\t(%rax), %rax\n2b: \tmovq\t%rax, 24(%rdi)\n2f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ minlight; scalar_t__ maxlight; scalar_t__ darktime; scalar_t__ count; TYPE_1__* sector; scalar_t__ brighttime; } ;\ntypedef  TYPE_2__ strobe_t ;\nstruct TYPE_4__ {scalar_t__ lightlevel; } ;\n\n/* Variables and functions */\n\nvoid T_StrobeFlash (strobe_t*\t\tflash)\n{\nif (--flash->count)\nreturn;\n\nif (flash->sector->lightlevel == flash->minlight)\n{\nflash-> sector->lightlevel = flash->maxlight;\nflash->count = flash->brighttime;\n}\nelse\n{\nflash-> sector->lightlevel = flash->minlight;\nflash->count =flash->darktime;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ flash_state; } ;\nstruct TYPE_5__ {scalar_t__ flash_state; scalar_t__ flash_counter; scalar_t__ flash_counter_max; TYPE_1__* flash_state_table; } ;\ntypedef  TYPE_2__* TL_Tile ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void T_StrobeFlash(TL_Tile* tile)\n{\nif (--tile->flash_counter == 0)\n{\nif (tile->flash_state == tile->flash_state_table[0].flash_state)\n{\ntile->flash_state = tile->flash_state_table[1].flash_state;\ntile->flash_counter = tile->flash_counter_max;\n}\nelse\n{\ntile->flash_state = tile->flash_state_table[0].flash_state;\ntile->flash_counter = tile->flash_counter_max;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_Init",
    "input":"\n0000000000000000 <S_Init>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%esi, %ebx\n5: \tmovl\t%edi, %ebp\n7: \tmovl\t(%rip), %edi  # 0xd <S_Init+0xd>\nd: \tmovl\t$0, %esi\n12: \tmovl\t%ebp, %edx\n14: \tcallq\t0x19 <S_Init+0x19>\n19: \txorl\t%eax, %eax\n1b: \tcallq\t0x20 <S_Init+0x20>\n20: \tmovl\t%ebp, %edi\n22: \tcallq\t0x27 <S_Init+0x27>\n27: \tmovl\t%ebx, %edi\n29: \tcallq\t0x2e <S_Init+0x2e>\n2e: \tmovl\t(%rip), %edi  # 0x34 <S_Init+0x34>\n34: \tshll\t$3, %edi\n37: \tmovl\t(%rip), %esi  # 0x3d <S_Init+0x3d>\n3d: \txorl\t%edx, %edx\n3f: \tcallq\t0x44 <S_Init+0x44>\n44: \tmovq\t%rax, (%rip)  # 0x4b <S_Init+0x4b>\n4b: \tmovl\t(%rip), %edx  # 0x51 <S_Init+0x51>\n51: \ttestl\t%edx, %edx\n53: \tjle\t0x63 <S_Init+0x63>\n55: \tshlq\t$3, %rdx\n59: \tmovq\t%rax, %rdi\n5c: \txorl\t%esi, %esi\n5e: \tcallq\t0x63 <S_Init+0x63>\n63: \tmovq\t$0, (%rip)    # 0x6e <S_Init+0x6e>\n6e: \tcmpl\t$2, (%rip)    # 0x75 <S_Init+0x75>\n75: \tjl\t0xa8 <S_Init+0xa8>\n77: \tmovl\t$1, %eax\n7c: \tmovq\t(%rip), %rcx  # 0x83 <S_Init+0x83>\n83: \tnopw\t%cs:(%rax,%rax)\n8d: \tnopl\t(%rax)\n90: \tmovq\t$-1, (%rcx,%rax,8)\n98: \taddq\t$1, %rax\n9c: \tmovslq\t(%rip), %rdx  # 0xa3 <S_Init+0xa3>\na3: \tcmpq\t%rdx, %rax\na6: \tjl\t0x90 <S_Init+0x90>\na8: \taddq\t$8, %rsp\nac: \tpopq\t%rbx\nad: \tpopq\t%rbp\nae: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ sfxinfo; } ;\ntypedef  TYPE_1__ channel_t ;\nstruct TYPE_5__ {int lumpnum; int usefulness; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SetChannels () ;\nint NUMSFX ;\nint /*<<< orphan*/  PU_STATIC ;\nint /*<<< orphan*/  S_SetMusicVolume (int) ;\nint /*<<< orphan*/  S_SetSfxVolume (int) ;\nTYPE_3__* S_sfx ;\nscalar_t__ Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__* channels ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int) ;\nscalar_t__ mus_paused ;\nint numChannels ;\nint /*<<< orphan*/  stderr ;\n\nvoid S_Init\n( int\t\tsfxVolume,\nint\t\tmusicVolume )\n{\nint\t\ti;\n\nfprintf( stderr, \"S_Init: default sfx volume %d\\n\", sfxVolume);\n\n// Whatever these did with DMX, these are rather dummies now.\nI_SetChannels();\n\nS_SetSfxVolume(sfxVolume);\n// No music with Linux - another dummy.\nS_SetMusicVolume(musicVolume);\n\n// Allocating the internal channels for mixing\n// (the maximum numer of sounds rendered\n// simultaneously) within zone memory.\nchannels =\n(channel_t *) Z_Malloc(numChannels*sizeof(channel_t), PU_STATIC, 0);\n\n// Free all channels for use\nfor (i=0 ; i<numChannels ; i++)\nchannels[i].sfxinfo = 0;\n\n// no sounds are playing, and they are not mus_paused\nmus_paused = 0;\n\n// Note that sounds have not been cached (yet).\nfor (i=1 ; i<NUMSFX ; i++)\nS_sfx[i].lumpnum = S_sfx[i].usefulness = -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_Bank ;\nint /*<<< orphan*/  S_Bank_Data ;\nint /*<<< orphan*/  S_Bank_Data_End ;\nint /*<<< orphan*/  S_Bank_Data_Start ;\nint /*<<< orphan*/  S_Bank_End ;\nint /*<<< orphan*/  S_Bank_Start ;\nint /*<<< orphan*/  S_Bank_Wave ;\nint /*<<< orphan*/  S_Bank_Wave_End ;\nint /*<<< orphan*/  S_Bank_Wave_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table ;\nint /*<<< orphan*/  S_Bank_Wave_Table_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Size ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_End ;\nint /*<<< orphan*/  S_Bank_Wave_Table_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start_Ptr_Start ;\nint /*<<< orphan*/  S_Bank"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_PageTicker",
    "input":"\n0000000000000000 <D_PageTicker>:\n0: \tmovq\t(%rip), %rax  # 0x7 <D_PageTicker+0x7>\n7: \tleaq\t-1(%rax), %rcx\nb: \tmovq\t%rcx, (%rip)  # 0x12 <D_PageTicker+0x12>\n12: \ttestq\t%rax, %rax\n15: \tjle\t0x18 <D_PageTicker+0x18>\n17: \tretq\n18: \txorl\t%eax, %eax\n1a: \tjmp\t0x1f <D_PageTicker+0x1f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_AdvanceDemo () ;\nscalar_t__ pagetic ;\n\nvoid D_PageTicker (void)\n{\nif (--pagetic < 0)\nD_AdvanceDemo ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_PageTicker_ (int /*<<< orphan*/ ) ;\nscalar_t__ D_PageTicker_Count ;\nint /*<<< orphan*/  D_PageTicker_Time ;\n\nvoid D_PageTicker(void)\n{\nD_PageTicker_Count--;\nif (D_PageTicker_Count <= 0)\n{\nD_PageTicker_Count = 0;\nD_PageTicker_(D_PageTicker_Time);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_initVariables",
    "input":"\n0000000000000000 <WI_initVariables>:\n0: \tmovq\t%rdi, (%rip)  # 0x7 <WI_initVariables+0x7>\n7: \tmovq\t$0, (%rip)    # 0x12 <WI_initVariables+0x12>\n12: \tmovq\t$0, (%rip)    # 0x1d <WI_initVariables+0x1d>\n1d: \tmovq\t$0, (%rip)    # 0x28 <WI_initVariables+0x28>\n28: \tmovl\t$1, (%rip)    # 0x32 <WI_initVariables+0x32>\n32: \tmovl\t12(%rdi), %eax\n35: \tmovl\t%eax, (%rip)  # 0x3b <WI_initVariables+0x3b>\n3b: \tmovl\t28(%rdi), %eax\n3e: \tmovl\t%eax, (%rip)  # 0x44 <WI_initVariables+0x44>\n44: \tcmpl\t$0, 16(%rdi)\n48: \tje\t0x7a <WI_initVariables+0x7a>\n4a: \tcmpl\t$0, 20(%rdi)\n4e: \tje\t0x87 <WI_initVariables+0x87>\n50: \tcmpl\t$0, 24(%rdi)\n54: \tjne\t0x5d <WI_initVariables+0x5d>\n56: \tmovl\t$1, 24(%rdi)\n5d: \tmovq\t(%rip), %rax  # 0x64 <WI_initVariables+0x64>\n64: \tcmpq\t(%rip), %rax  # 0x6b <WI_initVariables+0x6b>\n6b: \tje\t0x79 <WI_initVariables+0x79>\n6d: \tmovl\t(%rdi), %eax\n6f: \tcmpl\t$3, %eax\n72: \tjl\t0x79 <WI_initVariables+0x79>\n74: \taddl\t$-3, %eax\n77: \tmovl\t%eax, (%rdi)\n79: \tretq\n7a: \tmovl\t$1, 16(%rdi)\n81: \tcmpl\t$0, 20(%rdi)\n85: \tjne\t0x50 <WI_initVariables+0x50>\n87: \tmovl\t$1, 20(%rdi)\n8e: \tcmpl\t$0, 24(%rdi)\n92: \tjne\t0x5d <WI_initVariables+0x5d>\n94: \tjmp\t0x56 <WI_initVariables+0x56>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int epsd; int last; int next; int pnum; int maxkills; int maxitems; int maxsecret; int /*<<< orphan*/  plyr; } ;\ntypedef  TYPE_1__ wbstartstruct_t ;\n\n/* Variables and functions */\nint MAXPLAYERS ;\nint /*<<< orphan*/  RNGCHECK (int,int /*<<< orphan*/ ,int) ;\nscalar_t__ acceleratestage ;\nscalar_t__ bcnt ;\nscalar_t__ cnt ;\nscalar_t__ commercial ;\nint firstrefresh ;\nscalar_t__ gamemode ;\nint me ;\nint /*<<< orphan*/  plrs ;\nscalar_t__ retail ;\nTYPE_1__* wbs ;\n\nvoid WI_initVariables(wbstartstruct_t* wbstartstruct)\n{\n\nwbs = wbstartstruct;\n\n#ifdef RANGECHECKING\nif (gamemode != commercial)\n{\nif ( gamemode == retail )\nRNGCHECK(wbs->epsd, 0, 3);\nelse\nRNGCHECK(wbs->epsd, 0, 2);\n}\nelse\n{\nRNGCHECK(wbs->last, 0, 8);\nRNGCHECK(wbs->next, 0, 8);\n}\nRNGCHECK(wbs->pnum, 0, MAXPLAYERS);\nRNGCHECK(wbs->pnum, 0, MAXPLAYERS);\n#endif\n\nacceleratestage = 0;\ncnt = bcnt = 0;\nfirstrefresh = 1;\nme = wbs->pnum;\nplrs = wbs->plyr;\n\nif (!wbs->maxkills)\nwbs->maxkills = 1;\n\nif (!wbs->maxitems)\nwbs->maxitems = 1;\n\nif (!wbs->maxsecret)\nwbs->maxsecret = 1;\n\nif ( gamemode != retail )\nif (wbs->epsd > 2)\nwbs->epsd -= 3;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  dwFlags; int /*<<< orphan*/  dwMaxFileSize; int /*<<< orphan*/  dwMinFileSize; int /*<<< orphan*/  dwReserved; int /*<<< orphan*/  dwReserved2; int /*<<< orphan*/  dwReserved3; int /*<<< orphan*/  dwReserved4; int /*<<< orphan*/  dwReserved5; int /*<<< orphan*/  dwReserved6; int /*<<< orphan*/  dwReserved7; int /*<<< orphan*/  dwReserved8; int /*<<< orphan*/  dwReserved9; int /*<<< orphan*/  dwReserved10; int /*<<< orphan*/  dwReserved11; int /*<<< orphan*/  dwReserved12; int /*<<< orphan*/  dwReserved13; int /*<<< orphan*/  dwReserved14; int /*<<< orphan*/  dwReserved15; int /*<<< orphan*/  dwReserved16; int /*<<< orphan*/  dwReserved17; int /*<<< orphan*/  dwReserved18; int /*<<< orphan*/  dwReserved19; int /*<<< orphan*/  dwReserved20; int /*<<< orphan*/  dwReserved21; int /*<<< orphan*/  dwReserved22; int /*<<< orphan*/  dwReserved23; int /*<<< orphan*/  dwReserved24; int /*<<< orphan*/  dwReserved25; int /*<<< orphan*/  dwReserved26; int /*<<< orphan*/  dwReserved27; int /*<<< orphan*/  dwReserved28; int /*<<< orphan*/  dwReserved29; int /*<<< orphan*/  dwReserved30; int /*<<< orphan*/  dwReserved31; int /*<<< orphan*/  dwReserved32; int /*<<< orphan*/  dwReserved33; int /*<<< orphan*/  dwReserved34; int /*<<< orphan*/  dwReserved35; int /*<<< orphan*/  dwReserved36; int /*<<< orphan*/  dwReserved37; int /*<<< orphan*/  dwReserved38; int /*<<< orphan*/  dwReserved39; int /*<<< orphan*/  dwReserved40; int /*<<< orphan*/  dwReserved41; int /*<<< orphan*/  dwReserved42; int /*<<< orphan*/  dwReserved43; int /*<<< orphan*/  dwReserved44; int /*<<< orphan*/  dwReserved45; int /*<<< orphan*/  dwReserved46; int /*<<< orphan*/  dwReserved47; int /*<<< orphan*/  dwReserved48; int /*<<< orphan*/  dwReserved49; int /*<<< orphan*/  dwReserved50; int /*<<< orphan*/  dwReserved51; int /*<<< orphan*/  dwReserved52; int /*<<< orphan*/  dwReserved53; int /*<<< orphan*/  dwReserved54; int /*<<< orphan*/  dwReserved55; int /*<<< orphan*/  dwReserved56; int /*<<< orphan*/  dwReserved57; int /*<<< orphan*/  dwReserved58; int /*<<< orphan*/  dwReserved59; int /*<<< orphan*/  dwReserved60; int /*<<< orphan*/  dwReserved61; int /*<<< orphan*/  dwReserved62; int /*<<< orphan*/  dwReserved63; int /*<<< orphan*/  dwReserved64; int /*<<< orphan*/  dwReserved65; int /*<<< orphan*/  dwReserved66; int /*<<< orphan*/  dwReserved67; int /*<<< orphan*/  dwReserved68; int /*<<< orphan*/  dwReserved69; int /*<<< orphan*/  dwReserved70; int /*<<< orphan*/  dwReserved71; int /*<<< orphan*/  dwReserved72; int /*<<< orphan*/  dwReserved73; int /*<<< orphan*/  dwReserved74; int /*<<< orphan*/  dwReserved75; int /*<<< orphan*/  dwReserved76; int /*<<< orphan*/  dwReserved77; int /*<<< orphan*/  dwReserved78; int /*<<< orphan*/  dwReserved79; int /*<<< orphan*/  dwReserved80; int /*<<< orphan*/  dwReserved81; int /*<<< orphan*/  dwReserved82; int /*<<< orphan*/  dwReserved83; int /*<<< orphan*/  dwReserved84; int /*<<< orphan*/  dwReserved85; int /*<<< orphan*/  dwReserved86; int /*<<< orphan*/  dwReserved87; int /*<<< orphan*/  dwReserved88; int /*<<< orphan*/  dwReserved89; int /*<<< orphan*/  dwReserved90; int /*<<< orphan*/  dwReserved91; int /*<<< orphan*/  dwReserved92; int /*<<< orphan*/  dwReserved93; int /*<<< orphan*/  dwReserved94; int /*<<< orphan*/  dwReserved95; int /*<<< orphan*/  dwReserved96; int /*<<< orphan*/  dwReserved97; int /*<<< orphan*/  dwReserved98; int /*<<< orphan*/  dwReserved99; int /*<<< orphan*/  dwReserved100; int /*<<< orphan*/  dwReserved101; int /*<<< orphan*/  dwReserved102; int /*<<< orphan*/  dwReserved103; int /*<<< orphan*/  dwReserved104; int /*<<< orphan*/  dwReserved105; int /*<<< orphan*/  dwReserved106; int /*<<< orphan*/  dwReserved107; int /*<<< orphan*/  dwReserved108; int /*<<< orphan*/  dwReserved109; int /*<<< orphan*/  dwReserved110; int /*<<< orphan*/  dwReserved111; int /*<<< orphan*/  dwReserved112; int /*<<< orphan*/  dwReserved113; int /*<<< orphan*/  dwReserved114; int /*<<< orphan*/  dwReserved115; int /*<<< orphan*/  dwReserved116; int /*<<< orphan*/  dwReserved117; int /*<<< orphan*/  dwReserved118; int /*<<< orphan*/  dwReserved119; int /*<<< orphan*/  dwReserved120; int /*<<< orphan*/  dwReserved121; int /*<<< orphan*/  dwReserved122; int /*<<< orphan*/  dwReserved123; int /*<<< orphan*/  dwReserved124; int /*<<< orphan*/  dwReserved125; int /*<<< orphan*/  dwReserved126; int /*<<< orphan*/  dwReserved127; int /*<<< orphan*/  dwReserved128; int /*<<< orphan*/  dwReserved129; int /*<<< orphan*/  dwReserved130; int /*<<< orphan*/  dwReserved131; int /*<<< orphan*/  dwReserved132; int /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_InitExpand",
    "input":"\n0000000000000000 <InitExpand>:\n0: \tmovdqa\t(%rip), %xmm13# 0x9 <InitExpand+0x9>\n9: \tmovq\t(%rip), %rax  # 0x10 <InitExpand+0x10>\n10: \txorl\t%ecx, %ecx\n12: \tmovdqa\t(%rip), %xmm12# 0x1b <InitExpand+0x1b>\n1b: \tmovdqa\t(%rip), %xmm8 # 0x24 <InitExpand+0x24>\n24: \tmovdqa\t(%rip), %xmm9 # 0x2d <InitExpand+0x2d>\n2d: \tmovdqa\t(%rip), %xmm10# 0x36 <InitExpand+0x36>\n36: \tmovdqa\t(%rip), %xmm11# 0x3f <InitExpand+0x3f>\n3f: \tmovdqa\t%xmm13, %xmm3\n44: \tmovdqa\t%xmm13, %xmm7\n49: \tmovdqa\t%xmm13, %xmm5\n4e: \tnop\n50: \tmovdqa\t%xmm13, %xmm2\n55: \tpslld\t$8, %xmm2\n5a: \tmovdqa\t%xmm2, %xmm4\n5e: \tpaddd\t%xmm8, %xmm4\n63: \tmovdqa\t%xmm3, %xmm6\n67: \tpaddd\t%xmm9, %xmm6\n6c: \tpor\t%xmm4, %xmm6\n70: \tpor\t%xmm3, %xmm2\n74: \tmovdqa\t%xmm7, %xmm4\n78: \tpslld\t$16, %xmm4\n7d: \tmovdqa\t%xmm4, %xmm1\n81: \tpaddd\t%xmm10, %xmm1\n86: \tmovdqa\t%xmm5, %xmm0\n8a: \tpslld\t$24, %xmm0\n8f: \tpor\t%xmm0, %xmm4\n93: \tpaddd\t%xmm11, %xmm0\n98: \tpor\t%xmm1, %xmm0\n9c: \tpor\t%xmm6, %xmm0\na0: \tpor\t%xmm2, %xmm4\na4: \tmovdqu\t%xmm4, (%rax,%rcx,4)\na9: \tmovdqu\t%xmm0, 16(%rax,%rcx,4)\naf: \taddq\t$8, %rcx\nb3: \tpaddd\t%xmm12, %xmm13\nb8: \tpaddd\t%xmm12, %xmm3\nbd: \tpaddd\t%xmm12, %xmm7\nc2: \tpaddd\t%xmm12, %xmm5\nc7: \tcmpq\t$256, %rcx    # imm = 0x100\nce: \tjne\t0x50 <InitExpand+0x50>\nd0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint* exptable ;\n\nvoid InitExpand (void)\n{\nint\t\ti;\n\nfor (i=0 ; i<256 ; i++)\nexptable[i] = i | (i<<8) | (i<<16) | (i<<24);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  cmsUInt8Number ;\ntypedef  int /*<<< orphan*/ * cmsUInt32Number ;\n\n/* Variables and functions */\nint /*<<< orphan*/  cmsUNUSED_PARAMETER (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static\nvoid InitExpand(cmsUInt8Number* Out, cmsUInt32Number n)\n{\ncmsUInt32Number i;\n\nfor (i=0; i < n; i++) {\nOut[i] = (cmsUInt8Number) i;\n}\n\nreturn;\n\ncmsUNUSED_PARAMETER(Out);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_initNetgameStats",
    "input":"\n0000000000000000 <WI_initNetgameStats>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %eax  # 0x7 <WI_initNetgameStats+0x7>\n7: \tmovl\t%eax, (%rip)  # 0xd <WI_initNetgameStats+0xd>\nd: \tmovq\t$0, (%rip)    # 0x18 <WI_initNetgameStats+0x18>\n18: \tmovl\t$1, (%rip)    # 0x22 <WI_initNetgameStats+0x22>\n22: \tmovl\t(%rip), %eax  # 0x28 <WI_initNetgameStats+0x28>\n28: \tmovl\t%eax, (%rip)  # 0x2e <WI_initNetgameStats+0x2e>\n2e: \tmovl\t(%rip), %eax  # 0x34 <WI_initNetgameStats+0x34>\n34: \ttestl\t%eax, %eax\n36: \tjle\t0xaa <WI_initNetgameStats+0xaa>\n38: \txorl\t%ebx, %ebx\n3a: \tjmp\t0x4c <WI_initNetgameStats+0x4c>\n3c: \tnopl\t(%rax)\n40: \taddq\t$1, %rbx\n44: \tmovslq\t%eax, %rcx\n47: \tcmpq\t%rcx, %rbx\n4a: \tjge\t0xaa <WI_initNetgameStats+0xaa>\n4c: \tmovq\t(%rip), %rcx  # 0x53 <WI_initNetgameStats+0x53>\n53: \tcmpl\t$0, (%rcx,%rbx,4)\n57: \tje\t0x40 <WI_initNetgameStats+0x40>\n59: \tmovq\t(%rip), %rax  # 0x60 <WI_initNetgameStats+0x60>\n60: \tmovq\t$0, (%rax,%rbx,8)\n68: \tmovq\t(%rip), %rax  # 0x6f <WI_initNetgameStats+0x6f>\n6f: \tmovq\t$0, (%rax,%rbx,8)\n77: \tmovq\t(%rip), %rax  # 0x7e <WI_initNetgameStats+0x7e>\n7e: \tmovq\t$0, (%rax,%rbx,8)\n86: \tmovq\t(%rip), %rax  # 0x8d <WI_initNetgameStats+0x8d>\n8d: \tmovq\t$0, (%rax,%rbx,8)\n95: \tmovl\t%ebx, %edi\n97: \tcallq\t0x9c <WI_initNetgameStats+0x9c>\n9c: \taddl\t%eax, (%rip)  # 0xa2 <WI_initNetgameStats+0xa2>\na2: \tmovl\t(%rip), %eax  # 0xa8 <WI_initNetgameStats+0xa8>\na8: \tjmp\t0x40 <WI_initNetgameStats+0x40>\naa: \txorl\t%eax, %eax\nac: \tcmpl\t$0, (%rip)    # 0xb3 <WI_initNetgameStats+0xb3>\nb3: \tsetne\t%al\nb6: \tmovl\t%eax, (%rip)  # 0xbc <WI_initNetgameStats+0xbc>\nbc: \txorl\t%eax, %eax\nbe: \tpopq\t%rbx\nbf: \tjmp\t0xc4 <WI_initNetgameStats+0xc4>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint MAXPLAYERS ;\nint /*<<< orphan*/  StatCount ;\nint /*<<< orphan*/  TICRATE ;\nscalar_t__ WI_fragSum (int) ;\nint /*<<< orphan*/  WI_initAnimatedBack () ;\nscalar_t__ acceleratestage ;\nscalar_t__* cnt_frags ;\nscalar_t__* cnt_items ;\nscalar_t__* cnt_kills ;\nint /*<<< orphan*/  cnt_pause ;\nscalar_t__* cnt_secret ;\nint dofrags ;\nint ng_state ;\nint /*<<< orphan*/ * playeringame ;\nint /*<<< orphan*/  state ;\n\nvoid WI_initNetgameStats(void)\n{\n\nint i;\n\nstate = StatCount;\nacceleratestage = 0;\nng_state = 1;\n\ncnt_pause = TICRATE;\n\nfor (i=0 ; i<MAXPLAYERS ; i++)\n{\nif (!playeringame[i])\ncontinue;\n\ncnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = 0;\n\ndofrags += WI_fragSum(i);\n}\n\ndofrags = !!dofrags;\n\nWI_initAnimatedBack();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * ngs_kills; int /*<<< orphan*/ * ngs_deaths; int /*<<< orphan*/ * ngs_shots; int /*<<< orphan*/ * ngs_hits; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  WI_getNetgamePlayer (int) ;\nint /*<<< orphan*/  WI_numNetgamePlayers ;\nint /*<<< orphan*/  WI_numNetgamePlayersWithStats ;\nTYPE_1__* WI_player ;\nint /*<<< orphan*/  WI_playerStats ;\n\nint WI_initNetgameStats(void)\n{\nint i;\n\nWI_playerStats = FALSE;\nWI_numNetgamePlayersWithStats = 0;\n\nfor (i = 0; i < WI_numNetgamePlayers; i++)\n{\nif (WI_getNetgamePlayer(i))\n{\nWI_player[i].ngs_kills = 0;\nWI_player[i].ngs_deaths = 0;\nWI_player[i].ngs_shots = 0;\nWI_player[i].ngs_hits = 0;\nWI_numNetgamePlayersWithStats++;\n}\n}\n\nreturn WI_numNetgamePlayersWithStats ? TRUE : FALSE;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_exitMelt",
    "input":"\n0000000000000000 <wipe_exitMelt>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %edi  # 0x7 <wipe_exitMelt+0x7>\n7: \tcallq\t0xc <wipe_exitMelt+0xc>\nc: \txorl\t%eax, %eax\ne: \tpopq\t%rcx\nf: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  Z_Free (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  y ;\n\nint\nwipe_exitMelt\n( int\twidth,\nint\theight,\nint\tticks )\n{\nZ_Free(y);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exitMelt ;\nint /*<<< orphan*/  wipe_exit (int /*<<< orphan*/ ) ;\n\nint wipe_exitMelt(void *arg) {\nwipe_exit(exitMelt);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_SaveGame",
    "input":"\n0000000000000000 <M_SaveGame>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <M_SaveGame+0x8>\n8: \tje\t0x2c <M_SaveGame+0x2c>\na: \tmovq\t(%rip), %rax  # 0x11 <M_SaveGame+0x11>\n11: \tcmpq\t(%rip), %rax  # 0x18 <M_SaveGame+0x18>\n18: \tjne\t0x3c <M_SaveGame+0x3c>\n1a: \tmovl\t$0, %edi\n1f: \tcallq\t0x24 <M_SaveGame+0x24>\n24: \txorl\t%eax, %eax\n26: \tpopq\t%rcx\n27: \tjmp\t0x2c <M_SaveGame+0x2c>\n2c: \tmovl\t(%rip), %edi  # 0x32 <M_SaveGame+0x32>\n32: \txorl\t%esi, %esi\n34: \txorl\t%edx, %edx\n36: \tpopq\t%rax\n37: \tjmp\t0x3c <M_SaveGame+0x3c>\n3c: \tpopq\t%rax\n3d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ GS_LEVEL ;\nint /*<<< orphan*/  M_ReadSaveStrings () ;\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  SAVEDEAD ;\nint /*<<< orphan*/  SaveDef ;\nscalar_t__ gamestate ;\nint /*<<< orphan*/  usergame ;\n\nvoid M_SaveGame (int choice)\n{\nif (!usergame)\n{\nM_StartMessage(SAVEDEAD,NULL,false);\nreturn;\n}\n\nif (gamestate != GS_LEVEL)\nreturn;\n\nM_SetupNextMenu(&SaveDef);\nM_ReadSaveStrings();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SaveGame_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Normal () ;\nscalar_t__ M_SAVE_BETA ;\nscalar_t__ M_SAVE_NORMAL ;\nint /*<<< orphan*/  M_SaveGame_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal () ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Normal ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old ;\nint /*<<< orphan*/  M_SaveGame_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Old_Beta ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_net.c_NetbufferSize",
    "input":"\n0000000000000000 <NetbufferSize>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * cmds; } ;\ntypedef  TYPE_1__ doomdata_t ;\nstruct TYPE_4__ {size_t numtics; } ;\n\n/* Variables and functions */\nTYPE_2__* netbuffer ;\n\nint NetbufferSize (void)\n{\nreturn (int)&(((doomdata_t *)0)->cmds[netbuffer->numtics]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  NETBUFFER ;\n\n/* Variables and functions */\n\nvoid\nNetbufferSize(NETBUFFER *nb)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_StringWidth",
    "input":"\n0000000000000000 <M_StringWidth>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdi, %r14\n7: \tcallq\t0xc <M_StringWidth+0xc>\nc: \ttestl\t%eax, %eax\ne: \tjle\t0x6c <M_StringWidth+0x6c>\n10: \txorl\t%ebx, %ebx\n12: \txorl\t%ebp, %ebp\n14: \tjmp\t0x35 <M_StringWidth+0x35>\n16: \tnopw\t%cs:(%rax,%rax)\n20: \taddl\t%eax, %ebp\n22: \taddq\t$1, %rbx\n26: \tmovq\t%r14, %rdi\n29: \tcallq\t0x2e <M_StringWidth+0x2e>\n2e: \tcltq\n30: \tcmpq\t%rax, %rbx\n33: \tjge\t0x6e <M_StringWidth+0x6e>\n35: \tmovsbl\t(%r14,%rbx), %edi\n3a: \tcallq\t0x3f <M_StringWidth+0x3f>\n3f: \tmovl\t%eax, %ecx\n41: \tsubl\t(%rip), %ecx  # 0x47 <M_StringWidth+0x47>\n47: \tmovl\t$4, %eax\n4c: \tjs\t0x20 <M_StringWidth+0x20>\n4e: \tcmpl\t(%rip), %ecx  # 0x54 <M_StringWidth+0x54>\n54: \tjge\t0x20 <M_StringWidth+0x20>\n56: \tmovq\t(%rip), %rax  # 0x5d <M_StringWidth+0x5d>\n5d: \tmovl\t%ecx, %ecx\n5f: \tmovq\t(%rax,%rcx,8), %rax\n63: \tmovl\t(%rax), %edi\n65: \tcallq\t0x6a <M_StringWidth+0x6a>\n6a: \tjmp\t0x20 <M_StringWidth+0x20>\n6c: \txorl\t%ebp, %ebp\n6e: \tmovl\t%ebp, %eax\n70: \tpopq\t%rbx\n71: \tpopq\t%r14\n73: \tpopq\t%rbp\n74: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  width; } ;\n\n/* Variables and functions */\nint HU_FONTSIZE ;\nint HU_FONTSTART ;\nscalar_t__ SHORT (int /*<<< orphan*/ ) ;\nTYPE_1__** hu_font ;\nint strlen (char*) ;\nint toupper (char) ;\n\nint M_StringWidth(char* string)\n{\nint             i;\nint             w = 0;\nint             c;\n\nfor (i = 0;i < strlen(string);i++)\n{\nc = toupper(string[i]) - HU_FONTSTART;\nif (c < 0 || c >= HU_FONTSIZE)\nw += 4;\nelse\nw += SHORT (hu_font[c]->width);\n}\n\nreturn w;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WORD ;\ntypedef  int /*<<< orphan*/  BYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_GetCharWidth (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_GetFont () ;\nint /*<<< orphan*/  M_GetFontSize () ;\nint /*<<< orphan*/  M_GetFontStyle () ;\nint /*<<< orphan*/  M_GetFontWeight () ;\nint /*<<< orphan*/  M_GetHeight () ;\nint /*<<< orphan*/  M_GetWidth () ;\nint /*<<< orphan*/  M_GetWidths (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_GetWidthsSize () ;\nint /*<<< orphan*/  M_GetWidthsStyle () ;\nint /*<<< orphan*/  M_GetWidthsWeight () ;\nint /*<<< orphan*/  M_GetWidthsWidth () ;\nint /*<<< orphan*/  M_GetWidthsX () ;\nint /*<<< orphan*/  M_GetWidthsY () ;\nint /*<<< orphan*/  M_GetWidthsZ () ;\nint /*<<< orphan*/  M_GetWidthsZ1 () ;\nint /*<<< orphan*/  M_GetWidthsZ2 () ;\nint /*<<< orphan*/  M_GetWidthsZ3 () ;\nint /*<<< orphan*/  M_GetWidthsZ4 () ;\nint /*<<< orphan*/  M_GetWidthsZ5 () ;\nint /*<<< orphan*/  M_GetWidthsZ6 () ;\nint /*<<< orphan*/  M_GetWidthsZ7 () ;\nint /*<<< orphan*/  M_GetWidthsZ8 () ;\nint /*<<< orphan*/  M_GetWidthsZ9 () ;\nint /*<<< orphan*/  M_GetWidthsZA () ;\nint /*<<< orphan*/  M_GetWidthsZB () ;\nint /*<<< orphan*/  M_GetWidthsZC () ;\nint /*<<< orphan*/  M_GetWidthsZD () ;\nint /*<<< orphan*/  M_GetWidthsZE () ;\nint /*<<< orphan*/  M_GetWidthsZF () ;\nint /*<<< orphan*/  M_GetWidthsZG () ;\nint /*<<< orphan*/  M_GetWidthsZH () ;\nint /*<<< orphan*/  M_GetWidthsZI () ;\nint /*<<< orphan*/  M_GetWidthsZJ () ;\nint /*<<< orphan*/  M_GetWidthsZK () ;\nint /*<<< orphan*/  M_GetWidthsZL () ;\nint /*<<< orphan*/  M_GetWidthsZM () ;\nint /*<<< orphan*/  M_GetWidthsZN () ;\nint /*<<< orphan*/  M_GetWidthsZO () ;\nint /*<<< orphan*/  M_GetWidthsZP () ;\nint /*<<< orphan*/  M_GetWidthsZQ () ;\nint /*<<< orphan*/  M_GetWidthsZR () ;\nint /*<<< orphan*/  M_GetWidthsZS () ;\nint /*<<< orphan*/  M_GetWidthsZT () ;\nint /*<<< orphan*/  M_GetWidthsZU () ;\nint /*<<< orphan*/  M_GetWidthsZV () ;\nint /*<<< orphan*/  M_GetWidthsZW () ;\nint /*<<< orphan*/  M_GetWidthsZX () ;\nint /*<<< orphan*/  M_GetWidthsZY () ;\nint /*<<< orphan*/  M_GetWidthsZZ () ;\nint /*<<< orphan*/  M_GetWidthsZa () ;\nint /*<<< orphan*/  M_GetWidthsZb () ;\nint /*<<< orphan*/  M_GetWidthsZc () ;\nint /*<<< orphan*/  M_GetWidthsZd () ;\nint /*<<< orphan*/  M_GetWidthsZe () ;\nint /*<<< orphan*/  M_GetWidthsZf () ;\nint /*<<< orphan*/  M_GetWidthsZg () ;\nint /*<<< orphan*/  M_GetWidthsZh () ;\nint /*<<< orphan*/  M_GetWidthsZi () ;\nint /*<<< orphan*/  M_GetWidthsZj () ;\nint /*<<< orphan*/  M_GetWidthsZk () ;\nint /*<<< orphan*/  M_GetWidthsZl () ;\nint /*<<< orphan*/  M_GetWidthsZm () ;\nint /*<<< orphan*/  M_GetWidthsZn () ;\nint /*<<< orphan*/  M_GetWidthsZo () ;\nint /*<<< orphan*/  M_GetWidthsZp () ;\nint /*<<< orphan*/  M_GetWidthsZq () ;\nint /*<<< orphan*/  M_GetWidthsZr () ;\nint /*<<< orphan*/  M_GetWidthsZs () ;\nint /*<<< orphan*/  M_GetWidthsZt () ;\nint /*<<< orphan*/  M_GetWidthsZu () ;\nint /*<<< orphan*/  M_GetWidthsZv () ;\nint /*<<< orphan*/  M_GetWidthsZw () ;\nint /*<<< orphan*/  M_GetWidthsZx () ;\nint /*<<< orphan*/  M_GetWidthsZy () ;\nint /*<<< orphan*/  M_GetWidthsZz () ;\nint /*<<< orphan*/  M_GetWidthsZz1 () ;\nint /*<<< orphan*/  M_GetWidthsZz2 () ;\nint /*<<< orphan*/  M_GetWidthsZz3 () ;\nint /*<<< orphan*/  M_GetWidthsZz4 () ;\nint /*<<< orphan*/  M_GetWidthsZz5 () ;\nint /*<<< orphan*/  M_GetWidthsZz6 () ;\nint /*<<< orphan*/  M_GetWidthsZz7 () ;\nint /*<<< orphan*/  M_GetWidthsZz8 () ;\nint /*<<< orphan*/  M_GetWidthsZz9 () ;\nint /*<<< orphan*/  M_GetWidthsZza () ;\nint /*<<< orphan*/  M_GetWidthsZzb () ;\nint /*<<< orphan*/  M_GetWidthsZzc () ;\nint /*<<< orphan*/  M_GetWidthsZzd () ;\nint /*<<< orphan*/  M_GetWidthsZze () ;\nint /*<<< orphan*/  M_GetWidthsZzf () ;\nint /*<<< orphan*/  M_GetWidthsZzg () ;\nint /*<<< orphan*/  M_GetWidthsZzh () ;\nint /*<<< orphan*/  M_GetWidthsZzi () ;\nint /*<<< orphan*/  M_GetWidthsZzj () ;\nint /*<<< orphan*/  M_GetWidthsZzk () ;\nint /*<<< orphan*/  M_GetWidthsZzl () ;\nint /*<<< orphan*/  M_GetWidthsZzm () ;\nint /*<<< orphan*/  M_GetWidthsZzn () ;\nint /*<<< orphan*/  M_GetWidthsZzo () ;\nint /*<<< orphan*/  M_GetWidthsZzp () ;\nint /*<<< orphan*/  M_GetWidthsZzq () ;\nint /*<<< orphan*/  M_GetWidthsZzr () ;\nint /*<<< orphan*/  M_GetWidthsZzs () ;\nint /*<<< orphan*/  M_GetWidthsZzt () ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_PointOnSide",
    "input":"\n0000000000000000 <R_PointOnSide>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %rbx\n8: \tmovq\t%rsi, %r14\nb: \tmovq\t%rdi, %rsi\ne: \tmovq\t(%rdx), %rax\n11: \ttestq\t%rax, %rax\n14: \tje\t0x68 <R_PointOnSide+0x68>\n16: \tmovq\t16(%rbx), %rdi\n1a: \ttestq\t%rdi, %rdi\n1d: \tje\t0x7a <R_PointOnSide+0x7a>\n1f: \tsubq\t8(%rbx), %rsi\n23: \tsubq\t24(%rbx), %r14\n27: \tmovq\t%rsi, %rcx\n2a: \txorq\t%rdi, %rcx\n2d: \txorl\t%ecx, %eax\n2f: \tmovl\t%r14d, %edx\n32: \txorl\t%eax, %edx\n34: \tjs\t0x96 <R_PointOnSide+0x96>\n36: \tmovb\t(%rip), %cl   # 0x3c <R_PointOnSide+0x3c>\n3c: \tsarq\t%cl, %rdi\n3f: \tcallq\t0x44 <R_PointOnSide+0x44>\n44: \tmovq\t%rax, %r15\n47: \tmovq\t(%rbx), %rsi\n4a: \tmovb\t(%rip), %cl   # 0x50 <R_PointOnSide+0x50>\n50: \tsarq\t%cl, %rsi\n53: \tmovq\t%r14, %rdi\n56: \tcallq\t0x5b <R_PointOnSide+0x5b>\n5b: \tmovq\t%rax, %rcx\n5e: \txorl\t%eax, %eax\n60: \tcmpq\t%r15, %rcx\n63: \tsetge\t%al\n66: \tjmp\t0xa1 <R_PointOnSide+0xa1>\n68: \tmovq\t16(%rbx), %rcx\n6c: \tcmpq\t%rsi, 8(%rbx)\n70: \tjge\t0x8c <R_PointOnSide+0x8c>\n72: \tshrq\t$63, %rcx\n76: \tmovl\t%ecx, %eax\n78: \tjmp\t0xa1 <R_PointOnSide+0xa1>\n7a: \tcmpq\t%r14, 24(%rbx)\n7e: \tjge\t0x9d <R_PointOnSide+0x9d>\n80: \txorl\t%ecx, %ecx\n82: \ttestq\t%rax, %rax\n85: \tsetg\t%cl\n88: \tmovl\t%ecx, %eax\n8a: \tjmp\t0xa1 <R_PointOnSide+0xa1>\n8c: \txorl\t%eax, %eax\n8e: \ttestq\t%rcx, %rcx\n91: \tsetg\t%al\n94: \tjmp\t0xa1 <R_PointOnSide+0xa1>\n96: \tshrl\t$31, %ecx\n99: \tmovl\t%ecx, %eax\n9b: \tjmp\t0xa1 <R_PointOnSide+0xa1>\n9d: \tshrq\t$63, %rax\na1: \tpopq\t%rbx\na2: \tpopq\t%r14\na4: \tpopq\t%r15\na6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ dx; scalar_t__ x; scalar_t__ dy; scalar_t__ y; } ;\ntypedef  TYPE_1__ node_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nscalar_t__ FRACBITS ;\nscalar_t__ FixedMul (scalar_t__,scalar_t__) ;\n\nint\nR_PointOnSide\n( fixed_t\tx,\nfixed_t\ty,\nnode_t*\tnode )\n{\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\n\nif (!node->dx)\n{\nif (x <= node->x)\nreturn node->dy > 0;\n\nreturn node->dy < 0;\n}\nif (!node->dy)\n{\nif (y <= node->y)\nreturn node->dx < 0;\n\nreturn node->dx > 0;\n}\n\ndx = (x - node->x);\ndy = (y - node->y);\n\n// Try to quickly decide by looking at sign bits.\nif ( (node->dy ^ node->dx ^ dx ^ dy)&0x80000000 )\n{\nif  ( (node->dy ^ dx) & 0x80000000 )\n{\n// (left is negative)\nreturn 1;\n}\nreturn 0;\n}\n\nleft = FixedMul ( node->dy>>FRACBITS , dx );\nright = FixedMul ( dy , node->dx>>FRACBITS );\n\nif (right < left)\n{\n// front side\nreturn 0;\n}\n// back side\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; scalar_t__ x1; scalar_t__ y1; scalar_t__ x2; scalar_t__ y2; } ;\ntypedef  TYPE_1__ R_Line ;\ntypedef  scalar_t__ R_Point ;\n\n/* Variables and functions */\nint R_ABS (scalar_t__) ;\nint R_SIGN (scalar_t__) ;\n\nint R_PointOnSide(R_Point p, R_Line *l)\n{\nR_Point x, y;\n\nif (l->x == 0)\n{\nif (l->y1 > l->y2)\n{\nif (p.y < l->y1)\nreturn 1;\nif (p.y > l->y2)\nreturn 0;\n}\nelse\n{\nif (p.y < l->y2)\nreturn 1;\nif (p.y > l->y1)\nreturn 0;\n}\n}\nelse\n{\nif (l->x1 > l->x2)\n{\nif (p.x < l->x1)\nreturn 1;\nif (p.x > l->x2)\nreturn 0;\n}\nelse\n{\nif (p.x < l->x2)\nreturn 1;\nif (p.x > l->x1)\nreturn 0;\n}\n}\n\nx = p.x - l->x;\ny = p.y - l->y;\n\nif (l->x == 0)\n{\nif (R_SIGN(y) == R_SIGN(l->y1))\nreturn 1;\n}\nelse\n{\nif (R_SIGN(x) == R_SIGN(l->x1))\nreturn 1;\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_getSide",
    "input":"\n0000000000000000 <getSide>:\n0: \tmovq\t(%rip), %rax  # 0x7 <getSide+0x7>\n7: \tmovslq\t%edi, %rcx\na: \tmovq\t(%rax,%rcx,8), %rax\ne: \tmovslq\t%esi, %rcx\n11: \tmovq\t(%rax,%rcx,8), %rax\n15: \tmovq\t(%rax), %rax\n18: \tmovslq\t%edx, %rcx\n1b: \tmovq\t(%rax,%rcx,8), %rax\n1f: \tshlq\t$2, %rax\n23: \taddq\t(%rip), %rax  # 0x2a <getSide+0x2a>\n2a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  side_t ;\nstruct TYPE_4__ {TYPE_1__** lines; } ;\nstruct TYPE_3__ {size_t* sidenum; } ;\n\n/* Variables and functions */\nTYPE_2__* sectors ;\nint /*<<< orphan*/ * sides ;\n\nside_t*\ngetSide\n( int\t\tcurrentSector,\nint\t\tline,\nint\t\tside )\n{\nreturn &sides[ (sectors[currentSector].lines[line])->sidenum[side] ];\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__* Pixel ;\n\n/* Variables and functions */\nsize_t* side ;\n\n__attribute__((used)) static Pixel getSide(int x, int y, int z) {\nreturn side[x] + side[y] + side[z];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_Light2",
    "input":"\n0000000000000000 <A_Light2>:\n0: \tmovl\t$2, (%rdi)\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_3__ {int extralight; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\n\nvoid A_Light2 (player_t *player, pspdef_t *psp)\n{\nplayer->extralight = 2;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct _cms_typehandler_struct {int dummy; } ;\ntypedef  int /*<<< orphan*/  cmsUInt32Number ;\ntypedef  int /*<<< orphan*/  cmsContext ;\n\n/* Variables and functions */\n\n__attribute__((used)) static\nvoid A_Light2(cmsContext ContextID, struct _cms_typehandler_struct* self, cmsUInt32Number n, const void* Ptr, void* dst)\n{\n*(cmsUInt32Number*) dst = 2;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BabyMetal",
    "input":"\n0000000000000000 <A_BabyMetal>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <A_BabyMetal+0xa>\na: \tcallq\t0xf <A_BabyMetal+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_BabyMetal+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Chase (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_bspwlk ;\n\nvoid A_BabyMetal (mobj_t* mo)\n{\nS_StartSound (mo, sfx_bspwlk);\nA_Chase (mo);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  M68KPtr ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_BabyMetal_0 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_BabyMetal_1 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TRUE ;\n\nvoid A_BabyMetal(M68KPtr reg)\n{\nA_BabyMetal_0(reg);\nA_BabyMetal_1(reg);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_mobj.c_P_SetMobjState",
    "input":"\n0000000000000000 <P_SetMobjState>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tjmp\t0x17 <P_SetMobjState+0x17>\n9: \tnopl\t(%rax)\n10: \tmovq\t(%r14), %rsi\n13: \ttestl\t%eax, %eax\n15: \tjne\t0x5b <P_SetMobjState+0x5b>\n17: \tcmpq\t(%rip), %rsi  # 0x1e <P_SetMobjState+0x1e>\n1e: \tje\t0x62 <P_SetMobjState+0x62>\n20: \tmovq\t(%rip), %rcx  # 0x27 <P_SetMobjState+0x27>\n27: \tshlq\t$5, %rsi\n2b: \tleaq\t(%rcx,%rsi), %r14\n2f: \tmovq\t%r14, 16(%rbx)\n33: \tmovl\t24(%rcx,%rsi), %eax\n37: \tmovl\t%eax, 8(%rbx)\n3a: \tmovl\t20(%rcx,%rsi), %edx\n3e: \tmovl\t%edx, 4(%rbx)\n41: \tmovl\t16(%rcx,%rsi), %edx\n45: \tmovl\t%edx, (%rbx)\n47: \tmovq\t8(%rcx,%rsi), %rcx\n4c: \ttestq\t%rcx, %rcx\n4f: \tje\t0x10 <P_SetMobjState+0x10>\n51: \tmovq\t%rbx, %rdi\n54: \tcallq\t*%rcx\n56: \tmovl\t8(%rbx), %eax\n59: \tjmp\t0x10 <P_SetMobjState+0x10>\n5b: \tmovl\t$1, %eax\n60: \tjmp\t0x70 <P_SetMobjState+0x70>\n62: \tmovq\t%rsi, 16(%rbx)\n66: \tmovq\t%rbx, %rdi\n69: \tcallq\t0x6e <P_SetMobjState+0x6e>\n6e: \txorl\t%eax, %eax\n70: \taddq\t$8, %rsp\n74: \tpopq\t%rbx\n75: \tpopq\t%r14\n77: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  size_t statenum_t ;\nstruct TYPE_8__ {int /*<<< orphan*/  (* acp1 ) (TYPE_3__*) ;} ;\nstruct TYPE_9__ {size_t nextstate; TYPE_1__ action; int /*<<< orphan*/  frame; int /*<<< orphan*/  sprite; int /*<<< orphan*/  tics; } ;\ntypedef  TYPE_2__ state_t ;\nstruct TYPE_10__ {int /*<<< orphan*/  frame; int /*<<< orphan*/  sprite; int /*<<< orphan*/  tics; TYPE_2__* state; } ;\ntypedef  TYPE_3__ mobj_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_RemoveMobj (TYPE_3__*) ;\nsize_t S_NULL ;\nTYPE_2__* states ;\nint /*<<< orphan*/  stub1 (TYPE_3__*) ;\n\nboolean\nP_SetMobjState\n( mobj_t*\tmobj,\nstatenum_t\tstate )\n{\nstate_t*\tst;\n\ndo\n{\nif (state == S_NULL)\n{\nmobj->state = (state_t *) S_NULL;\nP_RemoveMobj (mobj);\nreturn false;\n}\n\nst = &states[state];\nmobj->state = st;\nmobj->tics = st->tics;\nmobj->sprite = st->sprite;\nmobj->frame = st->frame;\n\n// Modified handling.\n// Call action functions when the state is set\nif (st->action.acp1)\nst->action.acp1(mobj);\n\nstate = st->nextstate;\n} while (!mobj->tics);\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  height; int /*<<< orphan*/  radius; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  (* thinker_function ) (TYPE_3__*) ;} ;\nstruct TYPE_8__ {int /*<<< orphan*/  thinker_function; } ;\ntypedef  TYPE_1__ mstate_t ;\ntypedef  TYPE_2__ state_t ;\ntypedef  TYPE_3__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  (* stub1 ) (TYPE_3__*) ;\nint /*<<< orphan*/  P_MobjThinker (TYPE_3__*) ;\nint /*<<< orphan*/  P_RemoveMobj (TYPE_3__*) ;\nTYPE_2__* State ;\nTYPE_1__* StateMobj ;\n\nint P_SetMobjState(mobj_t *mobj, int state)\n{\nstate_t *st;\n\ndo\n{\nst = State + state;\n\nif (state == mobj->state)\n{\nreturn 1;\n}\n\nmobj->state = state;\nmobj->radius = st->radius;\nmobj->height = st->height;\nmobj->x = mobj->x;\nmobj->y = mobj->y;\n\nif (st->thinker_function)\n{\nmobj->thinker.function = st->thinker_function;\n}\nelse\n{\nP_RemoveMobj(mobj);\n}\n\nstate = mobj->state;\n} while (state != mobj->state);\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_initNoState",
    "input":"\n0000000000000000 <WI_initNoState>:\n0: \tmovl\t(%rip), %eax  # 0x6 <WI_initNoState+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <WI_initNoState+0xc>\nc: \tmovq\t$0, (%rip)    # 0x17 <WI_initNoState+0x17>\n17: \tmovl\t$10, (%rip)   # 0x21 <WI_initNoState+0x21>\n21: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  NoState ;\nscalar_t__ acceleratestage ;\nint cnt ;\nint /*<<< orphan*/  state ;\n\nvoid WI_initNoState(void)\n{\nstate = NoState;\nacceleratestage = 0;\ncnt = 10;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_noState ;\nint /*<<< orphan*/  WI_noState_len ;\nscalar_t__ WI_noState_ptr ;\nint WI_noState_pos ;\n\nvoid WI_initNoState(void)\n{\nWI_noState = WI_noState_ptr;\nWI_noState_len = 0;\nWI_noState_pos = 10;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ReadThis2",
    "input":"\n0000000000000000 <M_ReadThis2>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <M_ReadThis2+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ReadDef2 ;\n\nvoid M_ReadThis2(int choice)\n{\nchoice = 0;\nM_SetupNextMenu(&ReadDef2);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Fatal (char*) ;\n\n__attribute__((used)) static void M_ReadThis2(var self, var key, var val) {\nM_Fatal(\"M_ReadThis2\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_GetSfxLumpNum",
    "input":"\n0000000000000000 <I_GetSfxLumpNum>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t(%rdi), %rdx\n8: \tleaq\t7(%rsp), %rbx\nd: \tmovl\t$0, %esi\n12: \tmovq\t%rbx, %rdi\n15: \tcallq\t0x1a <I_GetSfxLumpNum+0x1a>\n1a: \tmovq\t%rbx, %rdi\n1d: \tcallq\t0x22 <I_GetSfxLumpNum+0x22>\n22: \taddq\t$16, %rsp\n26: \tpopq\t%rbx\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {char* name; } ;\ntypedef  TYPE_1__ sfxinfo_t ;\n\n/* Variables and functions */\nint W_GetNumForName (char*) ;\nint /*<<< orphan*/  sprintf (char*,char*,char*) ;\n\nint I_GetSfxLumpNum(sfxinfo_t* sfx)\n{\nchar namebuf[9];\nsprintf(namebuf, \"ds%s\", sfx->name);\nreturn W_GetNumForName(namebuf);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {char* sfx_name; } ;\ntypedef  TYPE_1__ gameaction_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  sscanf (char*,char*,int*) ;\n\nint I_GetSfxLumpNum(gameaction_t *ga)\n{\nint lumpnum;\n\nsscanf(ga->sfx_name, \"sfx%d\", &lumpnum);\nreturn lumpnum;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BspiAttack",
    "input":"\n0000000000000000 <A_BspiAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x1f <A_BspiAttack+0x1f>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_BspiAttack+0xe>\ne: \tmovl\t(%rbx), %esi\n10: \tmovl\t(%rip), %edx  # 0x16 <A_BspiAttack+0x16>\n16: \tmovq\t%rbx, %rdi\n19: \tpopq\t%rbx\n1a: \tjmp\t0x1f <A_BspiAttack+0x1f>\n1f: \tpopq\t%rbx\n20: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  MT_ARACHPLAZ ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_BspiAttack (mobj_t *actor)\n{\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\n\n// launch a missile\nP_SpawnMissile (actor, actor->target, MT_ARACHPLAZ);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  bspi_attack; int /*<<< orphan*/  bspi_attack_active; } ;\ntypedef  TYPE_1__ user ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  bspi_attack (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  bspi_attack_active (TYPE_1__*) ;\n\nvoid A_BspiAttack(user *u)\n{\nif (u->bspi_attack_active)\nbspi_attack(u, u->bspi_attack, TRUE);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_FatAttack1",
    "input":"\n0000000000000000 <A_FatAttack1>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tcallq\t0xc <A_FatAttack1+0xc>\nc: \tmovl\t(%rip), %eax  # 0x12 <A_FatAttack1+0x12>\n12: \taddl\t%eax, (%rbx)\n14: \tmovl\t32(%rbx), %esi\n17: \tmovl\t(%rip), %edx  # 0x1d <A_FatAttack1+0x1d>\n1d: \tmovq\t%rbx, %rdi\n20: \tcallq\t0x25 <A_FatAttack1+0x25>\n25: \tmovl\t32(%rbx), %esi\n28: \tmovl\t(%rip), %edx  # 0x2e <A_FatAttack1+0x2e>\n2e: \tmovq\t%rbx, %rdi\n31: \tcallq\t0x36 <A_FatAttack1+0x36>\n36: \tmovq\t%rax, %rbx\n39: \tmovl\t(%rax), %eax\n3b: \taddl\t(%rip), %eax  # 0x41 <A_FatAttack1+0x41>\n41: \tmovl\t%eax, (%rbx)\n43: \tmovb\t(%rip), %cl   # 0x49 <A_FatAttack1+0x49>\n49: \tsarl\t%cl, %eax\n4b: \tmovq\t8(%rbx), %rcx\n4f: \tmovl\t(%rcx), %edi\n51: \tmovq\t(%rip), %rcx  # 0x58 <A_FatAttack1+0x58>\n58: \tmovslq\t%eax, %r14\n5b: \tmovl\t(%rcx,%r14,4), %esi\n5f: \tcallq\t0x64 <A_FatAttack1+0x64>\n64: \tmovq\t%rax, 24(%rbx)\n68: \tmovq\t8(%rbx), %rax\n6c: \tmovl\t(%rax), %edi\n6e: \tmovq\t(%rip), %rax  # 0x75 <A_FatAttack1+0x75>\n75: \tmovl\t(%rax,%r14,4), %esi\n79: \tcallq\t0x7e <A_FatAttack1+0x7e>\n7e: \tmovq\t%rax, 16(%rbx)\n82: \taddq\t$8, %rsp\n86: \tpopq\t%rbx\n87: \tpopq\t%r14\n89: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int angle; TYPE_1__* info; void* momy; void* momx; int /*<<< orphan*/  target; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  speed; } ;\n\n/* Variables and functions */\nint ANGLETOFINESHIFT ;\nint /*<<< orphan*/  A_FaceTarget (TYPE_2__*) ;\nscalar_t__ FATSPREAD ;\nvoid* FixedMul (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MT_FATSHOT ;\nTYPE_2__* P_SpawnMissile (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * finecosine ;\nint /*<<< orphan*/ * finesine ;\n\nvoid A_FatAttack1 (mobj_t* actor)\n{\nmobj_t*\tmo;\nint\t\tan;\n\nA_FaceTarget (actor);\n// Change direction  to ...\nactor->angle += FATSPREAD;\nP_SpawnMissile (actor, actor->target, MT_FATSHOT);\n\nmo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\nmo->angle += FATSPREAD;\nan = mo->angle >> ANGLETOFINESHIFT;\nmo->momx = FixedMul (mo->info->speed, finecosine[an]);\nmo->momy = FixedMul (mo->info->speed, finesine[an]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  nAction; TYPE_1__* pTarget; int /*<<< orphan*/  nCounter; int /*<<< orphan*/  nMessage; } ;\ntypedef  TYPE_2__* PANIM_ANI ;\ntypedef  int /*<<< orphan*/  PANIM_OBJ ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FatAttack2 ;\nint /*<<< orphan*/  A_FatAttack3 ;\nint /*<<< orphan*/  A_FatAttack4 ;\nint /*<<< orphan*/  A_FatAttack5 ;\nint /*<<< orphan*/  A_FatAttack6 ;\nint /*<<< orphan*/  A_FatAttack7 ;\nint /*<<< orphan*/  A_FatAttack8 ;\nint /*<<< orphan*/  A_FatAttack9 ;\nint /*<<< orphan*/  A_FatAttack10 ;\nint /*<<< orphan*/  A_FatAttack11 ;\nint /*<<< orphan*/  A_FatAttack12 ;\nint /*<<< orphan*/  A_FatAttack13 ;\nint /*<<< orphan*/  A_FatAttack14 ;\nint /*<<< orphan*/  A_FatAttack15 ;\nint /*<<< orphan*/  A_FatAttack16 ;\nint /*<<< orphan*/  A_FatAttack17 ;\nint /*<<< orphan*/  A_FatAttack18 ;\nint /*<<< orphan*/  A_FatAttack19 ;\nint /*<<< orphan*/  A_FatAttack20 ;\nint /*<<< orphan*/  A_FatAttack21 ;\nint /*<<< orphan*/  A_FatAttack22 ;\nint /*<<< orphan*/  A_FatAttack23 ;\nint /*<<< orphan*/  A_FatAttack24 ;\nint /*<<< orphan*/  A_FatAttack25 ;\nint /*<<< orphan*/  A_FatAttack26 ;\nint /*<<< orphan*/  A_FatAttack27 ;\nint /*<<< orphan*/  A_FatAttack28 ;\nint /*<<< orphan*/  A_FatAttack29 ;\nint /*<<< orphan*/  A_FatAttack30 ;\nint /*<<< orphan*/  A_FatAttack31 ;\nint /*<<< orphan*/  A_FatAttack32 ;\nint /*<<< orphan*/  A_FatAttack33 ;\nint /*<<< orphan*/  A_FatAttack34 ;\nint /*<<< orphan*/  A_FatAttack35 ;\nint /*<<< orphan*/  A_FatAttack36 ;\nint /*<<< orphan*/  A_FatAttack37 ;\nint /*<<< orphan*/  A_FatAttack38 ;\nint /*<<< orphan*/  A_FatAttack39 ;\nint /*<<< orphan*/  A_FatAttack40 ;\nint /*<<< orphan*/  A_FatAttack41 ;\nint /*<<< orphan*/  A_FatAttack42 ;\nint /*<<< orphan*/  A_FatAttack43 ;\nint /*<<< orphan*/  A_FatAttack44 ;\nint /*<<< orphan*/  A_FatAttack45 ;\nint /*<<< orphan*/  A_FatAttack46 ;\nint /*<<< orphan*/  A_FatAttack47 ;\nint /*<<< orphan*/  A_FatAttack48 ;\nint /*<<< orphan*/  A_FatAttack49 ;\nint /*<<< orphan*/  A_FatAttack50 ;\nint /*<<< orphan*/  A_FatAttack51 ;\nint /*<<< orphan*/  A_FatAttack52 ;\nint /*<<< orphan*/  A_FatAttack53 ;\nint /*<<< orphan*/  A_FatAttack54 ;\nint /*<<< orphan*/  A_FatAttack55 ;\nint /*<<< orphan*/  A_FatAttack56 ;\nint /*<<< orphan*/  A_FatAttack57 ;\nint /*<<< orphan*/  A_FatAttack58 ;\nint /*<<< orphan*/  A_FatAttack59 ;\nint /*<<< orphan*/  A_FatAttack60 ;\nint /*<<< orphan*/  A_FatAttack61 ;\nint /*<<< orphan*/  A_FatAttack62 ;\nint /*<<< orphan*/  A_FatAttack63 ;\nint /*<<< orphan*/  A_FatAttack64 ;\nint /*<<< orphan*/  A_FatAttack65 ;\nint /*<<< orphan*/  A_FatAttack66 ;\nint /*<<< orphan*/  A_FatAttack67 ;\nint /*<<< orphan*/  A_FatAttack68 ;\nint /*<<< orphan*/  A_FatAttack69 ;\nint /*<<< orphan*/  A_FatAttack70 ;\nint /*<<< orphan*/  A_FatAttack71 ;\nint /*<<< orphan*/  A_FatAttack72 ;\nint /*<<< orphan*/  A_FatAttack73 ;\nint /*<<< orphan*/  A_FatAttack74 ;\nint /*<<< orphan*/  A_FatAttack75 ;\nint /*<<< orphan*/  A_FatAttack76 ;\nint /*<<< orphan*/  A_FatAttack77 ;\nint /*<<< orphan*/  A_FatAttack78 ;\nint /*<<< orphan*/  A_FatAttack79 ;\nint /*<<< orphan*/  A_FatAttack80 ;\nint /*<<< orphan*/  A_FatAttack81 ;\nint /*<<< orphan*/  A_FatAttack82 ;\nint /*<<< orphan*/  A_FatAttack83 ;\nint /*<<< orphan*/  A_FatAttack84 ;\nint /*<<< orphan*/  A_FatAttack85 ;\nint /*<<< orphan*/  A_FatAttack86 ;\nint /*<<< orphan*/  A_FatAttack87 ;\nint /*<<< orphan*/  A_FatAttack88 ;\nint /*<<< orphan*/  A_FatAttack89 ;\nint /*<<< orphan*/  A_FatAttack90 ;\nint /*<<< orphan*/  A_FatAttack91 ;\nint /*<<< orphan*/  A_FatAttack92 ;\nint /*<<< orphan*/  A_FatAttack93 ;\nint /*<<< orphan*/  A_FatAttack94 ;\nint /*<<< orphan*/  A_FatAttack95 ;\nint /*<<< orphan*/  A_FatAttack96 ;\nint /*<<< orphan*/  A_FatAttack97 ;\nint /*<<< orphan*/  A_FatAttack98 ;\nint /*<<< orphan*/  A_FatAttack99 ;\nint /*<<< orphan*/  A_FatAttack100 ;\nint"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_doRefresh",
    "input":"\n0000000000000000 <ST_doRefresh>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, (%rip)    # 0xb <ST_doRefresh+0xb>\nb: \txorl\t%eax, %eax\nd: \tcallq\t0x12 <ST_doRefresh+0x12>\n12: \tmovl\t$1, %edi\n17: \tpopq\t%rax\n18: \tjmp\t0x1d <ST_doRefresh+0x1d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_drawWidgets (int) ;\nint /*<<< orphan*/  ST_refreshBackground () ;\nint st_firsttime ;\n\nvoid ST_doRefresh(void)\n{\n\nst_firsttime = false;\n\n// draw status bar background to off-screen buff\nST_refreshBackground();\n\n// and refresh all widgets\nST_drawWidgets(true);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_doRefresh_all () ;\nint /*<<< orphan*/  ST_doRefresh_one () ;\nint /*<<< orphan*/  ST_refresh_all ;\n\nvoid ST_doRefresh(void)\n{\nST_refresh_all = 0;\nST_doRefresh_one();\nST_doRefresh_all();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_strupr",
    "input":"\n0000000000000000 <strupr>:\n0: \tpushq\t%rbx\n1: \tmovb\t(%rdi), %al\n3: \ttestb\t%al, %al\n5: \tje\t0x26 <strupr+0x26>\n7: \tmovq\t%rdi, %rbx\na: \taddq\t$1, %rbx\ne: \tnop\n10: \tmovsbl\t%al, %edi\n13: \tcallq\t0x18 <strupr+0x18>\n18: \tmovb\t%al, -1(%rbx)\n1b: \tmovzbl\t(%rbx), %eax\n1e: \taddq\t$1, %rbx\n22: \ttestb\t%al, %al\n24: \tjne\t0x10 <strupr+0x10>\n26: \tpopq\t%rbx\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar toupper (char) ;\n\nvoid strupr (char* s)\n{\nwhile (*s) { *s = toupper(*s); s++; }\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar toupper (char) ;\n\nvoid strupr(char *s)\n{\nwhile (*s)\n{\n*s = toupper(*s);\ns++;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_updateLightLev",
    "input":"\n0000000000000000 <AM_updateLightLev>:\n0: \tmovl\t(%rip), %eax  # 0x6 <AM_updateLightLev+0x6>\n6: \tcmpl\t(%rip), %eax  # 0xc <AM_updateLightLev+0xc>\nc: \tjle\t0x5e <AM_updateLightLev+0x5e>\ne: \tmovslq\t(%rip), %rcx  # 0x15 <AM_updateLightLev+0x15>\n15: \tleal\t1(%rcx), %edx\n18: \tmovl\t%edx, (%rip)  # 0x1e <AM_updateLightLev+0x1e>\n1e: \tmovl\t(,%rcx,4), %ecx\n25: \tmovl\t%ecx, (%rip)  # 0x2b <AM_updateLightLev+0x2b>\n2b: \tcmpl\t$8, %edx\n2e: \tjne\t0x3a <AM_updateLightLev+0x3a>\n30: \tmovl\t$0, (%rip)    # 0x3a <AM_updateLightLev+0x3a>\n3a: \tcltq\n3c: \timulq\t$715827883, %rax, %rax  # imm = 0x2AAAAAAB\n43: \tmovq\t%rax, %rcx\n46: \tshrq\t$63, %rcx\n4a: \tshrq\t$32, %rax\n4e: \taddl\t%ecx, %eax\n50: \tleal\t(%rax,%rax,2), %eax\n53: \taddl\t%eax, %eax\n55: \taddl\t$6, %eax\n58: \tmovl\t%eax, (%rip)  # 0x5e <AM_updateLightLev+0x5e>\n5e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  litelevels ;\n\n/* Variables and functions */\nint amclock ;\nint lightlev ;\nint nexttic ;\n\nvoid AM_updateLightLev(void)\n{\nstatic nexttic = 0;\n//static int litelevels[] = { 0, 3, 5, 6, 6, 7, 7, 7 };\nstatic int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\nstatic int litelevelscnt = 0;\n\n// Change light level\nif (amclock>nexttic)\n{\nlightlev = litelevels[litelevelscnt++];\nif (litelevelscnt == sizeof(litelevels)/sizeof(int)) litelevelscnt = 0;\nnexttic = amclock + 6 - (amclock % 6);\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint AM_lightLev ;\nint AM_lightLevMax ;\nint AM_lightLevMin ;\nint AM_lightLevStep ;\nint AM_lightLevStepMax ;\nint AM_lightLevStepMin ;\nint AM_lightLevStepTime ;\nint AM_lightLevTime ;\n\nvoid AM_updateLightLev(void)\n{\nif (AM_lightLev < AM_lightLevMax)\n{\nAM_lightLev++;\nAM_lightLevStep = AM_lightLevStepMin + (AM_lightLevStepMax - AM_lightLevStepMin) * AM_lightLev / AM_lightLevMax;\nif (AM_lightLev == 8)\nAM_lightLevStep = 0;\nAM_lightLevTime = AM_lightLevStep * 2 + 6;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BrainExplode",
    "input":"\n0000000000000000 <A_BrainExplode>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t(%rdi), %ebp\n9: \txorl\t%eax, %eax\nb: \tcallq\t0x10 <A_BrainExplode+0x10>\n10: \tmovl\t%eax, %ebx\n12: \txorl\t%eax, %eax\n14: \tcallq\t0x19 <A_BrainExplode+0x19>\n19: \tsubl\t%eax, %ebx\n1b: \tshll\t$11, %ebx\n1e: \taddl\t%ebx, %ebp\n20: \tmovl\t4(%r14), %ebx\n24: \txorl\t%eax, %eax\n26: \tcallq\t0x2b <A_BrainExplode+0x2b>\n2b: \timull\t(%rip), %eax  # 0x32 <A_BrainExplode+0x32>\n32: \tleal\t(%rax,%rax), %edx\n35: \taddl\t$128, %edx\n3b: \tmovl\t(%rip), %ecx  # 0x41 <A_BrainExplode+0x41>\n41: \tmovl\t%ebp, %edi\n43: \tmovl\t%ebx, %esi\n45: \tcallq\t0x4a <A_BrainExplode+0x4a>\n4a: \tmovq\t%rax, %rbx\n4d: \txorl\t%eax, %eax\n4f: \tcallq\t0x54 <A_BrainExplode+0x54>\n54: \tshll\t$9, %eax\n57: \tmovl\t%eax, 8(%rbx)\n5a: \tmovl\t(%rip), %esi  # 0x60 <A_BrainExplode+0x60>\n60: \tmovq\t%rbx, %rdi\n63: \tcallq\t0x68 <A_BrainExplode+0x68>\n68: \txorl\t%eax, %eax\n6a: \tcallq\t0x6f <A_BrainExplode+0x6f>\n6f: \tandl\t$7, %eax\n72: \tmovl\t12(%rbx), %ecx\n75: \tsubl\t%eax, %ecx\n77: \ttestl\t%ecx, %ecx\n79: \tmovl\t$1, %eax\n7e: \tcmovgl\t%ecx, %eax\n81: \tmovl\t%eax, 12(%rbx)\n84: \tpopq\t%rbx\n85: \tpopq\t%r14\n87: \tpopq\t%rbp\n88: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int x; int y; int momz; int tics; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint FRACUNIT ;\nint /*<<< orphan*/  MT_ROCKET ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_1__*,int /*<<< orphan*/ ) ;\nTYPE_1__* P_SpawnMobj (int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_BRAINEXPLODE1 ;\n\nvoid A_BrainExplode (mobj_t* mo)\n{\nint\t\tx;\nint\t\ty;\nint\t\tz;\nmobj_t*\tth;\n\nx = mo->x + (P_Random () - P_Random ())*2048;\ny = mo->y;\nz = 128 + P_Random()*2*FRACUNIT;\nth = P_SpawnMobj (x,y,z, MT_ROCKET);\nth->momz = P_Random()*512;\n\nP_SetMobjState (th, S_BRAINEXPLODE1);\n\nth->tics -= P_Random()&7;\nif (th->tics < 1)\nth->tics = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int z; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_1__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ACTOR_BRAIN ;\nint /*<<< orphan*/  ACTOR_BRAIN_EXPLODE ;\nint /*<<< orphan*/  ACTOR_BRAIN_EXPLODE_TIME ;\nint /*<<< orphan*/  ACTOR_BRAIN_EXPLODE_TIME_MAX ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetFrame (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetSprite (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetTimer (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Spawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_P_ChangeSector",
    "input":"\n0000000000000000 <P_ChangeSector>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovl\t$0, (%rip)    # 0xf <P_ChangeSector+0xf>\nf: \tmovl\t%esi, (%rip)  # 0x15 <P_ChangeSector+0x15>\n15: \tmovq\t(%rdi), %rcx\n18: \tmovq\t(%rip), %rax  # 0x1f <P_ChangeSector+0x1f>\n1f: \tmovl\t(%rcx,%rax,4), %r15d\n23: \tmovq\t(%rip), %rdx  # 0x2a <P_ChangeSector+0x2a>\n2a: \txorl\t%eax, %eax\n2c: \tcmpl\t(%rcx,%rdx,4), %r15d\n30: \tjg\t0x93 <P_ChangeSector+0x93>\n32: \tmovq\t%rdi, %r14\n35: \tmovq\t(%rip), %rax  # 0x3c <P_ChangeSector+0x3c>\n3c: \tjmp\t0x4d <P_ChangeSector+0x4d>\n3e: \tnop\n40: \tleal\t1(%r15), %esi\n44: \tcmpl\t(%rcx,%rdx,4), %r15d\n48: \tmovl\t%esi, %r15d\n4b: \tjge\t0x8d <P_ChangeSector+0x8d>\n4d: \tmovq\t(%rip), %rsi  # 0x54 <P_ChangeSector+0x54>\n54: \tmovl\t(%rcx,%rsi,4), %ebx\n57: \tcmpl\t(%rcx,%rax,4), %ebx\n5a: \tjg\t0x40 <P_ChangeSector+0x40>\n5c: \tnopl\t(%rax)\n60: \tmovl\t(%rip), %edx  # 0x66 <P_ChangeSector+0x66>\n66: \tmovl\t%r15d, %edi\n69: \tmovl\t%ebx, %esi\n6b: \tcallq\t0x70 <P_ChangeSector+0x70>\n70: \tleal\t1(%rbx), %edx\n73: \tmovq\t(%r14), %rcx\n76: \tmovq\t(%rip), %rax  # 0x7d <P_ChangeSector+0x7d>\n7d: \tcmpl\t(%rcx,%rax,4), %ebx\n80: \tmovl\t%edx, %ebx\n82: \tjl\t0x60 <P_ChangeSector+0x60>\n84: \tmovq\t(%rip), %rdx  # 0x8b <P_ChangeSector+0x8b>\n8b: \tjmp\t0x40 <P_ChangeSector+0x40>\n8d: \tmovl\t(%rip), %eax  # 0x93 <P_ChangeSector+0x93>\n93: \tpopq\t%rbx\n94: \tpopq\t%r14\n96: \tpopq\t%r15\n98: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* blockbox; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nsize_t BOXBOTTOM ;\nsize_t BOXLEFT ;\nsize_t BOXRIGHT ;\nsize_t BOXTOP ;\nint /*<<< orphan*/  PIT_ChangeSector ;\nint /*<<< orphan*/  P_BlockThingsIterator (int,int,int /*<<< orphan*/ ) ;\nint crushchange ;\nint nofit ;\n\nboolean\nP_ChangeSector\n( sector_t*\tsector,\nboolean\tcrunch )\n{\nint\t\tx;\nint\t\ty;\n\nnofit = false;\ncrushchange = crunch;\n\n// re-check heights for all things near the moving sector\nfor (x=sector->blockbox[BOXLEFT] ; x<= sector->blockbox[BOXRIGHT] ; x++)\nfor (y=sector->blockbox[BOXBOTTOM];y<= sector->blockbox[BOXTOP] ; y++)\nP_BlockThingsIterator (x, y, PIT_ChangeSector);\n\n\nreturn nofit;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* sector; } ;\ntypedef  TYPE_1__* PLAYER ;\ntypedef  int INT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_ChangeSector_f ;\nint /*<<< orphan*/  P_ChangeSector_p ;\nint /*<<< orphan*/  P_ChangeSector_s ;\nint /*<<< orphan*/  P_ChangeSector_u ;\nint /*<<< orphan*/  P_ChangeSector_v ;\nint /*<<< orphan*/  P_ChangeSector_w ;\nint /*<<< orphan*/  P_ChangeSector_x ;\nint /*<<< orphan*/  P_ChangeSector_y ;\nint /*<<< orphan*/  P_ChangeSector_z ;\nint /*<<< orphan*/  P_ChangeSector_z_ ;\nint /*<<< orphan*/  P_ChangeSector_z__ ;\nint /*<<< orphan*/  P_ChangeSector_z___ ;\nint /*<<< orphan*/  P_ChangeSector_z____ ;\nint /*<<< orphan*/  P_ChangeSector_z_____ ;\nint /*<<< orphan*/  P_ChangeSector_z______ ;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______ ;\nint /*<<< orphan*/  P_ChangeSector_z________;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;\nint /*<<< orphan*/  P_ChangeSector_z_______;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_Explode",
    "input":"\n0000000000000000 <A_Explode>:\n0: \tmovl\t(%rdi), %esi\n2: \tmovl\t$128, %edx\n7: \tjmp\t0xc <A_Explode+0xc>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_RadiusAttack (TYPE_1__*,int /*<<< orphan*/ ,int) ;\n\nvoid A_Explode (mobj_t* thingy)\n{\nP_RadiusAttack ( thingy, thingy->target, 128 );\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  a; } ;\ntypedef  TYPE_1__* Pcplx ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Explode_ (TYPE_1__*,int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void A_Explode(Pcplx z)\n{\nA_Explode_(z, z->a, 128);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_bsp.c_R_ClipPassWallSegment",
    "input":"\n0000000000000000 <R_ClipPassWallSegment>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%esi, %ebp\n5: \tmovl\t%edi, %eax\n7: \tmovq\t(%rip), %rbx  # 0xe <R_ClipPassWallSegment+0xe>\ne: \tleal\t-1(%rax), %ecx\n11: \taddq\t$4, %rbx\n15: \tnopw\t%cs:(%rax,%rax)\n1f: \tnop\n20: \tmovl\t-4(%rbx), %edi\n23: \taddq\t$8, %rbx\n27: \tcmpl\t%ecx, %edi\n29: \tjl\t0x20 <R_ClipPassWallSegment+0x20>\n2b: \tmovl\t-8(%rbx), %esi\n2e: \tcmpl\t%eax, %esi\n30: \tjle\t0x78 <R_ClipPassWallSegment+0x78>\n32: \taddl\t$-1, %esi\n35: \tmovl\t%eax, %edi\n37: \tcmpl\t%ebp, %esi\n39: \tjle\t0x48 <R_ClipPassWallSegment+0x48>\n3b: \tmovl\t%ebp, %esi\n3d: \taddq\t$8, %rsp\n41: \tpopq\t%rbx\n42: \tpopq\t%rbp\n43: \tjmp\t0x48 <R_ClipPassWallSegment+0x48>\n48: \tcallq\t0x4d <R_ClipPassWallSegment+0x4d>\n4d: \tmovl\t-12(%rbx), %edi\n50: \tjmp\t0x78 <R_ClipPassWallSegment+0x78>\n52: \tnopw\t%cs:(%rax,%rax)\n5c: \tnopl\t(%rax)\n60: \tmovl\t(%rbx), %esi\n62: \taddl\t$-1, %esi\n65: \taddl\t$1, %edi\n68: \tcmpl\t%ebp, %esi\n6a: \tjg\t0x3b <R_ClipPassWallSegment+0x3b>\n6c: \tcallq\t0x71 <R_ClipPassWallSegment+0x71>\n71: \tmovl\t-4(%rbx), %edi\n74: \taddq\t$8, %rbx\n78: \tcmpl\t%ebp, %edi\n7a: \tjl\t0x60 <R_ClipPassWallSegment+0x60>\n7c: \taddq\t$8, %rsp\n80: \tpopq\t%rbx\n81: \tpopq\t%rbp\n82: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int last; int first; } ;\ntypedef  TYPE_1__ cliprange_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_StoreWallRange (int,int) ;\nTYPE_1__* solidsegs ;\n\nvoid\nR_ClipPassWallSegment\n( int\tfirst,\nint\tlast )\n{\ncliprange_t*\tstart;\n\n// Find the first range that touches the range\n//  (adjacent pixels are touching).\nstart = solidsegs;\nwhile (start->last < first-1)\nstart++;\n\nif (first < start->first)\n{\nif (last < start->first-1)\n{\n// Post is entirely visible (above start).\nR_StoreWallRange (first, last);\nreturn;\n}\n\n// There is a fragment above *start.\nR_StoreWallRange (first, start->first - 1);\n}\n\n// Bottom contained in start?\nif (last <= start->last)\nreturn;\n\nwhile (last >= (start+1)->first-1)\n{\n// There is a fragment between two posts.\nR_StoreWallRange (start->last + 1, (start+1)->first - 1);\nstart++;\n\nif (last <= start->last)\nreturn;\n}\n\n// There is a fragment after *next.\nR_StoreWallRange (start->last + 1, last);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x1; int x2; int y1; int y2; } ;\ntypedef  TYPE_1__ line_t ;\n\n/* Variables and functions */\nTYPE_1__* linedefs ;\nint /*<<< orphan*/  R_DrawWallSegment (int,int) ;\n\nvoid R_ClipPassWallSegment(int x1, int x2)\n{\nline_t *ld;\n\nld = linedefs;\n\nwhile (ld->x1 < x1)\nld++;\n\nwhile (ld->x2 > x2)\n{\nif (ld->y1 < x1)\nR_DrawWallSegment(ld->y1, x1 - 1);\nif (ld->y2 > x2)\nR_DrawWallSegment(x2 + 1, ld->y2);\nld++;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_updateNum",
    "input":"\n0000000000000000 <STlib_updateNum>:\n0: \tmovq\t(%rdi), %rax\n3: \tcmpq\t$0, (%rax)\n7: \tje\t0xe <STlib_updateNum+0xe>\n9: \tjmp\t0xe <STlib_updateNum+0xe>\ne: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__* on; } ;\ntypedef  TYPE_1__ st_number_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  STlib_drawNum (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nvoid\nSTlib_updateNum\n( st_number_t*\t\tn,\nboolean\t\trefresh )\n{\nif (*n->on) STlib_drawNum(n, refresh);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* pVtbl; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  (* updateNum ) (TYPE_2__*,int /*<<< orphan*/ ) ;} ;\ntypedef  TYPE_2__ IStdStorage ;\ntypedef  int /*<<< orphan*/  HRESULT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  stub1 (TYPE_2__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static inline HRESULT STlib_updateNum(IStdStorage *This, HRESULT hr)\n{\nif (This->pVtbl->updateNum)\nreturn This->pVtbl->updateNum(This, hr);\nreturn hr;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_P_SpawnLightFlash",
    "input":"\n0000000000000000 <P_SpawnLightFlash>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovq\t$0, 8(%rdi)\nf: \tmovl\t(%rip), %esi  # 0x15 <P_SpawnLightFlash+0x15>\n15: \tmovl\t$40, %edi\n1a: \txorl\t%edx, %edx\n1c: \tcallq\t0x21 <P_SpawnLightFlash+0x21>\n21: \tmovq\t%rax, %rbx\n24: \tleaq\t32(%rax), %rdi\n28: \tcallq\t0x2d <P_SpawnLightFlash+0x2d>\n2d: \tmovq\t(%rip), %rax  # 0x34 <P_SpawnLightFlash+0x34>\n34: \tmovq\t%rax, 32(%rbx)\n38: \tmovq\t%r14, 24(%rbx)\n3c: \tmovl\t(%r14), %esi\n3f: \tmovl\t%esi, 16(%rbx)\n42: \tmovq\t%r14, %rdi\n45: \tcallq\t0x4a <P_SpawnLightFlash+0x4a>\n4a: \tmovl\t%eax, 12(%rbx)\n4d: \tmovabsq\t$30064771136, %rax # imm = 0x700000040\n57: \tmovq\t%rax, (%rbx)\n5a: \txorl\t%eax, %eax\n5c: \tcallq\t0x61 <P_SpawnLightFlash+0x61>\n61: \tandl\t(%rbx), %eax\n63: \taddl\t$1, %eax\n66: \tmovl\t%eax, 8(%rbx)\n69: \taddq\t$8, %rsp\n6d: \tpopq\t%rbx\n6e: \tpopq\t%r14\n70: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_7__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  lightlevel; scalar_t__ special; } ;\ntypedef  TYPE_2__ sector_t ;\nstruct TYPE_8__ {scalar_t__ acp1; } ;\nstruct TYPE_11__ {TYPE_1__ function; } ;\nstruct TYPE_10__ {int maxtime; int mintime; int count; int /*<<< orphan*/  minlight; int /*<<< orphan*/  maxlight; TYPE_2__* sector; TYPE_7__ thinker; } ;\ntypedef  TYPE_3__ lightflash_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_LEVSPEC ;\nint /*<<< orphan*/  P_AddThinker (TYPE_7__*) ;\nint /*<<< orphan*/  P_FindMinSurroundingLight (TYPE_2__*,int /*<<< orphan*/ ) ;\nint P_Random () ;\nscalar_t__ T_LightFlash ;\nTYPE_3__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid P_SpawnLightFlash (sector_t*\tsector)\n{\nlightflash_t*\tflash;\n\n// nothing special about it during gameplay\nsector->special = 0;\n\nflash = Z_Malloc ( sizeof(*flash), PU_LEVSPEC, 0);\n\nP_AddThinker (&flash->thinker);\n\nflash->thinker.function.acp1 = (actionf_p1) T_LightFlash;\nflash->sector = sector;\nflash->maxlight = sector->lightlevel;\n\nflash->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel);\nflash->maxtime = 64;\nflash->mintime = 7;\nflash->count = (P_Random()&flash->maxtime)+1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; int /*<<< orphan*/  z; int /*<<< orphan*/  radius; int /*<<< orphan*/  radius2; int /*<<< orphan*/  radius3; int /*<<< orphan*/  radius4; int /*<<< orphan*/  radius5; int /*<<< orphan*/  radius6; int /*<<< orphan*/  radius7; int /*<<< orphan*/  radius8; int /*<<< orphan*/  radius9; int /*<<< orphan*/  radius10; int /*<<< orphan*/  radius11; int /*<<< orphan*/  radius12; int /*<<< orphan*/  radius13; int /*<<< orphan*/  radius14; int /*<<< orphan*/  radius15; int /*<<< orphan*/  radius16; int /*<<< orphan*/  radius17; int /*<<< orphan*/  radius18; int /*<<< orphan*/  radius19; int /*<<< orphan*/  radius20; int /*<<< orphan*/  radius21; int /*<<< orphan*/  radius22; int /*<<< orphan*/  radius23; int /*<<< orphan*/  radius24; int /*<<< orphan*/  radius25; int /*<<< orphan*/  radius26; int /*<<< orphan*/  radius27; int /*<<< orphan*/  radius28; int /*<<< orphan*/  radius29; int /*<<< orphan*/  radius30; int /*<<< orphan*/  radius31; int /*<<< orphan*/  radius32; int /*<<< orphan*/  radius33; int /*<<< orphan*/  radius34; int /*<<< orphan*/  radius35; int /*<<< orphan*/  radius36; int /*<<< orphan*/  radius37; int /*<<< orphan*/  radius38; int /*<<< orphan*/  radius39; int /*<<< orphan*/  radius40; int /*<<< orphan*/  radius41; int /*<<< orphan*/  radius42; int /*<<< orphan*/  radius43; int /*<<< orphan*/  radius44; int /*<<< orphan*/  radius45; int /*<<< orphan*/  radius46; int /*<<< orphan*/  radius47; int /*<<< orphan*/  radius48; int /*<<< orphan*/  radius49; int /*<<< orphan*/  radius50; int /*<<< orphan*/  radius51; int /*<<< orphan*/  radius52; int /*<<< orphan*/  radius53; int /*<<< orphan*/  radius54; int /*<<< orphan*/  radius55; int /*<<< orphan*/  radius56; int /*<<< orphan*/  radius57; int /*<<< orphan*/  radius58; int /*<<< orphan*/  radius59; int /*<<< orphan*/  radius60; int /*<<< orphan*/  radius61; int /*<<< orphan*/  radius62; int /*<<< orphan*/  radius63; int /*<<< orphan*/  radius64; int /*<<< orphan*/  radius65; int /*<<< orphan*/  radius66; int /*<<< orphan*/  radius67; int /*<<< orphan*/  radius68; int /*<<< orphan*/  radius69; int /*<<< orphan*/  radius70; int /*<<< orphan*/  radius71; int /*<<< orphan*/  radius72; int /*<<< orphan*/  radius73; int /*<<< orphan*/  radius74; int /*<<< orphan*/  radius75; int /*<<< orphan*/  radius76; int /*<<< orphan*/  radius77; int /*<<< orphan*/  radius78; int /*<<< orphan*/  radius79; int /*<<< orphan*/  radius80; int /*<<< orphan*/  radius81; int /*<<< orphan*/  radius82; int /*<<< orphan*/  radius83; int /*<<< orphan*/  radius84; int /*<<< orphan*/  radius85; int /*<<< orphan*/  radius86; int /*<<< orphan*/  radius87; int /*<<< orphan*/  radius88; int /*<<< orphan*/  radius89; int /*<<< orphan*/  radius90; int /*<<< orphan*/  radius91; int /*<<< orphan*/  radius92; int /*<<< orphan*/  radius93; int /*<<< orphan*/  radius94; int /*<<< orphan*/  radius95; int /*<<< orphan*/  radius96; int /*<<< orphan*/  radius97; int /*<<< orphan*/  radius98; int /*<<< orphan*/  radius99; int /*<<< orphan*/  radius100; int /*<<< orphan*/  radius101; int /*<<< orphan*/  radius102; int /*<<< orphan*/  radius103; int /*<<< orphan*/  radius104; int /*<<< orphan*/  radius105; int /*<<< orphan*/  radius106; int /*<<< orphan*/  radius107; int /*<<< orphan*/  radius108; int /*<<< orphan*/  radius109; int /*<<< orphan*/  radius110; int /*<<< orphan*/  radius111; int /*<<< orphan*/  radius112; int /*<<< orphan*/  radius113; int /*<<< orphan*/  radius114; int /*<<< orphan*/  radius115; int /*<<< orphan*/  radius116; int /*<<< orphan*/  radius117; int /*<<< orphan*/  radius118; int /*<<< orphan*/  radius119; int /*<<< orphan*/  radius120; int /*<<< orphan*/  radius121; int /*<<< orphan*/  radius122; int /*<<< orphan*/  radius123; int /*<<< orphan*/  radius124; int /*<<< orphan*/  radius125; int /*<<< orphan*/  radius126; int /*<<< orphan*/  radius127; int /*<<< orphan*/  radius128; int /*<<< orphan*/  radius129; int /*<<< orphan*/  radius130; int /*<<< orphan*/  radius131; int /*<<< orphan*/  radius132; int /*<<< orphan*/  radius133; int /*<<< orphan*/  radius134; int /*<<< orphan*/  radius135; int /*<<< orphan*/  radius136; int /*<<< orphan*/  radius137; int /*<<< orphan*/  radius138; int /*<<< orphan*/  radius139; int /*<<< orphan*/  radius140; int /*<<< orphan*/  radius141; int /*<<< orphan*/  radius142; int /*<<< orphan*/  radius143; int /*<<< orphan*/  radius144; int /*<<< orphan*/  radius145; int /*<<< orphan*/  radius146; int /*<<< orphan*/  radius147; int /*<<< orphan*/  radius148; int /*<<< orphan*/  radius149; int /*<<< orphan*/  radius150; int /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_refreshBackground",
    "input":"\n0000000000000000 <ST_refreshBackground>:\n0: \tpushq\t%rax\n1: \tcmpq\t$0, (%rip)    # 0x9 <ST_refreshBackground+0x9>\n9: \tje\t0x7e <ST_refreshBackground+0x7e>\nb: \tmovl\t(%rip), %edi  # 0x11 <ST_refreshBackground+0x11>\n11: \tmovl\t(%rip), %edx  # 0x17 <ST_refreshBackground+0x17>\n17: \tmovl\t(%rip), %ecx  # 0x1d <ST_refreshBackground+0x1d>\n1d: \txorl\t%esi, %esi\n1f: \tcallq\t0x24 <ST_refreshBackground+0x24>\n24: \tcmpq\t$0, (%rip)    # 0x2c <ST_refreshBackground+0x2c>\n2c: \tje\t0x47 <ST_refreshBackground+0x47>\n2e: \tmovl\t(%rip), %edi  # 0x34 <ST_refreshBackground+0x34>\n34: \tmovl\t(%rip), %edx  # 0x3a <ST_refreshBackground+0x3a>\n3a: \tmovl\t(%rip), %ecx  # 0x40 <ST_refreshBackground+0x40>\n40: \txorl\t%esi, %esi\n42: \tcallq\t0x47 <ST_refreshBackground+0x47>\n47: \tmovl\t(%rip), %edi  # 0x4d <ST_refreshBackground+0x4d>\n4d: \tmovl\t(%rip), %edx  # 0x53 <ST_refreshBackground+0x53>\n53: \tmovl\t(%rip), %ecx  # 0x59 <ST_refreshBackground+0x59>\n59: \tmovl\t(%rip), %r8d  # 0x60 <ST_refreshBackground+0x60>\n60: \tmovl\t(%rip), %r10d # 0x67 <ST_refreshBackground+0x67>\n67: \tmovl\t(%rip), %eax  # 0x6d <ST_refreshBackground+0x6d>\n6d: \txorl\t%esi, %esi\n6f: \tmovl\t%edi, %r9d\n72: \tpushq\t%rax\n73: \tpushq\t%r10\n75: \tcallq\t0x7a <ST_refreshBackground+0x7a>\n7a: \taddq\t$16, %rsp\n7e: \tpopq\t%rax\n7f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  BG ;\nint /*<<< orphan*/  FG ;\nint /*<<< orphan*/  ST_FX ;\nint /*<<< orphan*/  ST_HEIGHT ;\nint /*<<< orphan*/  ST_WIDTH ;\nint /*<<< orphan*/  ST_X ;\nint /*<<< orphan*/  ST_Y ;\nint /*<<< orphan*/  V_CopyRect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  faceback ;\nscalar_t__ netgame ;\nint /*<<< orphan*/  sbar ;\nscalar_t__ st_statusbaron ;\n\nvoid ST_refreshBackground(void)\n{\n\nif (st_statusbaron)\n{\nV_DrawPatch(ST_X, 0, BG, sbar);\n\nif (netgame)\nV_DrawPatch(ST_FX, 0, BG, faceback);\n\nV_CopyRect(ST_X, 0, BG, ST_WIDTH, ST_HEIGHT, ST_X, ST_Y, FG);\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_BACKGROUND_COLOR ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_RED_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_GREEN ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_OPACITY ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_RED ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_ALPHA ;\nint /*<<< orphan*/  ST_BACKGROUND_COLOR_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_YELLOW_BLUE ;\nint /*<<< orphan*/  ST_BACKGROUND_COL"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_P_RecursiveSound",
    "input":"\n0000000000000000 <P_RecursiveSound>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovl\t%esi, %r14d\nb: \tmovq\t%rdi, %r15\ne: \tmovq\t(%rip), %rax  # 0x15 <P_RecursiveSound+0x15>\n15: \tcmpq\t%rax, (%rdi)\n18: \tjne\t0x29 <P_RecursiveSound+0x29>\n1a: \tleal\t1(%r14), %ecx\n1e: \tcmpl\t%ecx, 8(%r15)\n22: \tjg\t0x2d <P_RecursiveSound+0x2d>\n24: \tjmp\t0xbc <P_RecursiveSound+0xbc>\n29: \tleal\t1(%r14), %ecx\n2d: \tmovq\t%rax, (%r15)\n30: \tmovl\t%ecx, 8(%r15)\n34: \tmovl\t(%rip), %eax  # 0x3a <P_RecursiveSound+0x3a>\n3a: \tmovl\t%eax, 24(%r15)\n3e: \tcmpl\t$0, 12(%r15)\n43: \tjle\t0xbc <P_RecursiveSound+0xbc>\n45: \txorl\t%ebx, %ebx\n47: \tjmp\t0x5e <P_RecursiveSound+0x5e>\n49: \tmovl\t%r14d, %esi\n4c: \tcallq\t0x51 <P_RecursiveSound+0x51>\n51: \taddq\t$1, %rbx\n55: \tmovslq\t12(%r15), %rax\n59: \tcmpq\t%rax, %rbx\n5c: \tjge\t0xbc <P_RecursiveSound+0xbc>\n5e: \tmovq\t16(%r15), %rax\n62: \tmovq\t(%rax,%rbx,8), %r12\n66: \tmovl\t(%rip), %eax  # 0x6c <P_RecursiveSound+0x6c>\n6c: \ttestl\t%eax, (%r12)\n70: \tje\t0x51 <P_RecursiveSound+0x51>\n72: \tmovq\t%r12, %rdi\n75: \tcallq\t0x7a <P_RecursiveSound+0x7a>\n7a: \tcmpq\t$0, (%rip)    # 0x82 <P_RecursiveSound+0x82>\n82: \tjle\t0x51 <P_RecursiveSound+0x51>\n84: \tmovq\t(%rip), %rax  # 0x8b <P_RecursiveSound+0x8b>\n8b: \tmovq\t8(%r12), %rcx\n90: \tmovq\t(%rcx), %rdx\n93: \tmovq\t(%rax,%rdx,8), %rdi\n97: \tcmpq\t%r15, %rdi\n9a: \tjne\t0xa4 <P_RecursiveSound+0xa4>\n9c: \tmovq\t8(%rcx), %rcx\na0: \tmovq\t(%rax,%rcx,8), %rdi\na4: \tmovl\t(%rip), %eax  # 0xaa <P_RecursiveSound+0xaa>\naa: \ttestl\t%eax, (%r12)\nae: \tje\t0x49 <P_RecursiveSound+0x49>\nb0: \ttestl\t%r14d, %r14d\nb3: \tjne\t0x51 <P_RecursiveSound+0x51>\nb5: \tmovl\t$1, %esi\nba: \tjmp\t0x4c <P_RecursiveSound+0x4c>\nbc: \taddq\t$8, %rsp\nc0: \tpopq\t%rbx\nc1: \tpopq\t%r12\nc3: \tpopq\t%r14\nc5: \tpopq\t%r15\nc7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ validcount; int soundtraversed; int linecount; TYPE_2__** lines; int /*<<< orphan*/  soundtarget; } ;\ntypedef  TYPE_1__ sector_t ;\nstruct TYPE_7__ {int flags; size_t* sidenum; } ;\ntypedef  TYPE_2__ line_t ;\nstruct TYPE_8__ {TYPE_1__* sector; } ;\n\n/* Variables and functions */\nint ML_SOUNDBLOCK ;\nint ML_TWOSIDED ;\nint /*<<< orphan*/  P_LineOpening (TYPE_2__*) ;\nscalar_t__ openrange ;\nTYPE_3__* sides ;\nint /*<<< orphan*/  soundtarget ;\nscalar_t__ validcount ;\n\nvoid\nP_RecursiveSound\n( sector_t*\tsec,\nint\t\tsoundblocks )\n{\nint\t\ti;\nline_t*\tcheck;\nsector_t*\tother;\n\n// wake up all monsters in this sector\nif (sec->validcount == validcount\n&& sec->soundtraversed <= soundblocks+1)\n{\nreturn;\t\t// already flooded\n}\n\nsec->validcount = validcount;\nsec->soundtraversed = soundblocks+1;\nsec->soundtarget = soundtarget;\n\nfor (i=0 ;i<sec->linecount ; i++)\n{\ncheck = sec->lines[i];\nif (! (check->flags & ML_TWOSIDED) )\ncontinue;\n\nP_LineOpening (check);\n\nif (openrange <= 0)\ncontinue;\t// closed door\n\nif ( sides[ check->sidenum[0] ].sector == sec)\nother = sides[ check->sidenum[1] ] .sector;\nelse\nother = sides[ check->sidenum[0] ].sector;\n\nif (check->flags & ML_SOUNDBLOCK)\n{\nif (!soundblocks)\nP_RecursiveSound (other, 1);\n}\nelse\nP_RecursiveSound (other, soundblocks);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  sound_id; int /*<<< orphan*/  flags; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  sound_id; int /*<<< orphan*/  flags; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  sound_id; int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__* PANEL_OBJECT ;\ntypedef  TYPE_2__* PANEL_SOUND ;\ntypedef  TYPE_3__* PANEL_SOUND_LIST ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_RecursiveSound (TYPE_3__*,int) ;\nint /*<<< orphan*/  P_Sound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundList (TYPE_2__*,int) ;\nint /*<<< orphan*/  P_SoundObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundObjectRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursive (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObject (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveObjectList (TYPE_1__*,int) ;\nint /*<<< orphan*/  P_SoundSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSoundRecursiveSound (TYPE_1__*,int) ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_doors.c_P_SpawnDoorRaiseIn5Mins",
    "input":"\n0000000000000000 <P_SpawnDoorRaiseIn5Mins>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovl\t(%rip), %esi  # 0xd <P_SpawnDoorRaiseIn5Mins+0xd>\nd: \tmovl\t$40, %edi\n12: \txorl\t%edx, %edx\n14: \tcallq\t0x19 <P_SpawnDoorRaiseIn5Mins+0x19>\n19: \tmovq\t%rax, %rbx\n1c: \tleaq\t32(%rax), %rdi\n20: \tcallq\t0x25 <P_SpawnDoorRaiseIn5Mins+0x25>\n25: \tmovq\t%rbx, 8(%r14)\n29: \tmovq\t$0, (%r14)\n30: \tmovq\t(%rip), %rax  # 0x37 <P_SpawnDoorRaiseIn5Mins+0x37>\n37: \tmovq\t%rax, 32(%rbx)\n3b: \tmovq\t%r14, 24(%rbx)\n3f: \tmovl\t$2, (%rbx)\n45: \tmovl\t(%rip), %eax  # 0x4b <P_SpawnDoorRaiseIn5Mins+0x4b>\n4b: \tmovl\t%eax, 20(%rbx)\n4e: \tmovl\t(%rip), %eax  # 0x54 <P_SpawnDoorRaiseIn5Mins+0x54>\n54: \tmovl\t%eax, 16(%rbx)\n57: \tmovq\t%r14, %rdi\n5a: \tcallq\t0x5f <P_SpawnDoorRaiseIn5Mins+0x5f>\n5f: \tmovl\t(%rip), %ecx  # 0x65 <P_SpawnDoorRaiseIn5Mins+0x65>\n65: \tshll\t$2, %ecx\n68: \tsubl\t%ecx, %eax\n6a: \tmovl\t%eax, 4(%rbx)\n6d: \tmovl\t(%rip), %eax  # 0x73 <P_SpawnDoorRaiseIn5Mins+0x73>\n73: \tmovl\t%eax, 12(%rbx)\n76: \tmovl\t$10500, 8(%rbx)    # imm = 0x2904\n7d: \taddq\t$8, %rsp\n81: \tpopq\t%rbx\n82: \tpopq\t%r14\n84: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_7__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ acp1; } ;\nstruct TYPE_11__ {TYPE_1__ function; } ;\nstruct TYPE_9__ {int direction; int topheight; int topcountdown; int /*<<< orphan*/  topwait; int /*<<< orphan*/  speed; int /*<<< orphan*/  type; TYPE_3__* sector; TYPE_7__ thinker; } ;\ntypedef  TYPE_2__ vldoor_t ;\nstruct TYPE_10__ {scalar_t__ special; TYPE_2__* specialdata; } ;\ntypedef  TYPE_3__ sector_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint FRACUNIT ;\nint /*<<< orphan*/  PU_LEVSPEC ;\nint /*<<< orphan*/  P_AddThinker (TYPE_7__*) ;\nint P_FindLowestCeilingSurrounding (TYPE_3__*) ;\nscalar_t__ T_VerticalDoor ;\nint /*<<< orphan*/  VDOORSPEED ;\nint /*<<< orphan*/  VDOORWAIT ;\nTYPE_2__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  raiseIn5Mins ;\n\nvoid\nP_SpawnDoorRaiseIn5Mins\n( sector_t*\tsec,\nint\t\tsecnum )\n{\nvldoor_t*\tdoor;\n\ndoor = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\nP_AddThinker (&door->thinker);\n\nsec->specialdata = door;\nsec->special = 0;\n\ndoor->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\ndoor->sector = sec;\ndoor->direction = 2;\ndoor->type = raiseIn5Mins;\ndoor->speed = VDOORSPEED;\ndoor->topheight = P_FindLowestCeilingSurrounding(sec);\ndoor->topheight -= 4*FRACUNIT;\ndoor->topwait = VDOORWAIT;\ndoor->topcountdown = 5 * 60 * 35;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  type; int /*<<< orphan*/  special; int /*<<< orphan*/  height; int /*<<< orphan*/  angle; int /*<<< orphan*/  flags; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  type; int /*<<< orphan*/  special; int /*<<< orphan*/  height; int /*<<< orphan*/  angle; int /*<<< orphan*/  flags; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  type; int /*<<< orphan*/  special; int /*<<< orphan*/  height; int /*<<< orphan*/  angle; int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__* PANEL_SPRITE ;\ntypedef  TYPE_2__* PANEL_OBJECT ;\ntypedef  TYPE_3__* PANEL_SPRITE_OBJECT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PanelSpriteObject ;\nint /*<<< orphan*/  PanelSpriteObjectSize ;\nint /*<<< orphan*/  PanelSpriteObjectType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeType ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeTypeSize ;\nint /*<<< orphan*/  PanelSpriteObjectTypeType"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_v_video.c_V_DrawBlock",
    "input":"\n0000000000000000 <V_DrawBlock>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%r9, %rbx\ne: \tmovl\t%r8d, %r15d\n11: \tmovl\t%ecx, %r14d\n14: \tmovl\t%edx, %r13d\n17: \tmovl\t%esi, %ebp\n19: \tmovl\t%edi, %r12d\n1c: \tmovl\t%ecx, %edx\n1e: \tmovl\t%r8d, %ecx\n21: \tcallq\t0x26 <V_DrawBlock+0x26>\n26: \ttestl\t%r15d, %r15d\n29: \tje\t0x83 <V_DrawBlock+0x83>\n2b: \tmovq\t(%rip), %rax  # 0x32 <V_DrawBlock+0x32>\n32: \tmovslq\t%r13d, %rcx\n35: \tmovslq\t(%rip), %rdx  # 0x3c <V_DrawBlock+0x3c>\n3c: \tmovslq\t%ebp, %rsi\n3f: \timulq\t%rdx, %rsi\n43: \tshlq\t$2, %rsi\n47: \taddq\t(%rax,%rcx,8), %rsi\n4b: \tmovslq\t%r12d, %rax\n4e: \tleaq\t(%rsi,%rax,4), %rbp\n52: \tmovslq\t%r14d, %r12\n55: \tshlq\t$2, %r12\n59: \tnopl\t(%rax)\n60: \tmovq\t%rbp, %rdi\n63: \tmovq\t%rbx, %rsi\n66: \tmovl\t%r14d, %edx\n69: \tcallq\t0x6e <V_DrawBlock+0x6e>\n6e: \taddq\t%r12, %rbx\n71: \tmovslq\t(%rip), %rax  # 0x78 <V_DrawBlock+0x78>\n78: \tleaq\t(%rbp,%rax,4), %rbp\n7d: \taddl\t$-1, %r15d\n81: \tjne\t0x60 <V_DrawBlock+0x60>\n83: \taddq\t$8, %rsp\n87: \tpopq\t%rbx\n88: \tpopq\t%r12\n8a: \tpopq\t%r13\n8c: \tpopq\t%r14\n8e: \tpopq\t%r15\n90: \tpopq\t%rbp\n91: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/  V_MarkRect (int,int,int,int) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ ** screens ;\n\nvoid\nV_DrawBlock\n( int\t\tx,\nint\t\ty,\nint\t\tscrn,\nint\t\twidth,\nint\t\theight,\nbyte*\t\tsrc )\n{\nbyte*\tdest;\n\n#ifdef RANGECHECK\nif (x<0\n||x+width >SCREENWIDTH\n|| y<0\n|| y+height>SCREENHEIGHT\n|| (unsigned)scrn>4 )\n{\nI_Error (\"Bad V_DrawBlock\");\n}\n#endif\n\nV_MarkRect (x, y, width, height);\n\ndest = screens[scrn] + y*SCREENWIDTH+x;\n\nwhile (height--)\n{\nmemcpy (dest, src, width);\nsrc += width;\ndest += SCREENWIDTH;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  v_draw_block_line (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ ** v_draw_buffer ;\nint v_draw_buffer_height ;\nint v_draw_buffer_width ;\n\nvoid V_DrawBlock(int x, int y, int w, int h, uint8_t *src)\n{\nint i;\n\nv_draw_block_line(src, v_draw_buffer[y] + x, w);\n\nfor (i = 1; i < h; i++)\n{\nsrc += v_draw_buffer_width * 4;\nv_draw_block_line(src, v_draw_buffer[y + i] + x, w);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_InterceptVector",
    "input":"\n0000000000000000 <P_InterceptVector>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovl\t(%rsi), %edi\nc: \tsarl\t$8, %edi\nf: \tmovl\t4(%r14), %esi\n13: \tcallq\t0x18 <P_InterceptVector+0x18>\n18: \tmovss\t%xmm0, (%rsp)\n1d: \tmovl\t4(%rbx), %edi\n20: \tsarl\t$8, %edi\n23: \tmovl\t(%r14), %esi\n26: \tcallq\t0x2b <P_InterceptVector+0x2b>\n2b: \tmovss\t(%rsp), %xmm1 # xmm1 = mem[0],zero,zero,zero\n30: \tsubss\t%xmm0, %xmm1\n34: \txorps\t%xmm0, %xmm0\n37: \tmovss\t%xmm1, (%rsp)\n3c: \tucomiss\t%xmm0, %xmm1\n3f: \tjne\t0x4e <P_InterceptVector+0x4e>\n41: \tjp\t0x4e <P_InterceptVector+0x4e>\n43: \txorps\t%xmm0, %xmm0\n46: \taddq\t$8, %rsp\n4a: \tpopq\t%rbx\n4b: \tpopq\t%r14\n4d: \tretq\n4e: \tmovl\t(%rbx), %esi\n50: \tmovl\t8(%rbx), %edi\n53: \tsubl\t8(%r14), %edi\n57: \tsarl\t$8, %edi\n5a: \tcallq\t0x5f <P_InterceptVector+0x5f>\n5f: \tmovss\t%xmm0, 4(%rsp)\n65: \tmovl\t12(%r14), %edi\n69: \tsubl\t12(%rbx), %edi\n6c: \tsarl\t$8, %edi\n6f: \tmovl\t4(%rbx), %esi\n72: \tcallq\t0x77 <P_InterceptVector+0x77>\n77: \taddss\t4(%rsp), %xmm0\n7d: \tmovss\t(%rsp), %xmm1 # xmm1 = mem[0],zero,zero,zero\n82: \taddq\t$8, %rsp\n86: \tpopq\t%rbx\n87: \tpopq\t%r14\n89: \tjmp\t0x8e <P_InterceptVector+0x8e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  float fixed_t ;\nstruct TYPE_4__ {int dy; int dx; int x; int y; } ;\ntypedef  TYPE_1__ divline_t ;\n\n/* Variables and functions */\nfloat FRACUNIT ;\nfloat FixedDiv (float,float) ;\nfloat FixedMul (int,int) ;\n\nfixed_t\nP_InterceptVector\n( divline_t*\tv2,\ndivline_t*\tv1 )\n{\n#if 1\nfixed_t\tfrac;\nfixed_t\tnum;\nfixed_t\tden;\n\nden = FixedMul (v1->dy>>8,v2->dx) - FixedMul(v1->dx>>8,v2->dy);\n\nif (den == 0)\nreturn 0;\n//\tI_Error (\"P_InterceptVector: parallel\");\n\nnum =\nFixedMul ( (v1->x - v2->x)>>8 ,v1->dy )\n+FixedMul ( (v2->y - v1->y)>>8, v1->dx );\n\nfrac = FixedDiv (num , den);\n\nreturn frac;\n#else\t// UNUSED, float debug.\nfloat\tfrac;\nfloat\tnum;\nfloat\tden;\nfloat\tv1x;\nfloat\tv1y;\nfloat\tv1dx;\nfloat\tv1dy;\nfloat\tv2x;\nfloat\tv2y;\nfloat\tv2dx;\nfloat\tv2dy;\n\nv1x = (float)v1->x/FRACUNIT;\nv1y = (float)v1->y/FRACUNIT;\nv1dx = (float)v1->dx/FRACUNIT;\nv1dy = (float)v1->dy/FRACUNIT;\nv2x = (float)v2->x/FRACUNIT;\nv2y = (float)v2->y/FRACUNIT;\nv2dx = (float)v2->dx/FRACUNIT;\nv2dy = (float)v2->dy/FRACUNIT;\n\nden = v1dy*v2dx - v1dx*v2dy;\n\nif (den == 0)\nreturn 0;\t// parallel\n\nnum = (v1x - v2x)*v1dy + (v2y - v1y)*v1dx;\nfrac = num / den;\n\nreturn frac*FRACUNIT;\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int z; } ;\ntypedef  TYPE_1__ VECTOR ;\n\n/* Variables and functions */\nfloat V_Length (int,int) ;\nfloat V_DotProduct (int,int) ;\n\n__attribute__((used)) static float P_InterceptVector(VECTOR *v1, VECTOR *v2)\n{\nfloat dp, l1, l2;\n\ndp = V_DotProduct(v1->x >> 8, v2->x >> 8);\nl1 = V_Length(v1->x >> 8, v1->y >> 8);\nl2 = V_Length(v2->x >> 8, v2->y >> 8);\n\nif (dp + 1.0f < l1 * l2)\nreturn 0.0f;\n\nreturn V_DotProduct(v1->z >> 8, v2->z >> 8) / (l1 * l2);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_initSText",
    "input":"\n0000000000000000 <HUlib_initSText>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$24, %rsp\ne: \tmovl\t%edx, 12(%rsp)\n12: \tmovq\t80(%rsp), %rax\n17: \tmovl\t%ecx, (%rdi)\n19: \tmovq\t%rax, 24(%rdi)\n1d: \tmovl\t$1, 4(%rdi)\n24: \tmovq\t$0, 16(%rdi)\n2c: \ttestl\t%ecx, %ecx\n2e: \tjle\t0x94 <HUlib_initSText+0x94>\n30: \tmovl\t%r9d, %ebp\n33: \tmovq\t%r8, %r13\n36: \tmovl\t%esi, %ebx\n38: \tmovq\t%rdi, %r14\n3b: \tmovl\t%ecx, %eax\n3d: \tshlq\t$2, %rax\n41: \tmovq\t%rax, 16(%rsp)\n46: \txorl\t%r15d, %r15d\n49: \txorl\t%r12d, %r12d\n4c: \tmovl\t%esi, 8(%rsp)\n50: \tmovl\t%ebp, %ebx\n52: \tmovq\t8(%r14), %rbp\n56: \taddq\t%r12, %rbp\n59: \tmovq\t(%r13), %rax\n5d: \tmovl\t(%rax), %edi\n5f: \tcallq\t0x64 <HUlib_initSText+0x64>\n64: \taddl\t$1, %eax\n67: \timull\t%r15d, %eax\n6b: \tmovl\t12(%rsp), %edx\n6f: \tsubl\t%eax, %edx\n71: \tmovq\t%rbp, %rdi\n74: \tmovl\t%ebx, %ebp\n76: \tmovl\t8(%rsp), %esi\n7a: \tmovq\t%r13, %rcx\n7d: \tmovl\t%ebx, %r8d\n80: \tcallq\t0x85 <HUlib_initSText+0x85>\n85: \taddq\t$4, %r12\n89: \taddl\t$1, %r15d\n8d: \tcmpq\t%r12, 16(%rsp)\n92: \tjne\t0x50 <HUlib_initSText+0x50>\n94: \taddq\t$24, %rsp\n98: \tpopq\t%rbx\n99: \tpopq\t%r12\n9b: \tpopq\t%r13\n9d: \tpopq\t%r14\n9f: \tpopq\t%r15\na1: \tpopq\t%rbp\na2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  height; } ;\ntypedef  TYPE_1__ patch_t ;\nstruct TYPE_7__ {int h; int laston; int /*<<< orphan*/ * l; scalar_t__ cl; int /*<<< orphan*/ * on; } ;\ntypedef  TYPE_2__ hu_stext_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_initTextLine (int /*<<< orphan*/ *,int,int,TYPE_1__**,int) ;\nint SHORT (int /*<<< orphan*/ ) ;\n\nvoid\nHUlib_initSText\n( hu_stext_t*\ts,\nint\t\tx,\nint\t\ty,\nint\t\th,\npatch_t**\tfont,\nint\t\tstartchar,\nboolean*\ton )\n{\n\nint i;\n\ns->h = h;\ns->on = on;\ns->laston = true;\ns->cl = 0;\nfor (i=0;i<h;i++)\nHUlib_initTextLine(&s->l[i],\nx, y - i*(SHORT(font[0]->height)+1),\nfont, startchar);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  font; int /*<<< orphan*/ * text; int /*<<< orphan*/  x; int /*<<< orphan*/  y; int /*<<< orphan*/  w; int /*<<< orphan*/  h; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  font; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  font; } ;\ntypedef  TYPE_1__ HUChar ;\ntypedef  TYPE_2__ HUText ;\ntypedef  TYPE_3__ HUCharInfo ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_FONT_HEIGHT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_FONT_WIDTH (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_HEIGHT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_WIDTH (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_X (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_BOTTOM_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_BOTTOM_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HU_TEXT_Y_OFFSET_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_TOP_BOTTO"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BrainSpit",
    "input":"\n0000000000000000 <A_BrainSpit>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \txorl\t$1, (%rip)    # 0xe <A_BrainSpit+0xe>\ne: \tjne\t0x28 <A_BrainSpit+0x28>\n10: \tmovq\t(%rip), %rax  # 0x17 <A_BrainSpit+0x17>\n17: \tcmpq\t%rax, (%rip)  # 0x1e <A_BrainSpit+0x1e>\n1e: \tjg\t0x28 <A_BrainSpit+0x28>\n20: \taddq\t$8, %rsp\n24: \tpopq\t%rbx\n25: \tpopq\t%r14\n27: \tretq\n28: \tmovq\t(%rip), %rcx  # 0x2f <A_BrainSpit+0x2f>\n2f: \tmovq\t(%rip), %rax  # 0x36 <A_BrainSpit+0x36>\n36: \tmovq\t(%rcx,%rax,8), %rbx\n3a: \taddq\t$1, %rax\n3e: \txorl\t%edx, %edx\n40: \tdivq\t(%rip)   # 0x47 <A_BrainSpit+0x47>\n47: \tmovq\t%rdx, (%rip)  # 0x4e <A_BrainSpit+0x4e>\n4e: \tmovl\t(%rip), %edx  # 0x54 <A_BrainSpit+0x54>\n54: \tmovq\t%r14, %rdi\n57: \tmovq\t%rbx, %rsi\n5a: \tcallq\t0x5f <A_BrainSpit+0x5f>\n5f: \tmovq\t%rax, %rcx\n62: \tmovq\t%rbx, 24(%rax)\n66: \tmovl\t4(%rbx), %eax\n69: \tsubl\t4(%r14), %eax\n6d: \tcltd\n6e: \tidivl\t8(%rcx)\n71: \tmovq\t16(%rcx), %rsi\n75: \tcltd\n76: \tidivl\t(%rsi)\n78: \tmovl\t%eax, (%rcx)\n7a: \tmovl\t(%rip), %esi  # 0x80 <A_BrainSpit+0x80>\n80: \txorl\t%edi, %edi\n82: \taddq\t$8, %rsp\n86: \tpopq\t%rbx\n87: \tpopq\t%r14\n89: \tjmp\t0x8e <A_BrainSpit+0x8e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int reactiontime; int y; int momy; TYPE_1__* state; struct TYPE_9__* target; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_8__ {int tics; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MT_SPAWNSHOT ;\nTYPE_2__* P_SpawnMissile (TYPE_2__*,TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nsize_t braintargeton ;\nTYPE_2__** braintargets ;\nscalar_t__ gameskill ;\nsize_t numbraintargets ;\nint /*<<< orphan*/  sfx_bospit ;\nscalar_t__ sk_easy ;\n\nvoid A_BrainSpit (mobj_t*\tmo)\n{\nmobj_t*\ttarg;\nmobj_t*\tnewmobj;\n\nstatic int\teasy = 0;\n\neasy ^= 1;\nif (gameskill <= sk_easy && (!easy))\nreturn;\n\n// shoot a cube at current target\ntarg = braintargets[braintargeton];\nbraintargeton = (braintargeton+1)%numbraintargets;\n\n// spawn brain missile\nnewmobj = P_SpawnMissile (mo, targ, MT_SPAWNSHOT);\nnewmobj->target = targ;\nnewmobj->reactiontime =\n((targ->y - mo->y)/newmobj->momy) / newmobj->state->tics;\n\nS_StartSound(NULL, sfx_bospit);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int x; int y; int /*<<< orphan*/  sprite; int /*<<< orphan*/ * next; } ;\ntypedef  TYPE_1__ Object ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnimFacing (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ANIM_BRAINSPIT ;\nint /*<<< orphan*/  ANIM_BRAINSPIT_FRAMES ;\nint /*<<< orphan*/  ANIM_BRAINSPIT_RATE ;\nint /*<<< orphan*/  brainspit_list ;\nint /*<<< orphan*/  brainspit_num ;\nTYPE_1__** brainspit_objects ;\nint /*<<< orphan*/  brainspit_rate ;\nint /*<<< orphan*/  brainspit_sprite ;\n\nvoid A_BrainSpit(Object *o)\n{\nstatic int brainspit_count = 0;\n\nif (++brainspit_count == brainspit_rate)\n{\nbrainspit_count = 0;\n\nif (brainspit_num < brainspit_rate)\n{\nObject *brainspit;\n\nbrainspit = brainspit_objects[brainspit_num++];\nbrainspit->x = o->x;\nbrainspit->y = o->y;\nbrainspit->sprite = brainspit_sprite;\nbrainspit->next = NULL;\n\nA_SetAnim(brainspit, ANIM_BRAINSPIT, ANIM_BRAINSPIT_FRAMES);\nA_SetAnimFacing(brainspit, 0);\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_SfxVol",
    "input":"\n0000000000000000 <M_SfxVol>:\n0: \ttestl\t%edi, %edi\n2: \tje\t0x19 <M_SfxVol+0x19>\n4: \tcmpl\t$1, %edi\n7: \tjne\t0x31 <M_SfxVol+0x31>\n9: \tmovl\t(%rip), %edi  # 0xf <M_SfxVol+0xf>\nf: \tcmpl\t$14, %edi\n12: \tjg\t0x2c <M_SfxVol+0x2c>\n14: \taddl\t$1, %edi\n17: \tjmp\t0x26 <M_SfxVol+0x26>\n19: \tmovl\t(%rip), %edi  # 0x1f <M_SfxVol+0x1f>\n1f: \ttestl\t%edi, %edi\n21: \tje\t0x3c <M_SfxVol+0x3c>\n23: \taddl\t$-1, %edi\n26: \tmovl\t%edi, (%rip)  # 0x2c <M_SfxVol+0x2c>\n2c: \tjmp\t0x31 <M_SfxVol+0x31>\n31: \tmovl\t(%rip), %edi  # 0x37 <M_SfxVol+0x37>\n37: \tjmp\t0x3c <M_SfxVol+0x3c>\n3c: \txorl\t%edi, %edi\n3e: \tjmp\t0x43 <M_SfxVol+0x43>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  S_SetSfxVolume (int) ;\nint snd_SfxVolume ;\n\nvoid M_SfxVol(int choice)\n{\nswitch(choice)\n{\ncase 0:\nif (snd_SfxVolume)\nsnd_SfxVolume--;\nbreak;\ncase 1:\nif (snd_SfxVolume < 15)\nsnd_SfxVolume++;\nbreak;\n}\n\nS_SetSfxVolume(snd_SfxVolume /* *8 */);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SfxVol_Set (int) ;\nint /*<<< orphan*/  M_SfxVol_Stop () ;\nint /*<<< orphan*/  M_SfxVol_Stop_Set (int) ;\nint SfxVol ;\n\nvoid M_SfxVol(int vol)\n{\nif (vol)\n{\nif (vol != 1)\n{\nif (vol < 15)\n{\nvol++;\n}\nSfxVol = vol;\n}\nelse\n{\nSfxVol = 0;\n}\nM_SfxVol_Set(SfxVol);\n}\nelse\n{\nM_SfxVol_Stop();\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_keyInIText",
    "input":"\n0000000000000000 <HUlib_keyInIText>:\n0: \tpushq\t%rax\n1: \tleal\t-32(%rsi), %eax\n4: \tcmpb\t$63, %al\n6: \tja\t0x13 <HUlib_keyInIText+0x13>\n8: \tmovsbl\t%sil, %esi\nc: \tcallq\t0x11 <HUlib_keyInIText+0x11>\n11: \tjmp\t0x2e <HUlib_keyInIText+0x2e>\n13: \tcmpb\t%sil, (%rip)  # 0x1a <HUlib_keyInIText+0x1a>\n1a: \tjne\t0x23 <HUlib_keyInIText+0x23>\n1c: \tcallq\t0x21 <HUlib_keyInIText+0x21>\n21: \tjmp\t0x2e <HUlib_keyInIText+0x2e>\n23: \txorl\t%eax, %eax\n25: \tcmpb\t%sil, (%rip)  # 0x2c <HUlib_keyInIText+0x2c>\n2c: \tjne\t0x33 <HUlib_keyInIText+0x33>\n2e: \tmovl\t$1, %eax\n33: \tpopq\t%rcx\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  l; } ;\ntypedef  TYPE_1__ hu_itext_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_addCharToTextLine (int /*<<< orphan*/ *,char) ;\nint /*<<< orphan*/  HUlib_delCharFromIText (TYPE_1__*) ;\nunsigned char KEY_BACKSPACE ;\nunsigned char KEY_ENTER ;\n\nboolean\nHUlib_keyInIText\n( hu_itext_t*\tit,\nunsigned char ch )\n{\n\nif (ch >= ' ' && ch <= '_')\nHUlib_addCharToTextLine(&it->l, (char) ch);\nelse\nif (ch == KEY_BACKSPACE)\nHUlib_delCharFromIText(it);\nelse\nif (ch != KEY_ENTER)\nreturn false; // did not eat key\n\nreturn true; // ate the key\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HUCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_keyInText (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText5 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText6 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText7 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText8 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText9 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextA (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextB (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextC (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextD (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextE (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextF (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextG (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextH (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextI (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextJ (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextK (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextM (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextO (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextP (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextQ (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextR (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextS (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextU (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextV (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextW (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextX (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextY (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInTextZ (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_ (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_0 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_1 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_5 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_6 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_7 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_8 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_9 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_A (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_B (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_C (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_D (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_E (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_F (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_G (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_keyInText_H (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_draw.c_R_VideoErase",
    "input":"\n0000000000000000 <R_VideoErase>:\n0: \tmovl\t%esi, %edx\n2: \tmovl\t%edi, %esi\n4: \tmovq\t(%rip), %rax  # 0xb <R_VideoErase+0xb>\nb: \tmovl\t(%rax), %edi\nd: \taddl\t%esi, %edi\nf: \taddl\t4(%rax), %esi\n12: \tjmp\t0x17 <R_VideoErase+0x17>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (unsigned int,unsigned int,int) ;\nunsigned int* screens ;\n\nvoid\nR_VideoErase\n( unsigned\tofs,\nint\t\tcount )\n{\n// LFB copy.\n// This might not be a good idea if memcpy\n//  is not optiomal, e.g. byte by byte on\n//  a 32bit CPU, as GNU GCC/Linux libc did\n//  at one point.\nmemcpy (screens[0]+ofs, screens[1]+ofs, count);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  vram; int /*<<< orphan*/  vram_size; } ;\n\n/* Variables and functions */\nTYPE_1__* VDP ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int,int) ;\n\nvoid R_VideoErase(unsigned int x, unsigned int y)\n{\nmemset(VDP->vram + (x + y * VDP->vram_size), 0, VDP->vram_size);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_SetupNextMenu",
    "input":"\n0000000000000000 <M_SetupNextMenu>:\n0: \tmovq\t%rdi, (%rip)  # 0x7 <M_SetupNextMenu+0x7>\n7: \tmovl\t(%rdi), %eax\n9: \tmovl\t%eax, (%rip)  # 0xf <M_SetupNextMenu+0xf>\nf: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  lastOn; } ;\ntypedef  TYPE_1__ menu_t ;\n\n/* Variables and functions */\nTYPE_1__* currentMenu ;\nint /*<<< orphan*/  itemOn ;\n\nvoid M_SetupNextMenu(menu_t *menudef)\n{\ncurrentMenu = menudef;\nitemOn = currentMenu->lastOn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  menu; } ;\ntypedef  TYPE_1__ MENU_INFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_CurrentMenu ;\nTYPE_1__* M_NextMenu ;\n\nvoid M_SetupNextMenu(MENU_INFO *menu)\n{\nM_NextMenu = menu;\nM_CurrentMenu = menu->menu;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_fixed.c_FixedDiv",
    "input":"\n0000000000000000 <FixedDiv>:\n0: \tmovl\t%edi, %eax\n2: \tnegl\t%eax\n4: \tcmovll\t%edi, %eax\n7: \tshrl\t$14, %eax\na: \tmovl\t%esi, %ecx\nc: \tnegl\t%ecx\ne: \tcmovll\t%esi, %ecx\n11: \tcmpl\t%ecx, %eax\n13: \tjge\t0x1a <FixedDiv+0x1a>\n15: \tjmp\t0x1a <FixedDiv+0x1a>\n1a: \txorl\t%edi, %esi\n1c: \tmovl\t$0, %eax\n21: \tmovl\t$0, %ecx\n26: \tcmovsq\t%rax, %rcx\n2a: \tmovl\t(%rcx), %eax\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nint FixedDiv2 (int,int) ;\nint MAXINT ;\nint MININT ;\nint abs (int) ;\n\nfixed_t\nFixedDiv\n( fixed_t\ta,\nfixed_t\tb )\n{\nif ( (abs(a)>>14) >= abs(b))\nreturn (a^b)<0 ? MININT : MAXINT;\nreturn FixedDiv2 (a,b);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int Fixed ;\n\n/* Variables and functions */\nint FixedDiv2 (int,int) ;\nint FixedDiv3 (int,int) ;\nint FixedDiv4 (int,int) ;\n\n__attribute__((used)) static inline Fixed\nFixedDiv(Fixed a, Fixed b)\n{\nif (a < 0)\n{\nif (b < 0)\nreturn FixedDiv4(a, b);\nelse\nreturn FixedDiv2(a, b);\n}\nelse\n{\nif (b < 0)\nreturn FixedDiv2(a, b);\nelse\nreturn FixedDiv4(a, b);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_CacheLumpNum",
    "input":"\n0000000000000000 <W_CacheLumpNum>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%esi, %r14d\n7: \tmovl\t%edi, %ebx\n9: \tcmpl\t%edi, (%rip)  # 0xf <W_CacheLumpNum+0xf>\nf: \tja\t0x1d <W_CacheLumpNum+0x1d>\n11: \tmovl\t$0, %edi\n16: \tmovl\t%ebx, %esi\n18: \tcallq\t0x1d <W_CacheLumpNum+0x1d>\n1d: \tmovq\t(%rip), %rax  # 0x24 <W_CacheLumpNum+0x24>\n24: \tmovslq\t%ebx, %rbp\n27: \tmovq\t(%rax,%rbp,8), %rdi\n2b: \ttestq\t%rdi, %rdi\n2e: \tje\t0x3a <W_CacheLumpNum+0x3a>\n30: \tmovl\t%r14d, %esi\n33: \tcallq\t0x38 <W_CacheLumpNum+0x38>\n38: \tjmp\t0x6c <W_CacheLumpNum+0x6c>\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <W_CacheLumpNum+0x41>\n41: \tleaq\t(,%rbp,8), %rdx\n49: \taddq\t(%rip), %rdx  # 0x50 <W_CacheLumpNum+0x50>\n50: \tmovl\t%eax, %edi\n52: \tmovl\t%r14d, %esi\n55: \tcallq\t0x5a <W_CacheLumpNum+0x5a>\n5a: \tmovq\t(%rip), %rax  # 0x61 <W_CacheLumpNum+0x61>\n61: \tmovq\t(%rax,%rbp,8), %rsi\n65: \tmovl\t%ebx, %edi\n67: \tcallq\t0x6c <W_CacheLumpNum+0x6c>\n6c: \tmovq\t(%rip), %rax  # 0x73 <W_CacheLumpNum+0x73>\n73: \tmovq\t(%rax,%rbp,8), %rax\n77: \tpopq\t%rbx\n78: \tpopq\t%r14\n7a: \tpopq\t%rbp\n7b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int) ;\nint /*<<< orphan*/  W_LumpLength (int) ;\nint /*<<< orphan*/  W_ReadLump (int,void*) ;\nint /*<<< orphan*/  Z_ChangeTag (void*,int) ;\nint /*<<< orphan*/ * Z_Malloc (int /*<<< orphan*/ ,int,void**) ;\nvoid** lumpcache ;\nunsigned int numlumps ;\n\nvoid*\nW_CacheLumpNum\n( int\t\tlump,\nint\t\ttag )\n{\nbyte*\tptr;\n\nif ((unsigned)lump >= numlumps)\nI_Error (\"W_CacheLumpNum: %i >= numlumps\",lump);\n\nif (!lumpcache[lump])\n{\n// read the lump in\n\n//printf (\"cache miss on lump %i\\n\",lump);\nptr = Z_Malloc (W_LumpLength (lump), tag, &lumpcache[lump]);\nW_ReadLump (lump, lumpcache[lump]);\n}\nelse\n{\n//printf (\"cache hit on lump %i\\n\",lump);\nZ_ChangeTag (lumpcache[lump],tag);\n}\n\nreturn lumpcache[lump];\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lumpnum_t ;\ntypedef  int /*<<< orphan*/  lumpinfo_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_FATAL (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_AddLumpNum (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_AddLumpNumToCache (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_AddLumpNumToCache (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * W_Cache ;\nint /*<<< orphan*/ * W_LumpName (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * W_NewLumpNum (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * W_NumForName (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * W_NumForName (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * W_NumForName (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint W_NUM_LUMPS ;\n\nlumpinfo_t *\nW_CacheLumpNum (lumpnum_t lumpnum, lumpnum_t lumpinfo)\n{\nint\t\t\t\ti;\n\nif (lumpnum >= W_NUM_LUMPS)\nD_FATAL(\"W_CacheLumpNum: lumpnum >= W_NUM_LUMPS\", lumpnum);\n\nif (W_Cache[lumpnum] != NULL)\n{\nW_AddLumpNumToCache(lumpnum, lumpinfo);\n}\nelse\n{\nW_AddLumpNum(W_NumForName(W_LumpName(lumpnum)), lumpinfo);\nW_Cache[lumpnum] = W_NumForName(W_LumpName(lumpnum), lumpinfo);\n}\n\nreturn W_Cache[lumpnum];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_net.c_ExpandTics",
    "input":"\n0000000000000000 <ExpandTics>:\n0: \tmovl\t(%rip), %eax  # 0x6 <ExpandTics+0x6>\n6: \tmovzbl\t%al, %edx\n9: \tmovl\t%edi, %ecx\nb: \tsubl\t%edx, %ecx\nd: \tleal\t64(%rcx), %edx\n10: \tcmpl\t$129, %edx\n16: \tjb\t0x29 <ExpandTics+0x29>\n18: \tcmpl\t$65, %ecx\n1b: \tjl\t0x24 <ExpandTics+0x24>\n1d: \taddl\t$4294967040, %eax  # imm = 0xFFFFFF00\n22: \tjmp\t0x29 <ExpandTics+0x29>\n24: \taddl\t$256, %eax    # imm = 0x100\n29: \tandl\t$4294967040, %eax  # imm = 0xFFFFFF00\n2e: \taddl\t%edi, %eax\n30: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int,int) ;\nint maketic ;\n\nint ExpandTics (int low)\n{\nint\tdelta;\n\ndelta = low - (maketic&0xff);\n\nif (delta >= -64 && delta <= 64)\nreturn (maketic&~0xff) + low;\nif (delta > 64)\nreturn (maketic&~0xff) - 256 + low;\nif (delta < -64)\nreturn (maketic&~0xff) + 256 + low;\n\nI_Error (\"ExpandTics: strange value %i at maketic %i\",low,maketic);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int ULONG ;\n\n/* Variables and functions */\nint TICS_PER_SEC ;\n\nULONG\nExpandTics(ULONG Tics)\n{\nULONG TicsPerSec;\n\nTicsPerSec = TICS_PER_SEC;\n\nif (TicsPerSec < 129)\nTicsPerSec += 64;\nelse if (TicsPerSec > 65)\nTicsPerSec -= 64;\nelse\nTicsPerSec += 256;\n\nreturn (Tics + TicsPerSec) & 0xFFFFFF00;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_StartFire",
    "input":"\n0000000000000000 <A_StartFire>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <A_StartFire+0xa>\na: \tcallq\t0xf <A_StartFire+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_StartFire+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Fire (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_flamst ;\n\nvoid A_StartFire (mobj_t* actor)\n{\nS_StartSound(actor,sfx_flamst);\nA_Fire(actor);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Action ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Fire ;\nint /*<<< orphan*/  A_Start (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_StartFire_B ;\n\nvoid A_StartFire(Action *act)\n{\nA_Start(act, A_Fire);\nA_Start(act, A_StartFire_B);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_ChangeTag2",
    "input":"\n0000000000000000 <Z_ChangeTag2>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%esi, %ebp\n5: \tmovq\t%rdi, %rbx\n8: \tmovq\t-96(%rdi), %rax\nc: \tcmpq\t(%rip), %rax  # 0x13 <Z_ChangeTag2+0x13>\n13: \tje\t0x1f <Z_ChangeTag2+0x1f>\n15: \tmovl\t$0, %edi\n1a: \tcallq\t0x1f <Z_ChangeTag2+0x1f>\n1f: \tcmpl\t%ebp, (%rip)  # 0x25 <Z_ChangeTag2+0x25>\n25: \tjg\t0x3a <Z_ChangeTag2+0x3a>\n27: \tcmpl\t$255, -80(%rbx)\n2e: \tja\t0x3a <Z_ChangeTag2+0x3a>\n30: \tmovl\t$0, %edi\n35: \tcallq\t0x3a <Z_ChangeTag2+0x3a>\n3a: \tmovl\t%ebp, -88(%rbx)\n3d: \taddq\t$8, %rsp\n41: \tpopq\t%rbx\n42: \tpopq\t%rbp\n43: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ id; int tag; scalar_t__ user; } ;\ntypedef  TYPE_1__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint PU_PURGELEVEL ;\nscalar_t__ ZONEID ;\n\nvoid\nZ_ChangeTag2\n( void*\t\tptr,\nint\t\ttag )\n{\nmemblock_t*\tblock;\n\nblock = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));\n\nif (block->id != ZONEID)\nI_Error (\"Z_ChangeTag: freed a pointer without ZONEID\");\n\nif (tag >= PU_PURGELEVEL && (unsigned)block->user < 0x100)\nI_Error (\"Z_ChangeTag: an owner is required for purgable blocks\");\n\nblock->tag = tag;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ tag; int tag_len; int tag_len_orig; int /*<<< orphan*/  tag_orig; } ;\ntypedef  TYPE_1__ ZBUFF_DCtx ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ERROR (char*) ;\nscalar_t__ ZSTD_MAGIC_SKIPPABLE_START ;\nint ZSTD_SKIPPABLE_START_MAGIC ;\n\n__attribute__((used)) static void Z_ChangeTag2(ZBUFF_DCtx* zbc, int newTag)\n{\nif (zbc->tag != ZSTD_MAGIC_SKIPPABLE_START)\nERROR(\"ZBUFF_DCtx::tag must be ZSTD_MAGIC_SKIPPABLE_START\");\nif (newTag < ZSTD_SKIPPABLE_START_MAGIC || newTag > 255)\nERROR(\"ZBUFF_DCtx::tag_len must be between %i and 255\", ZSTD_SKIPPABLE_START_MAGIC);\nzbc->tag_len = newTag;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ChangeMessages",
    "input":"\n0000000000000000 <M_ChangeMessages>:\n0: \tmovl\t$1, %eax\n5: \tsubq\t(%rip), %rax  # 0xc <M_ChangeMessages+0xc>\nc: \tmovq\t%rax, (%rip)  # 0x13 <M_ChangeMessages+0x13>\n13: \tmovl\t$0, %eax\n18: \tmovl\t$0, %ecx\n1d: \tcmoveq\t%rax, %rcx\n21: \tmovl\t(%rcx), %eax\n23: \tmovq\t(%rip), %rcx  # 0x2a <M_ChangeMessages+0x2a>\n2a: \tmovq\t(%rip), %rdx  # 0x31 <M_ChangeMessages+0x31>\n31: \tmovl\t%eax, (%rcx,%rdx,4)\n34: \tmovl\t$1, (%rip)    # 0x3e <M_ChangeMessages+0x3e>\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  message; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MSGOFF ;\nint /*<<< orphan*/  MSGON ;\nsize_t consoleplayer ;\nint message_dontfuckwithme ;\nTYPE_1__* players ;\nscalar_t__ showMessages ;\n\nvoid M_ChangeMessages(int choice)\n{\n// warning: unused parameter `int choice'\nchoice = 0;\nshowMessages = 1 - showMessages;\n\nif (!showMessages)\nplayers[consoleplayer].message = MSGOFF;\nelse\nplayers[consoleplayer].message = MSGON ;\n\nmessage_dontfuckwithme = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BOOL ;\n\n/* Variables and functions */\nsize_t M_ChangeMessages_Index ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/ * M_ChangeMessages_Messages ;\nint /*<<< orphan*/ * M_ChangeMessages_Messages_Old ;\n\n__attribute__((used)) static BOOL M_ChangeMessages(void)\n{\nM_ChangeMessages_Index -= sizeof(M_ChangeMessages_Messages_Old);\nM_ChangeMessages_Messages = (M_ChangeMessages_Messages_Old + M_ChangeMessages_Index);\nM_ChangeMessages_Index = 1;\nreturn FALSE;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_P_NoiseAlert",
    "input":"\n0000000000000000 <P_NoiseAlert>:\n0: \taddl\t$1, (%rip)    # 0x7 <P_NoiseAlert+0x7>\n7: \tmovq\t%rdi, (%rip)  # 0xe <P_NoiseAlert+0xe>\ne: \tmovq\t(%rsi), %rax\n11: \tmovl\t(%rax), %edi\n13: \txorl\t%esi, %esi\n15: \tjmp\t0x1a <P_NoiseAlert+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {TYPE_1__* subsector; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  sector; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_RecursiveSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_2__* soundtarget ;\nint /*<<< orphan*/  validcount ;\n\nvoid\nP_NoiseAlert\n( mobj_t*\ttarget,\nmobj_t*\temmiter )\n{\nsoundtarget = target;\nvalidcount++;\nP_RecursiveSound (emmiter->subsector->sector, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * p_noise; } ;\ntypedef  TYPE_1__* PgStat_StatDBEntry ;\ntypedef  int /*<<< orphan*/  PGPROC ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_Blocked ;\nint /*<<< orphan*/  SetLatch (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * P_latch ;\n\nvoid\nP_NoiseAlert(PgStat_StatDBEntry dbentry, PGPROC *proc)\n{\nP_latch = &(proc->procLatch);\nP_Blocked++;\nSetLatch(dbentry->p_noise[0], 0);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_getChannel",
    "input":"\n0000000000000000 <S_getChannel>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rsi, %r14\n8: \tmovq\t%rdi, %r15\nb: \tmovl\t(%rip), %ecx  # 0x11 <S_getChannel+0x11>\n11: \ttestl\t%ecx, %ecx\n13: \tjle\t0x61 <S_getChannel+0x61>\n15: \tmovq\t(%rip), %rax  # 0x1c <S_getChannel+0x1c>\n1c: \taddq\t$8, %rax\n20: \txorl\t%ebx, %ebx\n22: \tjmp\t0x3d <S_getChannel+0x3d>\n24: \tnopw\t%cs:(%rax,%rax)\n2e: \tnop\n30: \taddq\t$1, %rbx\n34: \taddq\t$16, %rax\n38: \tcmpq\t%rcx, %rbx\n3b: \tjae\t0x5b <S_getChannel+0x5b>\n3d: \tcmpq\t$0, (%rax)\n41: \tje\t0x5b <S_getChannel+0x5b>\n43: \ttestq\t%r15, %r15\n46: \tje\t0x30 <S_getChannel+0x30>\n48: \tcmpq\t%r15, -8(%rax)\n4c: \tjne\t0x30 <S_getChannel+0x30>\n4e: \tmovl\t%ebx, %edi\n50: \tcallq\t0x55 <S_getChannel+0x55>\n55: \tmovl\t(%rip), %ecx  # 0x5b <S_getChannel+0x5b>\n5b: \tcmpl\t%ecx, %ebx\n5d: \tje\t0x67 <S_getChannel+0x67>\n5f: \tjmp\t0xae <S_getChannel+0xae>\n61: \txorl\t%ebx, %ebx\n63: \tcmpl\t%ecx, %ebx\n65: \tjne\t0xae <S_getChannel+0xae>\n67: \ttestl\t%ecx, %ecx\n69: \tjle\t0x9c <S_getChannel+0x9c>\n6b: \tmovq\t(%rip), %rax  # 0x72 <S_getChannel+0x72>\n72: \tmovq\t(%r14), %rdx\n75: \tmovl\t%ecx, %esi\n77: \taddq\t$8, %rax\n7b: \txorl\t%ebx, %ebx\n7d: \tnopl\t(%rax)\n80: \tmovq\t(%rax), %rdi\n83: \tcmpq\t%rdx, (%rdi)\n86: \tjge\t0x9e <S_getChannel+0x9e>\n88: \taddq\t$1, %rbx\n8c: \taddq\t$16, %rax\n90: \tcmpq\t%rbx, %rsi\n93: \tjne\t0x80 <S_getChannel+0x80>\n95: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n9a: \tjmp\t0xc6 <S_getChannel+0xc6>\n9c: \txorl\t%ebx, %ebx\n9e: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\na3: \tcmpl\t%ecx, %ebx\na5: \tje\t0xc6 <S_getChannel+0xc6>\na7: \tmovl\t%ebx, %edi\na9: \tcallq\t0xae <S_getChannel+0xae>\nae: \tmovq\t(%rip), %rax  # 0xb5 <S_getChannel+0xb5>\nb5: \tmovl\t%ebx, %ecx\nb7: \tshlq\t$4, %rcx\nbb: \tmovq\t%r14, 8(%rax,%rcx)\nc0: \tmovq\t%r15, (%rax,%rcx)\nc4: \tmovl\t%ebx, %eax\nc6: \tpopq\t%rbx\nc7: \tpopq\t%r14\nc9: \tpopq\t%r15\ncb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ priority; } ;\ntypedef  TYPE_1__ sfxinfo_t ;\nstruct TYPE_6__ {void* origin; TYPE_1__* sfxinfo; } ;\ntypedef  TYPE_2__ channel_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StopChannel (int) ;\nTYPE_2__* channels ;\nint numChannels ;\n\nint\nS_getChannel\n( void*\t\torigin,\nsfxinfo_t*\tsfxinfo )\n{\n// channel number to use\nint\t\tcnum;\n\nchannel_t*\tc;\n\n// Find an open channel\nfor (cnum=0 ; cnum<numChannels ; cnum++)\n{\nif (!channels[cnum].sfxinfo)\nbreak;\nelse if (origin &&  channels[cnum].origin ==  origin)\n{\nS_StopChannel(cnum);\nbreak;\n}\n}\n\n// None available\nif (cnum == numChannels)\n{\n// Look for lower priority\nfor (cnum=0 ; cnum<numChannels ; cnum++)\nif (channels[cnum].sfxinfo->priority >= sfxinfo->priority) break;\n\nif (cnum == numChannels)\n{\n// FUCK!  No lower priority.  Sorry, Charlie.\nreturn -1;\n}\nelse\n{\n// Otherwise, kick out lower priority.\nS_StopChannel(cnum);\n}\n}\n\nc = &channels[cnum];\n\n// channel is decided to be cnum.\nc->sfxinfo = sfxinfo;\nc->origin = origin;\n\nreturn cnum;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ channel; scalar_t__ user; } ;\ntypedef  TYPE_1__ SChannel ;\ntypedef  scalar_t__ UBYTE ;\n\n/* Variables and functions */\nint MAX_CHANNELS ;\nint MAX_USERS ;\nTYPE_1__* channels ;\nint /*<<< orphan*/  sortChannels () ;\n\nint S_getChannel(UBYTE user, UBYTE *channel)\n{\nint i;\n\nfor(i=0; i<MAX_CHANNELS; i++)\n{\nif(channels[i].channel==0)\ncontinue;\nif(user && channels[i].user!=user)\ncontinue;\nsortChannels();\nfor(i=0; i<MAX_USERS; i++)\n{\nif(channels[i].channel>=channels[i].user)\nbreak;\n}\nif(i==MAX_USERS)\nreturn -1;\nreturn i;\n}\nreturn -1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_InitColormaps",
    "input":"\n0000000000000000 <R_InitColormaps>:\n0: \tpushq\t%rbx\n1: \tmovl\t$0, %edi\n6: \tcallq\t0xb <R_InitColormaps+0xb>\nb: \tmovl\t%eax, %ebx\nd: \tmovl\t%eax, %edi\nf: \tcallq\t0x14 <R_InitColormaps+0x14>\n14: \tleal\t255(%rax), %edi\n1a: \tmovl\t(%rip), %esi  # 0x20 <R_InitColormaps+0x20>\n20: \txorl\t%edx, %edx\n22: \tcallq\t0x27 <R_InitColormaps+0x27>\n27: \taddl\t$255, %eax\n2c: \tmovslq\t%eax, %rsi\n2f: \tandq\t$-256, %rsi\n36: \tmovq\t%rsi, (%rip)  # 0x3d <R_InitColormaps+0x3d>\n3d: \tmovl\t%ebx, %edi\n3f: \tpopq\t%rbx\n40: \tjmp\t0x45 <R_InitColormaps+0x45>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nint W_GetNumForName (char*) ;\nint W_LumpLength (int) ;\nint /*<<< orphan*/  W_ReadLump (int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * colormaps ;\n\nvoid R_InitColormaps (void)\n{\nint\tlump, length;\n\n// Load in the light tables,\n//  256 byte align tables.\nlump = W_GetNumForName(\"COLORMAP\");\nlength = W_LumpLength (lump) + 255;\ncolormaps = Z_Malloc (length, PU_STATIC, 0);\ncolormaps = (byte *)( ((int)colormaps + 255)&~0xff);\nW_ReadLump (lump,colormaps);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_COLORMAP_SIZE ;\nint /*<<< orphan*/  R_InitColormap (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitColormap_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_256 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_16 (int) ;\nint /*<<< orphan*/  R_InitColormap_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_8_256"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_clearFB",
    "input":"\n0000000000000000 <AM_clearFB>:\n0: \tmovl\t%edi, %esi\n2: \tmovl\t(%rip), %edi  # 0x8 <AM_clearFB+0x8>\n8: \tmovl\t(%rip), %edx  # 0xe <AM_clearFB+0xe>\ne: \timull\t(%rip), %edx  # 0x15 <AM_clearFB+0x15>\n15: \tjmp\t0x1a <AM_clearFB+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint f_h ;\nint f_w ;\nint /*<<< orphan*/  fb ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int,int) ;\n\nvoid AM_clearFB(int color)\n{\nmemset(fb, color, f_w*f_h);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_FB ;\nint /*<<< orphan*/  AM_FB_SIZE ;\nint /*<<< orphan*/  AM_FB_SIZE_BYTES ;\nint /*<<< orphan*/  AM_write (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid AM_clearFB(UBYTE value)\n{\nAM_write(AM_FB, value, AM_FB_SIZE * AM_FB_SIZE_BYTES);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_QuitResponse",
    "input":"\n0000000000000000 <M_QuitResponse>:\n0: \tcmpl\t$121, %edi\n3: \tjne\t0x53 <M_QuitResponse+0x53>\n5: \tpushq\t%rax\n6: \tcmpl\t$0, (%rip)    # 0xd <M_QuitResponse+0xd>\nd: \tjne\t0x4b <M_QuitResponse+0x4b>\nf: \tmovq\t(%rip), %rax  # 0x16 <M_QuitResponse+0x16>\n16: \tcmpq\t(%rip), %rax  # 0x1d <M_QuitResponse+0x1d>\n1d: \tmovl\t$0, %eax\n22: \tmovl\t$0, %ecx\n27: \tcmoveq\t%rax, %rcx\n2b: \tmovq\t(%rcx), %rax\n2e: \tmovl\t(%rip), %ecx  # 0x34 <M_QuitResponse+0x34>\n34: \tandl\t$28, %ecx\n37: \tmovl\t(%rax,%rcx), %esi\n3a: \txorl\t%edi, %edi\n3c: \tcallq\t0x41 <M_QuitResponse+0x41>\n41: \tmovl\t$105, %edi\n46: \tcallq\t0x4b <M_QuitResponse+0x4b>\n4b: \txorl\t%eax, %eax\n4d: \tpopq\t%rcx\n4e: \tjmp\t0x53 <M_QuitResponse+0x53>\n53: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Quit () ;\nint /*<<< orphan*/  I_WaitVBL (int) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nscalar_t__ commercial ;\nscalar_t__ gamemode ;\nint gametic ;\nint /*<<< orphan*/  netgame ;\nint /*<<< orphan*/ * quitsounds ;\nint /*<<< orphan*/ * quitsounds2 ;\n\nvoid M_QuitResponse(int ch)\n{\nif (ch != 'y')\nreturn;\nif (!netgame)\n{\nif (gamemode == commercial)\nS_StartSound(NULL,quitsounds2[(gametic>>2)&7]);\nelse\nS_StartSound(NULL,quitsounds[(gametic>>2)&7]);\nI_WaitVBL(105);\n}\nI_Quit ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  b; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Quit (int) ;\nint /*<<< orphan*/  M_QuitResponse_1 ;\nint /*<<< orphan*/  M_QuitResponse_2 ;\nint /*<<< orphan*/  M_QuitResponse_3 ;\nint /*<<< orphan*/  M_QuitResponse_4 ;\nint /*<<< orphan*/  M_QuitResponse_5 ;\nint /*<<< orphan*/  M_QuitResponse_6 ;\nint /*<<< orphan*/  M_QuitResponse_7 ;\nint /*<<< orphan*/  M_QuitResponse_8 ;\nint /*<<< orphan*/  M_QuitResponse_9 ;\nint /*<<< orphan*/  M_QuitResponse_10 ;\nint /*<<< orphan*/  M_QuitResponse_11 ;\nint /*<<< orphan*/  M_QuitResponse_12 ;\nint /*<<< orphan*/  M_QuitResponse_13 ;\nint /*<<< orphan*/  M_QuitResponse_14 ;\nint /*<<< orphan*/  M_QuitResponse_15 ;\nint /*<<< orphan*/  M_QuitResponse_16 ;\nint /*<<< orphan*/  M_QuitResponse_17 ;\nint /*<<< orphan*/  M_QuitResponse_18 ;\nint /*<<< orphan*/  M_QuitResponse_19 ;\nint /*<<< orphan*/  M_QuitResponse_20 ;\nint /*<<< orphan*/  M_QuitResponse_21 ;\nint /*<<< orphan*/  M_QuitResponse_22 ;\nint /*<<< orphan*/  M_QuitResponse_23 ;\nint /*<<< orphan*/  M_QuitResponse_24 ;\nint /*<<< orphan*/  M_QuitResponse_25 ;\nint /*<<< orphan*/  M_QuitResponse_26 ;\nint /*<<< orphan*/  M_QuitResponse_27 ;\nint /*<<< orphan*/  M_QuitResponse_28 ;\nint /*<<< orphan*/  M_QuitResponse_29 ;\nint /*<<< orphan*/  M_QuitResponse_30 ;\nint /*<<< orphan*/  M_QuitResponse_31 ;\nint /*<<< orphan*/  M_QuitResponse_32 ;\nint /*<<< orphan*/  M_QuitResponse_33 ;\nint /*<<< orphan*/  M_QuitResponse_34 ;\nint /*<<< orphan*/  M_QuitResponse_35 ;\nint /*<<< orphan*/  M_QuitResponse_36 ;\nint /*<<< orphan*/  M_QuitResponse_37 ;\nint /*<<< orphan*/  M_QuitResponse_38 ;\nint /*<<< orphan*/  M_QuitResponse_39 ;\nint /*<<< orphan*/  M_QuitResponse_40 ;\nint /*<<< orphan*/  M_QuitResponse_41 ;\nint /*<<< orphan*/  M_QuitResponse_42 ;\nint /*<<< orphan*/  M_QuitResponse_43 ;\nint /*<<< orphan*/  M_QuitResponse_44 ;\nint /*<<< orphan*/  M_QuitResponse_45 ;\nint /*<<< orphan*/  M_QuitResponse_46 ;\nint /*<<< orphan*/  M_QuitResponse_47 ;\nint /*<<< orphan*/  M_QuitResponse_48 ;\nint /*<<< orphan*/  M_QuitResponse_49 ;\nint /*<<< orphan*/  M_QuitResponse_50 ;\nint /*<<< orphan*/  M_QuitResponse_51 ;\nint /*<<< orphan*/  M_QuitResponse_52 ;\nint /*<<< orphan*/  M_QuitResponse_53 ;\nint /*<<< orphan*/  M_QuitResponse_54 ;\nint /*<<< orphan*/  M_QuitResponse_55 ;\nint /*<<< orphan*/  M_QuitResponse_56 ;\nint /*<<< orphan*/  M_QuitResponse_57 ;\nint /*<<< orphan*/  M_QuitResponse_58 ;\nint /*<<< orphan*/  M_QuitResponse_59 ;\nint /*<<< orphan*/  M_QuitResponse_60 ;\nint /*<<< orphan*/  M_QuitResponse_61 ;\nint /*<<< orphan*/  M_QuitResponse_62 ;\nint /*<<< orphan*/  M_QuitResponse_63 ;\nint /*<<< orphan*/  M_QuitResponse_64 ;\nint /*<<< orphan*/  M_QuitResponse_65 ;\nint /*<<< orphan*/  M_QuitResponse_66 ;\nint /*<<< orphan*/  M_QuitResponse_67 ;\nint /*<<< orphan*/  M_QuitResponse_68 ;\nint /*<<< orphan*/  M_QuitResponse_69 ;\nint /*<<< orphan*/  M_QuitResponse_70 ;\nint /*<<< orphan*/  M_QuitResponse_71 ;\nint /*<<< orphan*/  M_QuitResponse_72 ;\nint /*<<< orphan*/  M_QuitResponse_73 ;\nint /*<<< orphan*/  M_QuitResponse_74 ;\nint /*<<< orphan*/  M_QuitResponse_75 ;\nint /*<<< orphan*/  M_QuitResponse_76 ;\nint /*<<< orphan*/  M_QuitResponse_77 ;\nint /*<<< orphan*/  M_QuitResponse_78 ;\nint /*<<< orphan*/  M_QuitResponse_79 ;\nint /*<<< orphan*/  M_QuitResponse_80 ;\nint /*<<< orphan*/  M_QuitResponse_81 ;\nint /*<<< orphan*/  M_QuitResponse_82 ;\nint /*<<< orphan*/  M_QuitResponse_83 ;\nint /*<<< orphan*/  M_QuitResponse_84 ;\nint /*<<< orphan*/  M_QuitResponse_85 ;\nint /*<<< orphan*/  M_QuitResponse_86 ;\nint /*<<< orphan*/  M_QuitResponse_87 ;\nint /*<<< orphan*/  M_QuitResponse_88 ;\nint /*<<< orphan*/  M_QuitResponse_89 ;\nint /*<<< orphan*/  M_QuitResponse_90 ;\nint /*<<< orphan*/  M_QuitResponse_91 ;\nint /*<<< orphan*/  M_QuitResponse_92 ;\nint /*<<< orphan*/  M_QuitResponse_93 ;\nint /*<<< orphan*/  M_QuitResponse_94 ;\nint /*<<< orphan*/  M_QuitResponse_95 ;\nint /*<<< orphan*/  M_QuitResponse_96 ;\nint /*<<< orphan*/  M_QuitResponse_97 ;\nint /*<<< orphan*/  M_QuitResponse_98 ;\nint /*<<< orphan*/  M_QuitResponse_99 ;\nint /*<<< orphan*/  M_QuitResponse_100 ;\nint /*<<< orphan*/  M_QuitResponse_101 ;\nint /*<<< orphan*/  M_QuitResponse_102 ;\nint /*<<< orphan*/  M_QuitResponse_103 ;\nint /*<<< orphan*/  M_QuitResponse_104 ;\nint /*<<< orphan*/  M"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_Metal",
    "input":"\n0000000000000000 <A_Metal>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <A_Metal+0xa>\na: \tcallq\t0xf <A_Metal+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_Metal+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Chase (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_metal ;\n\nvoid A_Metal (mobj_t* mo)\n{\nS_StartSound (mo, sfx_metal);\nA_Chase (mo);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pdf_processor ;\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_ColorSpace ;\nint /*<<< orphan*/  pdf_drop_colorspace (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  pdf_keep_colorspace (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void A_Metal(fz_context *ctx, pdf_processor *proc)\n{\npdf_drop_colorspace(ctx, A_ColorSpace);\nA_ColorSpace = pdf_keep_colorspace(ctx, A_ColorSpace);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_WorldDone",
    "input":"\n0000000000000000 <G_WorldDone>:\n0: \tmovl\t(%rip), %eax  # 0x6 <G_WorldDone+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <G_WorldDone+0xc>\nc: \tmovq\t(%rip), %rax  # 0x13 <G_WorldDone+0x13>\n13: \ttestq\t%rax, %rax\n16: \tje\t0x2d <G_WorldDone+0x2d>\n18: \tmovq\t(%rip), %rcx  # 0x1f <G_WorldDone+0x1f>\n1f: \tmovq\t(%rip), %rdx  # 0x26 <G_WorldDone+0x26>\n26: \tmovl\t$1, (%rcx,%rdx,4)\n2d: \tmovq\t(%rip), %rcx  # 0x34 <G_WorldDone+0x34>\n34: \tcmpq\t(%rip), %rcx  # 0x3b <G_WorldDone+0x3b>\n3b: \tjne\t0x68 <G_WorldDone+0x68>\n3d: \tmovl\t(%rip), %ecx  # 0x43 <G_WorldDone+0x43>\n43: \tcmpl\t$31, %ecx\n46: \tja\t0x68 <G_WorldDone+0x68>\n48: \tmovl\t$1074792512, %edx  # imm = 0x40100840\n4d: \tbtl\t%ecx, %edx\n50: \tjb\t0x61 <G_WorldDone+0x61>\n52: \tmovl\t$2147516416, %edx  # imm = 0x80008000\n57: \tbtl\t%ecx, %edx\n5a: \tjae\t0x68 <G_WorldDone+0x68>\n5c: \ttestq\t%rax, %rax\n5f: \tje\t0x68 <G_WorldDone+0x68>\n61: \txorl\t%eax, %eax\n63: \tjmp\t0x68 <G_WorldDone+0x68>\n68: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int didsecret; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  F_StartFinale () ;\nscalar_t__ commercial ;\nsize_t consoleplayer ;\nint /*<<< orphan*/  ga_worlddone ;\nint /*<<< orphan*/  gameaction ;\nint gamemap ;\nscalar_t__ gamemode ;\nTYPE_1__* players ;\nscalar_t__ secretexit ;\n\nvoid G_WorldDone (void)\n{\ngameaction = ga_worlddone;\n\nif (secretexit)\nplayers[consoleplayer].didsecret = true;\n\nif ( gamemode == commercial )\n{\nswitch (gamemap)\n{\ncase 15:\ncase 31:\nif (!secretexit)\nbreak;\ncase 6:\ncase 11:\ncase 20:\ncase 30:\nF_StartFinale ();\nbreak;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_DrawScreen () ;\nint /*<<< orphan*/  G_FadeOut () ;\nint /*<<< orphan*/  G_NextGameMode () ;\nscalar_t__ G_gameMode ;\nscalar_t__ G_normalGame ;\nint G_worldNum ;\nint* G_worldStatus ;\nscalar_t__ G_worldDone ;\n\nvoid G_WorldDone(void)\n{\nG_worldDone = 1;\n\nif (G_worldStatus[G_worldNum])\nG_worldStatus[G_worldNum] = 1;\n\nif (G_gameMode == G_normalGame)\n{\nif (G_worldNum == 31)\n{\nif (G_worldStatus[31] & 1)\nG_FadeOut();\nelse\nG_DrawScreen();\n}\nelse if (G_worldNum < 31 && (G_worldStatus[31] & 2))\nG_NextGameMode();\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_PointToAngle2",
    "input":"\n0000000000000000 <R_PointToAngle2>:\n0: \tmovq\t%rdi, (%rip)  # 0x7 <R_PointToAngle2+0x7>\n7: \tmovq\t%rsi, (%rip)  # 0xe <R_PointToAngle2+0xe>\ne: \tmovq\t%rdx, %rdi\n11: \tmovq\t%rcx, %rsi\n14: \tjmp\t0x19 <R_PointToAngle2+0x19>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  void* fixed_t ;\ntypedef  int /*<<< orphan*/  angle_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_PointToAngle (void*,void*) ;\nvoid* viewx ;\nvoid* viewy ;\n\nangle_t\nR_PointToAngle2\n( fixed_t\tx1,\nfixed_t\ty1,\nfixed_t\tx2,\nfixed_t\ty2 )\n{\nviewx = x1;\nviewy = y1;\n\nreturn R_PointToAngle (x2, y2);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fixed ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_PointToAngle (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_PointToAngle2_x ;\nint /*<<< orphan*/  R_PointToAngle2_y ;\n\nvoid R_PointToAngle2(fixed x, fixed y, fixed x2, fixed y2)\n{\nR_PointToAngle2_x = x;\nR_PointToAngle2_y = y;\nR_PointToAngle(x2, y2);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_DropWeapon",
    "input":"\n0000000000000000 <P_DropWeapon>:\n0: \tmovl\t(%rip), %esi  # 0x6 <P_DropWeapon+0x6>\n6: \tmovq\t(%rip), %rax  # 0xd <P_DropWeapon+0xd>\nd: \tmovq\t(%rdi), %rcx\n10: \tmovl\t(%rax,%rcx,4), %edx\n13: \tjmp\t0x18 <P_DropWeapon+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {size_t readyweapon; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_6__ {int /*<<< orphan*/  downstate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ps_weapon ;\nTYPE_2__* weaponinfo ;\n\nvoid P_DropWeapon (player_t* player)\n{\nP_SetPsprite (player,\nps_weapon,\nweaponinfo[player->readyweapon].downstate);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct player_t {int /*<<< orphan*/ * weapon; } ;\nstruct TYPE_3__ {int /*<<< orphan*/  weapon; } ;\n\n/* Variables and functions */\nTYPE_1__* P_WeaponTypes ;\nint /*<<< orphan*/  P_DropItem (struct player_t*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid P_DropWeapon(struct player_t *p)\n{\nP_DropItem(p, P_WeaponTypes[p->weapon].weapon, p->weapon);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawSave",
    "input":"\n0000000000000000 <M_DrawSave>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %esi  # 0xa <M_DrawSave+0xa>\na: \tmovl\t$0, %edi\nf: \tcallq\t0x14 <M_DrawSave+0x14>\n14: \tmovl\t$72, %edi\n19: \tmovl\t$28, %esi\n1e: \txorl\t%edx, %edx\n20: \tmovl\t%eax, %ecx\n22: \tcallq\t0x27 <M_DrawSave+0x27>\n27: \tcmpl\t$0, (%rip)    # 0x2e <M_DrawSave+0x2e>\n2e: \tjle\t0x9a <M_DrawSave+0x9a>\n30: \txorl\t%ebx, %ebx\n32: \tnopw\t%cs:(%rax,%rax)\n3c: \tnopl\t(%rax)\n40: \tmovq\t(%rip), %rdi  # 0x47 <M_DrawSave+0x47>\n47: \tmovslq\t(%rip), %rsi  # 0x4e <M_DrawSave+0x4e>\n4e: \tmovslq\t%ebx, %r14\n51: \timulq\t%r14, %rsi\n55: \taddq\t(%rip), %rsi  # 0x5c <M_DrawSave+0x5c>\n5c: \tcallq\t0x61 <M_DrawSave+0x61>\n61: \tmovq\t(%rip), %rdi  # 0x68 <M_DrawSave+0x68>\n68: \tmovslq\t(%rip), %rsi  # 0x6f <M_DrawSave+0x6f>\n6f: \timulq\t%r14, %rsi\n73: \taddq\t(%rip), %rsi  # 0x7a <M_DrawSave+0x7a>\n7a: \tmovq\t(%rip), %rax  # 0x81 <M_DrawSave+0x81>\n81: \tmovq\t(%rax,%rbx,8), %rdx\n85: \tcallq\t0x8a <M_DrawSave+0x8a>\n8a: \taddq\t$1, %rbx\n8e: \tmovslq\t(%rip), %rax  # 0x95 <M_DrawSave+0x95>\n95: \tcmpq\t%rax, %rbx\n98: \tjl\t0x40 <M_DrawSave+0x40>\n9a: \tcmpq\t$0, (%rip)    # 0xa2 <M_DrawSave+0xa2>\na2: \tje\t0xec <M_DrawSave+0xec>\na4: \tmovq\t(%rip), %rax  # 0xab <M_DrawSave+0xab>\nab: \tmovq\t(%rip), %rcx  # 0xb2 <M_DrawSave+0xb2>\nb2: \tmovq\t(%rax,%rcx,8), %rdi\nb6: \tcallq\t0xbb <M_DrawSave+0xbb>\nbb: \tmovslq\t%eax, %rdi\nbe: \taddq\t(%rip), %rdi  # 0xc5 <M_DrawSave+0xc5>\nc5: \tmovslq\t(%rip), %rsi  # 0xcc <M_DrawSave+0xcc>\ncc: \timulq\t(%rip), %rsi  # 0xd4 <M_DrawSave+0xd4>\nd4: \taddq\t(%rip), %rsi  # 0xdb <M_DrawSave+0xdb>\ndb: \tmovl\t$0, %edx\ne0: \taddq\t$8, %rsp\ne4: \tpopq\t%rbx\ne5: \tpopq\t%r14\ne7: \tjmp\t0xec <M_DrawSave+0xec>\nec: \taddq\t$8, %rsp\nf0: \tpopq\t%rbx\nf1: \tpopq\t%r14\nf3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ y; scalar_t__ x; } ;\n\n/* Variables and functions */\nint LINEHEIGHT ;\nTYPE_1__ LoadDef ;\nint /*<<< orphan*/  M_DrawSaveLoadBorder (scalar_t__,scalar_t__) ;\nint M_StringWidth (char*) ;\nint /*<<< orphan*/  M_WriteText (scalar_t__,scalar_t__,char*) ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint load_end ;\nsize_t saveSlot ;\nscalar_t__ saveStringEnter ;\nchar** savegamestrings ;\n\nvoid M_DrawSave(void)\n{\nint             i;\n\nV_DrawPatchDirect (72,28,0,W_CacheLumpName(\"M_SAVEG\",PU_CACHE));\nfor (i = 0;i < load_end; i++)\n{\nM_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);\nM_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);\n}\n\nif (saveStringEnter)\n{\ni = M_StringWidth(savegamestrings[saveSlot]);\nM_WriteText(LoadDef.x + i,LoadDef.y+LINEHEIGHT*saveSlot,\"_\");\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {size_t* save_x; size_t* save_y; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawText (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextB (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextC (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextR (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextT (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextU (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextV (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextW (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextX (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextY (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextZ (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexta (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextb (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextc (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextd (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexte (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextf (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextg (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexth (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexti (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextj (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextk (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextl (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextm (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextn (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexto (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextp (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextq (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextr (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexts (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextt (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextu (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextv (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextw (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextx (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexty (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextz (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextA (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextB (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextC (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextD (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextE (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextF (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextG (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextH (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextI (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextJ (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextK (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextL (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextM (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextN (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextO (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextP (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextQ (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextR (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextS (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextT (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextU (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextV (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextW (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextX (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextY (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextZ (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexta (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextb (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextc (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextd (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexte (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextf (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextg (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexth (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTexti (size_t,size_t,char*) ;\nint /*<<< orphan*/  M_DrawTextj (size_t"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_DrawMasked",
    "input":"\n0000000000000000 <R_DrawMasked>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <R_DrawMasked+0xb>\nb: \tmovq\t(%rip), %rax  # 0x12 <R_DrawMasked+0x12>\n12: \tcmpq\t(%rip), %rax  # 0x19 <R_DrawMasked+0x19>\n19: \tjle\t0x40 <R_DrawMasked+0x40>\n1b: \tmovq\t(%rip), %rbx  # 0x22 <R_DrawMasked+0x22>\n22: \tmovl\t$0, %r14d\n28: \tcmpq\t%r14, %rbx\n2b: \tje\t0x40 <R_DrawMasked+0x40>\n2d: \tnopl\t(%rax)\n30: \tmovq\t%rbx, %rdi\n33: \tcallq\t0x38 <R_DrawMasked+0x38>\n38: \tmovq\t(%rbx), %rbx\n3b: \tcmpq\t%r14, %rbx\n3e: \tjne\t0x30 <R_DrawMasked+0x30>\n40: \tmovq\t(%rip), %rbx  # 0x47 <R_DrawMasked+0x47>\n47: \taddq\t$-16, %rbx\n4b: \tmovq\t(%rip), %rax  # 0x52 <R_DrawMasked+0x52>\n52: \tjmp\t0x64 <R_DrawMasked+0x64>\n54: \tnopw\t%cs:(%rax,%rax)\n5e: \tnop\n60: \taddq\t$-16, %rbx\n64: \tcmpq\t%rax, %rbx\n67: \tjb\t0x86 <R_DrawMasked+0x86>\n69: \tcmpq\t$0, 8(%rbx)\n6e: \tje\t0x60 <R_DrawMasked+0x60>\n70: \tmovl\t(%rbx), %edx\n72: \tmovl\t4(%rbx), %esi\n75: \tmovq\t%rbx, %rdi\n78: \tcallq\t0x7d <R_DrawMasked+0x7d>\n7d: \tmovq\t(%rip), %rax  # 0x84 <R_DrawMasked+0x84>\n84: \tjmp\t0x60 <R_DrawMasked+0x60>\n86: \tcmpl\t$0, (%rip)    # 0x8d <R_DrawMasked+0x8d>\n8d: \tje\t0x97 <R_DrawMasked+0x97>\n8f: \taddq\t$8, %rsp\n93: \tpopq\t%rbx\n94: \tpopq\t%r14\n96: \tretq\n97: \txorl\t%eax, %eax\n99: \taddq\t$8, %rsp\n9d: \tpopq\t%rbx\n9e: \tpopq\t%r14\na0: \tjmp\t0xa5 <R_DrawMasked+0xa5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {struct TYPE_8__* next; } ;\ntypedef  TYPE_1__ vissprite_t ;\nstruct TYPE_9__ {int /*<<< orphan*/  x2; int /*<<< orphan*/  x1; scalar_t__ maskedtexturecol; } ;\ntypedef  TYPE_2__ drawseg_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DrawPlayerSprites () ;\nint /*<<< orphan*/  R_DrawSprite (TYPE_1__*) ;\nint /*<<< orphan*/  R_RenderMaskedSegRange (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_SortVisSprites () ;\nTYPE_2__* drawsegs ;\nTYPE_2__* ds_p ;\nint /*<<< orphan*/  viewangleoffset ;\nscalar_t__ vissprite_p ;\nscalar_t__ vissprites ;\nTYPE_1__ vsprsortedhead ;\n\nvoid R_DrawMasked (void)\n{\nvissprite_t*\tspr;\ndrawseg_t*\t\tds;\n\nR_SortVisSprites ();\n\nif (vissprite_p > vissprites)\n{\n// draw all vissprites back to front\nfor (spr = vsprsortedhead.next ;\nspr != &vsprsortedhead ;\nspr=spr->next)\n{\n\nR_DrawSprite (spr);\n}\n}\n\n// render any remaining masked mid textures\nfor (ds=ds_p-1 ; ds >= drawsegs ; ds--)\nif (ds->maskedtexturecol)\nR_RenderMaskedSegRange (ds, ds->x1, ds->x2);\n\n// draw the psprites on top of everything\n//  but does not draw on side views\nif (!viewangleoffset)\nR_DrawPlayerSprites ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ RDrawList ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DrawMaskedLine (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_DrawMaskedLineList (TYPE_1__*) ;\nint /*<<< orphan*/  R_DrawMaskedLineLists () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists2 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists3 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists4 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists5 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists6 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists7 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists8 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists9 () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsA () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsB () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsC () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsD () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsE () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsF () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsG () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsH () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsI () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsJ () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsK () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsL () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsM () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsN () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsO () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsP () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsQ () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsR () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsS () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsT () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsU () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsV () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsW () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsX () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsY () ;\nint /*<<< orphan*/  R_DrawMaskedLineListsZ () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_ () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_0 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_1 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_2 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_3 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_4 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_5 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_6 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_7 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_8 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_9 () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_A () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_B () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_C () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_D () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_E () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_F () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_G () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_H () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_I () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_J () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_K () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_L () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_M () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_N () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_O () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_P () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_Q () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_R () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_S () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_T () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_U () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_V () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_W () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_X () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_Y () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_Z () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_a () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_b () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_c () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_d () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_e () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_f () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_g () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_h () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_i () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_j () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_k () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_l () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_m () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_n () ;\nint /*<<< orphan*/  R_DrawMaskedLineLists_o () ;\nint /*<<< orphan*/  R_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_shittyColMajorXform",
    "input":"\n0000000000000000 <wipe_shittyColMajorXform>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovl\t%edx, %r12d\ne: \tmovl\t%esi, %r14d\n11: \tmovq\t%rdi, %r15\n14: \tmovl\t%esi, %edi\n16: \timull\t%edx, %edi\n19: \taddl\t%edi, %edi\n1b: \tmovl\t(%rip), %esi  # 0x21 <wipe_shittyColMajorXform+0x21>\n21: \tmovl\t%edi, 4(%rsp)\n25: \txorl\t%edx, %edx\n27: \tcallq\t0x2c <wipe_shittyColMajorXform+0x2c>\n2c: \tmovq\t%rax, %r13\n2f: \ttestl\t%r12d, %r12d\n32: \tjle\t0xdf <wipe_shittyColMajorXform+0xdf>\n38: \tmovl\t%r12d, %eax\n3b: \tmovslq\t%r14d, %r8\n3e: \tmovl\t%r8d, %edx\n41: \tmovl\t%edx, %r9d\n44: \tandl\t$1, %r9d\n48: \tleaq\t2(%r15), %rdi\n4c: \tleaq\t(%r8,%r8), %r10\n50: \tleaq\t(,%rax,4), %rbx\n58: \tandl\t$-2, %edx\n5b: \txorl\t%r12d, %r12d\n5e: \tmovq\t%r13, %r11\n61: \tjmp\t0x80 <wipe_shittyColMajorXform+0x80>\n63: \tnopw\t%cs:(%rax,%rax)\n6d: \tnopl\t(%rax)\n70: \taddq\t$1, %r12\n74: \taddq\t%r10, %rdi\n77: \taddq\t$2, %r11\n7b: \tcmpq\t%rax, %r12\n7e: \tje\t0xdf <wipe_shittyColMajorXform+0xdf>\n80: \ttestl\t%r14d, %r14d\n83: \tjle\t0x70 <wipe_shittyColMajorXform+0x70>\n85: \tcmpl\t$1, %r14d\n89: \tjne\t0x90 <wipe_shittyColMajorXform+0x90>\n8b: \txorl\t%ebp, %ebp\n8d: \tjmp\t0xbc <wipe_shittyColMajorXform+0xbc>\n8f: \tnop\n90: \tmovq\t%r11, %rcx\n93: \txorl\t%ebp, %ebp\n95: \tnopw\t%cs:(%rax,%rax)\n9f: \tnop\na0: \tmovzwl\t-2(%rdi,%rbp,2), %esi\na5: \tmovw\t%si, (%rcx)\na8: \tmovzwl\t(%rdi,%rbp,2), %esi\nac: \tmovw\t%si, (%rcx,%rax,2)\nb0: \taddq\t$2, %rbp\nb4: \taddq\t%rbx, %rcx\nb7: \tcmpq\t%rbp, %rdx\nba: \tjne\t0xa0 <wipe_shittyColMajorXform+0xa0>\nbc: \ttestq\t%r9, %r9\nbf: \tje\t0x70 <wipe_shittyColMajorXform+0x70>\nc1: \tmovq\t%r12, %rcx\nc4: \timulq\t%r8, %rcx\nc8: \taddq\t%rbp, %rcx\ncb: \tmovzwl\t(%r15,%rcx,2), %ecx\nd0: \timulq\t%rax, %rbp\nd4: \taddq\t%r12, %rbp\nd7: \tmovw\t%cx, (%r13,%rbp,2)\ndd: \tjmp\t0x70 <wipe_shittyColMajorXform+0x70>\ndf: \tmovq\t%r15, %rdi\ne2: \tmovq\t%r13, %rsi\ne5: \tmovl\t4(%rsp), %edx\ne9: \tcallq\t0xee <wipe_shittyColMajorXform+0xee>\nee: \tmovq\t%r13, %rdi\nf1: \taddq\t$8, %rsp\nf5: \tpopq\t%rbx\nf6: \tpopq\t%r12\nf8: \tpopq\t%r13\nfa: \tpopq\t%r14\nfc: \tpopq\t%r15\nfe: \tpopq\t%rbp\nff: \tjmp\t0x104 <wipe_shittyColMajorXform+0x104>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nint /*<<< orphan*/  Z_Free (short*) ;\nscalar_t__ Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memcpy (short*,short*,int) ;\n\nvoid\nwipe_shittyColMajorXform\n( short*\tarray,\nint\t\twidth,\nint\t\theight )\n{\nint\t\tx;\nint\t\ty;\nshort*\tdest;\n\ndest = (short*) Z_Malloc(width*height*2, PU_STATIC, 0);\n\nfor(y=0;y<height;y++)\nfor(x=0;x<width;x++)\ndest[x*height+y] = array[y*width+x];\n\nmemcpy(array, dest, width*height*2);\n\nZ_Free(dest);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint16_t ;\ntypedef  int /*<<< orphan*/  uint8_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AV_LOG_WARNING ;\nint /*<<< orphan*/  av_log (void*,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  av_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * av_malloc (int) ;\nint /*<<< orphan*/  av_memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void wipe_shittyColMajorXform(void *log_ctx, int width, int height)\n{\nuint8_t *xform = av_malloc(width * height * 2);\nint i, j;\n\nav_log(log_ctx, AV_LOG_WARNING, \"wipe_shittyColMajorXform: %d x %d\\n\", width, height);\n\nfor (i = 0; i < width * height; i++) {\nxform[i] = i & 0xff;\n}\n\nfor (i = 0; i < width; i++) {\nfor (j = 0; j < height; j++) {\nxform[i * height + j] = xform[i + j * width];\n}\n}\n\nav_memcpy(xform, xform + 1, width * height * 2 - 2);\n\nav_free(xform);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_tick.c_P_AddThinker",
    "input":"\n0000000000000000 <P_AddThinker>:\n0: \tmovq\t(%rip), %rax  # 0x7 <P_AddThinker+0x7>\n7: \tmovq\t%rdi, 8(%rax)\nb: \tmovq\t$0, 8(%rdi)\n13: \tmovq\t%rax, (%rdi)\n16: \tmovq\t%rdi, (%rip)  # 0x1d <P_AddThinker+0x1d>\n1d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {struct TYPE_4__* prev; struct TYPE_4__* next; } ;\ntypedef  TYPE_1__ thinker_t ;\n\n/* Variables and functions */\nTYPE_1__ thinkercap ;\n\nvoid P_AddThinker (thinker_t* thinker)\n{\nthinkercap.prev->next = thinker;\nthinker->next = &thinkercap;\nthinker->prev = thinkercap.prev;\nthinkercap.prev = thinker;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* prev; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ thinker_t ;\n\n/* Variables and functions */\nTYPE_1__* thinker_head ;\n\nvoid P_AddThinker(thinker_t *th)\n{\nth->next = thinker_head;\nth->prev = NULL;\nif (thinker_head)\nthinker_head->prev = th;\nthinker_head = th;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_bsp.c_R_ClearClipSegs",
    "input":"\n0000000000000000 <R_ClearClipSegs>:\n0: \tmovq\t(%rip), %rax  # 0x7 <R_ClearClipSegs+0x7>\n7: \tmovq\t$-2147483647, (%rax)    # imm = 0x80000001\ne: \tmovl\t(%rip), %ecx  # 0x14 <R_ClearClipSegs+0x14>\n14: \tmovl\t%ecx, 8(%rax)\n17: \tmovl\t$2147483647, 12(%rax)   # imm = 0x7FFFFFFF\n1e: \taddq\t$16, %rax\n22: \tmovq\t%rax, (%rip)  # 0x29 <R_ClearClipSegs+0x29>\n29: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int first; int last; } ;\n\n/* Variables and functions */\nTYPE_1__* newend ;\nTYPE_1__* solidsegs ;\nint viewwidth ;\n\nvoid R_ClearClipSegs (void)\n{\nsolidsegs[0].first = -0x7fffffff;\nsolidsegs[0].last = -1;\nsolidsegs[1].first = viewwidth;\nsolidsegs[1].last = 0x7fffffff;\nnewend = solidsegs+2;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x1; int y1; int x2; } ;\n\n/* Variables and functions */\nTYPE_1__* ClipSegs ;\nint /*<<< orphan*/  ClipSegsEnd ;\n\nvoid R_ClearClipSegs(void)\n{\nClipSegs->x1 = -0x80000001;\nClipSegs->y1 = ClipSegsEnd;\nClipSegs->x2 = 0x7fffffff;\nClipSegs++;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BrainAwake",
    "input":"\n0000000000000000 <A_BrainAwake>:\n0: \tmovq\t$0, (%rip)    # 0xb <A_BrainAwake+0xb>\nb: \tmovq\t$0, (%rip)    # 0x16 <A_BrainAwake+0x16>\n16: \tmovq\t(%rip), %rax  # 0x1d <A_BrainAwake+0x1d>\n1d: \tmovl\t$0, %ecx\n22: \tcmpq\t%rcx, %rax\n25: \tje\t0x72 <A_BrainAwake+0x72>\n27: \tmovq\t(%rip), %rdx  # 0x2e <A_BrainAwake+0x2e>\n2e: \txorl\t%esi, %esi\n30: \tjmp\t0x49 <A_BrainAwake+0x49>\n32: \tnopw\t%cs:(%rax,%rax)\n3c: \tnopl\t(%rax)\n40: \tmovq\t8(%rax), %rax\n44: \tcmpq\t%rcx, %rax\n47: \tje\t0x72 <A_BrainAwake+0x72>\n49: \tmovq\t(%rax), %rdi\n4c: \tcmpq\t%rdx, %rdi\n4f: \tjne\t0x40 <A_BrainAwake+0x40>\n51: \tcmpq\t(%rip), %rdi  # 0x58 <A_BrainAwake+0x58>\n58: \tjne\t0x40 <A_BrainAwake+0x40>\n5a: \tmovq\t(%rip), %rdi  # 0x61 <A_BrainAwake+0x61>\n61: \tmovq\t%rax, (%rdi,%rsi,8)\n65: \taddq\t$1, %rsi\n69: \tmovq\t%rsi, (%rip)  # 0x70 <A_BrainAwake+0x70>\n70: \tjmp\t0x40 <A_BrainAwake+0x40>\n72: \tmovl\t(%rip), %esi  # 0x78 <A_BrainAwake+0x78>\n78: \txorl\t%edi, %edi\n7a: \tjmp\t0x7f <A_BrainAwake+0x7f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {scalar_t__ acp1; } ;\nstruct TYPE_8__ {TYPE_1__ function; struct TYPE_8__* next; } ;\ntypedef  TYPE_2__ thinker_t ;\nstruct TYPE_9__ {scalar_t__ type; } ;\ntypedef  TYPE_3__ mobj_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nscalar_t__ MT_BOSSTARGET ;\nscalar_t__ P_MobjThinker ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nscalar_t__ braintargeton ;\nTYPE_3__** braintargets ;\nsize_t numbraintargets ;\nint /*<<< orphan*/  sfx_bossit ;\nTYPE_2__ thinkercap ;\n\nvoid A_BrainAwake (mobj_t* mo)\n{\nthinker_t*\tthinker;\nmobj_t*\tm;\n\n// find all the target spots\nnumbraintargets = 0;\nbraintargeton = 0;\n\nthinker = thinkercap.next;\nfor (thinker = thinkercap.next ;\nthinker != &thinkercap ;\nthinker = thinker->next)\n{\nif (thinker->function.acp1 != (actionf_p1)P_MobjThinker)\ncontinue;\t// not a mobj\n\nm = (mobj_t *)thinker;\n\nif (m->type == MT_BOSSTARGET )\n{\nbraintargets[numbraintargets] = m;\nnumbraintargets++;\n}\n}\n\nS_StartSound (NULL,sfx_bossit);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ brain_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BrainAwake ;\nscalar_t__ BRAIN_NONE ;\nscalar_t__ BRAIN_WAKE ;\nscalar_t__ BRAIN_WAKING ;\nint /*<<< orphan*/  BrainWake (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__* BrainWaking ;\nsize_t BrainWakingCount ;\nsize_t BrainWakingCountMax ;\n\nvoid A_BrainAwake(void)\n{\nbrain_t *b;\n\nBrainWakingCount = 0;\nBrainWaking = NULL;\n\nfor (b = BrainWaking; b != NULL; b = b->next)\n{\nif (b->next == NULL)\n{\nbreak;\n}\n\nif (b->next->next == NULL && b->next->next->next == BRAIN_NONE && b->next->next->next == BRAIN_WAKING)\n{\nBrainWaking = b->next;\nBrainWakingCount++;\n}\n}\n\nif (BrainWakingCount == 0)\n{\nBrainWake(0, BrainAwake);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_DeferedPlayDemo",
    "input":"\n0000000000000000 <G_DeferedPlayDemo>:\n0: \tmovq\t%rdi, (%rip)  # 0x7 <G_DeferedPlayDemo+0x7>\n7: \tmovl\t(%rip), %eax  # 0xd <G_DeferedPlayDemo+0xd>\nd: \tmovl\t%eax, (%rip)  # 0x13 <G_DeferedPlayDemo+0x13>\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* defdemoname ;\nint /*<<< orphan*/  ga_playdemo ;\nint /*<<< orphan*/  gameaction ;\n\nvoid G_DeferedPlayDemo (char* name)\n{\ndefdemoname = name;\ngameaction = ga_playdemo;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  char ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DEFERRED_PLAYDEMO ;\nint /*<<< orphan*/ * DEFERRED_PLAYDEMO_NAME ;\n\nvoid G_DeferedPlayDemo(char *name)\n{\nDEFERRED_PLAYDEMO_NAME = name;\nDEFERRED_PLAYDEMO = DEFERRED_PLAYDEMO;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_tick.c_P_Ticker",
    "input":"\n0000000000000000 <P_Ticker>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tcmpq\t$0, (%rip)    # 0xc <P_Ticker+0xc>\nc: \tjne\t0xa1 <P_Ticker+0xa1>\n12: \tcmpq\t$0, (%rip)    # 0x1a <P_Ticker+0x1a>\n1a: \tje\t0x3e <P_Ticker+0x3e>\n1c: \tmovl\t(%rip), %eax  # 0x22 <P_Ticker+0x22>\n22: \torl\t(%rip), %eax  # 0x28 <P_Ticker+0x28>\n28: \tjne\t0x3e <P_Ticker+0x3e>\n2a: \tmovq\t(%rip), %rax  # 0x31 <P_Ticker+0x31>\n31: \tmovq\t(%rip), %rcx  # 0x38 <P_Ticker+0x38>\n38: \tcmpl\t$1, (%rax,%rcx,4)\n3c: \tjne\t0xa1 <P_Ticker+0xa1>\n3e: \tmovl\t(%rip), %eax  # 0x44 <P_Ticker+0x44>\n44: \ttestl\t%eax, %eax\n46: \tjle\t0x85 <P_Ticker+0x85>\n48: \txorl\t%ebx, %ebx\n4a: \txorl\t%r14d, %r14d\n4d: \tjmp\t0x60 <P_Ticker+0x60>\n4f: \tnop\n50: \taddq\t$1, %r14\n54: \tmovslq\t%eax, %rcx\n57: \taddq\t$4, %rbx\n5b: \tcmpq\t%rcx, %r14\n5e: \tjge\t0x85 <P_Ticker+0x85>\n60: \tmovq\t(%rip), %rcx  # 0x67 <P_Ticker+0x67>\n67: \tcmpq\t$0, (%rcx,%rbx,2)\n6c: \tje\t0x50 <P_Ticker+0x50>\n6e: \tmovq\t(%rip), %rdi  # 0x75 <P_Ticker+0x75>\n75: \taddq\t%rbx, %rdi\n78: \tcallq\t0x7d <P_Ticker+0x7d>\n7d: \tmovl\t(%rip), %eax  # 0x83 <P_Ticker+0x83>\n83: \tjmp\t0x50 <P_Ticker+0x50>\n85: \txorl\t%eax, %eax\n87: \tcallq\t0x8c <P_Ticker+0x8c>\n8c: \txorl\t%eax, %eax\n8e: \tcallq\t0x93 <P_Ticker+0x93>\n93: \txorl\t%eax, %eax\n95: \tcallq\t0x9a <P_Ticker+0x9a>\n9a: \taddl\t$1, (%rip)    # 0xa1 <P_Ticker+0xa1>\na1: \taddq\t$8, %rsp\na5: \tpopq\t%rbx\na6: \tpopq\t%r14\na8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int viewz; } ;\n\n/* Variables and functions */\nint MAXPLAYERS ;\nint /*<<< orphan*/  P_PlayerThink (TYPE_1__*) ;\nint /*<<< orphan*/  P_RespawnSpecials () ;\nint /*<<< orphan*/  P_RunThinkers () ;\nint /*<<< orphan*/  P_UpdateSpecials () ;\nsize_t consoleplayer ;\nint /*<<< orphan*/  demoplayback ;\nint /*<<< orphan*/  leveltime ;\nscalar_t__ menuactive ;\nint /*<<< orphan*/  netgame ;\nscalar_t__ paused ;\nscalar_t__* playeringame ;\nTYPE_1__* players ;\n\nvoid P_Ticker (void)\n{\nint\t\ti;\n\n// run the tic\nif (paused)\nreturn;\n\n// pause if in menu and at least one tic has been run\nif ( !netgame\n&& menuactive\n&& !demoplayback\n&& players[consoleplayer].viewz != 1)\n{\nreturn;\n}\n\n\nfor (i=0 ; i<MAXPLAYERS ; i++)\nif (playeringame[i])\nP_PlayerThink (&players[i]);\n\nP_RunThinkers ();\nP_UpdateSpecials ();\nP_RespawnSpecials ();\n\n// for par times\nleveltime++;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * b_p_ul; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Check_Cursor_Pos () ;\nint /*<<< orphan*/  Check_Scroll_Bindings () ;\nint /*<<< orphan*/  Check_Tick () ;\nint /*<<< orphan*/  Check_User_Cmds () ;\nint /*<<< orphan*/  Check_Win_Pos () ;\nint /*<<< orphan*/  CursorHoldI ;\nint /*<<< orphan*/  CursorHoldI_arg ;\nint /*<<< orphan*/  CursorMoved ;\nint /*<<< orphan*/  CursorMoved_arg ;\nint /*<<< orphan*/  CursorMovedI ;\nint /*<<< orphan*/  CursorMovedI_arg ;\nint /*<<< orphan*/  FocusGained ;\nint /*<<< orphan*/  FocusLost ;\nint /*<<< orphan*/  FocusLost_arg ;\nint /*<<< orphan*/  FocusGained_arg ;\nint /*<<< orphan*/  FocusGainedI ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusGainedI_arg ;\nint /*<<< orphan*/  FocusGained_arg ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLost ;\nint /*<<< orphan*/  FocusLost_arg ;\nint /*<<< orphan*/  FocusGainedI_arg ;\nint /*<<< orphan*/  FocusGained ;\nint /*<<< orphan*/  FocusGainedI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLost_arg ;\nint /*<<< orphan*/  FocusLost ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;\nint /*<<< orphan*/  FocusLostI ;\nint /*<<< orphan*/  FocusLostI_arg ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_VerifyNightmare",
    "input":"\n0000000000000000 <M_VerifyNightmare>:\n0: \tcmpl\t$121, %edi\n3: \tjne\t0x29 <M_VerifyNightmare+0x29>\n5: \tpushq\t%rax\n6: \tmovl\t(%rip), %edi  # 0xc <M_VerifyNightmare+0xc>\nc: \tmovq\t(%rip), %rsi  # 0x13 <M_VerifyNightmare+0x13>\n13: \taddq\t$1, %rsi\n17: \tmovl\t$1, %edx\n1c: \tcallq\t0x21 <M_VerifyNightmare+0x21>\n21: \txorl\t%eax, %eax\n23: \tpopq\t%rcx\n24: \tjmp\t0x29 <M_VerifyNightmare+0x29>\n29: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_DeferedInitNew (int /*<<< orphan*/ ,scalar_t__,int) ;\nint /*<<< orphan*/  M_ClearMenus () ;\nscalar_t__ epi ;\nint /*<<< orphan*/  nightmare ;\n\nvoid M_VerifyNightmare(int ch)\n{\nif (ch != 'y')\nreturn;\n\nG_DeferedInitNew(nightmare,epi+1,1);\nM_ClearMenus ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_VerifyNightmare_1 ;\nint /*<<< orphan*/  memcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/ * pNightmare ;\n\n__attribute__((used)) static int M_VerifyNightmare(UCHAR opcode)\n{\nif (opcode == 0x79)\n{\nreturn !memcmp(M_VerifyNightmare_1, pNightmare+1, 1);\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_loadData",
    "input":"\n0000000000000000 <ST_loadData>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, %edi\n6: \tcallq\t0xb <ST_loadData+0xb>\nb: \tmovl\t%eax, (%rip)  # 0x11 <ST_loadData+0x11>\n11: \txorl\t%eax, %eax\n13: \tpopq\t%rcx\n14: \tjmp\t0x19 <ST_loadData+0x19>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_loadGraphics () ;\nint /*<<< orphan*/  W_GetNumForName (char*) ;\nint /*<<< orphan*/  lu_palette ;\n\nvoid ST_loadData(void)\n{\nlu_palette = W_GetNumForName (\"PLAYPAL\");\nST_loadGraphics();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_loadData_file ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  st_loadData_file ;\n\nint ST_loadData(int argc, char **argv)\n{\nfprintf(st_loadData_file, \"ST_loadData\\n\");\nST_loadData_file = st_loadData_file;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_Start",
    "input":"\n0000000000000000 <AM_Start>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <AM_Start+0x8>\n8: \tjne\t0x11 <AM_Start+0x11>\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <AM_Start+0x11>\n11: \tmovl\t$0, (%rip)    # 0x1b <AM_Start+0x1b>\n1b: \tmovl\t(%rip), %eax  # 0x21 <AM_Start+0x21>\n21: \tcmpl\t(%rip), %eax  # 0x27 <AM_Start+0x27>\n27: \tjne\t0x37 <AM_Start+0x37>\n29: \tmovl\t(%rip), %eax  # 0x2f <AM_Start+0x2f>\n2f: \tcmpl\t(%rip), %eax  # 0x35 <AM_Start+0x35>\n35: \tje\t0x56 <AM_Start+0x56>\n37: \txorl\t%eax, %eax\n39: \tcallq\t0x3e <AM_Start+0x3e>\n3e: \tmovl\t(%rip), %eax  # 0x44 <AM_Start+0x44>\n44: \tmovl\t%eax, (%rip)  # 0x4a <AM_Start+0x4a>\n4a: \tmovl\t(%rip), %eax  # 0x50 <AM_Start+0x50>\n50: \tmovl\t%eax, (%rip)  # 0x56 <AM_Start+0x56>\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <AM_Start+0x5d>\n5d: \txorl\t%eax, %eax\n5f: \tpopq\t%rcx\n60: \tjmp\t0x65 <AM_Start+0x65>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_LevelInit () ;\nint /*<<< orphan*/  AM_Stop () ;\nint /*<<< orphan*/  AM_initVariables () ;\nint /*<<< orphan*/  AM_loadPics () ;\nint gameepisode ;\nint gamemap ;\nint stopped ;\n\nvoid AM_Start (void)\n{\nstatic int lastlevel = -1, lastepisode = -1;\n\nif (!stopped) AM_Stop();\nstopped = false;\nif (lastlevel != gamemap || lastepisode != gameepisode)\n{\nAM_LevelInit();\nlastlevel = gamemap;\nlastepisode = gameepisode;\n}\nAM_initVariables();\nAM_loadPics();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_Init () ;\nint /*<<< orphan*/  AM_Reset () ;\nint /*<<< orphan*/  AM_Stop () ;\nint /*<<< orphan*/  AM_Update () ;\nint /*<<< orphan*/  AM_Update_PAL () ;\nint /*<<< orphan*/  AM_Update_NTSC () ;\nint /*<<< orphan*/  AM_VBlank () ;\nint /*<<< orphan*/  AM_VBlank_PAL () ;\nint /*<<< orphan*/  AM_VBlank_NTSC () ;\nint /*<<< orphan*/  AM_VBlank_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_PAL_old ;\nint /*<<< orphan*/  AM_VBlank_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old ;\nint /*<<< orphan*/  AM_VBlank_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_PAL_NTSC_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_old ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_old_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_old_PAL ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_old_PAL_NTSC ;\nint /*<<< orphan*/  AM_VBlank_old_old_old_old_old_old_old_old_old_old_old_PAL_NTSC_old ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_InitTables",
    "input":"\n0000000000000000 <R_InitTables>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint FINEANGLES ;\nint FRACUNIT ;\nint PI ;\nint* finesine ;\nint* finetangent ;\nint sin (float) ;\nint tan (float) ;\n\nvoid R_InitTables (void)\n{\n// UNUSED: now getting from tables.c\n#if 0\nint\t\ti;\nfloat\ta;\nfloat\tfv;\nint\t\tt;\n\n// viewangle tangent table\nfor (i=0 ; i<FINEANGLES/2 ; i++)\n{\na = (i-FINEANGLES/4+0.5)*PI*2/FINEANGLES;\nfv = FRACUNIT*tan (a);\nt = fv;\nfinetangent[i] = t;\n}\n\n// finesine table\nfor (i=0 ; i<5*FINEANGLES/4 ; i++)\n{\n// OPTIMIZE: mirror...\na = (i+0.5)*PI*2/FINEANGLES;\nt = FRACUNIT*sin (a);\nfinesine[i] = t;\n}\n#endif\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid R_InitTables(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_InitFlats",
    "input":"\n0000000000000000 <R_InitFlats>:\n0: \tpushq\t%rax\n1: \tmovl\t$0, %edi\n6: \tcallq\t0xb <R_InitFlats+0xb>\nb: \taddl\t$1, %eax\ne: \tmovl\t%eax, (%rip)  # 0x14 <R_InitFlats+0x14>\n14: \tmovl\t$0, %edi\n19: \tcallq\t0x1e <R_InitFlats+0x1e>\n1e: \taddl\t$-1, %eax\n21: \tmovl\t%eax, (%rip)  # 0x27 <R_InitFlats+0x27>\n27: \tsubl\t(%rip), %eax  # 0x2d <R_InitFlats+0x2d>\n2d: \tleal\t1(%rax), %ecx\n30: \tmovl\t%ecx, (%rip)  # 0x36 <R_InitFlats+0x36>\n36: \tleal\t8(,%rax,4), %edi\n3d: \tmovl\t(%rip), %esi  # 0x43 <R_InitFlats+0x43>\n43: \txorl\t%edx, %edx\n45: \tcallq\t0x4a <R_InitFlats+0x4a>\n4a: \tmovq\t%rax, (%rip)  # 0x51 <R_InitFlats+0x51>\n51: \tcmpl\t$0, (%rip)    # 0x58 <R_InitFlats+0x58>\n58: \tjle\t0x73 <R_InitFlats+0x73>\n5a: \txorl\t%ecx, %ecx\n5c: \tnopl\t(%rax)\n60: \tmovl\t%ecx, (%rax,%rcx,4)\n63: \taddq\t$1, %rcx\n67: \tmovslq\t(%rip), %rdx  # 0x6e <R_InitFlats+0x6e>\n6e: \tcmpq\t%rdx, %rcx\n71: \tjl\t0x60 <R_InitFlats+0x60>\n73: \tpopq\t%rax\n74: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nint W_GetNumForName (char*) ;\nint* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint firstflat ;\nint* flattranslation ;\nint lastflat ;\nint numflats ;\n\nvoid R_InitFlats (void)\n{\nint\t\ti;\n\nfirstflat = W_GetNumForName (\"F_START\") + 1;\nlastflat = W_GetNumForName (\"F_END\") - 1;\nnumflats = lastflat - firstflat + 1;\n\n// Create translation table for global animation.\nflattranslation = Z_Malloc ((numflats+1)*4, PU_STATIC, 0);\n\nfor (i=0 ; i<numflats ; i++)\nflattranslation[i] = i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_Flat ;\nint /*<<< orphan*/  R_FlatSize ;\nint /*<<< orphan*/  R_InitFlat (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize2 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize3 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize4 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize5 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize6 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize7 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize8 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSize9 (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeA (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeB (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeC (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeD (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeE (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeF (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeG (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeH (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeI (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeJ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeK (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeL (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeN (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeO (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeP (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeQ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeR (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeS (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeU (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeV (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeW (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeX (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeY (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_InitFlatSizeZ (int /*<<< orphan*/ ) ;\nint R_NumFlat ;\nint R_NumFlat2 ;\nint R_NumFlat3 ;\nint R_NumFlat4 ;\nint R_NumFlat5 ;\nint R_NumFlat6 ;\nint R_NumFlat7 ;\nint R_NumFlat8 ;\nint R_NumFlat9 ;\nint R_NumFlatA ;\nint R_NumFlatB ;\nint R_NumFlatC ;\nint R_NumFlatD ;\nint R_NumFlatE ;\nint R_NumFlatF ;\nint R_NumFlatG ;\nint R_NumFlatH ;\nint R_NumFlatI ;\nint R_NumFlatJ ;\nint R_NumFlatK ;\nint R_NumFlatL ;\nint R_NumFlatM ;\nint R_NumFlatN ;\nint R_NumFlatO ;\nint R_NumFlatP ;\nint R_NumFlatQ ;\nint R_NumFlatR ;\nint R_NumFlatS ;\nint R_NumFlatT ;\nint R_NumFlatU ;\nint R_NumFlatV ;\nint R_NumFlatW ;\nint R_NumFlatX ;\nint R_NumFlatY ;\nint R_NumFlatZ ;\nint /*<<< orphan*/ * R_PFlats ;\nint /*<<< orphan*/  R_PFlatsSize ;\nint /*<<< orphan*/  R_PFlatsSize2 ;\nint /*<<< orphan*/  R_PFlatsSize3 ;\nint /*<<< orphan*/  R_PFlatsSize4 ;\nint /*<<< orphan*/  R_PFlatsSize5 ;\nint /*<<< orphan*/  R_PFlatsSize6 ;\nint /*<<< orphan*/  R_PFlatsSize7 ;\nint /*<<< orphan*/  R_PFlatsSize8 ;\nint /*<<< orphan*/  R_PFlatsSize9 ;\nint /*<<< orphan*/  R_PFlatsSizeA ;\nint /*<<< orphan*/  R_PFlatsSizeB ;\nint /*<<< orphan*/  R_PFlatsSizeC ;\nint /*<<< orphan*/  R_PFlatsSizeD ;\nint /*<<< orphan*/  R_PFlatsSizeE ;\nint /*<<< orphan*/  R_PFlatsSizeF ;\nint /*<<< orphan*/  R_PFlatsSizeG ;\nint /*<<< orphan*/  R_PFlatsSizeH ;\nint /*<<< orphan*/  R_PFlatsSizeI ;\nint /*<<< orphan*/  R_PFlatsSizeJ ;\nint /*<<< orphan*/  R_PFlatsSizeK ;\nint /*<<< orphan*/  R_PFlatsSizeL ;\nint /*<<< orphan*/  R_PFlatsSizeM ;\nint /*<<< orphan*/  R_PFlatsSizeN ;\nint /*<<< orphan*/  R_PFlatsSizeO ;\nint /*<<< orphan*/  R_PFlatsSizeP ;\nint /*<<< orphan*/  R_PFlatsSizeQ ;\nint /*<<< orphan*/  R_PFlatsSizeR ;\nint /*<<< orphan*/  R_PFlatsSizeS ;\nint /*<<< orphan*/  R_PFlatsSizeT ;\nint /*<<< orphan*/  R_PFlatsSizeU ;\nint /*<<< orphan*/  R_PFlatsSizeV ;\nint /*<<< orphan*/  R_PFlatsSizeW ;\nint /*<<< orphan*/  R_PFlatsSizeX ;\nint /*<<< orphan*/  R_PFlatsSizeY ;\nint /*<<< orphan*/  R_PFlatsSizeZ ;\nint /*<<< orphan*/  R_PFlatsSize_ ;\nint /*<<< orphan*/  R_PFlatsSize"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_random.c_M_ClearRandom",
    "input":"\n0000000000000000 <M_ClearRandom>:\n0: \tmovq\t$0, (%rip)    # 0xb <M_ClearRandom+0xb>\nb: \tmovq\t$0, (%rip)    # 0x16 <M_ClearRandom+0x16>\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ prndindex ;\nscalar_t__ rndindex ;\n\nvoid M_ClearRandom (void)\n{\nrndindex = prndindex = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ m_rand_max ;\nscalar_t__ m_rand_seed ;\n\nvoid M_ClearRandom(void)\n{\nm_rand_seed = 0;\nm_rand_max = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_DumpHeap",
    "input":"\n0000000000000000 <Z_DumpHeap>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%esi, %r14d\na: \tmovl\t%edi, %r15d\nd: \tmovq\t(%rip), %rdx  # 0x14 <Z_DumpHeap+0x14>\n14: \tmovl\t(%rdx), %esi\n16: \tmovl\t$0, %edi\n1b: \txorl\t%eax, %eax\n1d: \tcallq\t0x22 <Z_DumpHeap+0x22>\n22: \tmovl\t$0, %edi\n27: \tmovl\t%r15d, %esi\n2a: \tmovl\t%r14d, %edx\n2d: \txorl\t%eax, %eax\n2f: \tcallq\t0x34 <Z_DumpHeap+0x34>\n34: \tmovq\t(%rip), %rbp  # 0x3b <Z_DumpHeap+0x3b>\n3b: \taddq\t$24, %rbp\n3f: \tnop\n40: \tmovq\t(%rbp), %rbx\n44: \tmovl\t(%rbx), %r8d\n47: \tcmpl\t%r15d, %r8d\n4a: \tjl\t0x66 <Z_DumpHeap+0x66>\n4c: \tcmpl\t%r14d, %r8d\n4f: \tjg\t0x66 <Z_DumpHeap+0x66>\n51: \tmovl\t4(%rbx), %edx\n54: \tmovl\t8(%rbx), %ecx\n57: \tmovl\t$0, %edi\n5c: \tmovq\t%rbx, %rsi\n5f: \txorl\t%eax, %eax\n61: \tcallq\t0x66 <Z_DumpHeap+0x66>\n66: \tmovq\t16(%rbx), %rax\n6a: \tmovq\t(%rip), %rcx  # 0x71 <Z_DumpHeap+0x71>\n71: \taddq\t$8, %rcx\n75: \tcmpq\t%rcx, %rax\n78: \tje\t0xc8 <Z_DumpHeap+0xc8>\n7a: \tleaq\t16(%rbx), %rbp\n7e: \tmovslq\t4(%rbx), %rcx\n82: \tleaq\t(%rbx,%rcx,4), %rcx\n86: \tcmpq\t%rax, %rcx\n89: \tje\t0x99 <Z_DumpHeap+0x99>\n8b: \tmovl\t$0, %edi\n90: \tcallq\t0x95 <Z_DumpHeap+0x95>\n95: \tmovq\t(%rbp), %rax\n99: \tcmpq\t%rbx, 24(%rax)\n9d: \tje\t0xa9 <Z_DumpHeap+0xa9>\n9f: \tmovl\t$0, %edi\na4: \tcallq\t0xa9 <Z_DumpHeap+0xa9>\na9: \tcmpl\t$0, 8(%rbx)\nad: \tjne\t0x40 <Z_DumpHeap+0x40>\naf: \tmovq\t(%rbp), %rax\nb3: \tcmpl\t$0, 8(%rax)\nb7: \tjne\t0x40 <Z_DumpHeap+0x40>\nb9: \tmovl\t$0, %edi\nbe: \tcallq\t0xc3 <Z_DumpHeap+0xc3>\nc3: \tjmp\t0x40 <Z_DumpHeap+0x40>\nc8: \taddq\t$8, %rsp\ncc: \tpopq\t%rbx\ncd: \tpopq\t%r14\ncf: \tpopq\t%r15\nd1: \tpopq\t%rbp\nd2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int tag; int size; int /*<<< orphan*/  user; struct TYPE_3__* next; struct TYPE_3__* prev; } ;\ntypedef  TYPE_1__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\nstruct TYPE_4__ {int size; TYPE_1__ blocklist; } ;\n\n/* Variables and functions */\nTYPE_2__* mainzone ;\nint /*<<< orphan*/  printf (char*,...) ;\n\nvoid\nZ_DumpHeap\n( int\t\tlowtag,\nint\t\thightag )\n{\nmemblock_t*\tblock;\n\nprintf (\"zone size: %i  location: %p\\n\",\nmainzone->size,mainzone);\n\nprintf (\"tag range: %i to %i\\n\",\nlowtag, hightag);\n\nfor (block = mainzone->blocklist.next ; ; block = block->next)\n{\nif (block->tag >= lowtag && block->tag <= hightag)\nprintf (\"block:%p    size:%7i    user:%p    tag:%3i\\n\",\nblock, block->size, block->user, block->tag);\n\nif (block->next == &mainzone->blocklist)\n{\n// all blocks have been hit\nbreak;\n}\n\nif ( (byte *)block + block->size != (byte *)block->next)\nprintf (\"ERROR: block size does not touch the next block\\n\");\n\nif ( block->next->prev != block)\nprintf (\"ERROR: next block doesn't have proper back link\\n\");\n\nif (!block->user && !block->next->user)\nprintf (\"ERROR: two consecutive free blocks\\n\");\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  next; int /*<<< orphan*/  prev; int /*<<< orphan*/  size; int /*<<< orphan*/  type; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  next; int /*<<< orphan*/  prev; int /*<<< orphan*/  size; int /*<<< orphan*/  type; } ;\nstruct TYPE_8__ {TYPE_2__* next; } ;\ntypedef  TYPE_1__ Z_List ;\ntypedef  TYPE_2__ Z_Block ;\ntypedef  TYPE_3__ Z_Heap ;\n\n/* Variables and functions */\nint /*<<< orphan*/  printf (char*,...) ;\nTYPE_3__* Z_heap ;\nTYPE_1__* Z_list ;\n\nvoid Z_DumpHeap(int min, int max)\n{\nZ_Heap *h;\nZ_Block *b;\n\nprintf(\"Heap: %d\\n\", Z_heap->next->type);\nprintf(\"Dumping heap from %d to %d\\n\", min, max);\n\nfor (h = Z_heap->next; h->type < max; h = h->next)\n{\nif (h->type < min)\ncontinue;\n\nprintf(\"Block: %d, size: %d, prev: %d, next: %d\\n\",\nh->type, h->size, h->prev, h->next->type);\n\nb = h->next;\nif (b->type != h->type + 1)\nprintf(\"Next block type is %d\\n\", b->type);\nif (b->prev != h)\nprintf(\"Next block prev is %d\\n\", b->prev->type);\nif (b->size == 0)\nprintf(\"Next block size is 0\\n\");\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_sight.c_P_CheckSight",
    "input":"\n0000000000000000 <P_CheckSight>:\n0: \tmovq\t32(%rdi), %rax\n4: \tmovl\t(%rax), %eax\n6: \tmovl\t(%rip), %ecx  # 0xc <P_CheckSight+0xc>\nc: \tsubl\t%ecx, %eax\ne: \tmovq\t32(%rsi), %rdx\n12: \tmovl\t(%rdx), %edx\n14: \tsubl\t%ecx, %edx\n16: \timull\t(%rip), %eax  # 0x1d <P_CheckSight+0x1d>\n1d: \taddl\t%edx, %eax\n1f: \tmovl\t%eax, %ecx\n21: \tsarl\t$3, %ecx\n24: \tandb\t$7, %al\n26: \tmovq\t(%rip), %rdx  # 0x2d <P_CheckSight+0x2d>\n2d: \tmovslq\t%ecx, %rcx\n30: \tmovl\t(%rdx,%rcx,4), %ecx\n33: \tmovzbl\t%al, %eax\n36: \tbtl\t%eax, %ecx\n39: \tmovq\t(%rip), %rax  # 0x40 <P_CheckSight+0x40>\n40: \tjae\t0x48 <P_CheckSight+0x48>\n42: \taddl\t$1, (%rax)\n45: \txorl\t%eax, %eax\n47: \tretq\n48: \taddl\t$1, 4(%rax)\n4c: \taddl\t$1, (%rip)    # 0x53 <P_CheckSight+0x53>\n53: \tmovslq\t8(%rdi), %rax\n57: \tmovq\t%rax, %rcx\n5a: \taddq\t(%rdi), %rcx\n5d: \tsarl\t$2, %eax\n60: \tnegl\t%eax\n62: \tcltq\n64: \taddq\t%rcx, %rax\n67: \tmovq\t%rax, (%rip)  # 0x6e <P_CheckSight+0x6e>\n6e: \tmovslq\t8(%rsi), %rcx\n72: \taddq\t(%rsi), %rcx\n75: \tsubq\t%rax, %rcx\n78: \tmovq\t%rcx, (%rip)  # 0x7f <P_CheckSight+0x7f>\n7f: \tmovq\t(%rsi), %rcx\n82: \tsubq\t%rax, %rcx\n85: \tmovq\t%rcx, (%rip)  # 0x8c <P_CheckSight+0x8c>\n8c: \tmovq\t24(%rdi), %rax\n90: \tmovq\t%rax, (%rip)  # 0x97 <P_CheckSight+0x97>\n97: \tmovq\t16(%rdi), %rcx\n9b: \tmovq\t%rcx, (%rip)  # 0xa2 <P_CheckSight+0xa2>\na2: \tmovq\t24(%rsi), %rdx\na6: \tmovq\t%rdx, (%rip)  # 0xad <P_CheckSight+0xad>\nad: \tmovq\t16(%rsi), %rsi\nb1: \tmovq\t%rsi, (%rip)  # 0xb8 <P_CheckSight+0xb8>\nb8: \tsubq\t%rax, %rdx\nbb: \tmovq\t%rdx, (%rip)  # 0xc2 <P_CheckSight+0xc2>\nc2: \tsubq\t%rcx, %rsi\nc5: \tmovq\t%rsi, (%rip)  # 0xcc <P_CheckSight+0xcc>\ncc: \tmovq\t(%rip), %rdi  # 0xd3 <P_CheckSight+0xd3>\nd3: \taddq\t$-1, %rdi\nd7: \tjmp\t0xdc <P_CheckSight+0xdc>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {void* z; int height; scalar_t__ y; scalar_t__ x; TYPE_1__* subsector; } ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  int boolean ;\nstruct TYPE_8__ {scalar_t__ dy; scalar_t__ dx; scalar_t__ y; scalar_t__ x; } ;\nstruct TYPE_6__ {int sector; } ;\n\n/* Variables and functions */\nint P_CrossBSPNode (scalar_t__) ;\nvoid* bottomslope ;\nscalar_t__ numnodes ;\nint numsectors ;\nint* rejectmatrix ;\nint sectors ;\nint /*<<< orphan*/ * sightcounts ;\nvoid* sightzstart ;\nTYPE_3__ strace ;\nscalar_t__ t2x ;\nscalar_t__ t2y ;\nvoid* topslope ;\nint /*<<< orphan*/  validcount ;\n\nboolean\nP_CheckSight\n( mobj_t*\tt1,\nmobj_t*\tt2 )\n{\nint\t\ts1;\nint\t\ts2;\nint\t\tpnum;\nint\t\tbytenum;\nint\t\tbitnum;\n\n// First check for trivial rejection.\n\n// Determine subsector entries in REJECT table.\ns1 = (t1->subsector->sector - sectors);\ns2 = (t2->subsector->sector - sectors);\npnum = s1*numsectors + s2;\nbytenum = pnum>>3;\nbitnum = 1 << (pnum&7);\n\n// Check in REJECT table.\nif (rejectmatrix[bytenum]&bitnum)\n{\nsightcounts[0]++;\n\n// can't possibly be connected\nreturn false;\n}\n\n// An unobstructed LOS is possible.\n// Now look from eyes of t1 to any part of t2.\nsightcounts[1]++;\n\nvalidcount++;\n\nsightzstart = t1->z + t1->height - (t1->height>>2);\ntopslope = (t2->z+t2->height) - sightzstart;\nbottomslope = (t2->z) - sightzstart;\n\nstrace.x = t1->x;\nstrace.y = t1->y;\nt2x = t2->x;\nt2y = t2->y;\nstrace.dx = t2->x - t1->x;\nstrace.dy = t2->y - t1->y;\n\n// the head node is the last node output\nreturn P_CrossBSPNode (numnodes-1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; } ;\ntypedef  TYPE_1__ D3DVECTOR ;\ntypedef  TYPE_2__ PLAYER ;\ntypedef  TYPE_3__ VECTOR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckSight_ ;\nint /*<<< orphan*/  P_CheckSight_Count ;\nint /*<<< orphan*/  P_CheckSight_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Count ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_Total_ ;\nint /*<<< orphan*/  P_CheckSight_Total_Total_Total_Total_Total_Total"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_init",
    "input":"\n0000000000000000 <STlib_init>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <STlib_init+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <STlib_init+0x11>\n11: \tmovq\t%rax, (%rip)  # 0x18 <STlib_init+0x18>\n18: \tpopq\t%rax\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  patch_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\nscalar_t__ W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * sttminus ;\n\nvoid STlib_init(void)\n{\nsttminus = (patch_t *) W_CacheLumpName(\"STTMINUS\", PU_STATIC);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HRESULT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CLSCTX_INPROC_SERVER ;\nint /*<<< orphan*/  CoInitialize (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * CoCreateInstance (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  IID_IStdStorage ;\nint /*<<< orphan*/  IID_IStorage ;\nint /*<<< orphan*/ * pStdStorage ;\n\n__attribute__((used)) static HRESULT STlib_init(void)\n{\nHRESULT hr;\n\nhr = CoInitialize(NULL);\nif (FAILED(hr)) return hr;\n\npStdStorage = (void*)CoCreateInstance(&IID_IStdStorage, NULL, CLSCTX_INPROC_SERVER, &IID_IStorage, NULL);\nreturn S_OK;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_TextureNumForName",
    "input":"\n0000000000000000 <R_TextureNumForName>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdi, %rbx\n6: \tcallq\t0xb <R_TextureNumForName+0xb>\nb: \tmovl\t%eax, %ebp\nd: \tcmpl\t$-1, %eax\n10: \tjne\t0x1f <R_TextureNumForName+0x1f>\n12: \tmovl\t$0, %edi\n17: \tmovq\t%rbx, %rsi\n1a: \tcallq\t0x1f <R_TextureNumForName+0x1f>\n1f: \tmovl\t%ebp, %eax\n21: \taddq\t$8, %rsp\n25: \tpopq\t%rbx\n26: \tpopq\t%rbp\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,char*) ;\nint R_CheckTextureNumForName (char*) ;\n\nint\tR_TextureNumForName (char* name)\n{\nint\t\ti;\n\ni = R_CheckTextureNumForName (name);\n\nif (i==-1)\n{\nI_Error (\"R_TextureNumForName: %s not found\",\nname);\n}\nreturn i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  char ;\n\n/* Variables and functions */\nint R_TextureNumForNameWithoutExtension (int /*<<< orphan*/  const*) ;\nint /*<<< orphan*/  R_Warning (char*,int /*<<< orphan*/  const*) ;\n\nint\nR_TextureNumForName(const char *name)\n{\nint\t\t\ttexnum;\n\ntexnum = R_TextureNumForNameWithoutExtension(name);\nif (texnum == -1)\nR_Warning(\"R_TextureNumForName: unknown texture '%s'\\n\", name);\nreturn texnum;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_FlatNumForName",
    "input":"\n0000000000000000 <R_FlatNumForName>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovq\t%rdi, %r14\nc: \tcallq\t0x11 <R_FlatNumForName+0x11>\n11: \tmovl\t%eax, %ebx\n13: \tcmpl\t$-1, %eax\n16: \tjne\t0x3f <R_FlatNumForName+0x3f>\n18: \tmovb\t$0, 15(%rsp)\n1d: \tleaq\t7(%rsp), %r15\n22: \tmovq\t%r15, %rdi\n25: \tmovq\t%r14, %rsi\n28: \tmovl\t$8, %edx\n2d: \tcallq\t0x32 <R_FlatNumForName+0x32>\n32: \tmovl\t$0, %edi\n37: \tmovq\t%r15, %rsi\n3a: \tcallq\t0x3f <R_FlatNumForName+0x3f>\n3f: \tmovl\t(%rip), %eax  # 0x45 <R_FlatNumForName+0x45>\n45: \tsubl\t%eax, %ebx\n47: \tmovl\t%ebx, %eax\n49: \taddq\t$16, %rsp\n4d: \tpopq\t%rbx\n4e: \tpopq\t%r14\n50: \tpopq\t%r15\n52: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,char*) ;\nint W_CheckNumForName (char*) ;\nint firstflat ;\nint /*<<< orphan*/  memcpy (char*,char*,int) ;\n\nint R_FlatNumForName (char* name)\n{\nint\t\ti;\nchar\tnamet[9];\n\ni = W_CheckNumForName (name);\n\nif (i == -1)\n{\nnamet[8] = 0;\nmemcpy (namet, name,8);\nI_Error (\"R_FlatNumForName: %s not found\",namet);\n}\nreturn i - firstflat;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  R_FlatNum ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_FlatNum_MAX ;\nint R_FlatNumForName_ (char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_NAME ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_NAME_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_NAME_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_LEN ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR_STR ;\nint /*<<< orphan*/  R_FlatNum_UNKNOWN_STR_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_RegisterSong",
    "input":"\n0000000000000000 <I_RegisterSong>:\n0: \tmovl\t$1, %eax\n5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nint I_RegisterSong(void* data)\n{\n// UNUSED.\ndata = NULL;\n\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\n\nUBYTE I_RegisterSong(UBYTE song)\n{\nreturn 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_ZoneBase",
    "input":"\n0000000000000000 <I_ZoneBase>:\n0: \tmovl\t(%rip), %eax  # 0x6 <I_ZoneBase+0x6>\n6: \tshll\t$20, %eax\n9: \tmovl\t%eax, (%rdi)\nb: \tmovl\t%eax, %edi\nd: \tjmp\t0x12 <I_ZoneBase+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nscalar_t__ malloc (int) ;\nint mb_used ;\n\nbyte* I_ZoneBase (int*\tsize)\n{\n*size = mb_used*1024*1024;\nreturn (byte *) malloc (*size);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ZoneBase_ ;\nint /*<<< orphan*/  I_ZoneBase_ (int /*<<< orphan*/ ) ;\n\nvoid I_ZoneBase(UBYTE *ptr)\n{\n*ptr = (I_ZoneBase_ << 20);\nI_ZoneBase_(ptr);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_InitFile",
    "input":"\n0000000000000000 <W_InitFile>:\n0: \tsubq\t$24, %rsp\n4: \tmovq\t%rdi, (%rsp)\n8: \tmovq\t$0, 8(%rsp)\n11: \tmovq\t%rsp, %rdi\n14: \tcallq\t0x19 <W_InitFile+0x19>\n19: \taddq\t$24, %rsp\n1d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  W_InitMultipleFiles (char**) ;\n\nvoid W_InitFile (char* filename)\n{\nchar*\tnames[2];\n\nnames[0] = filename;\nnames[1] = NULL;\nW_InitMultipleFiles (names);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {char* filename; scalar_t__ fd; } ;\ntypedef  TYPE_1__ Writer ;\n\n/* Variables and functions */\nint /*<<< orphan*/  W_Init (TYPE_1__*) ;\n\nvoid W_InitFile(char *filename)\n{\nWriter w;\nw.filename = filename;\nw.fd = 0;\nW_Init(&w);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_FatAttack2",
    "input":"\n0000000000000000 <A_FatAttack2>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tcallq\t0xc <A_FatAttack2+0xc>\nc: \tmovl\t(%rip), %eax  # 0x12 <A_FatAttack2+0x12>\n12: \tsubl\t%eax, (%rbx)\n14: \tmovl\t32(%rbx), %esi\n17: \tmovl\t(%rip), %edx  # 0x1d <A_FatAttack2+0x1d>\n1d: \tmovq\t%rbx, %rdi\n20: \tcallq\t0x25 <A_FatAttack2+0x25>\n25: \tmovl\t32(%rbx), %esi\n28: \tmovl\t(%rip), %edx  # 0x2e <A_FatAttack2+0x2e>\n2e: \tmovq\t%rbx, %rdi\n31: \tcallq\t0x36 <A_FatAttack2+0x36>\n36: \tmovq\t%rax, %rbx\n39: \tmovl\t(%rip), %eax  # 0x3f <A_FatAttack2+0x3f>\n3f: \taddl\t%eax, %eax\n41: \tmovl\t(%rbx), %edx\n43: \tsubl\t%eax, %edx\n45: \tmovl\t%edx, (%rbx)\n47: \tmovb\t(%rip), %cl   # 0x4d <A_FatAttack2+0x4d>\n4d: \tsarl\t%cl, %edx\n4f: \tmovq\t8(%rbx), %rax\n53: \tmovl\t(%rax), %edi\n55: \tmovq\t(%rip), %rax  # 0x5c <A_FatAttack2+0x5c>\n5c: \tmovslq\t%edx, %r14\n5f: \tmovl\t(%rax,%r14,4), %esi\n63: \tcallq\t0x68 <A_FatAttack2+0x68>\n68: \tmovq\t%rax, 24(%rbx)\n6c: \tmovq\t8(%rbx), %rax\n70: \tmovl\t(%rax), %edi\n72: \tmovq\t(%rip), %rax  # 0x79 <A_FatAttack2+0x79>\n79: \tmovl\t(%rax,%r14,4), %esi\n7d: \tcallq\t0x82 <A_FatAttack2+0x82>\n82: \tmovq\t%rax, 16(%rbx)\n86: \taddq\t$8, %rsp\n8a: \tpopq\t%rbx\n8b: \tpopq\t%r14\n8d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int angle; TYPE_1__* info; void* momy; void* momx; int /*<<< orphan*/  target; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  speed; } ;\n\n/* Variables and functions */\nint ANGLETOFINESHIFT ;\nint /*<<< orphan*/  A_FaceTarget (TYPE_2__*) ;\nint FATSPREAD ;\nvoid* FixedMul (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MT_FATSHOT ;\nTYPE_2__* P_SpawnMissile (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * finecosine ;\nint /*<<< orphan*/ * finesine ;\n\nvoid A_FatAttack2 (mobj_t* actor)\n{\nmobj_t*\tmo;\nint\t\tan;\n\nA_FaceTarget (actor);\n// Now here choose opposite deviation.\nactor->angle -= FATSPREAD;\nP_SpawnMissile (actor, actor->target, MT_FATSHOT);\n\nmo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\nmo->angle -= FATSPREAD*2;\nan = mo->angle >> ANGLETOFINESHIFT;\nmo->momx = FixedMul (mo->info->speed, finecosine[an]);\nmo->momy = FixedMul (mo->info->speed, finesine[an]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__* PANELENTRY ;\ntypedef  TYPE_2__* PANEL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FatAttack1 ;\nint /*<<< orphan*/  A_FatAttack2_1 ;\nint /*<<< orphan*/  A_FatAttack2_2 ;\nint /*<<< orphan*/  A_FatAttack2_3 ;\nint /*<<< orphan*/  A_FatAttack2_4 ;\nint /*<<< orphan*/  A_FatAttack2_5 ;\nint /*<<< orphan*/  A_FatAttack2_6 ;\nint /*<<< orphan*/  A_FatAttack2_7 ;\nint /*<<< orphan*/  A_FatAttack2_8 ;\nint /*<<< orphan*/  A_FatAttack2_9 ;\nint /*<<< orphan*/  A_FatAttack2_10 ;\nint /*<<< orphan*/  A_FatAttack2_11 ;\nint /*<<< orphan*/  A_FatAttack2_12 ;\nint /*<<< orphan*/  A_FatAttack2_13 ;\nint /*<<< orphan*/  A_FatAttack2_14 ;\nint /*<<< orphan*/  A_FatAttack2_15 ;\nint /*<<< orphan*/  A_FatAttack2_16 ;\nint /*<<< orphan*/  A_FatAttack2_17 ;\nint /*<<< orphan*/  A_FatAttack2_18 ;\nint /*<<< orphan*/  A_FatAttack2_19 ;\nint /*<<< orphan*/  A_FatAttack2_20 ;\nint /*<<< orphan*/  A_FatAttack2_21 ;\nint /*<<< orphan*/  A_FatAttack2_22 ;\nint /*<<< orphan*/  A_FatAttack2_23 ;\nint /*<<< orphan*/  A_FatAttack2_24 ;\nint /*<<< orphan*/  A_FatAttack2_25 ;\nint /*<<< orphan*/  A_FatAttack2_26 ;\nint /*<<< orphan*/  A_FatAttack2_27 ;\nint /*<<< orphan*/  A_FatAttack2_28 ;\nint /*<<< orphan*/  A_FatAttack2_29 ;\nint /*<<< orphan*/  A_FatAttack2_30 ;\nint /*<<< orphan*/  A_FatAttack2_31 ;\nint /*<<< orphan*/  A_FatAttack2_32 ;\nint /*<<< orphan*/  A_FatAttack2_33 ;\nint /*<<< orphan*/  A_FatAttack2_34 ;\nint /*<<< orphan*/  A_FatAttack2_35 ;\nint /*<<< orphan*/  A_FatAttack2_36 ;\nint /*<<< orphan*/  A_FatAttack2_37 ;\nint /*<<< orphan*/  A_FatAttack2_38 ;\nint /*<<< orphan*/  A_FatAttack2_39 ;\nint /*<<< orphan*/  A_FatAttack2_40 ;\nint /*<<< orphan*/  A_FatAttack2_41 ;\nint /*<<< orphan*/  A_FatAttack2_42 ;\nint /*<<< orphan*/  A_FatAttack2_43 ;\nint /*<<< orphan*/  A_FatAttack2_44 ;\nint /*<<< orphan*/  A_FatAttack2_45 ;\nint /*<<< orphan*/  A_FatAttack2_46 ;\nint /*<<< orphan*/  A_FatAttack2_47 ;\nint /*<<< orphan*/  A_FatAttack2_48 ;\nint /*<<< orphan*/  A_FatAttack2_49 ;\nint /*<<< orphan*/  A_FatAttack2_50 ;\nint /*<<< orphan*/  A_FatAttack2_51 ;\nint /*<<< orphan*/  A_FatAttack2_52 ;\nint /*<<< orphan*/  A_FatAttack2_53 ;\nint /*<<< orphan*/  A_FatAttack2_54 ;\nint /*<<< orphan*/  A_FatAttack2_55 ;\nint /*<<< orphan*/  A_FatAttack2_56 ;\nint /*<<< orphan*/  A_FatAttack2_57 ;\nint /*<<< orphan*/  A_FatAttack2_58 ;\nint /*<<< orphan*/  A_FatAttack2_59 ;\nint /*<<< orphan*/  A_FatAttack2_60 ;\nint /*<<< orphan*/  A_FatAttack2_61 ;\nint /*<<< orphan*/  A_FatAttack2_62 ;\nint /*<<< orphan*/  A_FatAttack2_63 ;\nint /*<<< orphan*/  A_FatAttack2_64 ;\nint /*<<< orphan*/  A_FatAttack2_65 ;\nint /*<<< orphan*/  A_FatAttack2_66 ;\nint /*<<< orphan*/  A_FatAttack2_67 ;\nint /*<<< orphan*/  A_FatAttack2_68 ;\nint /*<<< orphan*/  A_FatAttack2_69 ;\nint /*<<< orphan*/  A_FatAttack2_70 ;\nint /*<<< orphan*/  A_FatAttack2_71 ;\nint /*<<< orphan*/  A_FatAttack2_72 ;\nint /*<<< orphan*/  A_FatAttack2_73 ;\nint /*<<< orphan*/  A_FatAttack2_74 ;\nint /*<<< orphan*/  A_FatAttack2_75 ;\nint /*<<< orphan*/  A_FatAttack2_76 ;\nint /*<<< orphan*/  A_FatAttack2_77 ;\nint /*<<< orphan*/  A_FatAttack2_78 ;\nint /*<<< orphan*/  A_FatAttack2_79 ;\nint /*<<< orphan*/  A_FatAttack2_80 ;\nint /*<<< orphan*/  A_FatAttack2_81 ;\nint /*<<< orphan*/  A_FatAttack2_82 ;\nint /*<<< orphan*/  A_FatAttack2_83 ;\nint /*<<< orphan*/  A_FatAttack2_84 ;\nint /*<<< orphan*/  A_FatAttack2_85 ;\nint /*<<< orphan*/  A_FatAttack2_86 ;\nint /*<<< orphan*/  A_FatAttack2_87 ;\nint /*<<< orphan*/  A_FatAttack2_88 ;\nint /*<<< orphan*/  A_FatAttack2_89 ;\nint /*<<< orphan*/  A_FatAttack"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_things.c_R_DrawPlayerSprites",
    "input":"\n0000000000000000 <R_DrawPlayerSprites>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t(%rip), %rax  # 0xa <R_DrawPlayerSprites+0xa>\na: \tmovq\t8(%rax), %rcx\ne: \tmovq\t(%rcx), %rcx\n11: \tmovq\t(%rcx), %rcx\n14: \tmovl\t(%rcx), %edx\n16: \tmovb\t(%rip), %cl   # 0x1c <R_DrawPlayerSprites+0x1c>\n1c: \tsarl\t%cl, %edx\n1e: \taddl\t(%rip), %edx  # 0x24 <R_DrawPlayerSprites+0x24>\n24: \tjs\t0x40 <R_DrawPlayerSprites+0x40>\n26: \tmovslq\t(%rip), %rsi  # 0x2d <R_DrawPlayerSprites+0x2d>\n2d: \tmovq\t(%rip), %rcx  # 0x34 <R_DrawPlayerSprites+0x34>\n34: \tcmpl\t%esi, %edx\n36: \tjge\t0x49 <R_DrawPlayerSprites+0x49>\n38: \tmovl\t%edx, %edx\n3a: \tleaq\t(%rcx,%rdx,4), %rcx\n3e: \tjmp\t0x51 <R_DrawPlayerSprites+0x51>\n40: \tmovq\t(%rip), %rcx  # 0x47 <R_DrawPlayerSprites+0x47>\n47: \tjmp\t0x51 <R_DrawPlayerSprites+0x51>\n49: \tleaq\t(%rcx,%rsi,4), %rcx\n4d: \taddq\t$-4, %rcx\n51: \tmovl\t(%rcx), %ecx\n53: \tmovl\t%ecx, (%rip)  # 0x59 <R_DrawPlayerSprites+0x59>\n59: \tmovl\t(%rip), %ecx  # 0x5f <R_DrawPlayerSprites+0x5f>\n5f: \tmovl\t%ecx, (%rip)  # 0x65 <R_DrawPlayerSprites+0x65>\n65: \tmovl\t(%rip), %ecx  # 0x6b <R_DrawPlayerSprites+0x6b>\n6b: \tmovl\t%ecx, (%rip)  # 0x71 <R_DrawPlayerSprites+0x71>\n71: \tmovl\t(%rip), %ecx  # 0x77 <R_DrawPlayerSprites+0x77>\n77: \ttestl\t%ecx, %ecx\n79: \tjle\t0xb1 <R_DrawPlayerSprites+0xb1>\n7b: \tmovq\t(%rax), %rbx\n7e: \txorl\t%ebp, %ebp\n80: \tjmp\t0x9b <R_DrawPlayerSprites+0x9b>\n82: \tnopw\t%cs:(%rax,%rax)\n8c: \tnopl\t(%rax)\n90: \taddl\t$1, %ebp\n93: \taddq\t$8, %rbx\n97: \tcmpl\t%ecx, %ebp\n99: \tjge\t0xb1 <R_DrawPlayerSprites+0xb1>\n9b: \tcmpq\t$0, (%rbx)\n9f: \tje\t0x90 <R_DrawPlayerSprites+0x90>\na1: \tmovq\t%rbx, %rdi\na4: \tcallq\t0xa9 <R_DrawPlayerSprites+0xa9>\na9: \tmovl\t(%rip), %ecx  # 0xaf <R_DrawPlayerSprites+0xaf>\naf: \tjmp\t0x90 <R_DrawPlayerSprites+0x90>\nb1: \taddq\t$8, %rsp\nb5: \tpopq\t%rbx\nb6: \tpopq\t%rbp\nb7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ state; } ;\ntypedef  TYPE_4__ pspdef_t ;\nstruct TYPE_11__ {TYPE_4__* psprites; TYPE_2__* mo; } ;\nstruct TYPE_9__ {TYPE_1__* sector; } ;\nstruct TYPE_8__ {TYPE_3__* subsector; } ;\nstruct TYPE_7__ {int lightlevel; } ;\n\n/* Variables and functions */\nint LIGHTLEVELS ;\nint LIGHTSEGSHIFT ;\nint NUMPSPRITES ;\nint /*<<< orphan*/  R_DrawPSprite (TYPE_4__*) ;\nint extralight ;\nint /*<<< orphan*/  mceilingclip ;\nint /*<<< orphan*/  mfloorclip ;\nint /*<<< orphan*/  negonearray ;\nint /*<<< orphan*/ * scalelight ;\nint /*<<< orphan*/  screenheightarray ;\nint /*<<< orphan*/  spritelights ;\nTYPE_5__* viewplayer ;\n\nvoid R_DrawPlayerSprites (void)\n{\nint\t\ti;\nint\t\tlightnum;\npspdef_t*\tpsp;\n\n// get light level\nlightnum =\n(viewplayer->mo->subsector->sector->lightlevel >> LIGHTSEGSHIFT)\n+extralight;\n\nif (lightnum < 0)\nspritelights = scalelight[0];\nelse if (lightnum >= LIGHTLEVELS)\nspritelights = scalelight[LIGHTLEVELS-1];\nelse\nspritelights = scalelight[lightnum];\n\n// clip to screen bounds\nmfloorclip = screenheightarray;\nmceilingclip = negonearray;\n\n// add all active psprites\nfor (i=0, psp=viewplayer->psprites;\ni<NUMPSPRITES;\ni++,psp++)\n{\nif (psp->state)\nR_DrawPSprite (psp);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_9__ {TYPE_1__* sprites; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DrawSprite (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite2 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite3 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite4 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite5 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite6 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite7 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite8 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite9 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite10 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite11 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite12 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite13 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite14 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite15 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite16 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite17 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite18 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite19 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite20 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite21 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite22 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite23 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite24 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite25 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite26 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite27 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite28 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite29 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite30 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite31 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite32 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite33 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite34 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite35 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite36 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite37 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite38 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite39 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite40 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite41 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite42 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite43 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite44 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite45 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite46 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite47 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite48 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite49 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite50 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite51 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite52 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite53 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite54 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite55 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite56 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite57 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite58 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite59 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite60 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite61 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite62 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite63 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite64 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite65 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite66 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite67 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite68 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite69 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite70 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite71 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite72 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite73 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite74 (TYPE_3__*) ;\nint /*<<< orphan*/  R_DrawSprite75 (TYPE_3__*) ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_FaceTarget",
    "input":"\n0000000000000000 <A_FaceTarget>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t8(%rdi), %rax\n7: \ttestq\t%rax, %rax\na: \tje\t0x52 <A_FaceTarget+0x52>\nc: \tmovq\t%rdi, %rbx\nf: \tmovl\t(%rip), %ecx  # 0x15 <A_FaceTarget+0x15>\n15: \tnotl\t%ecx\n17: \tandl\t%ecx, 24(%rdi)\n1a: \tmovl\t16(%rdi), %esi\n1d: \tmovl\t20(%rdi), %edi\n20: \tmovl\t4(%rax), %ecx\n23: \tmovl\t8(%rax), %edx\n26: \tcallq\t0x2b <A_FaceTarget+0x2b>\n2b: \tmovl\t%eax, (%rbx)\n2d: \tmovq\t8(%rbx), %rax\n31: \tmovl\t(%rip), %ecx  # 0x37 <A_FaceTarget+0x37>\n37: \ttestl\t%ecx, (%rax)\n39: \tje\t0x52 <A_FaceTarget+0x52>\n3b: \txorl\t%eax, %eax\n3d: \tcallq\t0x42 <A_FaceTarget+0x42>\n42: \tmovl\t%eax, %ebp\n44: \txorl\t%eax, %eax\n46: \tcallq\t0x4b <A_FaceTarget+0x4b>\n4b: \tsubl\t%eax, %ebp\n4d: \tshll\t$21, %ebp\n50: \taddl\t%ebp, (%rbx)\n52: \taddq\t$8, %rsp\n56: \tpopq\t%rbx\n57: \tpopq\t%rbp\n58: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int angle; TYPE_1__* target; int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_4__ {int flags; int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MF_AMBUSH ;\nint MF_SHADOW ;\nint P_Random () ;\nint R_PointToAngle2 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_FaceTarget (mobj_t* actor)\n{\nif (!actor->target)\nreturn;\n\nactor->flags &= ~MF_AMBUSH;\n\nactor->angle = R_PointToAngle2 (actor->x,\nactor->y,\nactor->target->x,\nactor->target->y);\n\nif (actor->target->flags & MF_SHADOW)\nactor->angle += (P_Random()-P_Random())<<21;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; int /*<<< orphan*/  y_off; int /*<<< orphan*/  x_off; } ;\nstruct TYPE_5__ {int flags; int /*<<< orphan*/  y; int /*<unknown>*/  x; } ;\ntypedef  TYPE_1__ Actor ;\ntypedef  TYPE_2__ Object ;\n\n/* Variables and functions */\nint ACTOR_FACE_TARGET ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnimOff (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnimOff_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B (TYPE_1__*,int /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_ForeignTranslation",
    "input":"\n0000000000000000 <ForeignTranslation>:\n0: \tmovl\t%edi, %eax\n2: \ttestb\t%al, %al\n4: \tjs\t0x13 <ForeignTranslation+0x13>\n6: \tmovq\t(%rip), %rcx  # 0xd <ForeignTranslation+0xd>\nd: \tmovzbl\t%al, %eax\n10: \tmovb\t(%rcx,%rax), %al\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* frenchKeyMap ;\n\nchar ForeignTranslation(unsigned char ch)\n{\nreturn ch < 128 ? frenchKeyMap[ch] : ch;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar const* ForeignTranslationTable ;\n\n__attribute__((used)) static const char *\nForeignTranslation(int code)\n{\nif (code < 0)\nreturn \"???\";\nelse\nreturn ForeignTranslationTable[code];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_twoSided",
    "input":"\n0000000000000000 <twoSided>:\n0: \tmovq\t(%rip), %rax  # 0x7 <twoSided+0x7>\n7: \tmovslq\t%edi, %rcx\na: \tmovq\t(%rax,%rcx,8), %rax\ne: \tmovslq\t%esi, %rcx\n11: \tmovq\t(%rax,%rcx,8), %rcx\n15: \tmovl\t(%rip), %eax  # 0x1b <twoSided+0x1b>\n1b: \tandl\t(%rcx), %eax\n1d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {TYPE_1__** lines; } ;\nstruct TYPE_3__ {int flags; } ;\n\n/* Variables and functions */\nint ML_TWOSIDED ;\nTYPE_2__* sectors ;\n\nint\ntwoSided\n( int\tsector,\nint\tline )\n{\nreturn (sectors[sector].lines[line])->flags & ML_TWOSIDED;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* flags; } ;\n\n/* Variables and functions */\nTYPE_1__* flags ;\nint FLAG_TWOSIDED ;\n\nint twoSided(int a, int b)\n{\nreturn flags[a].flags[b] & FLAG_TWOSIDED;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawNewGame",
    "input":"\n0000000000000000 <M_DrawNewGame>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <M_DrawNewGame+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <M_DrawNewGame+0x11>\n11: \tmovl\t$96, %edi\n16: \tmovl\t$14, %esi\n1b: \txorl\t%edx, %edx\n1d: \tmovl\t%eax, %ecx\n1f: \tcallq\t0x24 <M_DrawNewGame+0x24>\n24: \tmovl\t(%rip), %esi  # 0x2a <M_DrawNewGame+0x2a>\n2a: \tmovl\t$0, %edi\n2f: \tcallq\t0x34 <M_DrawNewGame+0x34>\n34: \tmovl\t$54, %edi\n39: \tmovl\t$38, %esi\n3e: \txorl\t%edx, %edx\n40: \tmovl\t%eax, %ecx\n42: \tpopq\t%rax\n43: \tjmp\t0x48 <M_DrawNewGame+0x48>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid M_DrawNewGame(void)\n{\nV_DrawPatchDirect (96,14,0,W_CacheLumpName(\"M_NEWG\",PU_CACHE));\nV_DrawPatchDirect (54,38,0,W_CacheLumpName(\"M_SKILL\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawString (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawStringCenter (int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  msg_newgame ;\nint /*<<< orphan*/  msg_newgame2 ;\n\nvoid M_DrawNewGame(void)\n{\nM_DrawStringCenter(96, 14, msg_newgame);\nM_DrawString(54, 38, msg_newgame2);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_SetThingPosition",
    "input":"\n0000000000000000 <P_SetThingPosition>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rdi), %edi\n6: \tmovl\t4(%rbx), %esi\n9: \tcallq\t0xe <P_SetThingPosition+0xe>\ne: \tmovq\t%rax, 48(%rbx)\n12: \tmovl\t8(%rbx), %ecx\n15: \ttestl\t%ecx, (%rip)  # 0x1b <P_SetThingPosition+0x1b>\n1b: \tje\t0x27 <P_SetThingPosition+0x27>\n1d: \ttestl\t%ecx, (%rip)  # 0x23 <P_SetThingPosition+0x23>\n23: \tje\t0x4d <P_SetThingPosition+0x4d>\n25: \tpopq\t%rbx\n26: \tretq\n27: \tmovq\t(%rax), %rax\n2a: \tmovq\t$0, 32(%rbx)\n32: \tmovq\t(%rax), %rdx\n35: \tmovq\t%rdx, 40(%rbx)\n39: \ttestq\t%rdx, %rdx\n3c: \tje\t0x42 <P_SetThingPosition+0x42>\n3e: \tmovq\t%rbx, 32(%rdx)\n42: \tmovq\t%rbx, (%rax)\n45: \ttestl\t%ecx, (%rip)  # 0x4b <P_SetThingPosition+0x4b>\n4b: \tjne\t0x25 <P_SetThingPosition+0x25>\n4d: \tmovl\t(%rbx), %eax\n4f: \tsubl\t(%rip), %eax  # 0x55 <P_SetThingPosition+0x55>\n55: \tmovb\t(%rip), %cl   # 0x5b <P_SetThingPosition+0x5b>\n5b: \tsarl\t%cl, %eax\n5d: \tmovl\t4(%rbx), %edx\n60: \tsubl\t(%rip), %edx  # 0x66 <P_SetThingPosition+0x66>\n66: \tsarl\t%cl, %edx\n68: \ttestl\t%eax, %eax\n6a: \tjs\t0xb4 <P_SetThingPosition+0xb4>\n6c: \ttestl\t%edx, %edx\n6e: \tjs\t0xb4 <P_SetThingPosition+0xb4>\n70: \tmovl\t(%rip), %esi  # 0x76 <P_SetThingPosition+0x76>\n76: \tcmpl\t%esi, %eax\n78: \tjge\t0xb4 <P_SetThingPosition+0xb4>\n7a: \tcmpl\t(%rip), %edx  # 0x80 <P_SetThingPosition+0x80>\n80: \tjge\t0xb4 <P_SetThingPosition+0xb4>\n82: \tmovq\t(%rip), %rcx  # 0x89 <P_SetThingPosition+0x89>\n89: \timull\t%edx, %esi\n8c: \taddl\t%eax, %esi\n8e: \tmovslq\t%esi, %rax\n91: \tmovq\t$0, 16(%rbx)\n99: \tmovq\t(%rcx,%rax,8), %rdx\n9d: \tmovq\t%rdx, 24(%rbx)\na1: \tmovq\t(%rcx,%rax,8), %rdx\na5: \ttestq\t%rdx, %rdx\na8: \tje\t0xae <P_SetThingPosition+0xae>\naa: \tmovq\t%rbx, 16(%rdx)\nae: \tmovq\t%rbx, (%rcx,%rax,8)\nb2: \tpopq\t%rbx\nb3: \tretq\nb4: \txorps\t%xmm0, %xmm0\nb7: \tmovups\t%xmm0, 16(%rbx)\nbb: \tpopq\t%rbx\nbc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {TYPE_2__* sector; } ;\ntypedef  TYPE_1__ subsector_t ;\nstruct TYPE_8__ {TYPE_3__* thinglist; } ;\ntypedef  TYPE_2__ sector_t ;\nstruct TYPE_9__ {int x; int y; int flags; struct TYPE_9__* bprev; struct TYPE_9__* bnext; struct TYPE_9__* sprev; struct TYPE_9__* snext; TYPE_1__* subsector; } ;\ntypedef  TYPE_3__ mobj_t ;\n\n/* Variables and functions */\nint MAPBLOCKSHIFT ;\nint MF_NOBLOCKMAP ;\nint MF_NOSECTOR ;\nTYPE_1__* R_PointInSubsector (int,int) ;\nTYPE_3__** blocklinks ;\nint bmapheight ;\nint bmaporgx ;\nint bmaporgy ;\nint bmapwidth ;\n\nvoid\nP_SetThingPosition (mobj_t* thing)\n{\nsubsector_t*\tss;\nsector_t*\t\tsec;\nint\t\t\tblockx;\nint\t\t\tblocky;\nmobj_t**\t\tlink;\n\n\n// link into subsector\nss = R_PointInSubsector (thing->x,thing->y);\nthing->subsector = ss;\n\nif ( ! (thing->flags & MF_NOSECTOR) )\n{\n// invisible things don't go into the sector links\nsec = ss->sector;\n\nthing->sprev = NULL;\nthing->snext = sec->thinglist;\n\nif (sec->thinglist)\nsec->thinglist->sprev = thing;\n\nsec->thinglist = thing;\n}\n\n\n// link into blockmap\nif ( ! (thing->flags & MF_NOBLOCKMAP) )\n{\n// inert things don't need to be in blockmap\nblockx = (thing->x - bmaporgx)>>MAPBLOCKSHIFT;\nblocky = (thing->y - bmaporgy)>>MAPBLOCKSHIFT;\n\nif (blockx>=0\n&& blockx < bmapwidth\n&& blocky>=0\n&& blocky < bmapheight)\n{\nlink = &blocklinks[blocky*bmapwidth+blockx];\nthing->bprev = NULL;\nthing->bnext = *link;\nif (*link)\n(*link)->bprev = thing;\n\n*link = thing;\n}\nelse\n{\n// thing is off the map\nthing->bnext = thing->bprev = NULL;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int x; int y; int flags; TYPE_2__* floorz; TYPE_2__* ceilingz; TYPE_2__* nextthink; TYPE_2__* prevthink; } ;\nstruct TYPE_9__ {TYPE_1__* nextsector; } ;\nstruct TYPE_8__ {TYPE_3__* thing; } ;\ntypedef  TYPE_3__ thing_t ;\ntypedef  TYPE_2__ sector_t ;\n\n/* Variables and functions */\nint TH_TELEPORT ;\nint TH_TRAVERSE ;\nint TH_Z ;\nint TH_Z_INVERTED ;\nint TH_Z_NO_EFFECT ;\nint TH_Z_RESET ;\nint TH_Z_SET ;\nint TH_Z_UNSET ;\nint TH_Z_UNSET_INVERTED ;\nint TH_Z_UNSET_NO_EFFECT ;\nint TH_Z_UNSET_RESET ;\nint abs (int) ;\nint /*<<< orphan*/  floor_z ;\nint /*<<< orphan*/  sector_t_cmp ;\nTYPE_2__** sectors ;\nTYPE_2__* sector_t_find (int,int) ;\n\nvoid P_SetThingPosition(thing_t *thing)\n{\nsector_t *sec;\n\nsec = sector_t_find(thing->x, thing->y);\nthing->floorz = sec;\nthing->ceilingz = sec;\n\nif (thing->flags & TH_TELEPORT)\n{\nthing->nextthink = NULL;\nthing->prevthink = NULL;\n}\nelse if (thing->flags & TH_TRAVERSE)\n{\nthing->nextthink = NULL;\nthing->prevthink = NULL;\n}\nelse\n{\nint fz = abs(thing->x - floor_z);\nint cz = abs(thing->y - floor_z);\n\nif (fz >= TH_Z_SET || cz >= TH_Z_SET)\n{\nthing->floorz = NULL;\nthing->ceilingz = NULL;\n}\nelse\n{\nthing->floorz = sectors[fz * cz];\nthing->ceilingz = sectors[fz * cz + 1];\n\nif (thing->floorz)\nthing->floorz->nextsector = thing;\n\nif (thing->ceilingz)\nthing->ceilingz->nextsector = thing;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_StartControlPanel",
    "input":"\n0000000000000000 <M_StartControlPanel>:\n0: \tcmpl\t$0, (%rip)    # 0x7 <M_StartControlPanel+0x7>\n7: \tje\t0xa <M_StartControlPanel+0xa>\n9: \tretq\na: \tmovl\t$1, (%rip)    # 0x14 <M_StartControlPanel+0x14>\n14: \tmovq\t$0, (%rip)    # 0x1f <M_StartControlPanel+0x1f>\n1f: \tmovl\t(%rip), %eax  # 0x25 <M_StartControlPanel+0x25>\n25: \tmovl\t%eax, (%rip)  # 0x2b <M_StartControlPanel+0x2b>\n2b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  lastOn; } ;\n\n/* Variables and functions */\nTYPE_1__ MainDef ;\nTYPE_1__* currentMenu ;\nint /*<<< orphan*/  itemOn ;\nint menuactive ;\n\nvoid M_StartControlPanel (void)\n{\n// intro might call this repeatedly\nif (menuactive)\nreturn;\n\nmenuactive = 1;\ncurrentMenu = &MainDef;         // JDC\nitemOn = currentMenu->lastOn;   // JDC\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_StartControlPanel_ ;\nint /*<<< orphan*/  M_StartControlPanel_C ;\nint /*<<< orphan*/ * M_StartControlPanel_D ;\nint /*<<< orphan*/  M_StartControlPanel_E ;\nint /*<<< orphan*/  M_StartControlPanel_F ;\nint /*<<< orphan*/  M_StartControlPanel_G ;\nint /*<<< orphan*/  M_StartControlPanel_H ;\nint /*<<< orphan*/  M_StartControlPanel_I ;\nint /*<<< orphan*/  M_StartControlPanel_J ;\nint /*<<< orphan*/  M_StartControlPanel_K ;\nint /*<<< orphan*/  M_StartControlPanel_L ;\nint /*<<< orphan*/  M_StartControlPanel_M ;\nint /*<<< orphan*/  M_StartControlPanel_N ;\nint /*<<< orphan*/  M_StartControlPanel_O ;\nint /*<<< orphan*/  M_StartControlPanel_P ;\nint /*<<< orphan*/  M_StartControlPanel_Q ;\nint /*<<< orphan*/  M_StartControlPanel_R ;\nint /*<<< orphan*/  M_StartControlPanel_S ;\nint /*<<< orphan*/  M_StartControlPanel_T ;\nint /*<<< orphan*/  M_StartControlPanel_U ;\nint /*<<< orphan*/  M_StartControlPanel_V ;\nint /*<<< orphan*/  M_StartControlPanel_W ;\nint /*<<< orphan*/  M_StartControlPanel_X ;\nint /*<<< orphan*/  M_StartControlPanel_Y ;\nint /*<<< orphan*/  M_StartControlPanel_Z ;\nint /*<<< orphan*/  M_StartControlPanel_a ;\nint /*<<< orphan*/  M_StartControlPanel_b ;\nint /*<<< orphan*/  M_StartControlPanel_c ;\nint /*<<< orphan*/  M_StartControlPanel_d ;\nint /*<<< orphan*/  M_StartControlPanel_e ;\nint /*<<< orphan*/  M_StartControlPanel_f ;\nint /*<<< orphan*/  M_StartControlPanel_g ;\nint /*<<< orphan*/  M_StartControlPanel_h ;\nint /*<<< orphan*/  M_StartControlPanel_i ;\nint /*<<< orphan*/  M_StartControlPanel_j ;\nint /*<<< orphan*/  M_StartControlPanel_k ;\nint /*<<< orphan*/  M_StartControlPanel_l ;\nint /*<<< orphan*/  M_StartControlPanel_m ;\nint /*<<< orphan*/  M_StartControlPanel_n ;\nint /*<<< orphan*/  M_StartControlPanel_o ;\nint /*<<< orphan*/  M_StartControlPanel_p ;\nint /*<<< orphan*/  M_StartControlPanel_q ;\nint /*<<< orphan*/  M_StartControlPanel_r ;\nint /*<<< orphan*/  M_StartControlPanel_s ;\nint /*<<< orphan*/  M_StartControlPanel_t ;\nint /*<<< orphan*/  M_StartControlPanel_u ;\nint /*<<< orphan*/  M_StartControlPanel_v ;\nint /*<<< orphan*/  M_StartControlPanel_w ;\nint /*<<< orphan*/  M_StartControlPanel_x ;\nint /*<<< orphan*/  M_StartControlPanel_y ;\nint /*<<< orphan*/  M_StartControlPanel_z ;\nint /*<<< orphan*/  M_StartControlPanel_A ;\nint /*<<< orphan*/  M_StartControlPanel_B ;\nint /*<<< orphan*/  M_StartControlPanel_C ;\nint /*<<< orphan*/  M_StartControlPanel_D ;\nint /*<<< orphan*/  M_StartControlPanel_E ;\nint /*<<< orphan*/  M_StartControlPanel_F ;\nint /*<<< orphan*/  M_StartControlPanel_G ;\nint /*<<< orphan*/  M_StartControlPanel_H ;\nint /*<<< orphan*/  M_StartControlPanel_I ;\nint /*<<< orphan*/  M_StartControlPanel_J ;\nint /*<<< orphan*/  M_StartControlPanel_K ;\nint /*<<< orphan*/  M_StartControlPanel_L ;\nint /*<<< orphan*/  M_StartControlPanel_M ;\nint /*<<< orphan*/  M_StartControlPanel_N ;\nint /*<<< orphan*/  M_StartControlPanel_O ;\nint /*<<< orphan*/  M_StartControlPanel_P ;\nint /*<<< orphan*/  M_StartControlPanel_Q ;\nint /*<<< orphan*/  M_StartControlPanel_R ;\nint /*<<< orphan*/  M_StartControlPanel_S ;\nint /*<<< orphan*/  M_StartControlPanel_T ;\nint /*<<< orphan*/  M_StartControlPanel_U ;\nint /*<<< orphan*/  M_StartControlPanel_V ;\nint /*<<< orphan*/  M_StartControlPanel_W ;\nint /*<<< orphan*/  M_StartControlPanel_X ;\nint /*<<< orphan*/  M_StartControlPanel_Y ;\nint /*<<< orphan*/  M_StartControlPanel_Z ;\nint /*<<< orphan*/  M_StartControlPanel_a ;\nint /*<<< orphan*/  M_StartControlPanel_b ;\nint /*<<< orphan*/  M_StartControlPanel_c ;\nint /*<<< orphan*/  M_StartControlPanel_d ;\nint /*<<< orphan*/  M_StartControlPanel_e ;\nint /*<<< orphan*/  M_StartControlPanel_f ;\nint /*<<< orphan*/  M_StartControlPanel_g ;\nint /*<<< orphan*/  M_StartControlPanel_h ;\nint /*<<< orphan*/  M_StartControlPanel_i ;\nint /*<<< orphan*/  M_StartControlPanel_j ;\nint /*<<< orphan*/  M_StartControlPanel_k ;\nint /*<<< orphan*/  M_StartControlPanel_l ;\nint /*<<< orphan*/  M_StartControlPanel_m ;\nint /*<<< orphan*/  M_StartControlPanel_n ;\nint /*<<< orphan*/  M_StartControlPanel_o ;\nint /*<<< orphan*/  M_StartControlPanel_p ;\nint /*<<< orphan*/  M_StartControlPanel_q ;\nint /*<<< orphan*/  M_StartControlPanel_r ;\nint /*<<< orphan*/  M_StartControlPanel_s ;\nint /*<<< orphan*/  M_StartControlPanel_t ;\nint /*<<< orphan*/  M_StartControlPanel_u ;\nint /*<<< orphan*/  M_StartControlPanel_v ;\nint /*<<< orphan*/  M_StartControlPanel_w ;\nint /*<<< orphan*/  M_StartControlPanel_x ;\nint /*<<< orphan*/  M_StartControlPanel_y ;\nint /*<<< orphan*/  M_StartControlPanel_z ;\nint /*<<< orphan*/  M_StartControlPanel_A ;\nint /*<<< orphan*/  M_StartControlPanel_B ;\nint /*<<< orphan*/  M_StartControlPanel_C ;\nint /*<<< orphan*/  M_StartControlPanel_D ;\nint /*<<< orphan*/  M_StartControlPanel_E ;\nint /*<<< orphan*/  M_StartControlPanel_F ;\nint /*<<< orphan*/  M_StartControlPanel_G ;\nint /*<<< orphan*/  M_StartControlPanel_H ;\nint /*<<< orphan*/  M_StartControlPanel_I ;\nint /*<<< orphan*/  M_StartControl"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_Pain",
    "input":"\n0000000000000000 <A_Pain>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t(%rax), %rsi\n6: \ttestq\t%rsi, %rsi\n9: \tje\t0x10 <A_Pain+0x10>\nb: \tjmp\t0x10 <A_Pain+0x10>\n10: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {TYPE_1__* info; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_5__ {scalar_t__ painsound; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (TYPE_2__*,scalar_t__) ;\n\nvoid A_Pain (mobj_t* actor)\n{\nif (actor->info->painsound)\nS_StartSound (actor, actor->info->painsound);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_1__* actor; } ;\nstruct TYPE_4__ {scalar_t__* extra; } ;\ntypedef  TYPE_2__ m68k_struct ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Pain_Boss (TYPE_2__*,scalar_t__) ;\n\n__attribute__((used)) static void A_Pain(m68k_struct *ms)\n{\nif (ms->actor->extra[0])\nA_Pain_Boss(ms, ms->actor->extra[0]);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_LevelInit",
    "input":"\n0000000000000000 <AM_LevelInit>:\n0: \tpushq\t%rax\n1: \tmovq\t$0, (%rip)    # 0xc <AM_LevelInit+0xc>\nc: \tmovq\t$0, (%rip)    # 0x17 <AM_LevelInit+0x17>\n17: \tmovq\t$0, (%rip)    # 0x22 <AM_LevelInit+0x22>\n22: \tmovl\t(%rip), %eax  # 0x28 <AM_LevelInit+0x28>\n28: \tmovl\t%eax, (%rip)  # 0x2e <AM_LevelInit+0x2e>\n2e: \tmovl\t(%rip), %eax  # 0x34 <AM_LevelInit+0x34>\n34: \tmovl\t%eax, (%rip)  # 0x3a <AM_LevelInit+0x3a>\n3a: \txorl\t%eax, %eax\n3c: \tcallq\t0x41 <AM_LevelInit+0x41>\n41: \txorl\t%eax, %eax\n43: \tcallq\t0x48 <AM_LevelInit+0x48>\n48: \tmovsd\t(%rip), %xmm0 # xmm0 = mem[0],zero\n# 0x50 <AM_LevelInit+0x50>\n50: \tmovsd\t(%rip), %xmm1 # xmm1 = mem[0],zero\n# 0x58 <AM_LevelInit+0x58>\n58: \tmulsd\t(%rip), %xmm1 # 0x60 <AM_LevelInit+0x60>\n60: \tcvttsd2si\t%xmm1, %edi\n64: \tcallq\t0x69 <AM_LevelInit+0x69>\n69: \tmovl\t%eax, (%rip)  # 0x6f <AM_LevelInit+0x6f>\n6f: \tcmpl\t%eax, (%rip)  # 0x75 <AM_LevelInit+0x75>\n75: \tjge\t0x85 <AM_LevelInit+0x85>\n77: \tcvttsd2si\t(%rip), %eax    # 0x7f <AM_LevelInit+0x7f>\n7f: \tmovl\t%eax, (%rip)  # 0x85 <AM_LevelInit+0x85>\n85: \tmovsd\t(%rip), %xmm0 # xmm0 = mem[0],zero\n# 0x8d <AM_LevelInit+0x8d>\n8d: \tmovl\t%eax, %edi\n8f: \tcallq\t0x94 <AM_LevelInit+0x94>\n94: \tmovq\t%rax, (%rip)  # 0x9b <AM_LevelInit+0x9b>\n9b: \tpopq\t%rax\n9c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_clearMarks () ;\nint /*<<< orphan*/  AM_findMinMaxBoundaries () ;\ndouble FRACUNIT ;\nvoid* FixedDiv (double,int) ;\nint /*<<< orphan*/  f_h ;\nint /*<<< orphan*/  f_w ;\nscalar_t__ f_x ;\nscalar_t__ f_y ;\nint /*<<< orphan*/  finit_height ;\nint /*<<< orphan*/  finit_width ;\nscalar_t__ leveljuststarted ;\nint max_scale_mtof ;\ndouble min_scale_mtof ;\nvoid* scale_ftom ;\nint scale_mtof ;\n\nvoid AM_LevelInit(void)\n{\nleveljuststarted = 0;\n\nf_x = f_y = 0;\nf_w = finit_width;\nf_h = finit_height;\n\nAM_clearMarks();\n\nAM_findMinMaxBoundaries();\nscale_mtof = FixedDiv(min_scale_mtof, (int) (0.7*FRACUNIT));\nif (scale_mtof > max_scale_mtof)\nscale_mtof = min_scale_mtof;\nscale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_LevelInit_1 () ;\nint /*<<< orphan*/  AM_LevelInit_2 () ;\nint /*<<< orphan*/  AM_LevelInit_3 () ;\nint /*<<< orphan*/  AM_LevelInit_4 () ;\nint /*<<< orphan*/  AM_LevelInit_5 () ;\nint /*<<< orphan*/  AM_LevelInit_6 () ;\nint /*<<< orphan*/  AM_LevelInit_7 () ;\nint /*<<< orphan*/  AM_LevelInit_8 () ;\nint /*<<< orphan*/  AM_LevelInit_9 () ;\nint /*<<< orphan*/  AM_LevelInit_10 () ;\nint /*<<< orphan*/  AM_LevelInit_11 () ;\nint /*<<< orphan*/  AM_LevelInit_12 () ;\nint /*<<< orphan*/  AM_LevelInit_13 () ;\nint /*<<< orphan*/  AM_LevelInit_14 () ;\nint /*<<< orphan*/  AM_LevelInit_15 () ;\nint /*<<< orphan*/  AM_LevelInit_16 () ;\nint /*<<< orphan*/  AM_LevelInit_17 () ;\nint /*<<< orphan*/  AM_LevelInit_18 () ;\nint /*<<< orphan*/  AM_LevelInit_19 () ;\nint /*<<< orphan*/  AM_LevelInit_20 () ;\nint /*<<< orphan*/  AM_LevelInit_21 () ;\nint /*<<< orphan*/  AM_LevelInit_22 () ;\nint /*<<< orphan*/  AM_LevelInit_23 () ;\nint /*<<< orphan*/  AM_LevelInit_24 () ;\nint /*<<< orphan*/  AM_LevelInit_25 () ;\nint /*<<< orphan*/  AM_LevelInit_26 () ;\nint /*<<< orphan*/  AM_LevelInit_27 () ;\nint /*<<< orphan*/  AM_LevelInit_28 () ;\nint /*<<< orphan*/  AM_LevelInit_29 () ;\nint /*<<< orphan*/  AM_LevelInit_30 () ;\nint /*<<< orphan*/  AM_LevelInit_31 () ;\nint /*<<< orphan*/  AM_LevelInit_32 () ;\nint /*<<< orphan*/  AM_LevelInit_33 () ;\nint /*<<< orphan*/  AM_LevelInit_34 () ;\nint /*<<< orphan*/  AM_LevelInit_35 () ;\nint /*<<< orphan*/  AM_LevelInit_36 () ;\nint /*<<< orphan*/  AM_LevelInit_37 () ;\nint /*<<< orphan*/  AM_LevelInit_38 () ;\nint /*<<< orphan*/  AM_LevelInit_39 () ;\nint /*<<< orphan*/  AM_LevelInit_40 () ;\nint /*<<< orphan*/  AM_LevelInit_41 () ;\nint /*<<< orphan*/  AM_LevelInit_42 () ;\nint /*<<< orphan*/  AM_LevelInit_43 () ;\nint /*<<< orphan*/  AM_LevelInit_44 () ;\nint /*<<< orphan*/  AM_LevelInit_45 () ;\nint /*<<< orphan*/  AM_LevelInit_46 () ;\nint /*<<< orphan*/  AM_LevelInit_47 () ;\nint /*<<< orphan*/  AM_LevelInit_48 () ;\nint /*<<< orphan*/  AM_LevelInit_49 () ;\nint /*<<< orphan*/  AM_LevelInit_50 () ;\nint /*<<< orphan*/  AM_LevelInit_51 () ;\nint /*<<< orphan*/  AM_LevelInit_52 () ;\nint /*<<< orphan*/  AM_LevelInit_53 () ;\nint /*<<< orphan*/  AM_LevelInit_54 () ;\nint /*<<< orphan*/  AM_LevelInit_55 () ;\nint /*<<< orphan*/  AM_LevelInit_56 () ;\nint /*<<< orphan*/  AM_LevelInit_57 () ;\nint /*<<< orphan*/  AM_LevelInit_58 () ;\nint /*<<< orphan*/  AM_LevelInit_59 () ;\nint /*<<< orphan*/  AM_LevelInit_60 () ;\nint /*<<< orphan*/  AM_LevelInit_61 () ;\nint /*<<< orphan*/  AM_LevelInit_62 () ;\nint /*<<< orphan*/  AM_LevelInit_63 () ;\nint /*<<< orphan*/  AM_LevelInit_64 () ;\nint /*<<< orphan*/  AM_LevelInit_65 () ;\nint /*<<< orphan*/  AM_LevelInit_66 () ;\nint /*<<< orphan*/  AM_LevelInit_67 () ;\nint /*<<< orphan*/  AM_LevelInit_68 () ;\nint /*<<< orphan*/  AM_LevelInit_69 () ;\nint /*<<< orphan*/  AM_LevelInit_70 () ;\nint /*<<< orphan*/  AM_LevelInit_71 () ;\nint /*<<< orphan*/  AM_LevelInit_72 () ;\nint /*<<< orphan*/  AM_LevelInit_73 () ;\nint /*<<< orphan*/  AM_LevelInit_74 () ;\nint /*<<< orphan*/  AM_LevelInit_75 () ;\nint /*<<< orphan*/  AM_LevelInit_76 () ;\nint /*<<< orphan*/  AM_LevelInit_77 () ;\nint /*<<< orphan*/  AM_LevelInit_78 () ;\nint /*<<< orphan*/  AM_LevelInit_79 () ;\nint /*<<< orphan*/  AM_LevelInit_80 () ;\nint /*<<< orphan*/  AM_LevelInit_81 () ;\nint /*<<< orphan*/  AM_LevelInit_82 () ;\nint /*<<< orphan*/  AM_LevelInit_83 () ;\nint /*<<< orphan*/  AM_LevelInit_84 () ;\nint /*<<< orphan*/  AM_LevelInit_85 () ;\nint /*<<< orphan*/  AM_LevelInit_86 () ;\nint /*<<< orphan*/  AM_LevelInit_87 () ;\nint /*<<< orphan*/  AM_LevelInit_88 () ;\nint /*<<< orphan*/  AM_LevelInit_89 () ;\nint /*<<< orphan*/  AM_LevelInit_90 () ;\nint /*<<< orphan*/  AM_LevelInit_91 () ;\nint /*<<< orphan*/  AM_LevelInit_92 () ;\nint /*<<< orphan*/  AM_LevelInit_93 () ;\nint /*<<< orphan*/  AM_LevelInit_94 () ;\nint /*<<< orphan*/  AM_LevelInit_95 () ;\nint /*<<< orphan*/  AM_LevelInit_96 () ;\nint /*<<< orphan*/  AM_LevelInit_97 () ;\nint /*<<< orphan*/  AM_LevelInit_98 () ;\nint /*<<< orphan*/  AM_LevelInit_99 () ;\nint /*<<< orphan*/  AM_LevelInit_100 () ;\nint /*<<< orphan*/  AM_LevelInit_101 () ;\nint /*<<< orphan*/  AM_LevelInit_102 () ;\nint /*<<< orphan*/  AM_LevelInit_103 () ;\nint /*<<< orphan*/  AM_LevelInit_104 () ;\nint /*<<< orphan*/  AM_LevelInit_105 () ;\nint /*<<< orphan*/  AM_LevelInit_106 () ;\nint /*<<< orphan*/  AM_LevelInit_107 () ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_ShootSpecialLine",
    "input":"\n0000000000000000 <P_ShootSpecialLine>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tcmpl\t$0, (%rdi)\n7: \tmovl\t(%rsi), %eax\n9: \tje\t0x2a <P_ShootSpecialLine+0x2a>\nb: \tcmpl\t$47, %eax\ne: \tje\t0x4d <P_ShootSpecialLine+0x4d>\n10: \tcmpl\t$46, %eax\n13: \tje\t0x2f <P_ShootSpecialLine+0x2f>\n15: \tcmpl\t$24, %eax\n18: \tjne\t0x4b <P_ShootSpecialLine+0x4b>\n1a: \tmovl\t(%rip), %esi  # 0x20 <P_ShootSpecialLine+0x20>\n20: \tmovq\t%rbx, %rdi\n23: \tcallq\t0x28 <P_ShootSpecialLine+0x28>\n28: \tjmp\t0x5d <P_ShootSpecialLine+0x5d>\n2a: \tcmpl\t$46, %eax\n2d: \tjne\t0x4b <P_ShootSpecialLine+0x4b>\n2f: \tmovl\t(%rip), %esi  # 0x35 <P_ShootSpecialLine+0x35>\n35: \tmovq\t%rbx, %rdi\n38: \tcallq\t0x3d <P_ShootSpecialLine+0x3d>\n3d: \tmovq\t%rbx, %rdi\n40: \tmovl\t$1, %esi\n45: \tpopq\t%rbx\n46: \tjmp\t0x4b <P_ShootSpecialLine+0x4b>\n4b: \tpopq\t%rbx\n4c: \tretq\n4d: \tmovl\t(%rip), %esi  # 0x53 <P_ShootSpecialLine+0x53>\n53: \tmovq\t%rbx, %rdi\n56: \txorl\t%edx, %edx\n58: \tcallq\t0x5d <P_ShootSpecialLine+0x5d>\n5d: \tmovq\t%rbx, %rdi\n60: \txorl\t%esi, %esi\n62: \tpopq\t%rbx\n63: \tjmp\t0x68 <P_ShootSpecialLine+0x68>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  player; } ;\ntypedef  TYPE_1__ mobj_t ;\nstruct TYPE_10__ {int special; } ;\ntypedef  TYPE_2__ line_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EV_DoDoor (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  EV_DoFloor (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  EV_DoPlat (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_ChangeSwitchTexture (TYPE_2__*,int) ;\nint /*<<< orphan*/  open ;\nint /*<<< orphan*/  raiseFloor ;\nint /*<<< orphan*/  raiseToNearestAndChange ;\n\nvoid\nP_ShootSpecialLine\n( mobj_t*\tthing,\nline_t*\tline )\n{\nint\t\tok;\n\n//\tImpacts that other things can activate.\nif (!thing->player)\n{\nok = 0;\nswitch(line->special)\n{\ncase 46:\n// OPEN DOOR IMPACT\nok = 1;\nbreak;\n}\nif (!ok)\nreturn;\n}\n\nswitch(line->special)\n{\ncase 24:\n// RAISE FLOOR\nEV_DoFloor(line,raiseFloor);\nP_ChangeSwitchTexture(line,0);\nbreak;\n\ncase 46:\n// OPEN DOOR\nEV_DoDoor(line,open);\nP_ChangeSwitchTexture(line,1);\nbreak;\n\ncase 47:\n// RAISE FLOOR NEAR AND CHANGE\nEV_DoPlat(line,raiseToNearestAndChange,0);\nP_ChangeSwitchTexture(line,0);\nbreak;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  bSpecial; } ;\ntypedef  TYPE_1__ Parser ;\ntypedef  int /*<<< orphan*/  BOOLEAN ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_ShootLine (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_ShootLine_NoCheck (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_ShootLine_NoCheck_NoCheck (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  bSpecial ;\n\nvoid P_ShootSpecialLine(Parser *p, BOOLEAN bCheck)\n{\nif (p->bSpecial)\n{\nswitch (p->bSpecial)\n{\ncase 47:\nP_ShootLine_NoCheck(p, TRUE);\nbreak;\ncase 46:\nP_ShootLine_NoCheck(p, FALSE);\nbreak;\ncase 24:\nP_ShootLine_NoCheck_NoCheck(p, bSpecial, 0);\nbreak;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_init",
    "input":"\n0000000000000000 <HUlib_init>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid HUlib_init(void)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid HUlib_init(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_setup.c_P_Init",
    "input":"\n0000000000000000 <P_Init>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <P_Init+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <P_Init+0xf>\nf: \tmovl\t(%rip), %edi  # 0x15 <P_Init+0x15>\n15: \tpopq\t%rax\n16: \tjmp\t0x1b <P_Init+0x1b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  P_InitPicAnims () ;\nint /*<<< orphan*/  P_InitSwitchList () ;\nint /*<<< orphan*/  R_InitSprites (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sprnames ;\n\nvoid P_Init (void)\n{\nP_InitSwitchList ();\nP_InitPicAnims ();\nR_InitSprites (sprnames);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  P_Init_P () ;\nint /*<<< orphan*/  P_Init_R () ;\nint /*<<< orphan*/  P_Init_S () ;\nint /*<<< orphan*/  P_Init_T () ;\nint /*<<< orphan*/  P_Init_U () ;\nint /*<<< orphan*/  P_Init_V () ;\nint /*<<< orphan*/  P_Init_W () ;\nint /*<<< orphan*/  P_Init_X () ;\nint /*<<< orphan*/  P_Init_Y () ;\nint /*<<< orphan*/  P_Init_Z () ;\nint /*<<< orphan*/  P_Init_a () ;\nint /*<<< orphan*/  P_Init_b () ;\nint /*<<< orphan*/  P_Init_c () ;\nint /*<<< orphan*/  P_Init_d () ;\nint /*<<< orphan*/  P_Init_e () ;\nint /*<<< orphan*/  P_Init_f () ;\nint /*<<< orphan*/  P_Init_g () ;\nint /*<<< orphan*/  P_Init_h () ;\nint /*<<< orphan*/  P_Init_i () ;\nint /*<<< orphan*/  P_Init_j () ;\nint /*<<< orphan*/  P_Init_k () ;\nint /*<<< orphan*/  P_Init_l () ;\nint /*<<< orphan*/  P_Init_m () ;\nint /*<<< orphan*/  P_Init_n () ;\nint /*<<< orphan*/  P_Init_o () ;\nint /*<<< orphan*/  P_Init_p () ;\nint /*<<< orphan*/  P_Init_q () ;\nint /*<<< orphan*/  P_Init_r () ;\nint /*<<< orphan*/  P_Init_s () ;\nint /*<<< orphan*/  P_Init_t () ;\nint /*<<< orphan*/  P_Init_u () ;\nint /*<<< orphan*/  P_Init_v () ;\nint /*<<< orphan*/  P_Init_w () ;\nint /*<<< orphan*/  P_Init_x () ;\nint /*<<< orphan*/  P_Init_y () ;\nint /*<<< orphan*/  P_Init_z () ;\n\nvoid P_Init(void)\n{\nP_Init_a();\nP_Init_b();\nP_Init_c();\nP_Init_d();\nP_Init_e();\nP_Init_f();\nP_Init_g();\nP_Init_h();\nP_Init_i();\nP_Init_j();\nP_Init_k();\nP_Init_l();\nP_Init_m();\nP_Init_n();\nP_Init_o();\nP_Init_p();\nP_Init_q();\nP_Init_r();\nP_Init_s();\nP_Init_t();\nP_Init_u();\nP_Init_v();\nP_Init_w();\nP_Init_x();\nP_Init_y();\nP_Init_z();\nP_Init_A();\nP_Init_B();\nP_Init_C();\nP_Init_D();\nP_Init_E();\nP_Init_F();\nP_Init_G();\nP_Init_H();\nP_Init_I();\nP_Init_J();\nP_Init_K();\nP_Init_L();\nP_Init_M();\nP_Init_N();\nP_Init_O();\nP_Init_P();\nP_Init_Q();\nP_Init_R();\nP_Init_S();\nP_Init_T();\nP_Init_U();\nP_Init_V();\nP_Init_W();\nP_Init_X();\nP_Init_Y();\nP_Init_Z();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_WaitVBL",
    "input":"\n0000000000000000 <I_WaitVBL>:\n0: \timull\t$14285, %edi, %edi # imm = 0x37CD\n6: \tjmp\t0xb <I_WaitVBL+0xb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  sginap (int) ;\nint /*<<< orphan*/  sleep (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  usleep (int) ;\n\nvoid I_WaitVBL(int count)\n{\n#ifdef SGI\nsginap(1);\n#else\n#ifdef SUN\nsleep(0);\n#else\nusleep (count * (1000000/70) );\n#endif\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_WaitVBL_NoInt (int) ;\n\nvoid I_WaitVBL(int count)\n{\nI_WaitVBL_NoInt(count*14285);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_I_ShutdownGraphics",
    "input":"\n0000000000000000 <I_ShutdownGraphics>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %edi  # 0x7 <I_ShutdownGraphics+0x7>\n7: \tmovl\t$0, %esi\nc: \tcallq\t0x11 <I_ShutdownGraphics+0x11>\n11: \ttestl\t%eax, %eax\n13: \tjne\t0x1f <I_ShutdownGraphics+0x1f>\n15: \tmovl\t$0, %edi\n1a: \tcallq\t0x1f <I_ShutdownGraphics+0x1f>\n1f: \tmovl\t(%rip), %edi  # 0x25 <I_ShutdownGraphics+0x25>\n25: \tcallq\t0x2a <I_ShutdownGraphics+0x2a>\n2a: \tmovl\t(%rip), %edi  # 0x30 <I_ShutdownGraphics+0x30>\n30: \tmovl\t(%rip), %esi  # 0x36 <I_ShutdownGraphics+0x36>\n36: \txorl\t%edx, %edx\n38: \tcallq\t0x3d <I_ShutdownGraphics+0x3d>\n3d: \tmovq\t(%rip), %rax  # 0x44 <I_ShutdownGraphics+0x44>\n44: \tmovq\t$0, (%rax)\n4b: \tpopq\t%rax\n4c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  shmid; int /*<<< orphan*/  shmaddr; } ;\nstruct TYPE_4__ {int /*<<< orphan*/ * data; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  IPC_RMID ;\nint /*<<< orphan*/  I_Error (char*) ;\nint /*<<< orphan*/  XShmDetach (int /*<<< orphan*/ ,TYPE_2__*) ;\nint /*<<< orphan*/  X_display ;\nTYPE_2__ X_shminfo ;\nTYPE_1__* image ;\nint /*<<< orphan*/  shmctl (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  shmdt (int /*<<< orphan*/ ) ;\n\nvoid I_ShutdownGraphics(void)\n{\n// Detach from X server\nif (!XShmDetach(X_display, &X_shminfo))\nI_Error(\"XShmDetach() failed in I_ShutdownGraphics()\");\n\n// Release shared memory.\nshmdt(X_shminfo.shmaddr);\nshmctl(X_shminfo.shmid, IPC_RMID, 0);\n\n// Paranoia.\nimage->data = NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__* screen; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_GRAPHICS ;\nint /*<<< orphan*/  D_WARNING ;\nint /*<<< orphan*/  I_SetPalette (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_Free (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_NoMem (char*) ;\nint /*<<< orphan*/  M_WriteConfig (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetPalette (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_UnloadPalette () ;\nTYPE_1__* screen ;\nint /*<<< orphan*/  videoconfig ;\n\nvoid I_ShutdownGraphics(void)\n{\nif (!M_WriteConfig(videoconfig, 0))\nM_NoMem(\"I_ShutdownGraphics\");\n\nP_UnloadPalette();\n\nI_SetPalette(0, 0, 0);\n\nM_Free(screen->screen);\nscreen->screen = NULL;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_Free",
    "input":"\n0000000000000000 <Z_Free>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t-192(%rdi), %rax\nb: \tcmpq\t(%rip), %rax  # 0x12 <Z_Free+0x12>\n12: \tje\t0x1e <Z_Free+0x1e>\n14: \tmovl\t$0, %edi\n19: \tcallq\t0x1e <Z_Free+0x1e>\n1e: \tleaq\t-192(%rbx), %rdx\n25: \tmovq\t-184(%rbx), %rax\n2c: \tcmpq\t$257, %rax    # imm = 0x101\n32: \tjb\t0x3b <Z_Free+0x3b>\n34: \tmovq\t$0, (%rax)\n3b: \tmovq\t$0, -152(%rbx)\n46: \txorps\t%xmm0, %xmm0\n49: \tmovups\t%xmm0, (%rdx)\n4c: \tmovq\t-176(%rbx), %rax\n53: \tcmpq\t$0, 8(%rax)\n58: \tje\t0x6d <Z_Free+0x6d>\n5a: \tmovq\t-168(%rbx), %rcx\n61: \tmovq\t%rdx, %rax\n64: \tcmpq\t$0, 8(%rcx)\n69: \tjne\t0x9a <Z_Free+0x9a>\n6b: \tjmp\t0xa6 <Z_Free+0xa6>\n6d: \tmovq\t-160(%rbx), %rcx\n74: \taddq\t%rcx, 32(%rax)\n78: \tmovq\t-168(%rbx), %rcx\n7f: \tmovq\t%rcx, 24(%rax)\n83: \tmovq\t%rax, 16(%rcx)\n87: \tmovq\t(%rip), %rsi  # 0x8e <Z_Free+0x8e>\n8e: \tcmpq\t%rdx, (%rsi)\n91: \tje\t0x9c <Z_Free+0x9c>\n93: \tcmpq\t$0, 8(%rcx)\n98: \tje\t0xa6 <Z_Free+0xa6>\n9a: \tpopq\t%rbx\n9b: \tretq\n9c: \tmovq\t%rax, (%rsi)\n9f: \tcmpq\t$0, 8(%rcx)\na4: \tjne\t0x9a <Z_Free+0x9a>\na6: \tmovq\t32(%rcx), %rdx\naa: \taddq\t%rdx, 32(%rax)\nae: \tmovq\t24(%rcx), %rdx\nb2: \tmovq\t%rdx, 24(%rax)\nb6: \tmovq\t%rax, 16(%rdx)\nba: \tmovq\t(%rip), %rdx  # 0xc1 <Z_Free+0xc1>\nc1: \tcmpq\t(%rdx), %rcx\nc4: \tjne\t0x9a <Z_Free+0x9a>\nc6: \tmovq\t%rax, (%rdx)\nc9: \tpopq\t%rbx\nca: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ id; void** user; struct TYPE_3__* prev; struct TYPE_3__* next; scalar_t__ size; scalar_t__ tag; } ;\ntypedef  TYPE_1__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\nstruct TYPE_4__ {TYPE_1__* rover; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nscalar_t__ ZONEID ;\nTYPE_2__* mainzone ;\n\nvoid Z_Free (void* ptr)\n{\nmemblock_t*\t\tblock;\nmemblock_t*\t\tother;\n\nblock = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));\n\nif (block->id != ZONEID)\nI_Error (\"Z_Free: freed a pointer without ZONEID\");\n\nif (block->user > (void **)0x100)\n{\n// smaller values are not pointers\n// Note: OS-dependend?\n\n// clear the user's mark\n*block->user = 0;\n}\n\n// mark as free\nblock->user = NULL;\nblock->tag = 0;\nblock->id = 0;\n\nother = block->prev;\n\nif (!other->user)\n{\n// merge with previous free block\nother->size += block->size;\nother->next = block->next;\nother->next->prev = other;\n\nif (block == mainzone->rover)\nmainzone->rover = other;\n\nblock = other;\n}\n\nother = block->next;\nif (!other->user)\n{\n// merge the next free block onto the end\nblock->size += other->size;\nblock->next = other->next;\nblock->next->prev = block;\n\nif (other == mainzone->rover)\nmainzone->rover = block;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ type; } ;\nstruct TYPE_9__ {scalar_t__ type; } ;\nstruct TYPE_8__ {scalar_t__ type; } ;\nstruct TYPE_7__ {scalar_t__ type; } ;\nstruct ZSTD_CCtx_s {TYPE_4__* inBuff; TYPE_4__* outBuff; TYPE_4__* inBuffPos; TYPE_4__* outBuffPos; TYPE_4__* inBuffSize; TYPE_4__* outBuffContentSize; TYPE_4__* outBuffFlushedSize; TYPE_4__* outBuffFlushed; TYPE_4__* outBuffTarget; TYPE_4__* outBuffContent; TYPE_4__* outBuffFlushedPtr; TYPE_4__* outBuffFlushedEnd; TYPE_4__* outBuffFlushedEndPtr; TYPE_4__* outBuffFlushedEnd2; TYPE_4__* outBuffFlushedEnd3; TYPE_4__* outBuffFlushedEnd4; TYPE_4__* outBuffFlushedEnd5; TYPE_4__* outBuffFlushedEnd6; TYPE_4__* outBuffFlushedEnd7; TYPE_4__* outBuffFlushedEnd8; TYPE_4__* outBuffFlushedEnd9; TYPE_4__* outBuffFlushedEnd10; TYPE_4__* outBuffFlushedEnd11; TYPE_4__* outBuffFlushedEnd12; TYPE_4__* outBuffFlushedEnd13; TYPE_4__* outBuffFlushedEnd14; TYPE_4__* outBuffFlushedEnd15; TYPE_4__* outBuffFlushedEnd16; TYPE_4__* outBuffFlushedEnd17; TYPE_4__* outBuffFlushedEnd18; TYPE_4__* outBuffFlushedEnd19; TYPE_4__* outBuffFlushedEnd20; TYPE_4__* outBuffFlushedEnd21; TYPE_4__* outBuffFlushedEnd22; TYPE_4__* outBuffFlushedEnd23; TYPE_4__* outBuffFlushedEnd24; TYPE_4__* outBuffFlushedEnd25; TYPE_4__* outBuffFlushedEnd26; TYPE_4__* outBuffFlushedEnd27; TYPE_4__* outBuffFlushedEnd28; TYPE_4__* outBuffFlushedEnd29; TYPE_4__* outBuffFlushedEnd30; TYPE_4__* outBuffFlushedEnd31; TYPE_4__* outBuffFlushedEnd32; TYPE_4__* outBuffFlushedEnd33; TYPE_4__* outBuffFlushedEnd34; TYPE_4__* outBuffFlushedEnd35; TYPE_4__* outBuffFlushedEnd36; TYPE_4__* outBuffFlushedEnd37; TYPE_4__* outBuffFlushedEnd38; TYPE_4__* outBuffFlushedEnd39; TYPE_4__* outBuffFlushedEnd40; TYPE_4__* outBuffFlushedEnd41; TYPE_4__* outBuffFlushedEnd42; TYPE_4__* outBuffFlushedEnd43; TYPE_4__* outBuffFlushedEnd44; TYPE_4__* outBuffFlushedEnd45; TYPE_4__* outBuffFlushedEnd46; TYPE_4__* outBuffFlushedEnd47; TYPE_4__* outBuffFlushedEnd48; TYPE_4__* outBuffFlushedEnd49; TYPE_4__* outBuffFlushedEnd50; TYPE_4__* outBuffFlushedEnd51; TYPE_4__* outBuffFlushedEnd52; TYPE_4__* outBuffFlushedEnd53; TYPE_4__* outBuffFlushedEnd54; TYPE_4__* outBuffFlushedEnd55; TYPE_4__* outBuffFlushedEnd56; TYPE_4__* outBuffFlushedEnd57; TYPE_4__* outBuffFlushedEnd58; TYPE_4__* outBuffFlushedEnd59; TYPE_4__* outBuffFlushedEnd60; TYPE_4__* outBuffFlushedEnd61; TYPE_4__* outBuffFlushedEnd62; TYPE_4__* outBuffFlushedEnd63; TYPE_4__* outBuffFlushedEnd64; TYPE_4__* outBuffFlushedEnd65; TYPE_4__* outBuffFlushedEnd66; TYPE_4__* outBuffFlushedEnd67; TYPE_4__* outBuffFlushedEnd68; TYPE_4__* outBuffFlushedEnd69; TYPE_4__* outBuffFlushedEnd70; TYPE_4__* outBuffFlushedEnd71; TYPE_4__* outBuffFlushedEnd72; TYPE_4__* outBuffFlushedEnd73; TYPE_4__* outBuffFlushedEnd74; TYPE_4__* outBuffFlushedEnd75; TYPE_4__* outBuffFlushedEnd76; TYPE_4__* outBuffFlushedEnd77; TYPE_4__* outBuffFlushedEnd78; TYPE_4__* outBuffFlushedEnd79; TYPE_4__* outBuffFlushedEnd80; TYPE_4__* outBuffFlushedEnd81; TYPE_4__* outBuffFlushedEnd82; TYPE_4__* outBuffFlushedEnd83; TYPE_4__* outBuffFlushedEnd84; TYPE_4__* outBuffFlushedEnd85; TYPE_4__* outBuffFlushedEnd86; TYPE_4__* outBuffFlushedEnd87; TYPE_4__* outBuffFlushedEnd88; TYPE_4__* outBuffFlushedEnd89; TYPE_4__* outBuffFlushedEnd90; TYPE_4__* outBuffFlushedEnd91; TYPE_4__* outBuffFlushedEnd92; TYPE_4__* outBuffFlushedEnd93; TYPE_4__* outBuffFlushedEnd94; TYPE_4__* outBuffFlushedEnd95; TYPE_4__* outBuffFlushedEnd96; TYPE_4__* outBuffFlushedEnd97; TYPE_4__* outBuffFlushedEnd98; TYPE_4__* outBuffFlushedEnd99; TYPE_4__* outBuffFlushedEnd100; TYPE_4__* outBuffFlushedEnd101; TYPE_4__* outBuffFlushedEnd102; TYPE_4__* outBuffFlushedEnd103; TYPE_4__* outBuffFlushedEnd104; TYPE_4__* outBuffFlushedEnd105; TYPE_4__* outBuffFlushedEnd106; TYPE_4__* outBuffFlushedEnd107; TYPE_4__* outBuffFlushedEnd108; TYPE_4__* outBuffFlushedEnd109; TYPE_4__* outBuffFlushedEnd110"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_ChangeMusic",
    "input":"\n0000000000000000 <S_ChangeMusic>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovl\t%esi, %ebp\na: \tmovl\t%edi, %esi\nc: \tcmpl\t%edi, (%rip)  # 0x12 <S_ChangeMusic+0x12>\n12: \tjge\t0x35 <S_ChangeMusic+0x35>\n14: \tcmpl\t%esi, (%rip)  # 0x1a <S_ChangeMusic+0x1a>\n1a: \tjle\t0x35 <S_ChangeMusic+0x35>\n1c: \tmovslq\t%esi, %rbx\n1f: \tshlq\t$5, %rbx\n23: \taddq\t(%rip), %rbx  # 0x2a <S_ChangeMusic+0x2a>\n2a: \tcmpq\t%rbx, (%rip)  # 0x31 <S_ChangeMusic+0x31>\n31: \tjne\t0x3f <S_ChangeMusic+0x3f>\n33: \tjmp\t0x9d <S_ChangeMusic+0x9d>\n35: \tmovl\t$0, %edi\n3a: \tcallq\t0x3f <S_ChangeMusic+0x3f>\n3f: \txorl\t%eax, %eax\n41: \tcallq\t0x46 <S_ChangeMusic+0x46>\n46: \tmovq\t24(%rbx), %rdi\n4a: \ttestq\t%rdi, %rdi\n4d: \tjne\t0x73 <S_ChangeMusic+0x73>\n4f: \tmovq\t(%rbx), %rdx\n52: \tleaq\t7(%rsp), %r14\n57: \tmovl\t$0, %esi\n5c: \tmovq\t%r14, %rdi\n5f: \tcallq\t0x64 <S_ChangeMusic+0x64>\n64: \tmovq\t%r14, %rdi\n67: \tcallq\t0x6c <S_ChangeMusic+0x6c>\n6c: \tmovq\t%rax, %rdi\n6f: \tmovq\t%rax, 24(%rbx)\n73: \tmovl\t(%rip), %esi  # 0x79 <S_ChangeMusic+0x79>\n79: \tcallq\t0x7e <S_ChangeMusic+0x7e>\n7e: \tmovq\t%rax, 16(%rbx)\n82: \tmovq\t%rax, %rdi\n85: \tcallq\t0x8a <S_ChangeMusic+0x8a>\n8a: \tmovl\t%eax, 8(%rbx)\n8d: \tmovl\t%eax, %edi\n8f: \tmovl\t%ebp, %esi\n91: \tcallq\t0x96 <S_ChangeMusic+0x96>\n96: \tmovq\t%rbx, (%rip)  # 0x9d <S_ChangeMusic+0x9d>\n9d: \taddq\t$16, %rsp\na1: \tpopq\t%rbx\na2: \tpopq\t%r14\na4: \tpopq\t%rbp\na5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {char* name; int /*<<< orphan*/  handle; void* data; scalar_t__ lumpnum; } ;\ntypedef  TYPE_1__ musicinfo_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,int) ;\nint /*<<< orphan*/  I_PlaySong (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  I_RegisterSong (void*) ;\nint NUMMUSIC ;\nint /*<<< orphan*/  PU_MUSIC ;\nint /*<<< orphan*/  S_StopMusic () ;\nTYPE_1__* S_music ;\nscalar_t__ W_CacheLumpNum (scalar_t__,int /*<<< orphan*/ ) ;\nscalar_t__ W_GetNumForName (char*) ;\nint mus_None ;\nTYPE_1__* mus_playing ;\nint /*<<< orphan*/  sprintf (char*,char*,char*) ;\n\nvoid\nS_ChangeMusic\n( int\t\t\tmusicnum,\nint\t\t\tlooping )\n{\nmusicinfo_t*\tmusic;\nchar\t\tnamebuf[9];\n\nif ( (musicnum <= mus_None)\n|| (musicnum >= NUMMUSIC) )\n{\nI_Error(\"Bad music number %d\", musicnum);\n}\nelse\nmusic = &S_music[musicnum];\n\nif (mus_playing == music)\nreturn;\n\n// shutdown old music\nS_StopMusic();\n\n// get lumpnum if neccessary\nif (!music->lumpnum)\n{\nsprintf(namebuf, \"d_%s\", music->name);\nmusic->lumpnum = W_GetNumForName(namebuf);\n}\n\n// load & register it\nmusic->data = (void *) W_CacheLumpNum(music->lumpnum, PU_MUSIC);\nmusic->handle = I_RegisterSong(music->data);\n\n// play it\nI_PlaySong(music->handle, looping);\n\nmus_playing = music;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * handle; int /*<<< orphan*/ * data; int /*<<< orphan*/  length; int /*<<< orphan*/ * name; } ;\ntypedef  TYPE_1__ music_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_PANIC (char*) ;\nint /*<<< orphan*/  I_SetMusicVolume (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MUS_VOL ;\nint /*<<< orphan*/  S_StopMusic () ;\nint /*<<< orphan*/  S_UnloadMusic () ;\nint /*<<< orphan*/  S_music_volume ;\nint /*<<< orphan*/  S_music_volume_set ;\nint /*<<< orphan*/  S_music_volume_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_by_user_set ;\nint /*<<< orphan*/  S_music_volume_user_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  S_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_Responder",
    "input":"\n0000000000000000 <F_Responder>:\n0: \tcmpl\t$2, (%rip)    # 0x7 <F_Responder+0x7>\n7: \tjne\t0xe <F_Responder+0xe>\n9: \tjmp\t0xe <F_Responder+0xe>\ne: \txorl\t%eax, %eax\n10: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  event_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint F_CastResponder (int /*<<< orphan*/ *) ;\nint finalestage ;\n\nboolean F_Responder (event_t *event)\n{\nif (finalestage == 2)\nreturn F_CastResponder (event);\n\nreturn false;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_Responder_2 () ;\nint /*<<< orphan*/  F_Responder_3 () ;\nint /*<<< orphan*/  F_Responder_4 () ;\nint /*<<< orphan*/  F_Responder_5 () ;\nint /*<<< orphan*/  F_Responder_6 () ;\nint /*<<< orphan*/  F_Responder_7 () ;\nint /*<<< orphan*/  F_Responder_8 () ;\nint /*<<< orphan*/  F_Responder_9 () ;\nint /*<<< orphan*/  F_Responder_A () ;\nint /*<<< orphan*/  F_Responder_B () ;\nint /*<<< orphan*/  F_Responder_C () ;\nint /*<<< orphan*/  F_Responder_D () ;\nint /*<<< orphan*/  F_Responder_E () ;\nint /*<<< orphan*/  F_Responder_F () ;\nint /*<<< orphan*/  F_Responder_10 () ;\nint /*<<< orphan*/  F_Responder_11 () ;\nint /*<<< orphan*/  F_Responder_12 () ;\nint /*<<< orphan*/  F_Responder_13 () ;\nint /*<<< orphan*/  F_Responder_14 () ;\nint /*<<< orphan*/  F_Responder_15 () ;\nint /*<<< orphan*/  F_Responder_16 () ;\nint /*<<< orphan*/  F_Responder_17 () ;\nint /*<<< orphan*/  F_Responder_18 () ;\nint /*<<< orphan*/  F_Responder_19 () ;\nint /*<<< orphan*/  F_Responder_1A () ;\nint /*<<< orphan*/  F_Responder_1B () ;\nint /*<<< orphan*/  F_Responder_1C () ;\nint /*<<< orphan*/  F_Responder_1D () ;\nint /*<<< orphan*/  F_Responder_1E () ;\nint /*<<< orphan*/  F_Responder_1F () ;\nint /*<<< orphan*/  F_Responder_20 () ;\nint /*<<< orphan*/  F_Responder_21 () ;\nint /*<<< orphan*/  F_Responder_22 () ;\nint /*<<< orphan*/  F_Responder_23 () ;\nint /*<<< orphan*/  F_Responder_24 () ;\nint /*<<< orphan*/  F_Responder_25 () ;\nint /*<<< orphan*/  F_Responder_26 () ;\nint /*<<< orphan*/  F_Responder_27 () ;\nint /*<<< orphan*/  F_Responder_28 () ;\nint /*<<< orphan*/  F_Responder_29 () ;\nint /*<<< orphan*/  F_Responder_2A () ;\nint /*<<< orphan*/  F_Responder_2B () ;\nint /*<<< orphan*/  F_Responder_2C () ;\nint /*<<< orphan*/  F_Responder_2D () ;\nint /*<<< orphan*/  F_Responder_2E () ;\nint /*<<< orphan*/  F_Responder_2F () ;\nint /*<<< orphan*/  F_Responder_30 () ;\nint /*<<< orphan*/  F_Responder_31 () ;\nint /*<<< orphan*/  F_Responder_32 () ;\nint /*<<< orphan*/  F_Responder_33 () ;\nint /*<<< orphan*/  F_Responder_34 () ;\nint /*<<< orphan*/  F_Responder_35 () ;\nint /*<<< orphan*/  F_Responder_36 () ;\nint /*<<< orphan*/  F_Responder_37 () ;\nint /*<<< orphan*/  F_Responder_38 () ;\nint /*<<< orphan*/  F_Responder_39 () ;\nint /*<<< orphan*/  F_Responder_3A () ;\nint /*<<< orphan*/  F_Responder_3B () ;\nint /*<<< orphan*/  F_Responder_3C () ;\nint /*<<< orphan*/  F_Responder_3D () ;\nint /*<<< orphan*/  F_Responder_3E () ;\nint /*<<< orphan*/  F_Responder_3F () ;\nint /*<<< orphan*/  F_Responder_40 () ;\nint /*<<< orphan*/  F_Responder_41 () ;\nint /*<<< orphan*/  F_Responder_42 () ;\nint /*<<< orphan*/  F_Responder_43 () ;\nint /*<<< orphan*/  F_Responder_44 () ;\nint /*<<< orphan*/  F_Responder_45 () ;\nint /*<<< orphan*/  F_Responder_46 () ;\nint /*<<< orphan*/  F_Responder_47 () ;\nint /*<<< orphan*/  F_Responder_48 () ;\nint /*<<< orphan*/  F_Responder_49 () ;\nint /*<<< orphan*/  F_Responder_4A () ;\nint /*<<< orphan*/  F_Responder_4B () ;\nint /*<<< orphan*/  F_Responder_4C () ;\nint /*<<< orphan*/  F_Responder_4D () ;\nint /*<<< orphan*/  F_Responder_4E () ;\nint /*<<< orphan*/  F_Responder_4F () ;\nint /*<<< orphan*/  F_Responder_50 () ;\nint /*<<< orphan*/  F_Responder_51 () ;\nint /*<<< orphan*/  F_Responder_52 () ;\nint /*<<< orphan*/  F_Responder_53 () ;\nint /*<<< orphan*/  F_Responder_54 () ;\nint /*<<< orphan*/  F_Responder_55 () ;\nint /*<<< orphan*/  F_Responder_56 () ;\nint /*<<< orphan*/  F_Responder_57 () ;\nint /*<<< orphan*/  F_Responder_58 () ;\nint /*<<< orphan*/  F_Responder_59 () ;\nint /*<<< orphan*/  F_Responder_5A () ;\nint /*<<< orphan*/  F_Responder_5B () ;\nint /*<<< orphan*/  F_Responder_5C () ;\nint /*<<< orphan*/  F_Responder_5D () ;\nint /*<<< orphan*/  F_Responder_5E () ;\nint /*<<< orphan*/  F_Responder_5F () ;\nint /*<<< orphan*/  F_Responder_60 () ;\nint /*<<< orphan*/  F_Responder_61 () ;\nint /*<<< orphan*/  F_Responder_62 () ;\nint /*<<< orphan*/  F_Responder_63 () ;\nint /*<<< orphan*/  F_Responder_64 () ;\nint /*<<< orphan*/  F_Responder_65 () ;\nint /*<<< orphan*/  F_Responder_66 () ;\nint /*<<< orphan*/  F_Responder_67 () ;\nint /*<<< orphan*/  F_Responder_68 () ;\nint /*<<< orphan*/  F_Responder_69 () ;\nint /*<<< orphan*/  F_Responder_6A () ;\nint /*<<< orphan*/  F_Responder_6B () ;\nint /*<<< orphan*/  F_Responder_6C () ;\nint /*<<< orphan*/  F_Responder_6D () ;\nint /*"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_Ticker",
    "input":"\n0000000000000000 <AM_Ticker>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <AM_Ticker+0x8>\n8: \tje\t0x51 <AM_Ticker+0x51>\na: \taddl\t$1, (%rip)    # 0x11 <AM_Ticker+0x11>\n11: \tcmpq\t$0, (%rip)    # 0x19 <AM_Ticker+0x19>\n19: \tje\t0x22 <AM_Ticker+0x22>\n1b: \txorl\t%eax, %eax\n1d: \tcallq\t0x22 <AM_Ticker+0x22>\n22: \tmovq\t(%rip), %rax  # 0x29 <AM_Ticker+0x29>\n29: \tcmpq\t(%rip), %rax  # 0x30 <AM_Ticker+0x30>\n30: \tje\t0x39 <AM_Ticker+0x39>\n32: \txorl\t%eax, %eax\n34: \tcallq\t0x39 <AM_Ticker+0x39>\n39: \tmovq\t(%rip), %rax  # 0x40 <AM_Ticker+0x40>\n40: \torq\t(%rip), %rax  # 0x47 <AM_Ticker+0x47>\n47: \tje\t0x51 <AM_Ticker+0x51>\n49: \txorl\t%eax, %eax\n4b: \tpopq\t%rcx\n4c: \tjmp\t0x51 <AM_Ticker+0x51>\n51: \tpopq\t%rax\n52: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ y; scalar_t__ x; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_changeWindowLoc () ;\nint /*<<< orphan*/  AM_changeWindowScale () ;\nint /*<<< orphan*/  AM_doFollowPlayer () ;\nscalar_t__ FRACUNIT ;\nint /*<<< orphan*/  amclock ;\nint /*<<< orphan*/  automapactive ;\nscalar_t__ followplayer ;\nscalar_t__ ftom_zoommul ;\nTYPE_1__ m_paninc ;\n\nvoid AM_Ticker (void)\n{\n\nif (!automapactive)\nreturn;\n\namclock++;\n\nif (followplayer)\nAM_doFollowPlayer();\n\n// Change the zoom if necessary\nif (ftom_zoommul != FRACUNIT)\nAM_changeWindowScale();\n\n// Change x,y location\nif (m_paninc.x || m_paninc.y)\nAM_changeWindowLoc();\n\n// Update light level\n// AM_updateLightLev();\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ AM_TICK_CYCLE ;\nscalar_t__ AM_TICK_CYCLE_2 ;\nscalar_t__ AM_TICK_CYCLE_3 ;\nint /*<<< orphan*/  AM_Tick () ;\nint /*<<< orphan*/  AM_Tick2 () ;\nint /*<<< orphan*/  AM_Tick3 () ;\nint /*<<< orphan*/  AM_Tick4 () ;\nint /*<<< orphan*/  AM_Tick5 () ;\nint /*<<< orphan*/  AM_Tick6 () ;\nint /*<<< orphan*/  AM_Tick7 () ;\nint /*<<< orphan*/  AM_Tick8 () ;\nint /*<<< orphan*/  AM_Tick9 () ;\nint /*<<< orphan*/  AM_Tick10 () ;\nint /*<<< orphan*/  AM_Tick11 () ;\nint /*<<< orphan*/  AM_Tick12 () ;\nint /*<<< orphan*/  AM_Tick13 () ;\nint /*<<< orphan*/  AM_Tick14 () ;\nint /*<<< orphan*/  AM_Tick15 () ;\nint /*<<< orphan*/  AM_Tick16 () ;\nint /*<<< orphan*/  AM_Tick17 () ;\nint /*<<< orphan*/  AM_Tick18 () ;\nint /*<<< orphan*/  AM_Tick19 () ;\nint /*<<< orphan*/  AM_Tick20 () ;\nint /*<<< orphan*/  AM_Tick21 () ;\nint /*<<< orphan*/  AM_Tick22 () ;\nint /*<<< orphan*/  AM_Tick23 () ;\nint /*<<< orphan*/  AM_Tick24 () ;\nint /*<<< orphan*/  AM_Tick25 () ;\nint /*<<< orphan*/  AM_Tick26 () ;\nint /*<<< orphan*/  AM_Tick27 () ;\nint /*<<< orphan*/  AM_Tick28 () ;\nint /*<<< orphan*/  AM_Tick29 () ;\nint /*<<< orphan*/  AM_Tick30 () ;\nint /*<<< orphan*/  AM_Tick31 () ;\nint /*<<< orphan*/  AM_Tick32 () ;\nint /*<<< orphan*/  AM_Tick33 () ;\nint /*<<< orphan*/  AM_Tick34 () ;\nint /*<<< orphan*/  AM_Tick35 () ;\nint /*<<< orphan*/  AM_Tick36 () ;\nint /*<<< orphan*/  AM_Tick37 () ;\nint /*<<< orphan*/  AM_Tick38 () ;\nint /*<<< orphan*/  AM_Tick39 () ;\nint /*<<< orphan*/  AM_Tick40 () ;\nint /*<<< orphan*/  AM_Tick41 () ;\nint /*<<< orphan*/  AM_Tick42 () ;\nint /*<<< orphan*/  AM_Tick43 () ;\nint /*<<< orphan*/  AM_Tick44 () ;\nint /*<<< orphan*/  AM_Tick45 () ;\nint /*<<< orphan*/  AM_Tick46 () ;\nint /*<<< orphan*/  AM_Tick47 () ;\nint /*<<< orphan*/  AM_Tick48 () ;\nint /*<<< orphan*/  AM_Tick49 () ;\nint /*<<< orphan*/  AM_Tick50 () ;\nint /*<<< orphan*/  AM_Tick51 () ;\nint /*<<< orphan*/  AM_Tick52 () ;\nint /*<<< orphan*/  AM_Tick53 () ;\nint /*<<< orphan*/  AM_Tick54 () ;\nint /*<<< orphan*/  AM_Tick55 () ;\nint /*<<< orphan*/  AM_Tick56 () ;\nint /*<<< orphan*/  AM_Tick57 () ;\nint /*<<< orphan*/  AM_Tick58 () ;\nint /*<<< orphan*/  AM_Tick59 () ;\nint /*<<< orphan*/  AM_Tick60 () ;\nint /*<<< orphan*/  AM_Tick61 () ;\nint /*<<< orphan*/  AM_Tick62 () ;\nint /*<<< orphan*/  AM_Tick63 () ;\nint /*<<< orphan*/  AM_Tick64 () ;\nint /*<<< orphan*/  AM_Tick65 () ;\nint /*<<< orphan*/  AM_Tick66 () ;\nint /*<<< orphan*/  AM_Tick67 () ;\nint /*<<< orphan*/  AM_Tick68 () ;\nint /*<<< orphan*/  AM_Tick69 () ;\nint /*<<< orphan*/  AM_Tick70 () ;\nint /*<<< orphan*/  AM_Tick71 () ;\nint /*<<< orphan*/  AM_Tick72 () ;\nint /*<<< orphan*/  AM_Tick73 () ;\nint /*<<< orphan*/  AM_Tick74 () ;\nint /*<<< orphan*/  AM_Tick75 () ;\nint /*<<< orphan*/  AM_Tick76 () ;\nint /*<<< orphan*/  AM_Tick77 () ;\nint /*<<< orphan*/  AM_Tick78 () ;\nint /*<<< orphan*/  AM_Tick79 () ;\nint /*<<< orphan*/  AM_Tick80 () ;\nint /*<<< orphan*/  AM_Tick81 () ;\nint /*<<< orphan*/  AM_Tick82 () ;\nint /*<<< orphan*/  AM_Tick83 () ;\nint /*<<< orphan*/  AM_Tick84 () ;\nint /*<<< orphan*/  AM_Tick85 () ;\nint /*<<< orphan*/  AM_Tick86 () ;\nint /*<<< orphan*/  AM_Tick87 () ;\nint /*<<< orphan*/  AM_Tick88 () ;\nint /*<<< orphan*/  AM_Tick89 () ;\nint /*<<< orphan*/  AM_Tick90 () ;\nint /*<<< orphan*/  AM_Tick91 () ;\nint /*<<< orphan*/  AM_Tick92 () ;\nint /*<<< orphan*/  AM_Tick93 () ;\nint /*<<< orphan*/  AM_Tick94 () ;\nint /*<<< orphan*/  AM_Tick95 () ;\nint /*<<< orphan*/  AM_Tick96 () ;\nint /*<<< orphan*/  AM_Tick97 () ;\nint /*<<< orphan*/  AM_Tick98 () ;\nint /*<<< orphan*/  AM_Tick99 () ;\nint /*<<< orphan*/  AM_Tick100 () ;\nint /*<<< orphan*/  AM_Tick101 () ;\nint /*<<< orphan*/  AM_Tick102 () ;\nint /*<<< orphan*/  AM_Tick103 () ;\nint /*<<< orphan*/  AM_Tick104 () ;\nint /*<<< orphan*/  AM_Tick105 () ;\nint /*<<< orphan*/  AM_Tick106 () ;\nint /*<<< orphan*/  AM_Tick107 () ;\nint /*<<< orphan*/  AM_Tick108 () ;\nint /*<<< orphan*/  AM_Tick109 () ;\nint /*<<< orphan*/  AM_Tick110 () ;\nint /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_Start",
    "input":"\n0000000000000000 <WI_Start>:\n0: \tpushq\t%rax\n1: \tcallq\t0x6 <WI_Start+0x6>\n6: \txorl\t%eax, %eax\n8: \tcallq\t0xd <WI_Start+0xd>\nd: \tcmpq\t$0, (%rip)    # 0x15 <WI_Start+0x15>\n15: \tje\t0x1f <WI_Start+0x1f>\n17: \txorl\t%eax, %eax\n19: \tpopq\t%rcx\n1a: \tjmp\t0x1f <WI_Start+0x1f>\n1f: \tcmpq\t$0, (%rip)    # 0x27 <WI_Start+0x27>\n27: \tje\t0x31 <WI_Start+0x31>\n29: \txorl\t%eax, %eax\n2b: \tpopq\t%rcx\n2c: \tjmp\t0x31 <WI_Start+0x31>\n31: \txorl\t%eax, %eax\n33: \tpopq\t%rcx\n34: \tjmp\t0x39 <WI_Start+0x39>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  wbstartstruct_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_initDeathmatchStats () ;\nint /*<<< orphan*/  WI_initNetgameStats () ;\nint /*<<< orphan*/  WI_initStats () ;\nint /*<<< orphan*/  WI_initVariables (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  WI_loadData () ;\nscalar_t__ deathmatch ;\nscalar_t__ netgame ;\n\nvoid WI_Start(wbstartstruct_t* wbstartstruct)\n{\n\nWI_initVariables(wbstartstruct);\nWI_loadData();\n\nif (deathmatch)\nWI_initDeathmatchStats();\nelse if (netgame)\nWI_initNetgameStats();\nelse\nWI_initStats();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WRes ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_Init () ;\nint /*<<< orphan*/  WI_InitDll () ;\nint /*<<< orphan*/  WI_InitGlobals () ;\nscalar_t__ _7Z_IS_REGISTERED ;\nscalar_t__ _7Z_IS_REGISTERED_DLL ;\n\nWRes WI_Start(void)\n{\nWI_InitDll();\nWI_InitGlobals();\nWI_Init();\nif (_7Z_IS_REGISTERED)\nreturn 0;\nif (_7Z_IS_REGISTERED_DLL)\nreturn 0;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ChangeDetail",
    "input":"\n0000000000000000 <M_ChangeDetail>:\n0: \tmovl\t$1, %eax\n5: \tsubq\t(%rip), %rax  # 0xc <M_ChangeDetail+0xc>\nc: \tmovq\t%rax, (%rip)  # 0x13 <M_ChangeDetail+0x13>\n13: \tmovl\t(%rip), %edi  # 0x19 <M_ChangeDetail+0x19>\n19: \tmovl\t$0, %esi\n1e: \tjmp\t0x23 <M_ChangeDetail+0x23>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ detailLevel ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid M_ChangeDetail(int choice)\n{\nchoice = 0;\ndetailLevel = 1 - detailLevel;\n\n// FIXME - does not work. Remove anyway?\nfprintf( stderr, \"M_ChangeDetail: low detail mode n.a.\\n\");\n\nreturn;\n\n/*R_SetViewSize (screenblocks, detailLevel);\n\nif (!detailLevel)\nplayers[consoleplayer].message = DETAILHI;\nelse\nplayers[consoleplayer].message = DETAILLO;*/\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  stderr ;\nscalar_t__ verbosity ;\n\nvoid M_ChangeDetail(void)\n{\nverbosity = 1 - verbosity;\nfprintf(stderr, \"Verbosity changed to %d\\n\", verbosity);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_initIText",
    "input":"\n0000000000000000 <HUlib_initIText>:\n0: \tmovq\t$0, 16(%rdi)\n8: \tmovq\t%r9, 8(%rdi)\nc: \tmovl\t$1, (%rdi)\n12: \taddq\t$4, %rdi\n16: \tjmp\t0x1b <HUlib_initIText+0x1b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  patch_t ;\nstruct TYPE_3__ {int laston; int /*<<< orphan*/  l; int /*<<< orphan*/ * on; scalar_t__ lm; } ;\ntypedef  TYPE_1__ hu_itext_t ;\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_initTextLine (int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ **,int) ;\n\nvoid\nHUlib_initIText\n( hu_itext_t*\tit,\nint\t\tx,\nint\t\ty,\npatch_t**\tfont,\nint\t\tstartchar,\nboolean*\ton )\n{\nit->lm = 0; // default left margin is start of text\nit->on = on;\nit->laston = true;\nHUlib_initTextLine(&it->l, x, y, font, startchar);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  bIsText; int /*<<< orphan*/ * pText; int /*<<< orphan*/ * pFont; } ;\ntypedef  TYPE_1__ HUCHAR_INFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_initChar (TYPE_1__*) ;\n\nvoid HUlib_initIText(HUCHAR_INFO *pChar, int x, int y, int w, int h, int c, int bk, int fg)\n{\npChar->pFont = NULL;\npChar->pText = NULL;\npChar->bIsText = 1;\nHUlib_initChar(pChar + 1);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_FreeTags",
    "input":"\n0000000000000000 <Z_FreeTags>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t(%rip), %rax  # 0xb <Z_FreeTags+0xb>\nb: \tmovq\t8(%rax), %rbx\nf: \tcmpq\t%rax, %rbx\n12: \tje\t0x4f <Z_FreeTags+0x4f>\n14: \tmovl\t%esi, %r14d\n17: \tmovl\t%edi, %ebp\n19: \tjmp\t0x25 <Z_FreeTags+0x25>\n1b: \tnopl\t(%rax,%rax)\n20: \tcmpq\t%rax, %rbx\n23: \tje\t0x4f <Z_FreeTags+0x4f>\n25: \tmovq\t%rbx, %rdi\n28: \tmovq\t8(%rbx), %rbx\n2c: \tcmpl\t$0, 4(%rdi)\n30: \tje\t0x20 <Z_FreeTags+0x20>\n32: \tmovl\t(%rdi), %ecx\n34: \tcmpl\t%ebp, %ecx\n36: \tjl\t0x20 <Z_FreeTags+0x20>\n38: \tcmpl\t%r14d, %ecx\n3b: \tjg\t0x20 <Z_FreeTags+0x20>\n3d: \taddq\t$64, %rdi\n41: \tcallq\t0x46 <Z_FreeTags+0x46>\n46: \tmovq\t(%rip), %rax  # 0x4d <Z_FreeTags+0x4d>\n4d: \tjmp\t0x20 <Z_FreeTags+0x20>\n4f: \tpopq\t%rbx\n50: \tpopq\t%r14\n52: \tpopq\t%rbp\n53: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int tag; int /*<<< orphan*/  user; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\nstruct TYPE_4__ {TYPE_1__ blocklist; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Z_Free (int /*<<< orphan*/ *) ;\nTYPE_2__* mainzone ;\n\nvoid\nZ_FreeTags\n( int\t\tlowtag,\nint\t\thightag )\n{\nmemblock_t*\tblock;\nmemblock_t*\tnext;\n\nfor (block = mainzone->blocklist.next ;\nblock != &mainzone->blocklist ;\nblock = next)\n{\n// get link before freeing\nnext = block->next;\n\n// free block?\nif (!block->user)\ncontinue;\n\nif (block->tag >= lowtag && block->tag <= hightag)\nZ_Free ( (byte *)block+sizeof(memblock_t));\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int tag; int /*<<< orphan*/  used; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ Z_Tag ;\n\n/* Variables and functions */\nTYPE_1__* Z_TagList ;\nint /*<<< orphan*/  Z_Free (TYPE_1__*) ;\n\nvoid Z_FreeTags(int tag, int used)\n{\nZ_Tag *t, *next;\n\nfor (t = Z_TagList; t != NULL; t = next)\n{\nnext = t->next;\nif (t->used == 0 && t->tag >= tag && t->tag <= used)\n{\nZ_Free(t);\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_DrawColumnInCache",
    "input":"\n0000000000000000 <R_DrawColumnInCache>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovl\t(%rdi), %eax\nd: \tcmpl\t$255, %eax\n12: \tjne\t0x23 <R_DrawColumnInCache+0x23>\n14: \taddq\t$8, %rsp\n18: \tpopq\t%rbx\n19: \tpopq\t%r12\n1b: \tpopq\t%r13\n1d: \tpopq\t%r14\n1f: \tpopq\t%r15\n21: \tpopq\t%rbp\n22: \tretq\n23: \tmovl\t%ecx, %r13d\n26: \tmovl\t%edx, %r15d\n29: \tmovq\t%rsi, %r14\n2c: \tmovq\t%rdi, %rbp\n2f: \txorl\t%r12d, %r12d\n32: \tmovq\t%rdi, %rsi\n35: \tjmp\t0x5c <R_DrawColumnInCache+0x5c>\n37: \tnopw\t(%rax,%rax)\n40: \tmovslq\t%ecx, %rax\n43: \tleaq\t16(,%rax,4), %rsi\n4b: \taddq\t%rbp, %rsi\n4e: \tmovl\t16(%rbp,%rax,4), %eax\n52: \tmovq\t%rsi, %rbp\n55: \tcmpl\t$255, %eax\n5a: \tje\t0x14 <R_DrawColumnInCache+0x14>\n5c: \tmovl\t4(%rbp), %ecx\n5f: \taddl\t%r15d, %eax\n62: \tmovl\t%eax, %edi\n64: \tcmovsl\t%r12d, %edi\n68: \tmovl\t%eax, %ebx\n6a: \tsarl\t$31, %ebx\n6d: \tandl\t%eax, %ebx\n6f: \taddl\t%ecx, %ebx\n71: \tleal\t(%rbx,%rdi), %eax\n74: \tmovl\t%r13d, %edx\n77: \tsubl\t%edi, %edx\n79: \tcmpl\t%r13d, %eax\n7c: \tcmovlel\t%ebx, %edx\n7f: \ttestl\t%edx, %edx\n81: \tjle\t0x40 <R_DrawColumnInCache+0x40>\n83: \taddq\t$12, %rsi\n87: \tmovl\t%edi, %eax\n89: \tleaq\t(%r14,%rax,4), %rdi\n8d: \tcallq\t0x92 <R_DrawColumnInCache+0x92>\n92: \tmovl\t4(%rbp), %ecx\n95: \tjmp\t0x40 <R_DrawColumnInCache+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int topdelta; int length; } ;\ntypedef  TYPE_1__ column_t ;\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\n\nvoid\nR_DrawColumnInCache\n( column_t*\tpatch,\nbyte*\t\tcache,\nint\t\toriginy,\nint\t\tcacheheight )\n{\nint\t\tcount;\nint\t\tposition;\nbyte*\tsource;\nbyte*\tdest;\n\ndest = (byte *)cache + 3;\n\nwhile (patch->topdelta != 0xff)\n{\nsource = (byte *)patch + 3;\ncount = patch->length;\nposition = originy + patch->topdelta;\n\nif (position < 0)\n{\ncount += position;\nposition = 0;\n}\n\nif (position + count > cacheheight)\ncount = cacheheight - position;\n\nif (count > 0)\nmemcpy (cache + position, source, count);\n\npatch = (column_t *)(  (byte *)patch + patch->length + 4);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int y; int x; int color; } ;\ntypedef  TYPE_1__ RDrawColumnCache ;\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DrawColumn (int /*<<< orphan*/ *,int) ;\n\nvoid R_DrawColumnInCache(RDrawColumnCache *cache, UBYTE *dest, int x, int y)\n{\nint i;\n\nfor (i = 0; cache[i].y != 255; i++)\n{\nif (cache[i].y == 255)\nreturn;\n\nif (cache[i].y + y < 0)\ncontinue;\n\nif (cache[i].y + y >= 256)\nbreak;\n\nR_DrawColumn(dest + (cache[i].x + x), cache[i].color);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_P_SpawnFireFlicker",
    "input":"\n0000000000000000 <P_SpawnFireFlicker>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovq\t$0, 8(%rdi)\nf: \tmovl\t(%rip), %esi  # 0x15 <P_SpawnFireFlicker+0x15>\n15: \tmovl\t$40, %edi\n1a: \txorl\t%edx, %edx\n1c: \tcallq\t0x21 <P_SpawnFireFlicker+0x21>\n21: \tmovq\t%rax, %rbx\n24: \tleaq\t32(%rax), %rdi\n28: \tcallq\t0x2d <P_SpawnFireFlicker+0x2d>\n2d: \tmovq\t(%rip), %rax  # 0x34 <P_SpawnFireFlicker+0x34>\n34: \tmovq\t%rax, 32(%rbx)\n38: \tmovq\t%r14, 24(%rbx)\n3c: \tmovl\t(%r14), %esi\n3f: \tmovl\t%esi, 16(%rbx)\n42: \tmovq\t%r14, %rdi\n45: \tcallq\t0x4a <P_SpawnFireFlicker+0x4a>\n4a: \taddq\t$16, %rax\n4e: \tmovq\t%rax, 8(%rbx)\n52: \tmovl\t$4, (%rbx)\n58: \taddq\t$8, %rsp\n5c: \tpopq\t%rbx\n5d: \tpopq\t%r14\n5f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_7__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  lightlevel; scalar_t__ special; } ;\ntypedef  TYPE_2__ sector_t ;\nstruct TYPE_8__ {scalar_t__ acp1; } ;\nstruct TYPE_11__ {TYPE_1__ function; } ;\nstruct TYPE_10__ {int count; scalar_t__ minlight; int /*<<< orphan*/  maxlight; TYPE_2__* sector; TYPE_7__ thinker; } ;\ntypedef  TYPE_3__ fireflicker_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_LEVSPEC ;\nint /*<<< orphan*/  P_AddThinker (TYPE_7__*) ;\nscalar_t__ P_FindMinSurroundingLight (TYPE_2__*,int /*<<< orphan*/ ) ;\nscalar_t__ T_FireFlicker ;\nTYPE_3__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid P_SpawnFireFlicker (sector_t*\tsector)\n{\nfireflicker_t*\tflick;\n\n// Note that we are resetting sector attributes.\n// Nothing special about it during gameplay.\nsector->special = 0;\n\nflick = Z_Malloc ( sizeof(*flick), PU_LEVSPEC, 0);\n\nP_AddThinker (&flick->thinker);\n\nflick->thinker.function.acp1 = (actionf_p1) T_FireFlicker;\nflick->sector = sector;\nflick->maxlight = sector->lightlevel;\nflick->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel)+16;\nflick->count = 4;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  type; int /*<<< orphan*/  special; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  type; int /*<<< orphan*/  special; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; int /*<<< orphan*/  type; int /*<<< orphan*/  special; } ;\ntypedef  TYPE_1__* PLAYER ;\ntypedef  TYPE_2__* ENEMY ;\ntypedef  TYPE_3__* MOBJ ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MT_FIREFLICKER ;\nTYPE_1__* P_AllocatePlayer () ;\nTYPE_2__* Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  Z_Free (TYPE_2__*) ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_1__*,int /*<<< orphan*/ ) ;\nTYPE_3__* fireflicker ;\n\n__attribute__((used)) static MOBJ*\nP_SpawnFireFlicker(PLAYER *player)\n{\nENEMY *mobj;\n\nplayer->special = 0;\nmobj = Z_Malloc(sizeof(*mobj), 40, 0);\nZ_Free(fireflicker);\nfireflicker = mobj;\n\nmobj->type = MT_FIREFLICKER;\nmobj->special = player->special;\nmobj->x = player->x;\nmobj->y = player->y;\nP_SetMobjState(player, 4);\n\nreturn mobj;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SpidRefire",
    "input":"\n0000000000000000 <A_SpidRefire>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <A_SpidRefire+0x9>\n9: \txorl\t%eax, %eax\nb: \tcallq\t0x10 <A_SpidRefire+0x10>\n10: \tcmpl\t$10, %eax\n13: \tjge\t0x17 <A_SpidRefire+0x17>\n15: \tpopq\t%rbx\n16: \tretq\n17: \tmovq\t8(%rbx), %rsi\n1b: \ttestq\t%rsi, %rsi\n1e: \tje\t0x32 <A_SpidRefire+0x32>\n20: \tcmpq\t$0, (%rsi)\n24: \tjle\t0x32 <A_SpidRefire+0x32>\n26: \tmovq\t%rbx, %rdi\n29: \tcallq\t0x2e <A_SpidRefire+0x2e>\n2e: \ttestl\t%eax, %eax\n30: \tjne\t0x15 <A_SpidRefire+0x15>\n32: \tmovq\t(%rbx), %rax\n35: \tmovl\t(%rax), %esi\n37: \tmovq\t%rbx, %rdi\n3a: \tpopq\t%rbx\n3b: \tjmp\t0x40 <A_SpidRefire+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_5__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {TYPE_1__* info; TYPE_5__* target; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_10__ {scalar_t__ health; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  seestate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_2__*) ;\nint /*<<< orphan*/  P_CheckSight (TYPE_2__*,TYPE_5__*) ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_2__*,int /*<<< orphan*/ ) ;\n\nvoid A_SpidRefire (mobj_t* actor)\n{\n// keep firing unless target got out of sight\nA_FaceTarget (actor);\n\nif (P_Random () < 10)\nreturn;\n\nif (!actor->target\n|| actor->target->health <= 0\n|| !P_CheckSight (actor, actor->target) )\n{\nP_SetMobjState (actor, actor->info->seestate);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {TYPE_1__* info; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  spid; } ;\ntypedef  TYPE_2__ Object ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SpidFire (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SpidRefire (TYPE_2__*) ;\nint /*<<< orphan*/  A_SpidSet (TYPE_2__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SpidSetTime (TYPE_2__*) ;\nint /*<<< orphan*/  A_SpidTime () ;\n\nvoid A_SpidRefire(Object* o)\n{\nA_SpidSetTime(o);\nif (A_SpidTime() >= 10)\n{\nif (o->info->spid && o->info->spid[0] > 0)\n{\nif (!A_SpidFire(o, o->info->spid[0]))\n{\nA_SpidSet(o, o->info->spid[0]);\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_SaveGame",
    "input":"\n0000000000000000 <G_SaveGame>:\n0: \tpushq\t%rax\n1: \tmovl\t%edi, (%rip)  # 0x7 <G_SaveGame+0x7>\n7: \tmovl\t(%rip), %edi  # 0xd <G_SaveGame+0xd>\nd: \tcallq\t0x12 <G_SaveGame+0x12>\n12: \tmovl\t$1, (%rip)    # 0x1c <G_SaveGame+0x1c>\n1c: \tpopq\t%rax\n1d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  savedescription ;\nint savegameslot ;\nint sendsave ;\nint /*<<< orphan*/  strcpy (int /*<<< orphan*/ ,char*) ;\n\nvoid\nG_SaveGame\n( int\tslot,\nchar*\tdescription )\n{\nsavegameslot = slot;\nstrcpy (savedescription, description);\nsendsave = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_SaveGame_Patch () ;\nint /*<<< orphan*/  G_saveGame ;\nint save_game_pending ;\n\nvoid G_SaveGame(int slot)\n{\nG_saveGame = slot;\nG_SaveGame_Patch();\nsave_game_pending = 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_StopChannel",
    "input":"\n0000000000000000 <S_StopChannel>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t(%rip), %r15  # 0xc <S_StopChannel+0xc>\nc: \tmovslq\t%edi, %rbx\nf: \tshlq\t$4, %rbx\n13: \tcmpq\t$0, (%r15,%rbx)\n18: \tje\t0x49 <S_StopChannel+0x49>\n1a: \tleaq\t(%r15,%rbx), %r14\n1e: \tmovl\t8(%r15,%rbx), %edi\n23: \tcallq\t0x28 <S_StopChannel+0x28>\n28: \ttestq\t%rax, %rax\n2b: \tje\t0x3c <S_StopChannel+0x3c>\n2d: \tleaq\t(%r15,%rbx), %rax\n31: \taddq\t$8, %rax\n35: \tmovl\t(%rax), %edi\n37: \tcallq\t0x3c <S_StopChannel+0x3c>\n3c: \tmovq\t(%r14), %rax\n3f: \taddl\t$-1, (%rax)\n42: \tmovq\t$0, (%r14)\n49: \tpopq\t%rbx\n4a: \tpopq\t%r14\n4c: \tpopq\t%r15\n4e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_3__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {TYPE_3__* sfxinfo; int /*<<< orphan*/  handle; } ;\ntypedef  TYPE_1__ channel_t ;\nstruct TYPE_5__ {int /*<<< orphan*/  usefulness; } ;\n\n/* Variables and functions */\nscalar_t__ I_SoundIsPlaying (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  I_StopSound (int /*<<< orphan*/ ) ;\nTYPE_3__* S_sfx ;\nTYPE_1__* channels ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint numChannels ;\nsize_t sfx_sawful ;\nint /*<<< orphan*/  stderr ;\n\nvoid S_StopChannel(int cnum)\n{\n\nint\t\ti;\nchannel_t*\tc = &channels[cnum];\n\nif (c->sfxinfo)\n{\n// stop the sound playing\nif (I_SoundIsPlaying(c->handle))\n{\n#ifdef SAWDEBUG\nif (c->sfxinfo == &S_sfx[sfx_sawful])\nfprintf(stderr, \"stopped\\n\");\n#endif\nI_StopSound(c->handle);\n}\n\n// check to see\n//  if other channels are playing the sound\nfor (i=0 ; i<numChannels ; i++)\n{\nif (cnum != i\n&& c->sfxinfo == channels[i].sfxinfo)\n{\nbreak;\n}\n}\n\n// degrade usefulness of sound data\nc->sfxinfo->usefulness--;\n\nc->sfxinfo = 0;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * handle; int /*<<< orphan*/  channel; } ;\ntypedef  TYPE_1__ S_Channel ;\n\n/* Variables and functions */\nTYPE_1__** channels ;\nscalar_t__ S_StopSound (int /*<<< orphan*/ ) ;\n\nvoid S_StopChannel(int chan)\n{\nS_Channel *ch;\n\nif (!channels[chan])\nreturn;\n\nch = &channels[chan];\n\nif (S_StopSound(ch->channel))\nS_StopSound(ch->handle[1]);\n\nch->handle[0] = NULL;\nch->handle[1] = NULL;\nch->channel--;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_drawMarks",
    "input":"\n0000000000000000 <AM_drawMarks>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tcmpl\t$0, (%rip)    # 0xa <AM_drawMarks+0xa>\na: \tjle\t0x8b <AM_drawMarks+0x8b>\nc: \txorl\t%ebx, %ebx\ne: \tjmp\t0x20 <AM_drawMarks+0x20>\n10: \taddq\t$1, %rbx\n14: \tmovslq\t(%rip), %rax  # 0x1b <AM_drawMarks+0x1b>\n1b: \tcmpq\t%rax, %rbx\n1e: \tjge\t0x8b <AM_drawMarks+0x8b>\n20: \tmovq\t(%rip), %rax  # 0x27 <AM_drawMarks+0x27>\n27: \tmovl\t(%rax,%rbx,8), %edi\n2a: \tcmpl\t$-1, %edi\n2d: \tje\t0x10 <AM_drawMarks+0x10>\n2f: \tcallq\t0x34 <AM_drawMarks+0x34>\n34: \tmovl\t%eax, %ebp\n36: \tmovq\t(%rip), %rax  # 0x3d <AM_drawMarks+0x3d>\n3d: \tmovl\t4(%rax,%rbx,8), %edi\n41: \tcallq\t0x46 <AM_drawMarks+0x46>\n46: \tcmpl\t(%rip), %ebp  # 0x4c <AM_drawMarks+0x4c>\n4c: \tjl\t0x10 <AM_drawMarks+0x10>\n4e: \tmovl\t(%rip), %ecx  # 0x54 <AM_drawMarks+0x54>\n54: \taddl\t$-5, %ecx\n57: \tcmpl\t%ecx, %ebp\n59: \tjg\t0x10 <AM_drawMarks+0x10>\n5b: \tcmpl\t(%rip), %eax  # 0x61 <AM_drawMarks+0x61>\n61: \tjl\t0x10 <AM_drawMarks+0x10>\n63: \tmovl\t(%rip), %ecx  # 0x69 <AM_drawMarks+0x69>\n69: \taddl\t$-6, %ecx\n6c: \tcmpl\t%ecx, %eax\n6e: \tjg\t0x10 <AM_drawMarks+0x10>\n70: \tmovl\t(%rip), %edx  # 0x76 <AM_drawMarks+0x76>\n76: \tmovq\t(%rip), %rcx  # 0x7d <AM_drawMarks+0x7d>\n7d: \tmovl\t(%rcx,%rbx,4), %ecx\n80: \tmovl\t%ebp, %edi\n82: \tmovl\t%eax, %esi\n84: \tcallq\t0x89 <AM_drawMarks+0x89>\n89: \tjmp\t0x10 <AM_drawMarks+0x10>\n8b: \taddq\t$8, %rsp\n8f: \tpopq\t%rbx\n90: \tpopq\t%rbp\n91: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int x; int /*<<< orphan*/  y; } ;\n\n/* Variables and functions */\nint AM_NUMMARKPOINTS ;\nint CXMTOF (int) ;\nint CYMTOF (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  FB ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint f_h ;\nint f_w ;\nint f_x ;\nint f_y ;\nint /*<<< orphan*/ * marknums ;\nTYPE_1__* markpoints ;\n\nvoid AM_drawMarks(void)\n{\nint i, fx, fy, w, h;\n\nfor (i=0;i<AM_NUMMARKPOINTS;i++)\n{\nif (markpoints[i].x != -1)\n{\n//      w = SHORT(marknums[i]->width);\n//      h = SHORT(marknums[i]->height);\nw = 5; // because something's wrong with the wad, i guess\nh = 6; // because something's wrong with the wad, i guess\nfx = CXMTOF(markpoints[i].x);\nfy = CYMTOF(markpoints[i].y);\nif (fx >= f_x && fx <= f_w - w && fy >= f_y && fy <= f_h - h)\nV_DrawPatch(fx, fy, FB, marknums[i]);\n}\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; } ;\n\n/* Variables and functions */\nint AM_MARK_SIZE ;\nint AM_MARK_SIZE_MIN ;\nint AM_MARK_SIZE_MAX ;\nint AM_MARK_SIZE_MIN_X ;\nint AM_MARK_SIZE_MIN_Y ;\nint AM_MARK_SIZE_MAX_X ;\nint AM_MARK_SIZE_MAX_Y ;\nint AM_MARK_SIZE_MIN_Y_OFFSET ;\nint AM_MARK_SIZE_MAX_Y_OFFSET ;\nint AM_MARK_SIZE_MIN_X_OFFSET ;\nint AM_MARK_SIZE_MAX_X_OFFSET ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MAX_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MAX_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MAX_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MAX_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MAX_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MAX_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MAX_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MAX_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MIN_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MIN_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MIN_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MIN_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MIN_MAX ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MIN_MAX ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MIN_MAX ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MIN_MAX ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MAX_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MAX_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MAX_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MAX_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MAX_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MAX_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MAX_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MAX_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MAX_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MAX_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MAX_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MAX_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MAX_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_Y_OFFSET_MIN_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_Y_OFFSET_MIN_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MIN_X_OFFSET_MIN_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE_MAX_X_OFFSET_MIN_MIN_MIN_MIN_MIN ;\nint AM_MARK_SIZE"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_VileTarget",
    "input":"\n0000000000000000 <A_VileTarget>:\n0: \tpushq\t%rbx\n1: \tcmpq\t$0, (%rdi)\n5: \tje\t0x3c <A_VileTarget+0x3c>\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <A_VileTarget+0xf>\nf: \tmovq\t(%rbx), %rax\n12: \tmovl\t16(%rax), %edx\n15: \tmovl\t20(%rax), %edi\n18: \tmovl\t(%rip), %ecx  # 0x1e <A_VileTarget+0x1e>\n1e: \tmovl\t%edi, %esi\n20: \tcallq\t0x25 <A_VileTarget+0x25>\n25: \tmovq\t%rax, 8(%rbx)\n29: \tmovq\t%rbx, (%rax)\n2c: \tmovq\t(%rbx), %rcx\n2f: \tmovq\t%rcx, 8(%rax)\n33: \tmovq\t%rax, %rdi\n36: \tpopq\t%rbx\n37: \tjmp\t0x3c <A_VileTarget+0x3c>\n3c: \tpopq\t%rbx\n3d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {struct TYPE_6__* target; struct TYPE_6__* tracer; int /*<<< orphan*/  z; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  A_Fire (TYPE_1__*) ;\nint /*<<< orphan*/  MT_FIRE ;\nTYPE_1__* P_SpawnMobj (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_VileTarget (mobj_t*\tactor)\n{\nmobj_t*\tfog;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\n\nfog = P_SpawnMobj (actor->target->x,\nactor->target->x,\nactor->target->z, MT_FIRE);\n\nactor->tracer = fog;\nfog->target = actor;\nfog->tracer = actor->target;\nA_Fire (fog);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* actor; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; TYPE_1__* next; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_2__ DEx ;\ntypedef  TYPE_3__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_VileTarget_B ;\nTYPE_2__* AllocActor (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  NewTarget (TYPE_2__*) ;\n\nvoid A_VileTarget(void* info)\n{\nActor* my = (Actor*)info;\n\nif (my->extra == 0)\nreturn;\n\nNewTarget(my);\n\nDEx* ex = (DEx*)AllocActor(my->x, my->y, A_VileTarget_B, 0);\nex->next = my->extra;\nmy->extra = ex;\nex->x = my->x;\nex->y = my->y;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_FindHighestFloorSurrounding",
    "input":"\n0000000000000000 <P_FindHighestFloorSurrounding>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovslq\t(%rip), %rax  # 0xc <P_FindHighestFloorSurrounding+0xc>\nc: \timulq\t$-500, %rax, %r14  # imm = 0xFE0C\n13: \tcmpl\t$0, (%rdi)\n16: \tjle\t0x4e <P_FindHighestFloorSurrounding+0x4e>\n18: \tmovq\t%rdi, %r15\n1b: \txorl\t%ebx, %ebx\n1d: \tjmp\t0x2c <P_FindHighestFloorSurrounding+0x2c>\n1f: \tnop\n20: \taddq\t$1, %rbx\n24: \tmovslq\t(%r15), %rax\n27: \tcmpq\t%rax, %rbx\n2a: \tjge\t0x4e <P_FindHighestFloorSurrounding+0x4e>\n2c: \tmovq\t16(%r15), %rax\n30: \tmovq\t(%rax,%rbx,8), %rdi\n34: \tmovq\t%r15, %rsi\n37: \tcallq\t0x3c <P_FindHighestFloorSurrounding+0x3c>\n3c: \ttestq\t%rax, %rax\n3f: \tje\t0x20 <P_FindHighestFloorSurrounding+0x20>\n41: \tmovq\t8(%rax), %rax\n45: \tcmpq\t%r14, %rax\n48: \tcmovgeq\t%rax, %r14\n4c: \tjmp\t0x20 <P_FindHighestFloorSurrounding+0x20>\n4e: \tmovq\t%r14, %rax\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tpopq\t%r15\n56: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int linecount; scalar_t__ floorheight; int /*<<< orphan*/ ** lines; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nint FRACUNIT ;\nTYPE_1__* getNextSector (int /*<<< orphan*/ *,TYPE_1__*) ;\n\nfixed_t\tP_FindHighestFloorSurrounding(sector_t *sec)\n{\nint\t\t\ti;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\tfloor = -500*FRACUNIT;\n\nfor (i=0 ;i < sec->linecount ; i++)\n{\ncheck = sec->lines[i];\nother = getNextSector(check,sec);\n\nif (!other)\ncontinue;\n\nif (other->floorheight > floor)\nfloor = other->floorheight;\n}\nreturn floor;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int numsectors; TYPE_2__** sectors; } ;\nstruct TYPE_9__ {TYPE_1__* floorz; } ;\nstruct TYPE_8__ {scalar_t__ z; } ;\ntypedef  TYPE_1__ D3DVECTOR ;\ntypedef  TYPE_2__ SECTOR ;\ntypedef  TYPE_3__ PLAYER ;\n\n/* Variables and functions */\nint P_FindHighestFloorSurroundingSector (TYPE_2__*,TYPE_3__*) ;\n\n__attribute__((used)) static D3DVECTOR*\nP_FindHighestFloorSurrounding\n(PLAYER*\t\tplayer)\n{\nD3DVECTOR*"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_FireBFG",
    "input":"\n0000000000000000 <A_FireBFG>:\n0: \tmovl\t(%rip), %eax  # 0x6 <A_FireBFG+0x6>\n6: \tmovq\t(%rdi), %rcx\n9: \tmovq\t16(%rdi), %rdx\nd: \tmovq\t(%rip), %rsi  # 0x14 <A_FireBFG+0x14>\n14: \tmovq\t(%rsi,%rcx,8), %rcx\n18: \tsubl\t%eax, (%rdx,%rcx,4)\n1b: \tmovl\t8(%rdi), %edi\n1e: \tmovl\t(%rip), %esi  # 0x24 <A_FireBFG+0x24>\n24: \tjmp\t0x29 <A_FireBFG+0x29>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_4__ {size_t readyweapon; int /*<<< orphan*/  mo; int /*<<< orphan*/ * ammo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_5__ {size_t ammo; } ;\n\n/* Variables and functions */\nscalar_t__ BFGCELLS ;\nint /*<<< orphan*/  MT_BFG ;\nint /*<<< orphan*/  P_SpawnPlayerMissile (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_2__* weaponinfo ;\n\nvoid\nA_FireBFG\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nplayer->ammo[weaponinfo[player->readyweapon].ammo] -= BFGCELLS;\nP_SpawnPlayerMissile (player->mo, MT_BFG);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t* bfgext; int /*<<< orphan*/  bfgext_t; } ;\nstruct TYPE_4__ {TYPE_1__ s; } ;\ntypedef  TYPE_2__ actor_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Bounce (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  bfgext_t ;\nsize_t* bfgext_x ;\n\nvoid A_FireBFG(actor_t *actor)\n{\nactor->s.bfgext[actor->s.bfgext_t] -= 0x100;\nA_Bounce(actor->s.bfgext_t, bfgext_x[actor->s.bfgext_t]);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_KeenDie",
    "input":"\n0000000000000000 <A_KeenDie>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rbx\n8: \tcallq\t0xd <A_KeenDie+0xd>\nd: \tmovq\t(%rip), %rax  # 0x14 <A_KeenDie+0x14>\n14: \tmovl\t$0, %ecx\n19: \tcmpq\t%rcx, %rax\n1c: \tje\t0x51 <A_KeenDie+0x51>\n1e: \tmovq\t(%rip), %rdx  # 0x25 <A_KeenDie+0x25>\n25: \tjmp\t0x39 <A_KeenDie+0x39>\n27: \tnopw\t(%rax,%rax)\n30: \tmovq\t8(%rax), %rax\n34: \tcmpq\t%rcx, %rax\n37: \tje\t0x51 <A_KeenDie+0x51>\n39: \tcmpq\t%rbx, %rax\n3c: \tje\t0x30 <A_KeenDie+0x30>\n3e: \tcmpq\t%rdx, (%rax)\n41: \tjne\t0x30 <A_KeenDie+0x30>\n43: \tcmpq\t(%rbx), %rdx\n46: \tjne\t0x30 <A_KeenDie+0x30>\n48: \tcmpq\t$0, 8(%rax)\n4d: \tjle\t0x30 <A_KeenDie+0x30>\n4f: \tjmp\t0x69 <A_KeenDie+0x69>\n51: \tmovl\t$666, 8(%rsp) # imm = 0x29A\n59: \tmovl\t(%rip), %esi  # 0x5f <A_KeenDie+0x5f>\n5f: \tleaq\t8(%rsp), %rdi\n64: \tcallq\t0x69 <A_KeenDie+0x69>\n69: \taddq\t$16, %rsp\n6d: \tpopq\t%rbx\n6e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {scalar_t__ acp1; } ;\nstruct TYPE_10__ {TYPE_1__ function; struct TYPE_10__* next; } ;\ntypedef  TYPE_2__ thinker_t ;\nstruct TYPE_11__ {scalar_t__ type; scalar_t__ health; } ;\ntypedef  TYPE_3__ mobj_t ;\nstruct TYPE_12__ {int tag; } ;\ntypedef  TYPE_4__ line_t ;\ntypedef  scalar_t__ actionf_p1 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Fall (TYPE_3__*) ;\nint /*<<< orphan*/  EV_DoDoor (TYPE_4__*,int /*<<< orphan*/ ) ;\nscalar_t__ P_MobjThinker ;\nint /*<<< orphan*/  open ;\nTYPE_2__ thinkercap ;\n\nvoid A_KeenDie (mobj_t* mo)\n{\nthinker_t*\tth;\nmobj_t*\tmo2;\nline_t\tjunk;\n\nA_Fall (mo);\n\n// scan the remaining thinkers\n// to see if all Keens are dead\nfor (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n{\nif (th->function.acp1 != (actionf_p1)P_MobjThinker)\ncontinue;\n\nmo2 = (mobj_t *)th;\nif (mo2 != mo\n&& mo2->type == mo->type\n&& mo2->health > 0)\n{\n// other Keen not dead\nreturn;\n}\n}\n\njunk.tag = 666;\nEV_DoDoor(&junk,open);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_1__ SPRITE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_KeenDie_B ;\nint /*<<< orphan*/  A_KeenDie_C ;\nint /*<<< orphan*/  A_KeenDie_D ;\nint /*<<< orphan*/  A_KeenDie_E ;\nint /*<<< orphan*/  A_KeenDie_F ;\nint /*<<< orphan*/  A_KeenDie_G ;\nint /*<<< orphan*/  A_KeenDie_H ;\nint /*<<< orphan*/  A_KeenDie_I ;\nint /*<<< orphan*/  A_KeenDie_J ;\nint /*<<< orphan*/  A_KeenDie_K ;\nint /*<<< orphan*/  A_KeenDie_L ;\nint /*<<< orphan*/  A_KeenDie_M ;\nint /*<<< orphan*/  A_KeenDie_N ;\nint /*<<< orphan*/  A_KeenDie_O ;\nint /*<<< orphan*/  A_KeenDie_P ;\nint /*<<< orphan*/  A_KeenDie_Q ;\nint /*<<< orphan*/  A_KeenDie_R ;\nint /*<<< orphan*/  A_KeenDie_S ;\nint /*<<< orphan*/  A_KeenDie_T ;\nint /*<<< orphan*/  A_KeenDie_U ;\nint /*<<< orphan*/  A_KeenDie_V ;\nint /*<<< orphan*/  A_KeenDie_W ;\nint /*<<< orphan*/  A_KeenDie_X ;\nint /*<<< orphan*/  A_KeenDie_Y ;\nint /*<<< orphan*/  A_KeenDie_Z ;\nint /*<<< orphan*/  A_KeenDie_a ;\nint /*<<< orphan*/  A_KeenDie_b ;\nint /*<<< orphan*/  A_KeenDie_c ;\nint /*<<< orphan*/  A_KeenDie_d ;\nint /*<<< orphan*/  A_KeenDie_e ;\nint /*<<< orphan*/  A_KeenDie_f ;\nint /*<<< orphan*/  A_KeenDie_g ;\nint /*<<< orphan*/  A_KeenDie_h ;\nint /*<<< orphan*/  A_KeenDie_i ;\nint /*<<< orphan*/  A_KeenDie_j ;\nint /*<<< orphan*/  A_KeenDie_k ;\nint /*<<< orphan*/  A_KeenDie_l ;\nint /*<<< orphan*/  A_KeenDie_m ;\nint /*<<< orphan*/  A_KeenDie_n ;\nint /*<<< orphan*/  A_KeenDie_o ;\nint /*<<< orphan*/  A_KeenDie_p ;\nint /*<<< orphan*/  A_KeenDie_q ;\nint /*<<< orphan*/  A_KeenDie_r ;\nint /*<<< orphan*/  A_KeenDie_s ;\nint /*<<< orphan*/  A_KeenDie_t ;\nint /*<<< orphan*/  A_KeenDie_u ;\nint /*<<< orphan*/  A_KeenDie_v ;\nint /*<<< orphan*/  A_KeenDie_w ;\nint /*<<< orphan*/  A_KeenDie_x ;\nint /*<<< orphan*/  A_KeenDie_y ;\nint /*<<< orphan*/  A_KeenDie_z ;\nint /*<<< orphan*/  A_KeenDie_A ;\nint /*<<< orphan*/  A_KeenDie_B_ ;\nint /*<<< orphan*/  A_KeenDie_C_ ;\nint /*<<< orphan*/  A_KeenDie_D_ ;\nint /*<<< orphan*/  A_KeenDie_E_ ;\nint /*<<< orphan*/  A_KeenDie_F_ ;\nint /*<<< orphan*/  A_KeenDie_G_ ;\nint /*<<< orphan*/  A_KeenDie_H_ ;\nint /*<<< orphan*/  A_KeenDie_I_ ;\nint /*<<< orphan*/  A_KeenDie_J_ ;\nint /*<<< orphan*/  A_KeenDie_K_ ;\nint /*<<< orphan*/  A_KeenDie_L_ ;\nint /*<<< orphan*/  A_KeenDie_M_ ;\nint /*<<< orphan*/  A_KeenDie_N_ ;\nint /*<<< orphan*/  A_KeenDie_O_ ;\nint /*<<< orphan*/  A_KeenDie_P_ ;\nint /*<<< orphan*/  A_KeenDie_Q_ ;\nint /*<<< orphan*/  A_KeenDie_R_ ;\nint /*<<< orphan*/  A_KeenDie_S_ ;\nint /*<<< orphan*/  A_KeenDie_T_ ;\nint /*<<< orphan*/  A_KeenDie_U_ ;\nint /*<<< orphan*/  A_KeenDie_V_ ;\nint /*<<< orphan*/  A_KeenDie_W_ ;\nint /*<<< orphan*/  A_KeenDie_X_ ;\nint /*<<< orphan*/  A_KeenDie_Y_ ;\nint /*<<< orphan*/  A_KeenDie_Z_ ;\nint /*<<< orphan*/  A_KeenDie_a_ ;\nint /*<<< orphan*/  A_KeenDie_b_ ;\nint /*<<< orphan*/  A_KeenDie_c_ ;\nint /*<<< orphan*/  A_KeenDie_d_ ;\nint /*<<< orphan*/  A_KeenDie_e_ ;\nint /*<<< orphan*/  A_KeenDie_f_ ;\nint /*<<< orphan*/  A_KeenDie_g_ ;\nint /*<<< orphan*/  A_KeenDie_h_ ;\nint /*<<< orphan*/  A_KeenDie_i_ ;\nint /*<<< orphan*/  A_KeenDie_j_ ;\nint /*<<< orphan*/  A_KeenDie_k_ ;\nint /*<<< orphan*/  A_KeenDie_l_ ;\nint /*<<< orphan*/  A_KeenDie_m_ ;\nint /*<<< orphan*/  A_KeenDie_n_ ;\nint /*<<< orphan*/  A_KeenDie_o_ ;\nint /*<<< orphan*/  A_KeenDie_p_ ;\nint /*<<< orphan*/  A_KeenDie_q_ ;\nint /*<<< orphan*/  A_KeenDie_r_ ;\nint /*<<< orphan*/  A_KeenDie_s_ ;\nint /*<<< orphan*/  A_KeenDie_t_ ;\nint /*<<< orphan*/  A_KeenDie_u_ ;\nint /*<<< orphan*/  A_KeenDie_v_ ;\nint /*<<< orphan*/  A_KeenDie_w_ ;\nint /*<<< orphan*/  A_KeenDie_x_ ;\nint /*<<< orphan*/  A_KeenDie_y_ ;\nint /*<<< orphan*/  A_KeenDie_z_ ;\nint /*<<< orphan*/  A_KeenDie_A_ ;\nint /*<<< orphan*/  A_KeenDie_B__ ;\nint /*<<< orphan*/  A_KeenDie_C__ ;\nint /*<<< orphan*/  A_KeenDie_D__ ;\nint /*<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_CheckReload",
    "input":"\n0000000000000000 <A_CheckReload>:\n0: \tjmp\t0x5 <A_CheckReload+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_5__ {int* ammo; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckAmmo (TYPE_1__*) ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_DSNR1 ;\nsize_t am_shell ;\nint /*<<< orphan*/  ps_weapon ;\n\nvoid\nA_CheckReload\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nP_CheckAmmo (player);\n#if 0\nif (player->ammo[am_shell]<2)\nP_SetPsprite (player, ps_weapon, S_DSNR1);\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Reload (int /*<<< orphan*/ *) ;\n\nvoid A_CheckReload(uint8 *action)\n{\nA_Reload(action);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_Init",
    "input":"\n0000000000000000 <R_Init>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <R_Init+0x8>\n8: \tmovl\t$0, %edi\nd: \tcallq\t0x12 <R_Init+0x12>\n12: \txorl\t%eax, %eax\n14: \tcallq\t0x19 <R_Init+0x19>\n19: \tmovl\t$0, %edi\n1e: \tcallq\t0x23 <R_Init+0x23>\n23: \txorl\t%eax, %eax\n25: \tcallq\t0x2a <R_Init+0x2a>\n2a: \tmovl\t$0, %edi\n2f: \tcallq\t0x34 <R_Init+0x34>\n34: \tmovl\t(%rip), %edi  # 0x3a <R_Init+0x3a>\n3a: \tmovl\t(%rip), %esi  # 0x40 <R_Init+0x40>\n40: \tcallq\t0x45 <R_Init+0x45>\n45: \txorl\t%eax, %eax\n47: \tcallq\t0x4c <R_Init+0x4c>\n4c: \tmovl\t$0, %edi\n51: \tcallq\t0x56 <R_Init+0x56>\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <R_Init+0x5d>\n5d: \tmovl\t$0, %edi\n62: \tcallq\t0x67 <R_Init+0x67>\n67: \txorl\t%eax, %eax\n69: \tcallq\t0x6e <R_Init+0x6e>\n6e: \tmovl\t$0, %edi\n73: \tcallq\t0x78 <R_Init+0x78>\n78: \txorl\t%eax, %eax\n7a: \tcallq\t0x7f <R_Init+0x7f>\n7f: \tmovl\t$0, %edi\n84: \tcallq\t0x89 <R_Init+0x89>\n89: \tmovq\t$0, (%rip)    # 0x94 <R_Init+0x94>\n94: \tpopq\t%rax\n95: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_InitData () ;\nint /*<<< orphan*/  R_InitLightTables () ;\nint /*<<< orphan*/  R_InitPlanes () ;\nint /*<<< orphan*/  R_InitPointToAngle () ;\nint /*<<< orphan*/  R_InitSkyMap () ;\nint /*<<< orphan*/  R_InitTables () ;\nint /*<<< orphan*/  R_InitTranslationTables () ;\nint /*<<< orphan*/  R_SetViewSize (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  detailLevel ;\nscalar_t__ framecount ;\nint /*<<< orphan*/  printf (char*) ;\nint /*<<< orphan*/  screenblocks ;\n\nvoid R_Init (void)\n{\nR_InitData ();\nprintf (\"\\nR_InitData\");\nR_InitPointToAngle ();\nprintf (\"\\nR_InitPointToAngle\");\nR_InitTables ();\n// viewwidth / viewheight / detailLevel are set by the defaults\nprintf (\"\\nR_InitTables\");\n\nR_SetViewSize (screenblocks, detailLevel);\nR_InitPlanes ();\nprintf (\"\\nR_InitPlanes\");\nR_InitLightTables ();\nprintf (\"\\nR_InitLightTables\");\nR_InitSkyMap ();\nprintf (\"\\nR_InitSkyMap\");\nR_InitTranslationTables ();\nprintf (\"\\nR_InitTranslationsTables\");\n\nframecount = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_Cleanup () ;\nint /*<<< orphan*/  R_Fini () ;\nint /*<<< orphan*/  R_Init_Rmath () ;\nint /*<<< orphan*/  R_Init_Rmath_lib () ;\nint /*<<< orphan*/  R_Init_Rmath_rand48 () ;\nint /*<<< orphan*/  R_Init_Rmath_rk () ;\nint /*<<< orphan*/  R_Init_Rmath_rng () ;\nint /*<<< orphan*/  R_Init_Rmath_rand () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_r () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_19937_96 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_19937_123 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_19937_19937 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937_19937_19937_19937_19937_19937_19937_19937_64 () ;\nint /*<<< orphan*/  R_Init_Rmath_rand_mt19937_19937"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_EndGameResponse",
    "input":"\n0000000000000000 <M_EndGameResponse>:\n0: \tcmpl\t$121, %edi\n3: \tjne\t0x24 <M_EndGameResponse+0x24>\n5: \tpushq\t%rax\n6: \tmovl\t(%rip), %eax  # 0xc <M_EndGameResponse+0xc>\nc: \tmovq\t(%rip), %rcx  # 0x13 <M_EndGameResponse+0x13>\n13: \tmovl\t%eax, (%rcx)\n15: \txorl\t%eax, %eax\n17: \tcallq\t0x1c <M_EndGameResponse+0x1c>\n1c: \txorl\t%eax, %eax\n1e: \tpopq\t%rcx\n1f: \tjmp\t0x24 <M_EndGameResponse+0x24>\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  lastOn; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_StartTitle () ;\nint /*<<< orphan*/  M_ClearMenus () ;\nTYPE_1__* currentMenu ;\nint /*<<< orphan*/  itemOn ;\n\nvoid M_EndGameResponse(int ch)\n{\nif (ch != 'y')\nreturn;\n\ncurrentMenu->lastOn = itemOn;\nM_ClearMenus ();\nD_StartTitle ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EndGame () ;\nint /*<<< orphan*/ * inbuf ;\nint /*<<< orphan*/  inbuf_ptr ;\n\nvoid M_EndGameResponse(uint8 type)\n{\nif (type == 121)\n{\ninbuf_ptr = *inbuf;\nEndGame();\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_Drawer",
    "input":"\n0000000000000000 <AM_Drawer>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <AM_Drawer+0x8>\n8: \tje\t0x82 <AM_Drawer+0x82>\na: \tmovl\t(%rip), %edi  # 0x10 <AM_Drawer+0x10>\n10: \tcallq\t0x15 <AM_Drawer+0x15>\n15: \tcmpq\t$0, (%rip)    # 0x1d <AM_Drawer+0x1d>\n1d: \tje\t0x2a <AM_Drawer+0x2a>\n1f: \tmovl\t(%rip), %edi  # 0x25 <AM_Drawer+0x25>\n25: \tcallq\t0x2a <AM_Drawer+0x2a>\n2a: \txorl\t%eax, %eax\n2c: \tcallq\t0x31 <AM_Drawer+0x31>\n31: \txorl\t%eax, %eax\n33: \tcallq\t0x38 <AM_Drawer+0x38>\n38: \tcmpl\t$2, (%rip)    # 0x3f <AM_Drawer+0x3f>\n3f: \tjne\t0x52 <AM_Drawer+0x52>\n41: \tmovl\t(%rip), %edi  # 0x47 <AM_Drawer+0x47>\n47: \tmovl\t(%rip), %esi  # 0x4d <AM_Drawer+0x4d>\n4d: \tcallq\t0x52 <AM_Drawer+0x52>\n52: \tmovl\t(%rip), %edi  # 0x58 <AM_Drawer+0x58>\n58: \tcallq\t0x5d <AM_Drawer+0x5d>\n5d: \txorl\t%eax, %eax\n5f: \tcallq\t0x64 <AM_Drawer+0x64>\n64: \tmovl\t(%rip), %edi  # 0x6a <AM_Drawer+0x6a>\n6a: \tmovl\t(%rip), %esi  # 0x70 <AM_Drawer+0x70>\n70: \tmovl\t(%rip), %edx  # 0x76 <AM_Drawer+0x76>\n76: \tmovl\t(%rip), %ecx  # 0x7c <AM_Drawer+0x7c>\n7c: \tpopq\t%rax\n7d: \tjmp\t0x82 <AM_Drawer+0x82>\n82: \tpopq\t%rax\n83: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_clearFB (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  AM_drawCrosshair (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  AM_drawGrid (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  AM_drawMarks () ;\nint /*<<< orphan*/  AM_drawPlayers () ;\nint /*<<< orphan*/  AM_drawThings (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  AM_drawWalls () ;\nint /*<<< orphan*/  BACKGROUND ;\nint /*<<< orphan*/  GRIDCOLORS ;\nint /*<<< orphan*/  THINGCOLORS ;\nint /*<<< orphan*/  THINGRANGE ;\nint /*<<< orphan*/  V_MarkRect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  XHAIRCOLORS ;\nint /*<<< orphan*/  automapactive ;\nint cheating ;\nint /*<<< orphan*/  f_h ;\nint /*<<< orphan*/  f_w ;\nint /*<<< orphan*/  f_x ;\nint /*<<< orphan*/  f_y ;\nscalar_t__ grid ;\n\nvoid AM_Drawer (void)\n{\nif (!automapactive) return;\n\nAM_clearFB(BACKGROUND);\nif (grid)\nAM_drawGrid(GRIDCOLORS);\nAM_drawWalls();\nAM_drawPlayers();\nif (cheating==2)\nAM_drawThings(THINGCOLORS, THINGRANGE);\nAM_drawCrosshair(XHAIRCOLORS);\n\nAM_drawMarks();\n\nV_MarkRect(f_x, f_y, f_w, f_h);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_DrawBorders () ;\nint /*<<< orphan*/  AM_DrawButtons () ;\nint /*<<< orphan*/  AM_DrawClock () ;\nint /*<<< orphan*/  AM_DrawClockBorders () ;\nint /*<<< orphan*/  AM_DrawClockText () ;\nint /*<<< orphan*/  AM_DrawClockTextBorders () ;\nint /*<<< orphan*/  AM_DrawClockTextShadow () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders2 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders3 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders4 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders5 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders6 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders7 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders8 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorders9 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersA () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersB () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersC () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersD () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersE () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersF () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersG () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersH () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersI () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersJ () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersK () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersL () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersM () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersN () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersO () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersP () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersQ () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersR () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersS () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersT () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersU () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersV () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersW () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersX () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersY () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersZ () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersa () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersb () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersc () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersd () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordere () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersf () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersg () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersh () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersi () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersj () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersk () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersl () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersm () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersn () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorderso () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersp () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersq () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersr () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorderss () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordert () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersu () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersv () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersw () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersx () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersy () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersz () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordera () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersb1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersc1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersd1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordere1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersf1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersg1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersh1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersi1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersj1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersk1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersl1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersm1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersn1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorderso1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersp1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersq1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordersr1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBorderss1 () ;\nint /*<<< orphan*/  AM_DrawClockTextShadowBordert1 () ;\nint /*<<< orphan*/  AM_Draw"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_net.c_CheckAbort",
    "input":"\n0000000000000000 <CheckAbort>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <CheckAbort+0xa>\na: \tmovl\t%eax, %ebx\nc: \taddl\t$2, %ebx\nf: \tnop\n10: \txorl\t%eax, %eax\n12: \tcallq\t0x17 <CheckAbort+0x17>\n17: \tmovl\t%eax, %ebp\n19: \txorl\t%eax, %eax\n1b: \tcallq\t0x20 <CheckAbort+0x20>\n20: \tcmpl\t%ebx, %ebp\n22: \tjl\t0x10 <CheckAbort+0x10>\n24: \tmovl\t(%rip), %eax  # 0x2a <CheckAbort+0x2a>\n2a: \tmovl\t(%rip), %ecx  # 0x30 <CheckAbort+0x30>\n30: \tjmp\t0x54 <CheckAbort+0x54>\n32: \tnopw\t%cs:(%rax,%rax)\n3c: \tnopl\t(%rax)\n40: \taddl\t$1, %eax\n43: \tmovl\t(%rip), %edx  # 0x49 <CheckAbort+0x49>\n49: \taddl\t$-1, %edx\n4c: \tandl\t%edx, %eax\n4e: \tmovl\t%eax, (%rip)  # 0x54 <CheckAbort+0x54>\n54: \tcmpl\t%ecx, %eax\n56: \tje\t0x99 <CheckAbort+0x99>\n58: \tmovq\t(%rip), %rdx  # 0x5f <CheckAbort+0x5f>\n5f: \tmovslq\t%eax, %rsi\n62: \tshlq\t$4, %rsi\n66: \tmovq\t(%rdx,%rsi), %rdi\n6a: \tcmpq\t(%rip), %rdi  # 0x71 <CheckAbort+0x71>\n71: \tjne\t0x40 <CheckAbort+0x40>\n73: \tmovq\t8(%rdx,%rsi), %rdx\n78: \tcmpq\t(%rip), %rdx  # 0x7f <CheckAbort+0x7f>\n7f: \tjne\t0x40 <CheckAbort+0x40>\n81: \tmovl\t$0, %edi\n86: \tcallq\t0x8b <CheckAbort+0x8b>\n8b: \tmovl\t(%rip), %eax  # 0x91 <CheckAbort+0x91>\n91: \tmovl\t(%rip), %ecx  # 0x97 <CheckAbort+0x97>\n97: \tjmp\t0x40 <CheckAbort+0x40>\n99: \taddq\t$8, %rsp\n9d: \tpopq\t%rbx\n9e: \tpopq\t%rbp\n9f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ type; scalar_t__ data1; } ;\ntypedef  TYPE_1__ event_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint I_GetTime () ;\nint /*<<< orphan*/  I_StartTic () ;\nscalar_t__ KEY_ESCAPE ;\nint MAXEVENTS ;\nscalar_t__ ev_keydown ;\nint eventhead ;\nTYPE_1__* events ;\nint eventtail ;\n\nvoid CheckAbort (void)\n{\nevent_t *ev;\nint\t\tstoptic;\n\nstoptic = I_GetTime () + 2;\nwhile (I_GetTime() < stoptic)\nI_StartTic ();\n\nI_StartTic ();\nfor ( ; eventtail != eventhead\n; eventtail = (++eventtail)&(MAXEVENTS-1) )\n{\nev = &events[eventtail];\nif (ev->type == ev_keydown && ev->data1 == KEY_ESCAPE)\nI_Error (\"Network game synchronization aborted.\");\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ type; scalar_t__ state; } ;\ntypedef  TYPE_1__* PcKey ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CheckAbort () ;\nint /*<<< orphan*/  DPRINT1 (char*) ;\nint /*<<< orphan*/  FALSE ;\nscalar_t__ KEY_ABORT ;\nscalar_t__ KEY_DOWN ;\nint /*<<< orphan*/  KEY_UP ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  abort_key ;\nint /*<<< orphan*/  abort_key_state ;\nint /*<<< orphan*/  abort_key_type ;\nTYPE_1__* key_state ;\n\n__attribute__((used)) static void CheckAbort(void)\n{\nint i;\n\nfor (i = 0; i < 2; i++)\n{\nif (CheckAbort())\n{\nabort_key = KEY_ABORT;\nabort_key_state = KEY_UP;\nabort_key_type = KEY_DOWN;\nDPRINT1(\"Abort key pressed\\n\");\nreturn;\n}\n}\n\nfor (i = 0; i < 16; i++)\n{\nif (key_state[i].type == abort_key_type &&\nkey_state[i].state == abort_key_state)\n{\nabort_key = KEY_ABORT;\nabort_key_state = KEY_UP;\nabort_key_type = KEY_DOWN;\nDPRINT1(\"Abort key pressed\\n\");\nreturn;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_Scream",
    "input":"\n0000000000000000 <A_Scream>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdi, %rbx\n7: \tmovq\t8(%rdi), %rax\nb: \tmovl\t(%rax), %esi\nd: \tleal\t-128(%rsi), %eax\n10: \tcmpl\t$3, %eax\n13: \tjb\t0x2d <A_Scream+0x2d>\n15: \tleal\t-131(%rsi), %eax\n1b: \tcmpl\t$2, %eax\n1e: \tjae\t0x6c <A_Scream+0x6c>\n20: \tmovl\t$132, %r14d\n26: \tmovl\t$2, %ebp\n2b: \tjmp\t0x38 <A_Scream+0x38>\n2d: \tmovl\t$130, %r14d\n33: \tmovl\t$3, %ebp\n38: \txorl\t%eax, %eax\n3a: \tcallq\t0x3f <A_Scream+0x3f>\n3f: \tcltd\n40: \tidivl\t%ebp\n42: \tmovl\t%edx, %esi\n44: \taddl\t%r14d, %esi\n47: \tmovq\t(%rbx), %rax\n4a: \tcmpq\t(%rip), %rax  # 0x51 <A_Scream+0x51>\n51: \tje\t0x61 <A_Scream+0x61>\n53: \tcmpq\t(%rip), %rax  # 0x5a <A_Scream+0x5a>\n5a: \tje\t0x61 <A_Scream+0x61>\n5c: \tmovq\t%rbx, %rdi\n5f: \tjmp\t0x63 <A_Scream+0x63>\n61: \txorl\t%edi, %edi\n63: \tpopq\t%rbx\n64: \tpopq\t%r14\n66: \tpopq\t%rbp\n67: \tjmp\t0x6c <A_Scream+0x6c>\n6c: \ttestl\t%esi, %esi\n6e: \tjne\t0x47 <A_Scream+0x47>\n70: \tpopq\t%rbx\n71: \tpopq\t%r14\n73: \tpopq\t%rbp\n74: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ type; TYPE_1__* info; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_5__ {int deathsound; } ;\n\n/* Variables and functions */\nscalar_t__ MT_CYBORG ;\nscalar_t__ MT_SPIDER ;\nint P_Random () ;\nint /*<<< orphan*/  S_StartSound (TYPE_2__*,int) ;\n#define  sfx_bgdth1 132\n#define  sfx_bgdth2 131\n#define  sfx_podth1 130\n#define  sfx_podth2 129\n#define  sfx_podth3 128\n\nvoid A_Scream (mobj_t* actor)\n{\nint\t\tsound;\n\nswitch (actor->info->deathsound)\n{\ncase 0:\nreturn;\n\ncase sfx_podth1:\ncase sfx_podth2:\ncase sfx_podth3:\nsound = sfx_podth1 + P_Random ()%3;\nbreak;\n\ncase sfx_bgdth1:\ncase sfx_bgdth2:\nsound = sfx_bgdth1 + P_Random ()%2;\nbreak;\n\ndefault:\nsound = actor->info->deathsound;\nbreak;\n}\n\n// Check for bosses.\nif (actor->type==MT_SPIDER\n|| actor->type == MT_CYBORG)\n{\n// full volume\nS_StartSound (NULL, sound);\n}\nelse\nS_StartSound (actor, sound);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ state; int /*<<< orphan*/  freq; } ;\ntypedef  TYPE_1__ A_Channel ;\n\n/* Variables and functions */\nscalar_t__ A_STATE_OFF ;\nscalar_t__ A_STATE_ON ;\nint /*<<< orphan*/  A_SetFreq (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetState (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_Tick (TYPE_1__*) ;\n\nvoid A_Scream(A_Channel *ch)\n{\nint i;\n\ni = ch->freq;\nif (i < 128)\n{\nA_SetState(ch, 0);\nreturn;\n}\nif (i < 131)\n{\ni = 132;\n}\nelse if (i < 134)\n{\ni = 130;\n}\nelse\n{\ni = 131;\n}\n\nif (ch->state != A_STATE_OFF && ch->state != A_STATE_ON)\n{\nA_Tick(ch);\n}\n\nA_SetFreq(ch, i);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_WriteText",
    "input":"\n0000000000000000 <M_WriteText>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rdx, %r12\ne: \tmovl\t%esi, %r15d\n11: \tmovl\t%edi, %r14d\n14: \taddq\t$1, %r12\n18: \tmovl\t%r14d, %r13d\n1b: \tjmp\t0x28 <M_WriteText+0x28>\n1d: \tnopl\t(%rax)\n20: \taddl\t$4, %r13d\n24: \taddq\t$1, %r12\n28: \tmovsbl\t-1(%r12), %edi\n2e: \ttestl\t%edi, %edi\n30: \tje\t0x99 <M_WriteText+0x99>\n32: \tcmpb\t$10, %dil\n36: \tje\t0x90 <M_WriteText+0x90>\n38: \tcallq\t0x3d <M_WriteText+0x3d>\n3d: \tsubl\t(%rip), %eax  # 0x43 <M_WriteText+0x43>\n43: \tjs\t0x20 <M_WriteText+0x20>\n45: \tcmpl\t(%rip), %eax  # 0x4b <M_WriteText+0x4b>\n4b: \tjge\t0x20 <M_WriteText+0x20>\n4d: \tmovq\t(%rip), %rcx  # 0x54 <M_WriteText+0x54>\n54: \tmovl\t%eax, %ebx\n56: \tmovq\t(%rcx,%rbx,8), %rax\n5a: \tmovl\t(%rax), %edi\n5c: \tcallq\t0x61 <M_WriteText+0x61>\n61: \tmovl\t%eax, %ebp\n63: \taddl\t%r13d, %ebp\n66: \tcmpl\t(%rip), %ebp  # 0x6c <M_WriteText+0x6c>\n6c: \tjg\t0x99 <M_WriteText+0x99>\n6e: \tmovq\t(%rip), %rax  # 0x75 <M_WriteText+0x75>\n75: \tmovq\t(%rax,%rbx,8), %rcx\n79: \tmovl\t%r13d, %edi\n7c: \tmovl\t%r15d, %esi\n7f: \txorl\t%edx, %edx\n81: \tcallq\t0x86 <M_WriteText+0x86>\n86: \taddq\t$1, %r12\n8a: \tmovl\t%ebp, %r13d\n8d: \tjmp\t0x28 <M_WriteText+0x28>\n8f: \tnop\n90: \taddl\t$12, %r15d\n94: \tjmp\t0x14 <M_WriteText+0x14>\n99: \taddq\t$8, %rsp\n9d: \tpopq\t%rbx\n9e: \tpopq\t%r12\na0: \tpopq\t%r13\na2: \tpopq\t%r14\na4: \tpopq\t%r15\na6: \tpopq\t%rbp\na7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  width; } ;\n\n/* Variables and functions */\nint HU_FONTSIZE ;\nint HU_FONTSTART ;\nint SCREENWIDTH ;\nint SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,TYPE_1__*) ;\nTYPE_1__** hu_font ;\nint toupper (int) ;\n\nvoid\nM_WriteText\n( int\t\tx,\nint\t\ty,\nchar*\t\tstring)\n{\nint\t\tw;\nchar*\tch;\nint\t\tc;\nint\t\tcx;\nint\t\tcy;\n\n\nch = string;\ncx = x;\ncy = y;\n\nwhile(1)\n{\nc = *ch++;\nif (!c)\nbreak;\nif (c == '\\n')\n{\ncx = x;\ncy += 12;\ncontinue;\n}\n\nc = toupper(c) - HU_FONTSTART;\nif (c < 0 || c>= HU_FONTSIZE)\n{\ncx += 4;\ncontinue;\n}\n\nw = SHORT (hu_font[c]->width);\nif (cx+w > SCREENWIDTH)\nbreak;\nV_DrawPatchDirect(cx, cy, 0, hu_font[c]);\ncx+=w;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  fp; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fputc (char,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fwrite (char const*,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ftell (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  stdout ;\nTYPE_1__* text_files ;\n\nvoid M_WriteText(int file, int line, const char *text)\n{\nint i;\n\nfor (i = 0; text[i]; i++)\n{\nif (text[i] == '\\n')\n{\nline += 12;\n}\nelse\n{\nint pos = ftell(text_files[file].fp);\n\nif (pos < 0 || pos >= 0x10000)\n{\nfputc('\\n', stderr);\n}\nelse\n{\nfwrite(text, i, 1, text_files[file].fp);\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_fragSum",
    "input":"\n0000000000000000 <WI_fragSum>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %r11d # 0x8 <WI_fragSum+0x8>\n8: \ttestl\t%r11d, %r11d\nb: \tjle\t0x4b <WI_fragSum+0x4b>\nd: \tmovq\t(%rip), %rsi  # 0x14 <WI_fragSum+0x14>\n14: \tmovq\t(%rip), %r8   # 0x1b <WI_fragSum+0x1b>\n1b: \tmovslq\t%edi, %r10\n1e: \tmovl\t%edi, %edi\n20: \tmovl\t%r11d, %r9d\n23: \tandl\t$1, %r9d\n27: \tcmpl\t$1, %r11d\n2b: \tjne\t0x61 <WI_fragSum+0x61>\n2d: \txorl\t%ecx, %ecx\n2f: \txorl\t%eax, %eax\n31: \ttestq\t%r9, %r9\n34: \tje\t0x57 <WI_fragSum+0x57>\n36: \tcmpq\t%rdi, %rcx\n39: \tje\t0x57 <WI_fragSum+0x57>\n3b: \tcmpq\t$0, (%rsi,%rcx,8)\n40: \tje\t0x57 <WI_fragSum+0x57>\n42: \tmovq\t(%r8,%r10,8), %rdx\n46: \taddl\t(%rdx,%rcx,8), %eax\n49: \tjmp\t0x57 <WI_fragSum+0x57>\n4b: \tmovq\t(%rip), %r8   # 0x52 <WI_fragSum+0x52>\n52: \tmovslq\t%edi, %r10\n55: \txorl\t%eax, %eax\n57: \tmovq\t(%r8,%r10,8), %rcx\n5b: \tsubl\t(%rcx,%r10,8), %eax\n5f: \tpopq\t%rbx\n60: \tretq\n61: \tsubq\t%r9, %r11\n64: \txorl\t%edx, %edx\n66: \txorl\t%eax, %eax\n68: \tjmp\t0x83 <WI_fragSum+0x83>\n6a: \tnopw\t(%rax,%rax)\n70: \tmovq\t%rdx, %rcx\n73: \taddq\t$2, %rcx\n77: \taddq\t$1, %rbx\n7b: \tmovq\t%rbx, %rdx\n7e: \tcmpq\t%rcx, %r11\n81: \tje\t0x31 <WI_fragSum+0x31>\n83: \tcmpq\t%rdx, %rdi\n86: \tje\t0x96 <WI_fragSum+0x96>\n88: \tcmpq\t$0, (%rsi,%rdx,8)\n8d: \tje\t0x96 <WI_fragSum+0x96>\n8f: \tmovq\t(%r8,%r10,8), %rcx\n93: \taddl\t(%rcx,%rdx,8), %eax\n96: \tleaq\t1(%rdx), %rbx\n9a: \tcmpq\t%rdi, %rbx\n9d: \tje\t0x70 <WI_fragSum+0x70>\n9f: \tcmpq\t$0, 8(%rsi,%rdx,8)\na5: \tje\t0x70 <WI_fragSum+0x70>\na7: \tmovq\t(%r8,%r10,8), %rcx\nab: \taddl\t8(%rcx,%rdx,8), %eax\naf: \tjmp\t0x70 <WI_fragSum+0x70>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__* frags; } ;\n\n/* Variables and functions */\nint MAXPLAYERS ;\nscalar_t__* playeringame ;\nTYPE_1__* plrs ;\n\nint WI_fragSum(int playernum)\n{\nint\t\ti;\nint\t\tfrags = 0;\n\nfor (i=0 ; i<MAXPLAYERS ; i++)\n{\nif (playeringame[i]\n&& i!=playernum)\n{\nfrags += plrs[playernum].frags[i];\n}\n}\n\n\n// JDC hack - negative frags.\nfrags -= plrs[playernum].frags[playernum];\n// UNUSED if (frags < 0)\n// \tfrags = 0;\n\nreturn frags;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  size_t UInt32 ;\n\n/* Variables and functions */\nsize_t* WI_frags ;\nsize_t* WI_frags_len ;\nint WI_numFrags ;\n\n__attribute__((used)) static UInt32 WI_fragSum(UInt32 i)\n{\nUInt32 sum = 0;\nint j;\nfor (j = 0; j < WI_numFrags; j++)\n{\nif (WI_frags[j] == i)\n{\nsum += WI_frags_len[j];\n}\nelse if (WI_frags[j] > i)\n{\nbreak;\n}\n}\nreturn sum;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_inter.c_P_GivePower",
    "input":"\n0000000000000000 <P_GivePower>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t%esi, %ebx\n6: \tmovq\t%rdi, %r14\n9: \tcmpl\t%esi, (%rip)  # 0xf <P_GivePower+0xf>\nf: \tjne\t0x22 <P_GivePower+0x22>\n11: \tmovl\t(%rip), %eax  # 0x17 <P_GivePower+0x17>\n17: \tmovq\t(%r14), %rcx\n1a: \tmovslq\t%ebx, %rdx\n1d: \tmovl\t%eax, (%rcx,%rdx,4)\n20: \tjmp\t0x45 <P_GivePower+0x45>\n22: \tcmpl\t%ebx, (%rip)  # 0x28 <P_GivePower+0x28>\n28: \tjne\t0x52 <P_GivePower+0x52>\n2a: \tmovl\t(%rip), %eax  # 0x30 <P_GivePower+0x30>\n30: \tmovq\t(%r14), %rcx\n33: \tmovslq\t%ebx, %rdx\n36: \tmovl\t%eax, (%rcx,%rdx,4)\n39: \tmovl\t(%rip), %eax  # 0x3f <P_GivePower+0x3f>\n3f: \tmovq\t8(%r14), %rcx\n43: \torl\t%eax, (%rcx)\n45: \tmovl\t$1, %eax\n4a: \taddq\t$8, %rsp\n4e: \tpopq\t%rbx\n4f: \tpopq\t%r14\n51: \tretq\n52: \tcmpl\t%ebx, (%rip)  # 0x58 <P_GivePower+0x58>\n58: \tjne\t0x62 <P_GivePower+0x62>\n5a: \tmovl\t(%rip), %eax  # 0x60 <P_GivePower+0x60>\n60: \tjmp\t0x17 <P_GivePower+0x17>\n62: \tcmpl\t%ebx, (%rip)  # 0x68 <P_GivePower+0x68>\n68: \tjne\t0x72 <P_GivePower+0x72>\n6a: \tmovl\t(%rip), %eax  # 0x70 <P_GivePower+0x70>\n70: \tjmp\t0x17 <P_GivePower+0x17>\n72: \tcmpl\t%ebx, (%rip)  # 0x78 <P_GivePower+0x78>\n78: \tjne\t0x96 <P_GivePower+0x96>\n7a: \tmovq\t%r14, %rdi\n7d: \tmovl\t$100, %esi\n82: \tcallq\t0x87 <P_GivePower+0x87>\n87: \tmovq\t(%r14), %rax\n8a: \tmovslq\t%ebx, %rcx\n8d: \tmovl\t$1, (%rax,%rcx,4)\n94: \tjmp\t0x45 <P_GivePower+0x45>\n96: \tmovq\t(%r14), %rcx\n99: \tmovslq\t%ebx, %rdx\n9c: \txorl\t%eax, %eax\n9e: \tcmpl\t$0, (%rcx,%rdx,4)\na2: \tjne\t0x4a <P_GivePower+0x4a>\na4: \tmovl\t$1, (%rcx,%rdx,4)\nab: \tjmp\t0x45 <P_GivePower+0x45>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int* powers; TYPE_1__* mo; } ;\ntypedef  TYPE_2__ player_t ;\ntypedef  int boolean ;\nstruct TYPE_5__ {int /*<<< orphan*/  flags; } ;\n\n/* Variables and functions */\nint INFRATICS ;\nint INVISTICS ;\nint INVULNTICS ;\nint IRONTICS ;\nint /*<<< orphan*/  MF_SHADOW ;\nint /*<<< orphan*/  P_GiveBody (TYPE_2__*,int) ;\nint pw_infrared ;\nint pw_invisibility ;\nint pw_invulnerability ;\nint pw_ironfeet ;\nint pw_strength ;\n\nboolean\nP_GivePower\n( player_t*\tplayer,\nint /*powertype_t*/\tpower )\n{\nif (power == pw_invulnerability)\n{\nplayer->powers[power] = INVULNTICS;\nreturn true;\n}\n\nif (power == pw_invisibility)\n{\nplayer->powers[power] = INVISTICS;\nplayer->mo->flags |= MF_SHADOW;\nreturn true;\n}\n\nif (power == pw_infrared)\n{\nplayer->powers[power] = INFRATICS;\nreturn true;\n}\n\nif (power == pw_ironfeet)\n{\nplayer->powers[power] = IRONTICS;\nreturn true;\n}\n\nif (power == pw_strength)\n{\nP_GiveBody (player, 100);\nplayer->powers[power] = 1;\nreturn true;\n}\n\nif (player->powers[power])\nreturn false;\t// already got it\n\nplayer->powers[power] = 1;\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct player_t {int* powerup_time; int /*<<< orphan*/ * powerup_flags; TYPE_1__* player; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  pflags; } ;\n\n/* Variables and functions */\nint PF_FRIENDLYFIRE ;\nint PF_GODMODE ;\nint PF_INVULNERABLE ;\nint PF_NIGHTMARE ;\nint PF_RESPAWN ;\nint PF_RESPAWN_INVULNERABLE ;\nint PF_RESPAWN_NOGOD ;\nint PF_RESPAWN_NOINVULNERABLE ;\nint PF_RESPAWN_NORMAL ;\nint PF_RESPAWN_NORMAL_INVULNERABLE ;\nint PF_RESPAWN_NORMAL_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_FRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE ;\nint PF_RESPAWN_NORMAL_NOINVULNERABLE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NOFRIENDLYFIRE_NOGOD_NO"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_net.c_UDPsocket",
    "input":"\n0000000000000000 <UDPsocket>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %edi  # 0x7 <UDPsocket+0x7>\n7: \tmovl\t(%rip), %esi  # 0xd <UDPsocket+0xd>\nd: \tmovl\t(%rip), %edx  # 0x13 <UDPsocket+0x13>\n13: \tcallq\t0x18 <UDPsocket+0x18>\n18: \tmovl\t%eax, %ebx\n1a: \ttestl\t%eax, %eax\n1c: \tjns\t0x35 <UDPsocket+0x35>\n1e: \tmovl\t(%rip), %edi  # 0x24 <UDPsocket+0x24>\n24: \tcallq\t0x29 <UDPsocket+0x29>\n29: \tmovl\t$0, %edi\n2e: \tmovl\t%eax, %esi\n30: \tcallq\t0x35 <UDPsocket+0x35>\n35: \tmovl\t%ebx, %eax\n37: \tpopq\t%rbx\n38: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  IPPROTO_UDP ;\nint /*<<< orphan*/  I_Error (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PF_INET ;\nint /*<<< orphan*/  SOCK_DGRAM ;\nint /*<<< orphan*/  errno ;\nint socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\n\nint UDPsocket (void)\n{\nint\ts;\n\n// allocate a socket\ns = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP);\nif (s<0)\nI_Error (\"can't create socket: %s\",strerror(errno));\n\nreturn s;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  SOCK_DGRAM ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint /*<<< orphan*/  errno ;\nint socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  printf (char*,int /*<<< orphan*/ ) ;\n\nint UDPsocket(void)\n{\nint sock;\n\nsock = socket(AF_INET, SOCK_DGRAM, SOCK_STREAM);\nif (sock < 0)\n{\nprintf(\"socket() failed: %s\\n\", strerror(errno));\n}\nreturn sock;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_FireShotgun",
    "input":"\n0000000000000000 <A_FireShotgun>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t8(%rdi), %edi\n7: \tmovl\t(%rip), %esi  # 0xd <A_FireShotgun+0xd>\nd: \tcallq\t0x12 <A_FireShotgun+0x12>\n12: \tmovl\t8(%rbx), %edi\n15: \tmovl\t(%rip), %esi  # 0x1b <A_FireShotgun+0x1b>\n1b: \tcallq\t0x20 <A_FireShotgun+0x20>\n20: \tmovq\t(%rbx), %rax\n23: \tmovq\t16(%rbx), %rcx\n27: \tmovq\t(%rip), %rdx  # 0x2e <A_FireShotgun+0x2e>\n2e: \tshlq\t$4, %rax\n32: \tmovq\t(%rdx,%rax), %rsi\n36: \taddl\t$-1, (%rcx,%rsi,4)\n3a: \tmovl\t(%rip), %esi  # 0x40 <A_FireShotgun+0x40>\n40: \tmovl\t8(%rdx,%rax), %edx\n44: \tmovq\t%rbx, %rdi\n47: \tcallq\t0x4c <A_FireShotgun+0x4c>\n4c: \tmovl\t8(%rbx), %edi\n4f: \tcallq\t0x54 <A_FireShotgun+0x54>\n54: \tmovl\t8(%rbx), %edi\n57: \txorl\t%esi, %esi\n59: \tcallq\t0x5e <A_FireShotgun+0x5e>\n5e: \tmovl\t8(%rbx), %edi\n61: \txorl\t%esi, %esi\n63: \tcallq\t0x68 <A_FireShotgun+0x68>\n68: \tmovl\t8(%rbx), %edi\n6b: \txorl\t%esi, %esi\n6d: \tcallq\t0x72 <A_FireShotgun+0x72>\n72: \tmovl\t8(%rbx), %edi\n75: \txorl\t%esi, %esi\n77: \tcallq\t0x7c <A_FireShotgun+0x7c>\n7c: \tmovl\t8(%rbx), %edi\n7f: \txorl\t%esi, %esi\n81: \tcallq\t0x86 <A_FireShotgun+0x86>\n86: \tmovl\t8(%rbx), %edi\n89: \txorl\t%esi, %esi\n8b: \tcallq\t0x90 <A_FireShotgun+0x90>\n90: \tmovl\t8(%rbx), %edi\n93: \txorl\t%esi, %esi\n95: \tpopq\t%rbx\n96: \tjmp\t0x9b <A_FireShotgun+0x9b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_5__ {size_t readyweapon; int /*<<< orphan*/  mo; int /*<<< orphan*/ * ammo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_6__ {size_t ammo; int /*<<< orphan*/  flashstate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_BulletSlope (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_GunShot (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  P_SetMobjState (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_PLAY_ATK2 ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ps_flash ;\nint /*<<< orphan*/  sfx_shotgn ;\nTYPE_2__* weaponinfo ;\n\nvoid\nA_FireShotgun\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nint\t\ti;\n\nS_StartSound (player->mo, sfx_shotgn);\nP_SetMobjState (player->mo, S_PLAY_ATK2);\n\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\n\nP_SetPsprite (player,\nps_flash,\nweaponinfo[player->readyweapon].flashstate);\n\nP_BulletSlope (player->mo);\n\nfor (i=0 ; i<7 ; i++)\nP_GunShot (player->mo, false);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/ * ammo_count; TYPE_1__* player; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  gun_pos; } ;\ntypedef  TYPE_2__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_2__*,int /*<<< orphan*/ ,int /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_Drawer",
    "input":"\n0000000000000000 <WI_Drawer>:\n0: \tmovl\t(%rip), %eax  # 0x6 <WI_Drawer+0x6>\n6: \tcmpl\t$130, %eax\nb: \tje\t0x2b <WI_Drawer+0x2b>\nd: \tcmpl\t$129, %eax\n12: \tje\t0x32 <WI_Drawer+0x32>\n14: \tcmpl\t$128, %eax\n19: \tjne\t0x39 <WI_Drawer+0x39>\n1b: \tcmpl\t$0, (%rip)    # 0x22 <WI_Drawer+0x22>\n22: \tje\t0x3a <WI_Drawer+0x3a>\n24: \txorl\t%eax, %eax\n26: \tjmp\t0x2b <WI_Drawer+0x2b>\n2b: \txorl\t%eax, %eax\n2d: \tjmp\t0x32 <WI_Drawer+0x32>\n32: \txorl\t%eax, %eax\n34: \tjmp\t0x39 <WI_Drawer+0x39>\n39: \tretq\n3a: \tcmpl\t$0, (%rip)    # 0x41 <WI_Drawer+0x41>\n41: \tje\t0x4a <WI_Drawer+0x4a>\n43: \txorl\t%eax, %eax\n45: \tjmp\t0x4a <WI_Drawer+0x4a>\n4a: \txorl\t%eax, %eax\n4c: \tjmp\t0x51 <WI_Drawer+0x51>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n#define  NoState 130\n#define  ShowNextLoc 129\n#define  StatCount 128\nint /*<<< orphan*/  WI_drawDeathmatchStats () ;\nint /*<<< orphan*/  WI_drawNetgameStats () ;\nint /*<<< orphan*/  WI_drawNoState () ;\nint /*<<< orphan*/  WI_drawShowNextLoc () ;\nint /*<<< orphan*/  WI_drawStats () ;\nint /*<<< orphan*/  deathmatch ;\nint /*<<< orphan*/  netgame ;\nint state ;\n\nvoid WI_Drawer (void)\n{\nswitch (state)\n{\ncase StatCount:\nif (deathmatch)\nWI_drawDeathmatchStats();\nelse if (netgame)\nWI_drawNetgameStats();\nelse\nWI_drawStats();\nbreak;\n\ncase ShowNextLoc:\nWI_drawShowNextLoc();\nbreak;\n\ncase NoState:\nWI_drawNoState();\nbreak;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  BOOLEAN ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_DrawMenuBar () ;\nint /*<<< orphan*/  WI_DrawStatusBar () ;\nint /*<<< orphan*/  WI_DrawToolBar () ;\nint /*<<< orphan*/  WI_DrawWindow () ;\nint /*<<< orphan*/  WI_DrawWorkspace () ;\nint /*<<< orphan*/  WI_RedrawAll () ;\nint /*<<< orphan*/  WI_RedrawMenuBar () ;\nint /*<<< orphan*/  WI_RedrawStatusBar () ;\nint /*<<< orphan*/  WI_RedrawToolBar () ;\nint /*<<< orphan*/  WI_RedrawWindow () ;\nint /*<<< orphan*/  WI_RedrawWorkspace () ;\nint /*<<< orphan*/  WI_UpdateMenuBar () ;\nint /*<<< orphan*/  WI_UpdateStatusBar () ;\nint /*<<< orphan*/  WI_UpdateToolBar () ;\nint /*<<< orphan*/  WI_UpdateWindow () ;\nint /*<<< orphan*/  WI_UpdateWorkspace () ;\nint /*<<< orphan*/  WI_bMenuBar ;\nint /*<<< orphan*/  WI_bStatusBar ;\nint /*<<< orphan*/  WI_bToolBar ;\nint /*<<< orphan*/  WI_bWindow ;\nint /*<<< orphan*/  WI_bWorkspace ;\n\nVOID\nWI_Drawer(BOOLEAN bRedraw)\n{\nswitch (WI_bWindow)\n{\ncase 128:\nif (WI_bMenuBar)\n{\nif (bRedraw)\nWI_RedrawMenuBar();\nelse\nWI_UpdateMenuBar();\n}\nelse\n{\nif (bRedraw)\nWI_RedrawMenuBar();\nelse\nWI_UpdateMenuBar();\n}\nbreak;\n\ncase 129:\nif (WI_bStatusBar)\n{\nif (bRedraw)\nWI_RedrawStatusBar();\nelse\nWI_UpdateStatusBar();\n}\nelse\n{\nif (bRedraw)\nWI_RedrawStatusBar();\nelse\nWI_UpdateStatusBar();\n}\nbreak;\n\ncase 130:\nif (WI_bToolBar)\n{\nif (bRedraw)\nWI_RedrawToolBar();\nelse\nWI_UpdateToolBar();\n}\nelse\n{\nif (bRedraw)\nWI_RedrawToolBar();\nelse\nWI_UpdateToolBar();\n}\nbreak;\n\ncase 131:\nif (WI_bWindow)\n{\nif (bRedraw)\nWI_RedrawWindow();\nelse\nWI_UpdateWindow();\n}\nelse\n{\nif (bRedraw)\nWI_RedrawWindow();\nelse\nWI_UpdateWindow();\n}\nbreak;\n\ncase 132:\nif (WI_bWorkspace)\n{\nif (bRedraw)\nWI_RedrawWorkspace();\nelse\nWI_UpdateWorkspace();\n}\nelse\n{\nif (bRedraw)\nWI_RedrawWorkspace();\nelse\nWI_UpdateWorkspace();\n}\nbreak;\n\ndefault:\nif (bRedraw)\nWI_RedrawAll();\nelse\nWI_UpdateAll();\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_P_ThingHeightClip",
    "input":"\n0000000000000000 <P_ThingHeightClip>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %rbx\n8: \tmovq\t(%rdi), %r14\nb: \tmovq\t8(%rdi), %r15\nf: \tmovl\t36(%rdi), %esi\n12: \tmovl\t32(%rdi), %edx\n15: \tcallq\t0x1a <P_ThingHeightClip+0x1a>\n1a: \tmovq\t(%rip), %rax  # 0x21 <P_ThingHeightClip+0x21>\n21: \tmovq\t%rax, 8(%rbx)\n25: \tmovq\t(%rip), %rcx  # 0x2c <P_ThingHeightClip+0x2c>\n2c: \tmovq\t%rcx, 16(%rbx)\n30: \tcmpq\t%r15, %r14\n33: \tjne\t0x3e <P_ThingHeightClip+0x3e>\n35: \tmovq\t%rax, (%rbx)\n38: \tmovq\t24(%rbx), %rdx\n3c: \tjmp\t0x56 <P_ThingHeightClip+0x56>\n3e: \tmovq\t24(%rbx), %rdx\n42: \tmovq\t(%rbx), %rsi\n45: \taddq\t%rdx, %rsi\n48: \tcmpq\t%rcx, %rsi\n4b: \tjle\t0x56 <P_ThingHeightClip+0x56>\n4d: \tmovq\t%rcx, %rsi\n50: \tsubq\t%rdx, %rsi\n53: \tmovq\t%rsi, (%rbx)\n56: \tsubq\t%rax, %rcx\n59: \txorl\t%eax, %eax\n5b: \tcmpq\t%rdx, %rcx\n5e: \tsetge\t%al\n61: \tpopq\t%rbx\n62: \tpopq\t%r14\n64: \tpopq\t%r15\n66: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ z; scalar_t__ floorz; scalar_t__ ceilingz; scalar_t__ height; int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckPosition (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nscalar_t__ tmceilingz ;\nscalar_t__ tmfloorz ;\n\nboolean P_ThingHeightClip (mobj_t* thing)\n{\nboolean\t\tonfloor;\n\nonfloor = (thing->z == thing->floorz);\n\nP_CheckPosition (thing, thing->x, thing->y);\n// what about stranding a monster partially off an edge?\n\nthing->floorz = tmfloorz;\nthing->ceilingz = tmceilingz;\n\nif (onfloor)\n{\n// walking monsters rise and fall with the floor\nthing->z = thing->floorz;\n}\nelse\n{\n// don't adjust a floating monster unless forced to\nif (thing->z+thing->height > thing->ceilingz)\nthing->z = thing->ceilingz - thing->height;\n}\n\nif (thing->ceilingz - thing->floorz < thing->height)\nreturn false;\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ y; scalar_t__ bottomclip; scalar_t__ topclip; scalar_t__ height; int /*<<< orphan*/  yoffset; int /*<<< orphan*/  xoffset; } ;\ntypedef  TYPE_1__ DThing ;\n\n/* Variables and functions */\nscalar_t__ BOTTOM_CLIP ;\nscalar_t__ TOP_CLIP ;\nint /*<<< orphan*/  P_UnsetThingPosition (TYPE_1__*) ;\n\n__attribute__((used)) static boolean\nP_ThingHeightClip(DThing *thing)\n{\nscalar_t_t\toldtop, oldbottom;\n\noldtop = thing->topclip;\noldbottom = thing->bottomclip;\n\nP_UnsetThingPosition(thing);\n\nthing->topclip = TOP_CLIP;\nthing->bottomclip = BOTTOM_CLIP;\n\nif (thing->y == oldtop)\n{\nthing->y = thing->bottomclip - thing->height;\n}\nelse if (thing->y + thing->height > thing->bottomclip)\n{\nthing->y = thing->bottomclip - thing->height;\n}\n\nreturn (thing->y >= oldtop);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_EndRead",
    "input":"\n0000000000000000 <I_EndRead>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_EndRead(void)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  IStream_t ;\n\n/* Variables and functions */\n\nvoid I_EndRead(IStream_t *stream)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_GetNumForName",
    "input":"\n0000000000000000 <W_GetNumForName>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdi, %rbx\n6: \tcallq\t0xb <W_GetNumForName+0xb>\nb: \tmovl\t%eax, %ebp\nd: \tcmpl\t$-1, %eax\n10: \tjne\t0x1f <W_GetNumForName+0x1f>\n12: \tmovl\t$0, %edi\n17: \tmovq\t%rbx, %rsi\n1a: \tcallq\t0x1f <W_GetNumForName+0x1f>\n1f: \tmovl\t%ebp, %eax\n21: \taddq\t$8, %rsp\n25: \tpopq\t%rbx\n26: \tpopq\t%rbp\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,char*) ;\nint W_CheckNumForName (char*) ;\n\nint W_GetNumForName (char* name)\n{\nint\ti;\n\ni = W_CheckNumForName (name);\n\nif (i == -1)\nI_Error (\"W_GetNumForName: %s not found!\", name);\n\nreturn i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint W_GetNumForName_aux (int /*<<< orphan*/ *,char const*) ;\nint /*<<< orphan*/  luaL_error (int /*<<< orphan*/ *,char*,char const*) ;\n\n__attribute__((used)) static int W_GetNumForName (lua_State *L) {\nint n = W_GetNumForName_aux(L, luaL_checkstring(L, 1));\nif (n == -1)\nluaL_error(L, \"unknown name '%s'\", luaL_checkstring(L, 1));\nreturn n;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_FreeMemory",
    "input":"\n0000000000000000 <Z_FreeMemory>:\n0: \tmovq\t(%rip), %rcx  # 0x7 <Z_FreeMemory+0x7>\n7: \tmovq\t24(%rcx), %rdx\nb: \txorl\t%eax, %eax\nd: \tcmpq\t%rcx, %rdx\n10: \tje\t0x39 <Z_FreeMemory+0x39>\n12: \tmovq\t(%rip), %rsi  # 0x19 <Z_FreeMemory+0x19>\n19: \tjmp\t0x2c <Z_FreeMemory+0x2c>\n1b: \tnopl\t(%rax,%rax)\n20: \taddl\t8(%rdx), %eax\n23: \tmovq\t24(%rdx), %rdx\n27: \tcmpq\t%rcx, %rdx\n2a: \tje\t0x39 <Z_FreeMemory+0x39>\n2c: \tcmpl\t$0, 16(%rdx)\n30: \tje\t0x20 <Z_FreeMemory+0x20>\n32: \tcmpq\t%rsi, (%rdx)\n35: \tjge\t0x20 <Z_FreeMemory+0x20>\n37: \tjmp\t0x23 <Z_FreeMemory+0x23>\n39: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ tag; scalar_t__ size; int /*<<< orphan*/  user; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ memblock_t ;\nstruct TYPE_4__ {TYPE_1__ blocklist; } ;\n\n/* Variables and functions */\nscalar_t__ PU_PURGELEVEL ;\nTYPE_2__* mainzone ;\n\nint Z_FreeMemory (void)\n{\nmemblock_t*\t\tblock;\nint\t\t\tfree;\n\nfree = 0;\n\nfor (block = mainzone->blocklist.next ;\nblock != &mainzone->blocklist;\nblock = block->next)\n{\nif (!block->user || block->tag >= PU_PURGELEVEL)\nfree += block->size;\n}\nreturn free;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ size; int /*<<< orphan*/  used; int /*<<< orphan*/  free; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ Z_Memory ;\n\n/* Variables and functions */\nTYPE_1__* Z_Memory_First ;\nTYPE_1__* Z_Memory_Last ;\n\nint Z_FreeMemory(void)\n{\nZ_Memory *p;\nint total = 0;\n\nfor (p = Z_Memory_First; p != Z_Memory_Last; p = p->next)\n{\nif (p->free)\ntotal += p->free;\nif (p->used >= p->size)\ncontinue;\nif (p->size >= Z_Memory_First->size)\nbreak;\n}\nreturn total;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_initColorXForm",
    "input":"\n0000000000000000 <wipe_initColorXForm>:\n0: \tpushq\t%rax\n1: \tmovl\t%edi, %edx\n3: \tmovl\t(%rip), %edi  # 0x9 <wipe_initColorXForm+0x9>\n9: \tmovl\t(%rip), %eax  # 0xf <wipe_initColorXForm+0xf>\nf: \timull\t%esi, %edx\n12: \tmovl\t%eax, %esi\n14: \tcallq\t0x19 <wipe_initColorXForm+0x19>\n19: \txorl\t%eax, %eax\n1b: \tpopq\t%rcx\n1c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  wipe_scr ;\nint /*<<< orphan*/  wipe_scr_start ;\n\nint\nwipe_initColorXForm\n( int\twidth,\nint\theight,\nint\tticks )\n{\nmemcpy(wipe_scr, wipe_scr_start, width*height);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\ntypedef  int /*<<< orphan*/  uint32_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AV_LOG_DEBUG ;\nint /*<<< orphan*/  av_log (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  color_xform ;\n\n__attribute__((used)) static int wipe_initColorXForm(uint8_t *dst, uint32_t width)\n{\nav_log(NULL, AV_LOG_DEBUG, \"wipe_initColorXForm\\n\");\ncolor_xform = width;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_PTR_UseTraverse",
    "input":"\n0000000000000000 <PTR_UseTraverse>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rdi), %rdx\n4: \tcmpl\t$0, (%rdx)\n7: \tje\t0x38 <PTR_UseTraverse+0x38>\n9: \tmovq\t%rdi, %rbx\nc: \tmovq\t(%rip), %rax  # 0x13 <PTR_UseTraverse+0x13>\n13: \tmovl\t(%rax), %esi\n15: \tmovl\t4(%rax), %edi\n18: \tcallq\t0x1d <PTR_UseTraverse+0x1d>\n1d: \txorl\t%edx, %edx\n1f: \tcmpl\t$1, %eax\n22: \tsete\t%dl\n25: \tmovq\t(%rip), %rdi  # 0x2c <PTR_UseTraverse+0x2c>\n2c: \tmovq\t(%rbx), %rsi\n2f: \tcallq\t0x34 <PTR_UseTraverse+0x34>\n34: \txorl\t%eax, %eax\n36: \tjmp\t0x4f <PTR_UseTraverse+0x4f>\n38: \tmovq\t%rdx, %rdi\n3b: \tcallq\t0x40 <PTR_UseTraverse+0x40>\n40: \tmovl\t$1, %eax\n45: \tcmpq\t$0, (%rip)    # 0x4d <PTR_UseTraverse+0x4d>\n4d: \tjle\t0x51 <PTR_UseTraverse+0x51>\n4f: \tpopq\t%rbx\n50: \tretq\n51: \tmovq\t(%rip), %rdi  # 0x58 <PTR_UseTraverse+0x58>\n58: \tmovl\t(%rip), %esi  # 0x5e <PTR_UseTraverse+0x5e>\n5e: \tcallq\t0x63 <PTR_UseTraverse+0x63>\n63: \tjmp\t0x34 <PTR_UseTraverse+0x34>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_6__ ;\ntypedef  struct TYPE_12__   TYPE_3__ ;\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_6__* line; } ;\nstruct TYPE_11__ {TYPE_1__ d; } ;\ntypedef  TYPE_2__ intercept_t ;\ntypedef  int boolean ;\nstruct TYPE_13__ {int /*<<< orphan*/  special; } ;\nstruct TYPE_12__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_LineOpening (TYPE_6__*) ;\nint P_PointOnLineSide (int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_6__*) ;\nint /*<<< orphan*/  P_UseSpecialLine (TYPE_3__*,TYPE_6__*,int) ;\nint /*<<< orphan*/  S_StartSound (TYPE_3__*,int /*<<< orphan*/ ) ;\nscalar_t__ openrange ;\nint /*<<< orphan*/  sfx_noway ;\nTYPE_3__* usething ;\n\nboolean\tPTR_UseTraverse (intercept_t* in)\n{\nint\t\tside;\n\nif (!in->d.line->special)\n{\nP_LineOpening (in->d.line);\nif (openrange <= 0)\n{\nS_StartSound (usething, sfx_noway);\n\n// can't use through a wall\nreturn false;\n}\n// not a special line, but keep checking\nreturn true ;\n}\n\nside = 0;\nif (P_PointOnLineSide (usething->x, usething->y, in->d.line) == 1)\nside = 1;\n\n//\treturn false;\t\t// don't use back side\n\nP_UseSpecialLine (usething, in->d.line, side);\n\n// can't use for than one special line in a row\nreturn false;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * ptr; } ;\ntypedef  TYPE_1__ PTR_Object ;\ntypedef  int /*<<< orphan*/  PTR_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PTR_FREE ;\nint /*<<< orphan*/  PTR_USED ;\nint /*<<< orphan*/  PTR_free (TYPE_1__*) ;\nint /*<<< orphan*/  PTR_mark (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTR_set_state (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PTR_traverse (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  gc_mark_stack ;\nint /*<<< orphan*/  gc_mark_stack_top ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr ;\nint /*<<< orphan*/  gc_mark_stack_top_ptr_ptr"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_finale.c_F_Ticker",
    "input":"\n0000000000000000 <F_Ticker>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rip), %rax  # 0x8 <F_Ticker+0x8>\n8: \tmovl\t(%rip), %ebx  # 0xe <F_Ticker+0xe>\ne: \tcmpq\t(%rip), %rax  # 0x15 <F_Ticker+0x15>\n15: \tjne\t0x66 <F_Ticker+0x66>\n17: \tcmpl\t$51, %ebx\n1a: \tjl\t0x66 <F_Ticker+0x66>\n1c: \tmovl\t(%rip), %eax  # 0x22 <F_Ticker+0x22>\n22: \ttestl\t%eax, %eax\n24: \tjle\t0x66 <F_Ticker+0x66>\n26: \tmovq\t(%rip), %rcx  # 0x2d <F_Ticker+0x2d>\n2d: \txorl\t%edx, %edx\n2f: \tnop\n30: \tcmpq\t$0, (%rcx,%rdx,8)\n35: \tjne\t0x42 <F_Ticker+0x42>\n37: \taddq\t$1, %rdx\n3b: \tcmpq\t%rax, %rdx\n3e: \tjb\t0x30 <F_Ticker+0x30>\n40: \tjmp\t0x66 <F_Ticker+0x66>\n42: \tcmpl\t$30, (%rip)   # 0x49 <F_Ticker+0x49>\n49: \tjne\t0x5a <F_Ticker+0x5a>\n4b: \txorl\t%eax, %eax\n4d: \tcallq\t0x52 <F_Ticker+0x52>\n52: \tmovl\t(%rip), %ebx  # 0x58 <F_Ticker+0x58>\n58: \tjmp\t0x66 <F_Ticker+0x66>\n5a: \tmovl\t(%rip), %eax  # 0x60 <F_Ticker+0x60>\n60: \tmovl\t%eax, (%rip)  # 0x66 <F_Ticker+0x66>\n66: \tleal\t1(%rbx), %eax\n69: \tmovl\t%eax, (%rip)  # 0x6f <F_Ticker+0x6f>\n6f: \tmovl\t(%rip), %eax  # 0x75 <F_Ticker+0x75>\n75: \tcmpl\t$2, %eax\n78: \tjne\t0x82 <F_Ticker+0x82>\n7a: \txorl\t%eax, %eax\n7c: \tpopq\t%rbx\n7d: \tjmp\t0x82 <F_Ticker+0x82>\n82: \ttestl\t%eax, %eax\n84: \tjne\t0xe5 <F_Ticker+0xe5>\n86: \tmovq\t(%rip), %rax  # 0x8d <F_Ticker+0x8d>\n8d: \tcmpq\t%rax, (%rip)  # 0x94 <F_Ticker+0x94>\n94: \tje\t0xe5 <F_Ticker+0xe5>\n96: \tmovl\t(%rip), %edi  # 0x9c <F_Ticker+0x9c>\n9c: \tcallq\t0xa1 <F_Ticker+0xa1>\na1: \timull\t(%rip), %eax  # 0xa8 <F_Ticker+0xa8>\na8: \taddl\t(%rip), %eax  # 0xae <F_Ticker+0xae>\nae: \tcmpl\t%eax, %ebx\nb0: \tjl\t0xe5 <F_Ticker+0xe5>\nb2: \tmovl\t$0, (%rip)    # 0xbc <F_Ticker+0xbc>\nbc: \tmovl\t$1, (%rip)    # 0xc6 <F_Ticker+0xc6>\nc6: \tmovl\t$4294967295, (%rip)# imm = 0xFFFFFFFF\n# 0xd0 <F_Ticker+0xd0>\nd0: \tcmpl\t$3, (%rip)    # 0xd7 <F_Ticker+0xd7>\nd7: \tjne\t0xe5 <F_Ticker+0xe5>\nd9: \tmovl\t(%rip), %edi  # 0xdf <F_Ticker+0xdf>\ndf: \tpopq\t%rbx\ne0: \tjmp\t0xe5 <F_Ticker+0xe5>\ne5: \tpopq\t%rbx\ne6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ buttons; } ;\nstruct TYPE_4__ {TYPE_1__ cmd; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  F_CastTicker () ;\nint /*<<< orphan*/  F_StartCast () ;\nint MAXPLAYERS ;\nint /*<<< orphan*/  S_StartMusic (int /*<<< orphan*/ ) ;\nint TEXTSPEED ;\nint TEXTWAIT ;\nscalar_t__ commercial ;\nint finalecount ;\nint finalestage ;\nint /*<<< orphan*/  finaletext ;\nint /*<<< orphan*/  ga_worlddone ;\nint /*<<< orphan*/  gameaction ;\nint gameepisode ;\nint gamemap ;\nscalar_t__ gamemode ;\nint /*<<< orphan*/  mus_bunny ;\nTYPE_2__* players ;\nint strlen (int /*<<< orphan*/ ) ;\nint wipegamestate ;\n\nvoid F_Ticker (void)\n{\nint\t\ti;\n\n// check for skipping\nif ( (gamemode == commercial)\n&& ( finalecount > 50) )\n{\n// go on to the next level\nfor (i=0 ; i<MAXPLAYERS ; i++)\nif (players[i].cmd.buttons)\nbreak;\n\nif (i < MAXPLAYERS)\n{\nif (gamemap == 30)\nF_StartCast ();\nelse\ngameaction = ga_worlddone;\n}\n}\n\n// advance animation\nfinalecount++;\n\nif (finalestage == 2)\n{\nF_CastTicker ();\nreturn;\n}\n\nif ( gamemode == commercial)\nreturn;\n\nif (!finalestage && finalecount>strlen (finaletext)*TEXTSPEED + TEXTWAIT)\n{\nfinalecount = 0;\nfinalestage = 1;\nwipegamestate = -1;\t\t// force a wipe\nif (gameepisode == 3)\nS_StartMusic (mus_bunny);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_Draw () ;\nint /*<<< orphan*/  F_Draw_BG () ;\nint /*<<< orphan*/  F_Draw_FG () ;\nint /*<<< orphan*/  F_Draw_Pause () ;\nint /*<<< orphan*/  F_Draw_Title () ;\nint /*<<< orphan*/  F_Draw_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Title () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_BG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_FG () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Wave_Pause () ;\nint /*<<< orphan*/  F_Draw_Wave_Wave_W"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SkelMissile",
    "input":"\n0000000000000000 <A_SkelMissile>:\n0: \tpushq\t%rbx\n1: \tcmpq\t$0, 8(%rdi)\n6: \tje\t0x4c <A_SkelMissile+0x4c>\n8: \tmovq\t%rdi, %rbx\nb: \tcallq\t0x10 <A_SkelMissile+0x10>\n10: \tmovl\t(%rip), %eax  # 0x16 <A_SkelMissile+0x16>\n16: \tshll\t$4, %eax\n19: \taddl\t%eax, (%rbx)\n1b: \tmovq\t8(%rbx), %rsi\n1f: \tmovl\t(%rip), %edx  # 0x25 <A_SkelMissile+0x25>\n25: \tmovq\t%rbx, %rdi\n28: \tcallq\t0x2d <A_SkelMissile+0x2d>\n2d: \tmovl\t(%rip), %ecx  # 0x33 <A_SkelMissile+0x33>\n33: \tshll\t$4, %ecx\n36: \tsubl\t%ecx, (%rbx)\n38: \tmovl\t24(%rax), %ecx\n3b: \tmovl\t40(%rax), %edx\n3e: \taddl\t%edx, 48(%rax)\n41: \taddl\t%ecx, 32(%rax)\n44: \tmovq\t8(%rbx), %rcx\n48: \tmovq\t%rcx, 16(%rax)\n4c: \tpopq\t%rbx\n4d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int z; scalar_t__ target; scalar_t__ tracer; scalar_t__ momy; int /*<<< orphan*/  y; scalar_t__ momx; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint FRACUNIT ;\nint /*<<< orphan*/  MT_TRACER ;\nTYPE_1__* P_SpawnMissile (TYPE_1__*,scalar_t__,int /*<<< orphan*/ ) ;\n\nvoid A_SkelMissile (mobj_t* actor)\n{\nmobj_t*\tmo;\n\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nactor->z += 16*FRACUNIT;\t// so missile spawns higher\nmo = P_SpawnMissile (actor, actor->target, MT_TRACER);\nactor->z -= 16*FRACUNIT;\t// back to normal\n\nmo->x += mo->momx;\nmo->y += mo->momy;\nmo->tracer = actor->target;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; } ;\ntypedef  TYPE_1__ D3DVECTOR ;\ntypedef  TYPE_2__ D3DVECTOR2 ;\ntypedef  int /*<<< orphan*/  BOOLEAN ;\ntypedef  int /*<<< orphan*/  ACTOR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SkelMissile2 ;\nint /*<<< orphan*/  A_SkelMissile3 ;\nint /*<<< orphan*/  A_SkelMissile4 ;\nint /*<<< orphan*/  A_SkelMissile5 ;\nint /*<<< orphan*/  A_SkelMissile6 ;\nint /*<<< orphan*/  A_SkelMissile7 ;\nint /*<<< orphan*/  A_SkelMissile8 ;\nint /*<<< orphan*/  A_SkelMissile9 ;\nint /*<<< orphan*/  A_SkelMissile10 ;\nint /*<<< orphan*/  A_SkelMissile11 ;\nint /*<<< orphan*/  A_SkelMissile12 ;\nint /*<<< orphan*/  A_SkelMissile13 ;\nint /*<<< orphan*/  A_SkelMissile14 ;\nint /*<<< orphan*/  A_SkelMissile15 ;\nint /*<<< orphan*/  A_SkelMissile16 ;\nint /*<<< orphan*/  A_SkelMissile17 ;\nint /*<<< orphan*/  A_SkelMissile18 ;\nint /*<<< orphan*/  A_SkelMissile19 ;\nint /*<<< orphan*/  A_SkelMissile20 ;\nint /*<<< orphan*/  A_SkelMissile21 ;\nint /*<<< orphan*/  A_SkelMissile22 ;\nint /*<<< orphan*/  A_SkelMissile23 ;\nint /*<<< orphan*/  A_SkelMissile24 ;\nint /*<<< orphan*/  A_SkelMissile25 ;\nint /*<<< orphan*/  A_SkelMissile26 ;\nint /*<<< orphan*/  A_SkelMissile27 ;\nint /*<<< orphan*/  A_SkelMissile28 ;\nint /*<<< orphan*/  A_SkelMissile29 ;\nint /*<<< orphan*/  A_SkelMissile30 ;\nint /*<<< orphan*/  A_SkelMissile31 ;\nint /*<<< orphan*/  A_SkelMissile32 ;\nint /*<<< orphan*/  A_SkelMissile33 ;\nint /*<<< orphan*/  A_SkelMissile34 ;\nint /*<<< orphan*/  A_SkelMissile35 ;\nint /*<<< orphan*/  A_SkelMissile36 ;\nint /*<<< orphan*/  A_SkelMissile37 ;\nint /*<<< orphan*/  A_SkelMissile38 ;\nint /*<<< orphan*/  A_SkelMissile39 ;\nint /*<<< orphan*/  A_SkelMissile40 ;\nint /*<<< orphan*/  A_SkelMissile41 ;\nint /*<<< orphan*/  A_SkelMissile42 ;\nint /*<<< orphan*/  A_SkelMissile43 ;\nint /*<<< orphan*/  A_SkelMissile44 ;\nint /*<<< orphan*/  A_SkelMissile45 ;\nint /*<<< orphan*/  A_SkelMissile46 ;\nint /*<<< orphan*/  A_SkelMissile47 ;\nint /*<<< orphan*/  A_SkelMissile48 ;\nint /*<<< orphan*/  A_SkelMissile49 ;\nint /*<<< orphan*/  A_SkelMissile50 ;\nint /*<<< orphan*/  A_SkelMissile51 ;\nint /*<<< orphan*/  A_SkelMissile52 ;\nint /*<<< orphan*/  A_SkelMissile53 ;\nint /*<<< orphan*/  A_SkelMissile54 ;\nint /*<<< orphan*/  A_SkelMissile55 ;\nint /*<<< orphan*/  A_SkelMissile56 ;\nint /*<<< orphan*/  A_SkelMissile57 ;\nint /*<<< orphan*/  A_SkelMissile58 ;\nint /*<<< orphan*/  A_SkelMissile59 ;\nint /*<<< orphan*/  A_SkelMissile60 ;\nint /*<<< orphan*/  A_SkelMissile61 ;\nint /*<<< orphan*/  A_SkelMissile62 ;\nint /*<<< orphan*/  A_SkelMissile63 ;\nint /*<<< orphan*/  A_SkelMissile64 ;\nint /*<<< orphan*/  A_SkelMissile65 ;\nint /*<<< orphan*/  A_SkelMissile66 ;\nint /*<<< orphan*/  A_SkelMissile67 ;\nint /*<<< orphan*/  A_SkelMissile68 ;\nint /*<<< orphan*/  A_SkelMissile69 ;\nint /*<<< orphan*/  A_SkelMissile70 ;\nint /*<<< orphan*/  A_SkelMissile71 ;\nint /*<<< orphan*/  A_SkelMissile72 ;\nint /*<<< orphan*/  A_SkelMissile73 ;\nint /*<<< orphan*/  A_SkelMissile74 ;\nint /*<<< orphan*/  A_SkelMissile75 ;\nint /*<<< orphan*/  A_SkelMissile76 ;\nint /*<<< orphan*/  A_SkelMissile77 ;\nint /*<<< orphan*/  A_SkelMissile78 ;\nint /*<<< orphan*/  A_SkelMissile79 ;\nint /*<<< orphan*/  A_SkelMissile80 ;\nint /*<<< orphan*/  A_SkelMissile81 ;\nint /*<<< orphan*/  A_SkelMissile82 ;\nint /*<<< orphan*/  A_SkelMissile83 ;\nint /*<<< orphan*/  A_SkelMissile84 ;\nint /*<<< orphan*/  A_SkelMissile85 ;\nint /*<<< orphan*/  A_SkelMissile86 ;\nint /*<<< orphan*/  A_SkelMissile87 ;\nint /*<<< orphan*/  A_SkelMissile88 ;\nint /*<<< orphan*/  A_SkelMissile89 ;\nint /*<<< orphan*/  A_SkelMissile90 ;\nint /*<<< orphan*/  A_SkelMissile91 ;\nint /*<<< orphan*/  A_SkelMissile92 ;\nint /*<<< orphan*/  A_SkelMissile93 ;\nint /*<<< orphan*/  A_SkelMissile94 ;\nint /*<<< orphan*/  A_SkelMissile95 ;\nint /*<<< orphan*/  A_SkelMissile96 ;\nint /*<<< orphan*/  A_SkelMissile97 ;\nint /*<<< orphan*/  A_SkelMissile98 ;\nint /*<<< orphan*/  A_SkelMissile99 ;\nint /*<<< orphan*/  A_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_cheat.c_cht_GetParam",
    "input":"\n0000000000000000 <cht_GetParam>:\n0: \tmovq\t(%rdi), %rax\n3: \tnopw\t%cs:(%rax,%rax)\nd: \tnopl\t(%rax)\n10: \tcmpb\t$1, (%rax)\n13: \tleaq\t1(%rax), %rax\n17: \tjne\t0x10 <cht_GetParam+0x10>\n19: \tmovb\t(%rax), %cl\n1b: \tmovl\t$1, %edi\n20: \tmovq\t%rdi, %rdx\n23: \tmovb\t%cl, -1(%rsi,%rdi)\n27: \tmovb\t$0, -1(%rax,%rdi)\n2c: \ttestb\t%cl, %cl\n2e: \tmovzbl\t(%rax,%rdi), %ecx\n32: \tje\t0x3f <cht_GetParam+0x3f>\n34: \tleaq\t1(%rdx), %rdi\n38: \tcmpb\t$-1, %cl\n3b: \tjne\t0x20 <cht_GetParam+0x20>\n3d: \tjmp\t0x45 <cht_GetParam+0x45>\n3f: \tcmpb\t$-1, %cl\n42: \tje\t0x45 <cht_GetParam+0x45>\n44: \tretq\n45: \tmovb\t$0, (%rsi,%rdx)\n49: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {unsigned char* sequence; } ;\ntypedef  TYPE_1__ cheatseq_t ;\n\n/* Variables and functions */\n\nvoid\ncht_GetParam\n( cheatseq_t*\tcht,\nchar*\t\tbuffer )\n{\n\nunsigned char *p, c;\n\np = cht->sequence;\nwhile (*(p++) != 1);\n\ndo\n{\nc = *p;\n*(buffer++) = c;\n*(p++) = 0;\n}\nwhile (c && *p!=0xff );\n\nif (*p==0xff)\n*buffer = 0;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static void cht_GetParam(const char *str, char *param)\n{\nconst char *p = str;\n\nwhile (*p != '\\0' && *p != ' ')\np++;\n\nif (*p == '\\0')\nreturn;\n\n*param++ = *p++;\nwhile (*p != '\\0' && *p != ' ')\n*param++ = *p++;\n*param = '\\0';\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_net.c_I_NetCmd",
    "input":"\n0000000000000000 <I_NetCmd>:\n0: \tmovq\t(%rip), %rax  # 0x7 <I_NetCmd+0x7>\n7: \tmovq\t(%rax), %rsi\na: \tcmpq\t(%rip), %rsi  # 0x11 <I_NetCmd+0x11>\n11: \tjne\t0x1a <I_NetCmd+0x1a>\n13: \txorl\t%eax, %eax\n15: \tjmp\t0x1a <I_NetCmd+0x1a>\n1a: \tcmpq\t(%rip), %rsi  # 0x21 <I_NetCmd+0x21>\n21: \tjne\t0x2a <I_NetCmd+0x2a>\n23: \txorl\t%eax, %eax\n25: \tjmp\t0x2a <I_NetCmd+0x2a>\n2a: \tmovl\t$0, %edi\n2f: \tjmp\t0x34 <I_NetCmd+0x34>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ command; } ;\n\n/* Variables and functions */\nscalar_t__ CMD_GET ;\nscalar_t__ CMD_SEND ;\nint /*<<< orphan*/  I_Error (char*,scalar_t__) ;\nTYPE_1__* doomcom ;\nint /*<<< orphan*/  netget () ;\nint /*<<< orphan*/  netsend () ;\n\nvoid I_NetCmd (void)\n{\nif (doomcom->command == CMD_SEND)\n{\nnetsend ();\n}\nelse if (doomcom->command == CMD_GET)\n{\nnetget ();\n}\nelse\nI_Error (\"Bad net cmd: %i\\n\",doomcom->command);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ cmd; } ;\n\n/* Variables and functions */\nscalar_t__ CMD_NET_CLOSE ;\nscalar_t__ CMD_NET_OPEN ;\nint /*<<< orphan*/  I_NetClose () ;\nint /*<<< orphan*/  I_NetOpen () ;\nint /*<<< orphan*/  printf (char*) ;\nTYPE_1__* net_cmd ;\n\nvoid I_NetCmd(void)\n{\nif (net_cmd->cmd == CMD_NET_OPEN)\nI_NetOpen();\nelse if (net_cmd->cmd == CMD_NET_CLOSE)\nI_NetClose();\nelse\nprintf(\"Unknown net command\\n\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_BulletSlope",
    "input":"\n0000000000000000 <P_BulletSlope>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tmovl\t(%rdi), %r14d\na: \tmovl\t(%rip), %edx  # 0x10 <P_BulletSlope+0x10>\n10: \tshll\t$10, %edx\n13: \tmovl\t%r14d, %esi\n16: \tcallq\t0x1b <P_BulletSlope+0x1b>\n1b: \tmovl\t%eax, (%rip)  # 0x21 <P_BulletSlope+0x21>\n21: \tcmpl\t$0, (%rip)    # 0x28 <P_BulletSlope+0x28>\n28: \tjne\t0x72 <P_BulletSlope+0x72>\n2a: \tleal\t67108864(%r14), %esi\n31: \tmovl\t(%rip), %edx  # 0x37 <P_BulletSlope+0x37>\n37: \tshll\t$10, %edx\n3a: \tmovq\t%rbx, %rdi\n3d: \tcallq\t0x42 <P_BulletSlope+0x42>\n42: \tmovl\t%eax, (%rip)  # 0x48 <P_BulletSlope+0x48>\n48: \tcmpl\t$0, (%rip)    # 0x4f <P_BulletSlope+0x4f>\n4f: \tjne\t0x72 <P_BulletSlope+0x72>\n51: \taddl\t$4227858432, %r14d # imm = 0xFC000000\n58: \tmovl\t(%rip), %edx  # 0x5e <P_BulletSlope+0x5e>\n5e: \tshll\t$10, %edx\n61: \tmovq\t%rbx, %rdi\n64: \tmovl\t%r14d, %esi\n67: \tcallq\t0x6c <P_BulletSlope+0x6c>\n6c: \tmovl\t%eax, (%rip)  # 0x72 <P_BulletSlope+0x72>\n72: \taddq\t$8, %rsp\n76: \tpopq\t%rbx\n77: \tpopq\t%r14\n79: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int angle; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int angle_t ;\n\n/* Variables and functions */\nint FRACUNIT ;\nint /*<<< orphan*/  P_AimLineAttack (TYPE_1__*,int,int) ;\nint /*<<< orphan*/  bulletslope ;\nint /*<<< orphan*/  linetarget ;\n\nvoid P_BulletSlope (mobj_t*\tmo)\n{\nangle_t\tan;\n\n// see which target is to be aimed at\nan = mo->angle;\nbulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\nif (!linetarget)\n{\nan += 1<<26;\nbulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\nif (!linetarget)\n{\nan -= 2<<26;\nbulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; } ;\ntypedef  TYPE_1__ D3DVECTOR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_BulletSlope1 ;\nint /*<<< orphan*/  P_BulletSlope2 ;\nint /*<<< orphan*/  P_BulletSlope3 ;\nint /*<<< orphan*/  P_BulletSlope4 ;\nint /*<<< orphan*/  P_BulletSlope5 ;\nint /*<<< orphan*/  P_BulletSlope6 ;\nint /*<<< orphan*/  P_BulletSlope7 ;\nint /*<<< orphan*/  P_BulletSlope8 ;\nint /*<<< orphan*/  P_BulletSlope9 ;\nint /*<<< orphan*/  P_BulletSlope10 ;\nint /*<<< orphan*/  P_BulletSlope11 ;\nint /*<<< orphan*/  P_BulletSlope12 ;\nint /*<<< orphan*/  P_BulletSlope13 ;\nint /*<<< orphan*/  P_BulletSlope14 ;\nint /*<<< orphan*/  P_BulletSlope15 ;\nint /*<<< orphan*/  P_BulletSlope16 ;\nint /*<<< orphan*/  P_BulletSlope17 ;\nint /*<<< orphan*/  P_BulletSlope18 ;\nint /*<<< orphan*/  P_BulletSlope19 ;\nint /*<<< orphan*/  P_BulletSlope20 ;\nint /*<<< orphan*/  P_BulletSlope21 ;\nint /*<<< orphan*/  P_BulletSlope22 ;\nint /*<<< orphan*/  P_BulletSlope23 ;\nint /*<<< orphan*/  P_BulletSlope24 ;\nint /*<<< orphan*/  P_BulletSlope25 ;\nint /*<<< orphan*/  P_BulletSlope26 ;\nint /*<<< orphan*/  P_BulletSlope27 ;\nint /*<<< orphan*/  P_BulletSlope28 ;\nint /*<<< orphan*/  P_BulletSlope29 ;\nint /*<<< orphan*/  P_BulletSlope30 ;\nint /*<<< orphan*/  P_BulletSlope31 ;\nint /*<<< orphan*/  P_BulletSlope32 ;\nint /*<<< orphan*/  P_BulletSlope33 ;\nint /*<<< orphan*/  P_BulletSlope34 ;\nint /*<<< orphan*/  P_BulletSlope35 ;\nint /*<<< orphan*/  P_BulletSlope36 ;\nint /*<<< orphan*/  P_BulletSlope37 ;\nint /*<<< orphan*/  P_BulletSlope38 ;\nint /*<<< orphan*/  P_BulletSlope39 ;\nint /*<<< orphan*/  P_BulletSlope40 ;\nint /*<<< orphan*/  P_BulletSlope41 ;\nint /*<<< orphan*/  P_BulletSlope42 ;\nint /*<<< orphan*/  P_BulletSlope43 ;\nint /*<<< orphan*/  P_BulletSlope44 ;\nint /*<<< orphan*/  P_BulletSlope45 ;\nint /*<<< orphan*/  P_BulletSlope46 ;\nint /*<<< orphan*/  P_BulletSlope47 ;\nint /*<<< orphan*/  P_BulletSlope48 ;\nint /*<<< orphan*/  P_BulletSlope49 ;\nint /*<<< orphan*/  P_BulletSlope50 ;\nint /*<<< orphan*/  P_BulletSlope51 ;\nint /*<<< orphan*/  P_BulletSlope52 ;\nint /*<<< orphan*/  P_BulletSlope53 ;\nint /*<<< orphan*/  P_BulletSlope54 ;\nint /*<<< orphan*/  P_BulletSlope55 ;\nint /*<<< orphan*/  P_BulletSlope56 ;\nint /*<<< orphan*/  P_BulletSlope57 ;\nint /*<<< orphan*/  P_BulletSlope58 ;\nint /*<<< orphan*/  P_BulletSlope59 ;\nint /*<<< orphan*/  P_BulletSlope60 ;\nint /*<<< orphan*/  P_BulletSlope61 ;\nint /*<<< orphan*/  P_BulletSlope62 ;\nint /*<<< orphan*/  P_BulletSlope63 ;\nint /*<<< orphan*/  P_BulletSlope64 ;\nint /*<<< orphan*/  P_BulletSlope65 ;\nint /*<<< orphan*/  P_BulletSlope66 ;\nint /*<<< orphan*/  P_BulletSlope67 ;\nint /*<<< orphan*/  P_BulletSlope68 ;\nint /*<<< orphan*/  P_BulletSlope69 ;\nint /*<<< orphan*/  P_BulletSlope70 ;\nint /*<<< orphan*/  P_BulletSlope71 ;\nint /*<<< orphan*/  P_BulletSlope72 ;\nint /*<<< orphan*/  P_BulletSlope73 ;\nint /*<<< orphan*/  P_BulletSlope74 ;\nint /*<<< orphan*/  P_BulletSlope75 ;\nint /*<<< orphan*/  P_BulletSlope76 ;\nint /*<<< orphan*/  P_BulletSlope77 ;\nint /*<<< orphan*/  P_BulletSlope78 ;\nint /*<<< orphan*/  P_BulletSlope79 ;\nint /*<<< orphan*/  P_BulletSlope80 ;\nint /*<<< orphan*/  P_BulletSlope81 ;\nint /*<<< orphan*/  P_BulletSlope82 ;\nint /*<<< orphan*/  P_BulletSlope83 ;\nint /*<<< orphan*/  P_BulletSlope84 ;\nint /*<<< orphan*/  P_BulletSlope85 ;\nint /*<<< orphan*/  P_BulletSlope86 ;\nint /*<<< orphan*/  P_BulletSlope87 ;\nint /*<<< orphan*/  P_BulletSlope88 ;\nint /*<<< orphan*/  P_BulletSlope89 ;\nint /*<<< orphan*/  P_BulletSlope90 ;\nint /*<<< orphan*/  P_BulletSlope91 ;\nint /*<<< orphan*/  P_BulletSlope92 ;\nint /*<<< orphan*/  P_BulletSlope93 ;\nint /*<<< orphan*/  P_BulletSlope94 ;\nint /*<<< orphan*/  P_Bullet"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_addLineToSText",
    "input":"\n0000000000000000 <HUlib_addLineToSText>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t(%rdi), %rax\n7: \taddq\t$1, %rax\nb: \txorl\t%edi, %edi\nd: \tcmpq\t8(%rbx), %rax\n11: \tcmovneq\t%rax, %rdi\n15: \tmovq\t%rdi, (%rbx)\n18: \tshlq\t$2, %rdi\n1c: \taddq\t16(%rbx), %rdi\n20: \tcallq\t0x25 <HUlib_addLineToSText+0x25>\n25: \tmovq\t8(%rbx), %rax\n29: \ttestq\t%rax, %rax\n2c: \tje\t0x140 <HUlib_addLineToSText+0x140>\n32: \tmovq\t16(%rbx), %rcx\n36: \tcmpq\t$8, %rax\n3a: \tjae\t0x43 <HUlib_addLineToSText+0x43>\n3c: \txorl\t%edx, %edx\n3e: \tjmp\t0x130 <HUlib_addLineToSText+0x130>\n43: \tmovq\t%rax, %rdx\n46: \tandq\t$-8, %rdx\n4a: \tleaq\t-8(%rdx), %rbx\n4e: \tmovq\t%rbx, %rdi\n51: \tshrq\t$3, %rdi\n55: \taddq\t$1, %rdi\n59: \tmovl\t%edi, %esi\n5b: \tandl\t$7, %esi\n5e: \tcmpq\t$56, %rbx\n62: \tjae\t0x6b <HUlib_addLineToSText+0x6b>\n64: \txorl\t%ebx, %ebx\n66: \tjmp\t0xf1 <HUlib_addLineToSText+0xf1>\n6b: \tsubq\t%rsi, %rdi\n6e: \txorl\t%ebx, %ebx\n70: \tmovaps\t(%rip), %xmm0 # 0x77 <HUlib_addLineToSText+0x77>\n77: \tnopw\t(%rax,%rax)\n80: \tmovups\t%xmm0, (%rcx,%rbx,4)\n84: \tmovups\t%xmm0, 16(%rcx,%rbx,4)\n89: \tmovups\t%xmm0, 32(%rcx,%rbx,4)\n8e: \tmovups\t%xmm0, 48(%rcx,%rbx,4)\n93: \tmovups\t%xmm0, 64(%rcx,%rbx,4)\n98: \tmovups\t%xmm0, 80(%rcx,%rbx,4)\n9d: \tmovups\t%xmm0, 96(%rcx,%rbx,4)\na2: \tmovups\t%xmm0, 112(%rcx,%rbx,4)\na7: \tmovups\t%xmm0, 128(%rcx,%rbx,4)\naf: \tmovups\t%xmm0, 144(%rcx,%rbx,4)\nb7: \tmovups\t%xmm0, 160(%rcx,%rbx,4)\nbf: \tmovups\t%xmm0, 176(%rcx,%rbx,4)\nc7: \tmovups\t%xmm0, 192(%rcx,%rbx,4)\ncf: \tmovups\t%xmm0, 208(%rcx,%rbx,4)\nd7: \tmovups\t%xmm0, 224(%rcx,%rbx,4)\ndf: \tmovups\t%xmm0, 240(%rcx,%rbx,4)\ne7: \taddq\t$64, %rbx\neb: \taddq\t$-8, %rdi\nef: \tjne\t0x80 <HUlib_addLineToSText+0x80>\nf1: \ttestq\t%rsi, %rsi\nf4: \tje\t0x120 <HUlib_addLineToSText+0x120>\nf6: \tleaq\t(%rcx,%rbx,4), %rdi\nfa: \taddq\t$16, %rdi\nfe: \tnegq\t%rsi\n101: \tmovaps\t(%rip), %xmm0 # 0x108 <HUlib_addLineToSText+0x108>\n108: \tnopl\t(%rax,%rax)\n110: \tmovups\t%xmm0, -16(%rdi)\n114: \tmovups\t%xmm0, (%rdi)\n117: \taddq\t$32, %rdi\n11b: \tincq\t%rsi\n11e: \tjne\t0x110 <HUlib_addLineToSText+0x110>\n120: \tcmpq\t%rdx, %rax\n123: \tje\t0x140 <HUlib_addLineToSText+0x140>\n125: \tnopw\t%cs:(%rax,%rax)\n12f: \tnop\n130: \tmovl\t$4, (%rcx,%rdx,4)\n137: \taddq\t$1, %rdx\n13b: \tcmpq\t%rdx, %rax\n13e: \tja\t0x130 <HUlib_addLineToSText+0x130>\n140: \tpopq\t%rbx\n141: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t cl; size_t h; TYPE_2__* l; } ;\ntypedef  TYPE_1__ hu_stext_t ;\nstruct TYPE_5__ {int needsupdate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_clearTextLine (TYPE_2__*) ;\n\nvoid HUlib_addLineToSText(hu_stext_t* s)\n{\n\nint i;\n\n// add a clear line\nif (++s->cl == s->h)\ns->cl = 0;\nHUlib_clearTextLine(&s->l[s->cl]);\n\n// everything needs updating\nfor (i=0 ; i<s->h ; i++)\ns->l[i].needsupdate = 4;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t line; int /*<<< orphan*/ * text; } ;\ntypedef  TYPE_1__ HUlib_SText ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memset (int /*<<< orphan*/ *,int /*<<< orphan*/ ,size_t) ;\n\nvoid HUlib_addLineToSText(HUlib_SText *stext)\n{\nsize_t line = stext->line + 1;\n\nif (line > 0xff)\nline = 0;\n\nstext->line = line;\n\nif (line > 0)\n{\nsize_t i;\n\nif (line > 8)\n{\nfor (i = 0; i < line; i += 8)\n{\nmemset(stext->text + i, 0, 8 * sizeof(int));\n}\n}\nelse\n{\nfor (i = 0; i < line; i++)\n{\nstext->text[i] = 0;\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_swap.c_SwapSHORT",
    "input":"\n0000000000000000 <SwapSHORT>:\n0: \tmovl\t%edi, %eax\n2: \trolw\t$8, %ax\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nunsigned short SwapSHORT(unsigned short x)\n{\n// No masking with 0xFF should be necessary.\nreturn (x>>8) | (x<<8);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int WORD ;\n\n/* Variables and functions */\n\n__attribute__((used)) static inline WORD SwapSHORT(WORD w)\n{\nreturn ((w & 0xff) << 8) | ((w & 0xff00) >> 8);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_InitExpand2",
    "input":"\n0000000000000000 <InitExpand2>:\n0: \tpushq\t%rbx\n1: \tmovl\t$0, %edi\n6: \tcallq\t0xb <InitExpand2+0xb>\nb: \txorl\t%r8d, %r8d\ne: \tmovq\t(%rip), %r9   # 0x15 <InitExpand2+0x15>\n15: \tnopw\t%cs:(%rax,%rax)\n1f: \tnop\n20: \tmovl\t%r8d, %eax\n23: \tshll\t$8, %eax\n26: \torl\t%r8d, %eax\n29: \tmovl\t%r8d, %ecx\n2c: \tshll\t$16, %ecx\n2f: \tmovl\t%r8d, %edx\n32: \tshll\t$24, %edx\n35: \torl\t%ecx, %edx\n37: \torl\t%eax, %edx\n39: \tmovl\t$256, %r10d   # imm = 0x100\n3f: \tmovl\t$65536, %edi  # imm = 0x10000\n44: \tmovl\t$16777216, %eax    # imm = 0x1000000\n49: \txorl\t%ecx, %ecx\n4b: \tnopl\t(%rax,%rax)\n50: \tleal\t-256(%r10), %esi\n57: \torl\t%ecx, %esi\n59: \tleal\t-65536(%rdi), %r11d\n60: \tleal\t-16777216(%rax), %ebx\n66: \torl\t%r11d, %ebx\n69: \torl\t%esi, %ebx\n6b: \tshlq\t$32, %rbx\n6f: \tmovl\t%edx, %esi\n71: \torq\t%rsi, %rbx\n74: \tmovq\t%rbx, (%r9)\n77: \tleal\t1(%rcx), %ebx\n7a: \tmovl\t%r10d, %edx\n7d: \torl\t%edi, %edx\n7f: \torl\t%ebx, %edx\n81: \torl\t%eax, %edx\n83: \tshlq\t$32, %rdx\n87: \torq\t%rsi, %rdx\n8a: \tmovq\t%rdx, 8(%r9)\n8e: \taddq\t$16, %r9\n92: \taddl\t$512, %r10d   # imm = 0x200\n99: \taddl\t$131072, %edi # imm = 0x20000\n9f: \taddl\t$33554432, %eax    # imm = 0x2000000\na4: \taddl\t$2, %ecx\na7: \tcmpl\t$256, %ecx    # imm = 0x100\nad: \tjne\t0x50 <InitExpand2+0x50>\naf: \taddl\t$1, %r8d\nb3: \tcmpl\t$256, %r8d    # imm = 0x100\nba: \tjne\t0x20 <InitExpand2+0x20>\nc0: \tmovl\t$0, %edi\nc5: \tpopq\t%rbx\nc6: \tjmp\t0xcb <InitExpand2+0xcb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\ndouble* exptable2 ;\nint /*<<< orphan*/  printf (char*) ;\n\nvoid InitExpand2 (void)\n{\nint\t\ti;\nint\t\tj;\n// UNUSED unsigned\tiexp, jexp;\ndouble*\texp;\nunion\n{\ndouble \t\td;\nunsigned\tu[2];\n} pixel;\n\nprintf (\"building exptable2...\\n\");\nexp = exptable2;\nfor (i=0 ; i<256 ; i++)\n{\npixel.u[0] = i | (i<<8) | (i<<16) | (i<<24);\nfor (j=0 ; j<256 ; j++)\n{\npixel.u[1] = j | (j<<8) | (j<<16) | (j<<24);\n*exp++ = pixel.d;\n}\n}\nprintf (\"done.\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int ULONG ;\ntypedef  int* PULONG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TRACE (char*) ;\nint* g_Expand2 ;\n\nvoid InitExpand2(void)\n{\nULONG i, j;\n\nTRACE(\"InitExpand2\\n\");\n\nfor (i = 0; i < 256; i++)\nfor (j = 0; j < 256; j++)\ng_Expand2[i * 256 + j] = (i << 8) | j;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_bbox.c_M_ClearBox",
    "input":"\n0000000000000000 <M_ClearBox>:\n0: \tmovl\t(%rip), %eax  # 0x6 <M_ClearBox+0x6>\n6: \tmovq\t(%rip), %rcx  # 0xd <M_ClearBox+0xd>\nd: \tmovl\t%eax, (%rdi,%rcx,4)\n10: \tmovq\t(%rip), %rcx  # 0x17 <M_ClearBox+0x17>\n17: \tmovl\t%eax, (%rdi,%rcx,4)\n1a: \tmovl\t(%rip), %eax  # 0x20 <M_ClearBox+0x20>\n20: \tmovq\t(%rip), %rcx  # 0x27 <M_ClearBox+0x27>\n27: \tmovl\t%eax, (%rdi,%rcx,4)\n2a: \tmovq\t(%rip), %rcx  # 0x31 <M_ClearBox+0x31>\n31: \tmovl\t%eax, (%rdi,%rcx,4)\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fixed_t ;\n\n/* Variables and functions */\nsize_t BOXBOTTOM ;\nsize_t BOXLEFT ;\nsize_t BOXRIGHT ;\nsize_t BOXTOP ;\nint /*<<< orphan*/  MAXINT ;\nint /*<<< orphan*/  MININT ;\n\nvoid M_ClearBox (fixed_t *box)\n{\nbox[BOXTOP] = box[BOXRIGHT] = MININT;\nbox[BOXBOTTOM] = box[BOXLEFT] = MAXINT;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  cmsUInt8Number ;\ntypedef  int /*<<< orphan*/ * cmsUInt32Number ;\n\n/* Variables and functions */\nint /*<<< orphan*/  _cmsTRANSFORM_LUT_INVALID ;\nsize_t Blue ;\nsize_t Green ;\nsize_t Red ;\nsize_t Transparency ;\n\n__attribute__((used)) static\nvoid M_ClearBox(cmsUInt32Number* out)\n{\nout[Red] = out[Green] = out[Blue] = out[Transparency] = _cmsTRANSFORM_LUT_INVALID;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_StartMessage",
    "input":"\n0000000000000000 <M_StartMessage>:\n0: \tmovl\t(%rip), %eax  # 0x6 <M_StartMessage+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <M_StartMessage+0xc>\nc: \tmovl\t$1, (%rip)    # 0x16 <M_StartMessage+0x16>\n16: \tmovq\t%rdi, (%rip)  # 0x1d <M_StartMessage+0x1d>\n1d: \tmovq\t%rsi, (%rip)  # 0x24 <M_StartMessage+0x24>\n24: \tmovl\t%edx, (%rip)  # 0x2a <M_StartMessage+0x2a>\n2a: \tmovl\t$1, (%rip)    # 0x34 <M_StartMessage+0x34>\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  boolean ;\n\n/* Variables and functions */\nint menuactive ;\nint messageLastMenuActive ;\nint /*<<< orphan*/  messageNeedsInput ;\nvoid* messageRoutine ;\nchar* messageString ;\nint messageToPrint ;\n\nvoid\nM_StartMessage\n( char*\t\tstring,\nvoid*\t\troutine,\nboolean\tinput )\n{\nmessageLastMenuActive = menuactive;\nmessageToPrint = 1;\nmessageString = string;\nmessageRoutine = routine;\nmessageNeedsInput = input;\nmenuactive = true;\nreturn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  PVOID ;\ntypedef  int /*<<< orphan*/  PCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_CurrentMessage ;\nint /*<<< orphan*/  M_CurrentMessageSize ;\nint /*<<< orphan*/  M_CurrentMessageType ;\nint /*<<< orphan*/  M_CurrentMessageTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringType ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringSize ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeString ;\nint /*<<< orphan*/  M_CurrentMessageTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeStringTypeSize ;\nint /*<<<"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_QuickSave",
    "input":"\n0000000000000000 <M_QuickSave>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <M_QuickSave+0x8>\n8: \tje\t0x54 <M_QuickSave+0x54>\na: \tmovq\t(%rip), %rax  # 0x11 <M_QuickSave+0x11>\n11: \tcmpq\t(%rip), %rax  # 0x18 <M_QuickSave+0x18>\n18: \tjne\t0x62 <M_QuickSave+0x62>\n1a: \tmovq\t(%rip), %rax  # 0x21 <M_QuickSave+0x21>\n21: \tmovl\t(%rip), %edi  # 0x27 <M_QuickSave+0x27>\n27: \tmovq\t(%rip), %rsi  # 0x2e <M_QuickSave+0x2e>\n2e: \tmovq\t(%rip), %rcx  # 0x35 <M_QuickSave+0x35>\n35: \tmovl\t(%rcx,%rax,4), %edx\n38: \tcallq\t0x3d <M_QuickSave+0x3d>\n3d: \tmovl\t(%rip), %edi  # 0x43 <M_QuickSave+0x43>\n43: \tmovl\t(%rip), %esi  # 0x49 <M_QuickSave+0x49>\n49: \tmovl\t$1, %edx\n4e: \tpopq\t%rax\n4f: \tjmp\t0x54 <M_QuickSave+0x54>\n54: \tmovl\t(%rip), %esi  # 0x5a <M_QuickSave+0x5a>\n5a: \txorl\t%edi, %edi\n5c: \tpopq\t%rax\n5d: \tjmp\t0x62 <M_QuickSave+0x62>\n62: \tpopq\t%rax\n63: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ GS_LEVEL ;\nint /*<<< orphan*/  M_QuickSaveResponse ;\nint /*<<< orphan*/  M_ReadSaveStrings () ;\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  M_StartControlPanel () ;\nint /*<<< orphan*/  M_StartMessage (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nchar* QSPROMPT ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SaveDef ;\nscalar_t__ gamestate ;\nsize_t quickSaveSlot ;\nint /*<<< orphan*/ * savegamestrings ;\nint /*<<< orphan*/  sfx_oof ;\nint /*<<< orphan*/  sprintf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  tempstring ;\nint /*<<< orphan*/  usergame ;\n\nvoid M_QuickSave(void)\n{\nif (!usergame)\n{\nS_StartSound(NULL,sfx_oof);\nreturn;\n}\n\nif (gamestate != GS_LEVEL)\nreturn;\n\nif (quickSaveSlot < 0)\n{\nM_StartControlPanel();\nM_ReadSaveStrings();\nM_SetupNextMenu(&SaveDef);\nquickSaveSlot = -2;\t// means to pick a slot now\nreturn;\n}\nsprintf(tempstring,QSPROMPT,savegamestrings[quickSaveSlot]);\nM_StartMessage(tempstring,M_QuickSaveResponse,true);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\ntypedef  int /*<<< orphan*/  PCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DPRINT (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  M_Save ;\nint /*<<< orphan*/  M_Save_Error ;\nint /*<<< orphan*/  M_Save_Success ;\nint /*<<< orphan*/  M_Save_Success_Msg ;\nint /*<<< orphan*/  M_Save_Success_Msg_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len ;\nint /*<<< orphan*/  M_Save_Success_Msg_Ptr_Ptr_Len_Ptr_Len_Ptr_Len_Ptr_Len_Ptr"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_fixed.c_FixedMul",
    "input":"\n0000000000000000 <FixedMul>:\n0: \tmovq\t%rdi, %rax\n3: \timulq\t%rsi, %rax\n7: \tmovb\t(%rip), %cl   # 0xd <FixedMul+0xd>\nd: \tsarq\t%cl, %rax\n10: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  long long fixed_t ;\n\n/* Variables and functions */\nlong long FRACBITS ;\n\nfixed_t\nFixedMul\n( fixed_t\ta,\nfixed_t\tb )\n{\nreturn ((long long) a * (long long) b) >> FRACBITS;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ FIXED ;\n\n/* Variables and functions */\nint FIXED_SHIFT ;\n\n__attribute__((used)) static inline FIXED FixedMul(FIXED a, FIXED b)\n{\nreturn (a * b) >> FIXED_SHIFT;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_CmdChecksum",
    "input":"\n0000000000000000 <G_CmdChecksum>:\n0: \txorl\t%eax, %eax\n2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ticcmd_t ;\n\n/* Variables and functions */\n\nint G_CmdChecksum (ticcmd_t* cmd)\n{\nint\t\ti;\nint\t\tsum = 0;\n\nfor (i=0 ; i< sizeof(*cmd)/4 - 1 ; i++)\nsum += ((int *)cmd)[i];\n\nreturn sum;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  G_Cmd ;\n\n/* Variables and functions */\n\nint G_CmdChecksum(G_Cmd *cmd)\n{\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_PainDie",
    "input":"\n0000000000000000 <A_PainDie>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <A_PainDie+0x9>\n9: \tmovq\t(%rip), %rsi  # 0x10 <A_PainDie+0x10>\n10: \taddq\t(%rbx), %rsi\n13: \tmovq\t%rbx, %rdi\n16: \tcallq\t0x1b <A_PainDie+0x1b>\n1b: \tmovq\t(%rip), %rsi  # 0x22 <A_PainDie+0x22>\n22: \taddq\t(%rbx), %rsi\n25: \tmovq\t%rbx, %rdi\n28: \tcallq\t0x2d <A_PainDie+0x2d>\n2d: \tmovq\t(%rip), %rsi  # 0x34 <A_PainDie+0x34>\n34: \taddq\t(%rbx), %rsi\n37: \tmovq\t%rbx, %rdi\n3a: \tpopq\t%rbx\n3b: \tjmp\t0x40 <A_PainDie+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ angle; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nscalar_t__ ANG180 ;\nscalar_t__ ANG270 ;\nscalar_t__ ANG90 ;\nint /*<<< orphan*/  A_Fall (TYPE_1__*) ;\nint /*<<< orphan*/  A_PainShootSkull (TYPE_1__*,scalar_t__) ;\n\nvoid A_PainDie (mobj_t* actor)\n{\nA_Fall (actor);\nA_PainShootSkull (actor, actor->angle+ANG90);\nA_PainShootSkull (actor, actor->angle+ANG180);\nA_PainShootSkull (actor, actor->angle+ANG270);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x; } ;\ntypedef  TYPE_1__ m68k_struct ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_PainDie_B ;\nint /*<<< orphan*/  A_PainDie_C ;\nint /*<<< orphan*/  A_PainDie_D ;\nint /*<<< orphan*/  A_PainDie_E ;\nint /*<<< orphan*/  A_PainDie_F ;\nint /*<<< orphan*/  A_PainDie_G ;\nint /*<<< orphan*/  A_PainDie_H ;\nint /*<<< orphan*/  A_PainDie_I ;\nint /*<<< orphan*/  A_PainDie_J ;\nint /*<<< orphan*/  A_PainDie_K ;\nint /*<<< orphan*/  A_PainDie_L ;\nint /*<<< orphan*/  A_PainDie_M ;\nint /*<<< orphan*/  A_PainDie_N ;\nint /*<<< orphan*/  A_PainDie_O ;\nint /*<<< orphan*/  A_PainDie_P ;\nint /*<<< orphan*/  A_PainDie_Q ;\nint /*<<< orphan*/  A_PainDie_R ;\nint /*<<< orphan*/  A_PainDie_S ;\nint /*<<< orphan*/  A_PainDie_T ;\nint /*<<< orphan*/  A_PainDie_U ;\nint /*<<< orphan*/  A_PainDie_V ;\nint /*<<< orphan*/  A_PainDie_W ;\nint /*<<< orphan*/  A_PainDie_X ;\nint /*<<< orphan*/  A_PainDie_Y ;\nint /*<<< orphan*/  A_PainDie_Z ;\nint /*<<< orphan*/  A_PainDie_a ;\nint /*<<< orphan*/  A_PainDie_b ;\nint /*<<< orphan*/  A_PainDie_c ;\nint /*<<< orphan*/  A_PainDie_d ;\nint /*<<< orphan*/  A_PainDie_e ;\nint /*<<< orphan*/  A_PainDie_f ;\nint /*<<< orphan*/  A_PainDie_g ;\nint /*<<< orphan*/  A_PainDie_h ;\nint /*<<< orphan*/  A_PainDie_i ;\nint /*<<< orphan*/  A_PainDie_j ;\nint /*<<< orphan*/  A_PainDie_k ;\nint /*<<< orphan*/  A_PainDie_l ;\nint /*<<< orphan*/  A_PainDie_m ;\nint /*<<< orphan*/  A_PainDie_n ;\nint /*<<< orphan*/  A_PainDie_o ;\nint /*<<< orphan*/  A_PainDie_p ;\nint /*<<< orphan*/  A_PainDie_q ;\nint /*<<< orphan*/  A_PainDie_r ;\nint /*<<< orphan*/  A_PainDie_s ;\nint /*<<< orphan*/  A_PainDie_t ;\nint /*<<< orphan*/  A_PainDie_u ;\nint /*<<< orphan*/  A_PainDie_v ;\nint /*<<< orphan*/  A_PainDie_w ;\nint /*<<< orphan*/  A_PainDie_x ;\nint /*<<< orphan*/  A_PainDie_y ;\nint /*<<< orphan*/  A_PainDie_z ;\nint /*<<< orphan*/  A_PainDie_z_ ;\nint /*<<< orphan*/  A_PainDie_z_a ;\nint /*<<< orphan*/  A_PainDie_z_b ;\nint /*<<< orphan*/  A_PainDie_z_c ;\nint /*<<< orphan*/  A_PainDie_z_d ;\nint /*<<< orphan*/  A_PainDie_z_e ;\nint /*<<< orphan*/  A_PainDie_z_f ;\nint /*<<< orphan*/  A_PainDie_z_g ;\nint /*<<< orphan*/  A_PainDie_z_h ;\nint /*<<< orphan*/  A_PainDie_z_i ;\nint /*<<< orphan*/  A_PainDie_z_j ;\nint /*<<< orphan*/  A_PainDie_z_k ;\nint /*<<< orphan*/  A_PainDie_z_l ;\nint /*<<< orphan*/  A_PainDie_z_m ;\nint /*<<< orphan*/  A_PainDie_z_n ;\nint /*<<< orphan*/  A_PainDie_z_o ;\nint /*<<< orphan*/  A_PainDie_z_p ;\nint /*<<< orphan*/  A_PainDie_z_q ;\nint /*<<< orphan*/  A_PainDie_z_r ;\nint /*<<< orphan*/  A_PainDie_z_s ;\nint /*<<< orphan*/  A_PainDie_z_t ;\nint /*<<< orphan*/  A_PainDie_z_u ;\nint /*<<< orphan*/  A_PainDie_z_v ;\nint /*<<< orphan*/  A_PainDie_z_w ;\nint /*<<< orphan*/  A_PainDie_z_x ;\nint /*<<< orphan*/  A_PainDie_z_y ;\nint /*<<< orphan*/  A_PainDie_z_z ;\nint /*<<< orphan*/  A_PainDie_z_z_ ;\nint /*<<< orphan*/  A_PainDie_z_z_a ;\nint /*<<< orphan*/  A_PainDie_z_z_b ;\nint /*<<< orphan*/  A_PainDie_z_z_c ;\nint /*<<< orphan*/  A_PainDie_z_z_d ;\nint /*<<< orphan*/  A_PainDie_z_z_e ;\nint /*<<< orphan*/  A_PainDie_z_z_f ;\nint /*<<< orphan*/  A_PainDie_z_z_g ;\nint /*<<< orphan*/  A_PainDie_z_z_h ;\nint /*<<< orphan*/  A_PainDie_z_z_i ;\nint /*<<< orphan*/  A_PainDie_z_z_j ;\nint /*<<< orphan*/  A_PainDie_z_z_k ;\nint /*<<< orphan*/  A_PainDie_z_z_l ;\nint /*<<< orphan*/  A_PainDie_z_z_m ;\nint /*<<< orphan*/  A_PainDie_z_z_n ;\nint /*<<< orphan*/  A_PainDie_z_z_o ;\nint /*<<< orphan*/  A_PainDie_z_z_p ;\nint /*<<< orphan*/  A_PainDie_z_z_q ;\nint /*<<< orphan*/  A_PainDie_z_z_r ;\nint /*<<< orphan*/  A_PainDie_z_z_s ;\nint /*<<< orphan*/  A_PainDie_z_z_t ;\nint /*<<< orphan*/  A_PainDie_z_z_u ;\nint /*<<< orphan*/  A_PainDie_z_z_v ;\nint /*<<< orphan*/  A_PainDie_z_z_w"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_rotate",
    "input":"\n0000000000000000 <AM_rotate>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tmovq\t%rdx, %rbx\nc: \tmovq\t%rsi, %r14\nf: \tmovq\t%rdi, %r15\n12: \tmovq\t(%rdi), %rdi\n15: \tmovq\t(%rip), %rax  # 0x1c <AM_rotate+0x1c>\n1c: \tmovb\t(%rip), %cl   # 0x22 <AM_rotate+0x22>\n22: \tshrq\t%cl, %rdx\n25: \tmovl\t(%rax,%rdx,4), %esi\n28: \tcallq\t0x2d <AM_rotate+0x2d>\n2d: \tmovq\t%rax, %r12\n30: \tmovq\t(%r14), %rdi\n33: \tmovq\t(%rip), %rax  # 0x3a <AM_rotate+0x3a>\n3a: \tmovb\t(%rip), %cl   # 0x40 <AM_rotate+0x40>\n40: \tmovq\t%rbx, %rdx\n43: \tshrq\t%cl, %rdx\n46: \tmovl\t(%rax,%rdx,4), %esi\n49: \tcallq\t0x4e <AM_rotate+0x4e>\n4e: \tsubq\t%rax, %r12\n51: \tmovq\t(%r15), %rdi\n54: \tmovq\t(%rip), %rax  # 0x5b <AM_rotate+0x5b>\n5b: \tmovb\t(%rip), %cl   # 0x61 <AM_rotate+0x61>\n61: \tmovq\t%rbx, %rdx\n64: \tshrq\t%cl, %rdx\n67: \tmovl\t(%rax,%rdx,4), %esi\n6a: \tcallq\t0x6f <AM_rotate+0x6f>\n6f: \tmovq\t%rax, %r13\n72: \tmovq\t(%r14), %rdi\n75: \tmovq\t(%rip), %rax  # 0x7c <AM_rotate+0x7c>\n7c: \tmovb\t(%rip), %cl   # 0x82 <AM_rotate+0x82>\n82: \tshrq\t%cl, %rbx\n85: \tmovl\t(%rax,%rbx,4), %esi\n88: \tcallq\t0x8d <AM_rotate+0x8d>\n8d: \taddq\t%r13, %rax\n90: \tmovq\t%rax, (%r14)\n93: \tmovq\t%r12, (%r15)\n96: \tpopq\t%rbx\n97: \tpopq\t%r12\n99: \tpopq\t%r13\n9b: \tpopq\t%r14\n9d: \tpopq\t%r15\n9f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\ntypedef  size_t angle_t ;\n\n/* Variables and functions */\nsize_t ANGLETOFINESHIFT ;\nscalar_t__ FixedMul (scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * finecosine ;\nint /*<<< orphan*/ * finesine ;\n\nvoid\nAM_rotate\n( fixed_t*\tx,\nfixed_t*\ty,\nangle_t\ta )\n{\nfixed_t tmpx;\n\ntmpx =\nFixedMul(*x,finecosine[a>>ANGLETOFINESHIFT])\n- FixedMul(*y,finesine[a>>ANGLETOFINESHIFT]);\n\n*y   =\nFixedMul(*x,finesine[a>>ANGLETOFINESHIFT])\n+ FixedMul(*y,finecosine[a>>ANGLETOFINESHIFT]);\n\n*x = tmpx;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; } ;\ntypedef  TYPE_1__ fz_point ;\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_BITS ;\nint /*<<< orphan*/  AM_SHIFT ;\nint /*<<< orphan*/  AM_X ;\nint /*<<< orphan*/  AM_Y ;\nscalar_t__ AM_get_bits (int /*<<< orphan*/ *,int /*<<< orphan*/ ,scalar_t__) ;\n\n__attribute__((used)) static void AM_rotate(fz_context *ctx, fz_point *a, fz_point *b)\n{\nscalar_t__ x = AM_get_bits(ctx, AM_X, b->x);\nscalar_t__ y = AM_get_bits(ctx, AM_Y, b->y);\n\na->x = x + AM_get_bits(ctx, AM_X, y);\na->y = y - AM_get_bits(ctx, AM_Y, x);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_ResumeSound",
    "input":"\n0000000000000000 <S_ResumeSound>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <S_ResumeSound+0x8>\n8: \ttestq\t%rax, %rax\nb: \tje\t0x27 <S_ResumeSound+0x27>\nd: \tcmpl\t$0, (%rip)    # 0x14 <S_ResumeSound+0x14>\n14: \tje\t0x27 <S_ResumeSound+0x27>\n16: \tmovl\t(%rax), %edi\n18: \tcallq\t0x1d <S_ResumeSound+0x1d>\n1d: \tmovl\t$0, (%rip)    # 0x27 <S_ResumeSound+0x27>\n27: \tpopq\t%rax\n28: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  handle; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ResumeSong (int /*<<< orphan*/ ) ;\nint mus_paused ;\nTYPE_1__* mus_playing ;\n\nvoid S_ResumeSound(void)\n{\nif (mus_playing && mus_paused)\n{\nI_ResumeSong(mus_playing->handle);\nmus_paused = false;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  paused; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_ResumeSounds () ;\nTYPE_1__* dma ;\n\nvoid S_ResumeSound(void)\n{\nif (dma && !dma->paused)\n{\nS_ResumeSounds();\ndma->paused = 0;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_sight.c_P_DivlineSide",
    "input":"\n0000000000000000 <P_DivlineSide>:\n0: \tmovq\t(%rdx), %r8\n3: \ttestq\t%r8, %r8\n6: \tje\t0x47 <P_DivlineSide+0x47>\n8: \tmovq\t16(%rdx), %rax\nc: \ttestq\t%rax, %rax\nf: \tje\t0x5f <P_DivlineSide+0x5f>\n11: \tsubq\t8(%rdx), %rdi\n15: \tsubq\t24(%rdx), %rsi\n19: \tmovb\t(%rip), %cl   # 0x1f <P_DivlineSide+0x1f>\n1f: \tsarq\t%cl, %rax\n22: \tsarq\t%cl, %rdi\n25: \tsarq\t%cl, %rsi\n28: \tsarq\t%cl, %r8\n2b: \timulq\t%rax, %rdi\n2f: \timulq\t%rsi, %r8\n33: \txorl\t%eax, %eax\n35: \tcmpq\t%rdi, %r8\n38: \tjl\t0x6d <P_DivlineSide+0x6d>\n3a: \txorl\t%eax, %eax\n3c: \tcmpq\t%r8, %rdi\n3f: \tsete\t%al\n42: \taddl\t$1, %eax\n45: \tjmp\t0x6d <P_DivlineSide+0x6d>\n47: \tmovl\t$2, %eax\n4c: \tcmpq\t%rdi, 8(%rdx)\n50: \tje\t0x6d <P_DivlineSide+0x6d>\n52: \tmovq\t16(%rdx), %rcx\n56: \tjge\t0x7c <P_DivlineSide+0x7c>\n58: \tshrq\t$63, %rcx\n5c: \tmovl\t%ecx, %eax\n5e: \tretq\n5f: \tmovq\t24(%rdx), %rcx\n63: \tmovl\t$2, %eax\n68: \tcmpq\t%rdi, %rcx\n6b: \tjne\t0x6e <P_DivlineSide+0x6e>\n6d: \tretq\n6e: \tcmpq\t%rsi, %rcx\n71: \tjge\t0x85 <P_DivlineSide+0x85>\n73: \txorl\t%eax, %eax\n75: \ttestq\t%r8, %r8\n78: \tsetg\t%al\n7b: \tretq\n7c: \txorl\t%eax, %eax\n7e: \ttestq\t%rcx, %rcx\n81: \tsetg\t%al\n84: \tretq\n85: \tshrq\t$63, %r8\n89: \tmovl\t%r8d, %eax\n8c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\nstruct TYPE_3__ {scalar_t__ dx; scalar_t__ x; scalar_t__ dy; scalar_t__ y; } ;\ntypedef  TYPE_1__ divline_t ;\n\n/* Variables and functions */\nscalar_t__ FRACBITS ;\n\nint\nP_DivlineSide\n( fixed_t\tx,\nfixed_t\ty,\ndivline_t*\tnode )\n{\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tleft;\nfixed_t\tright;\n\nif (!node->dx)\n{\nif (x==node->x)\nreturn 2;\n\nif (x <= node->x)\nreturn node->dy > 0;\n\nreturn node->dy < 0;\n}\n\nif (!node->dy)\n{\nif (x==node->y)\nreturn 2;\n\nif (y <= node->y)\nreturn node->dx < 0;\n\nreturn node->dx > 0;\n}\n\ndx = (x - node->x);\ndy = (y - node->y);\n\nleft =  (node->dy>>FRACBITS) * (dx>>FRACBITS);\nright = (dy>>FRACBITS) * (node->dx>>FRACBITS);\n\nif (right < left)\nreturn 0;\t// front side\n\nif (left == right)\nreturn 2;\nreturn 1;\t\t// back side\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ x1; scalar_t__ y1; scalar_t__ x2; scalar_t__ y2; } ;\ntypedef  TYPE_1__ P_Divline ;\n\n/* Variables and functions */\nint P_DivlineSide_C (scalar_t__,scalar_t__,scalar_t__,scalar_t__) ;\nint P_DivlineSide_S (scalar_t__,scalar_t__,scalar_t__,scalar_t__) ;\n\n__attribute__((used)) static int P_DivlineSide(scalar_t__ x, scalar_t__ y, P_Divline *D)\n{\nif (D->y2 == 0)\n{\nif (D->x2 == x)\nreturn 1;\nelse\nreturn 0;\n}\nelse\n{\nif (D->x2 == 0)\n{\nif (D->y2 == y)\nreturn 1;\nelse\nreturn 0;\n}\nelse\n{\nreturn P_DivlineSide_S(x, y, D->x1, D->y1) +\nP_DivlineSide_C(x, y, D->x2, D->y2);\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_PainAttack",
    "input":"\n0000000000000000 <A_PainAttack>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, 4(%rdi)\n5: \tje\t0x1a <A_PainAttack+0x1a>\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <A_PainAttack+0xf>\nf: \tmovl\t(%rbx), %esi\n11: \tmovq\t%rbx, %rdi\n14: \tpopq\t%rbx\n15: \tjmp\t0x1a <A_PainAttack+0x1a>\n1a: \tpopq\t%rbx\n1b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  angle; int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  A_PainShootSkull (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nvoid A_PainAttack (mobj_t* actor)\n{\nif (!actor->target)\nreturn;\n\nA_FaceTarget (actor);\nA_PainShootSkull (actor, actor->angle);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  hurt_sound; int /*<<< orphan*/  pain_attack; } ;\ntypedef  TYPE_1__ Enemy ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_PlaySound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ) ;\n\nvoid A_PainAttack(Enemy *en)\n{\nif (en->pain_attack)\n{\nA_PlaySound(en, en->hurt_sound);\nA_SetAnim(en, en->pain_attack);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_doColorXForm",
    "input":"\n0000000000000000 <wipe_doColorXForm>:\n0: \timull\t%esi, %edi\n3: \ttestl\t%edi, %edi\n5: \tje\t0x63 <wipe_doColorXForm+0x63>\n7: \tmovq\t(%rip), %rax  # 0xe <wipe_doColorXForm+0xe>\ne: \tmovslq\t%edi, %r10\n11: \tmovq\t(%rip), %r9   # 0x18 <wipe_doColorXForm+0x18>\n18: \tshlq\t$2, %r10\n1c: \txorl\t%edi, %edi\n1e: \txorl\t%r8d, %r8d\n21: \tjmp\t0x49 <wipe_doColorXForm+0x49>\n23: \tnopw\t%cs:(%rax,%rax)\n2d: \tnopl\t(%rax)\n30: \tsubl\t%edx, %esi\n32: \tcmpl\t%ecx, %esi\n34: \tcmovll\t%ecx, %esi\n37: \tmovl\t%esi, (%rax,%rdi)\n3a: \tmovl\t$1, %r8d\n40: \taddq\t$4, %rdi\n44: \tcmpq\t%rdi, %r10\n47: \tje\t0x66 <wipe_doColorXForm+0x66>\n49: \tmovl\t(%rax,%rdi), %esi\n4c: \tmovl\t(%r9,%rdi), %ecx\n50: \tcmpl\t%ecx, %esi\n52: \tje\t0x40 <wipe_doColorXForm+0x40>\n54: \tjg\t0x30 <wipe_doColorXForm+0x30>\n56: \tcmpl\t%ecx, %esi\n58: \tjge\t0x40 <wipe_doColorXForm+0x40>\n5a: \taddl\t%edx, %esi\n5c: \tcmpl\t%ecx, %esi\n5e: \tcmovgl\t%ecx, %esi\n61: \tjmp\t0x37 <wipe_doColorXForm+0x37>\n63: \txorl\t%r8d, %r8d\n66: \txorl\t%eax, %eax\n68: \ttestl\t%r8d, %r8d\n6b: \tsete\t%al\n6e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int byte ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nint* wipe_scr ;\nint* wipe_scr_end ;\n\nint\nwipe_doColorXForm\n( int\twidth,\nint\theight,\nint\tticks )\n{\nboolean\tchanged;\nbyte*\tw;\nbyte*\te;\nint\t\tnewval;\n\nchanged = false;\nw = wipe_scr;\ne = wipe_scr_end;\n\nwhile (w!=wipe_scr+width*height)\n{\nif (*w != *e)\n{\nif (*w > *e)\n{\nnewval = *w - ticks;\nif (newval < *e)\n*w = *e;\nelse\n*w = newval;\nchanged = true;\n}\nelse if (*w < *e)\n{\nnewval = *w + ticks;\nif (newval > *e)\n*w = *e;\nelse\n*w = newval;\nchanged = true;\n}\n}\nw++;\ne++;\n}\n\nreturn !changed;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint8_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * color_xform ;\nint /*<<< orphan*/ * color_xform_inv ;\n\n__attribute__((used)) static int wipe_doColorXForm(int x, int y, int w, int h)\n{\nint i;\nfor (i = 0; i < w * h; i++) {\nuint8_t c = color_xform[i];\nif (c != color_xform_inv[i]) {\nif (c < color_xform_inv[i])\ncolor_xform[i] = color_xform_inv[i];\nelse\ncolor_xform[i] = c;\nreturn 1;\n}\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_InitPointToAngle",
    "input":"\n0000000000000000 <R_InitPointToAngle>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SLOPERANGE ;\ndouble atan (float) ;\nlong* tantoangle ;\n\nvoid R_InitPointToAngle (void)\n{\n// UNUSED - now getting from tables.c\n#if 0\nint\ti;\nlong\tt;\nfloat\tf;\n//\n// slope (tangent) to angle lookup\n//\nfor (i=0 ; i<=SLOPERANGE ; i++)\n{\nf = atan( (float)i/SLOPERANGE )/(3.141592657*2);\nt = 0xffffffff*f;\ntantoangle[i] = t;\n}\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  R_Point ;\n\n/* Variables and functions */\n\nvoid R_InitPointToAngle(R_Point *p)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_clearMarks",
    "input":"\n0000000000000000 <AM_clearMarks>:\n0: \tcmpl\t$0, (%rip)    # 0x7 <AM_clearMarks+0x7>\n7: \tjle\t0x37 <AM_clearMarks+0x37>\n9: \tmovq\t(%rip), %rax  # 0x10 <AM_clearMarks+0x10>\n10: \txorl\t%ecx, %ecx\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \tmovl\t$4294967295, (%rax,%rcx,4) # imm = 0xFFFFFFFF\n27: \taddq\t$1, %rcx\n2b: \tmovslq\t(%rip), %rdx  # 0x32 <AM_clearMarks+0x32>\n32: \tcmpq\t%rdx, %rcx\n35: \tjl\t0x20 <AM_clearMarks+0x20>\n37: \tmovq\t$0, (%rip)    # 0x42 <AM_clearMarks+0x42>\n42: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int x; } ;\n\n/* Variables and functions */\nint AM_NUMMARKPOINTS ;\nscalar_t__ markpointnum ;\nTYPE_1__* markpoints ;\n\nvoid AM_clearMarks(void)\n{\nint i;\n\nfor (i=0;i<AM_NUMMARKPOINTS;i++)\nmarkpoints[i].x = -1; // means empty\nmarkpointnum = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint AM_markCount ;\nint* AM_marks ;\n\nvoid AM_clearMarks (void) {\nint i;\nfor (i = 0; i < AM_markCount; i++) {\nAM_marks[i] = -1;\n}\nAM_markCount = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_d_main.c_D_ProcessEvents",
    "input":"\n0000000000000000 <D_ProcessEvents>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rip), %rax  # 0x8 <D_ProcessEvents+0x8>\n8: \tcmpq\t(%rip), %rax  # 0xf <D_ProcessEvents+0xf>\nf: \tjne\t0x20 <D_ProcessEvents+0x20>\n11: \tmovl\t$0, %edi\n16: \tcallq\t0x1b <D_ProcessEvents+0x1b>\n1b: \ttestq\t%rax, %rax\n1e: \tjs\t0x77 <D_ProcessEvents+0x77>\n20: \tmovl\t(%rip), %eax  # 0x26 <D_ProcessEvents+0x26>\n26: \tjmp\t0x4a <D_ProcessEvents+0x4a>\n28: \tnopl\t(%rax,%rax)\n30: \tmovl\t(%rip), %ecx  # 0x36 <D_ProcessEvents+0x36>\n36: \taddl\t$1, %ecx\n39: \tmovl\t(%rip), %eax  # 0x3f <D_ProcessEvents+0x3f>\n3f: \taddl\t$-1, %eax\n42: \tandl\t%ecx, %eax\n44: \tmovl\t%eax, (%rip)  # 0x4a <D_ProcessEvents+0x4a>\n4a: \tcmpl\t(%rip), %eax  # 0x50 <D_ProcessEvents+0x50>\n50: \tje\t0x77 <D_ProcessEvents+0x77>\n52: \tmovslq\t%eax, %rbx\n55: \tshlq\t$2, %rbx\n59: \taddq\t(%rip), %rbx  # 0x60 <D_ProcessEvents+0x60>\n60: \tmovq\t%rbx, %rdi\n63: \tcallq\t0x68 <D_ProcessEvents+0x68>\n68: \ttestq\t%rax, %rax\n6b: \tjne\t0x30 <D_ProcessEvents+0x30>\n6d: \tmovq\t%rbx, %rdi\n70: \tcallq\t0x75 <D_ProcessEvents+0x75>\n75: \tjmp\t0x30 <D_ProcessEvents+0x30>\n77: \tpopq\t%rbx\n78: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  event_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_Responder (int /*<<< orphan*/ *) ;\nint MAXEVENTS ;\nscalar_t__ M_Responder (int /*<<< orphan*/ *) ;\nscalar_t__ W_CheckNumForName (char*) ;\nscalar_t__ commercial ;\nint eventhead ;\nint /*<<< orphan*/ * events ;\nint eventtail ;\nscalar_t__ gamemode ;\n\nvoid D_ProcessEvents (void)\n{\nevent_t*\tev;\n\n// IF STORE DEMO, DO NOT ACCEPT INPUT\nif ( ( gamemode == commercial )\n&& (W_CheckNumForName(\"map01\")<0) )\nreturn;\n\nfor ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS-1) )\n{\nev = &events[eventtail];\nif (M_Responder (ev))\ncontinue;               // menu ate the event\nG_Responder (ev);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  event_queue; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_ProcessEvent (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  D_ProcessEventQueue (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  D_ProcessEventQueue_Lock ;\nint /*<<< orphan*/  D_ProcessEventQueue_Unlock ;\nint /*<<< orphan*/  D_ProcessEvent_Lock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock ;\nint /*<<< orphan*/  D_ProcessEvent_Unlock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_NoLock_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_PIT_VileCheck",
    "input":"\n0000000000000000 <PIT_VileCheck>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t(%rip), %eax  # 0xa <PIT_VileCheck+0xa>\na: \tmovl\t$1, %ebp\nf: \ttestl\t%eax, (%rdi)\n11: \tje\t0xa9 <PIT_VileCheck+0xa9>\n17: \tmovq\t%rdi, %rbx\n1a: \tcmpl\t$-1, 4(%rdi)\n1e: \tjne\t0xa9 <PIT_VileCheck+0xa9>\n24: \tmovq\t48(%rbx), %rax\n28: \tmovq\t(%rax), %rcx\n2b: \tcmpq\t(%rip), %rcx  # 0x32 <PIT_VileCheck+0x32>\n32: \tje\t0xa9 <PIT_VileCheck+0xa9>\n34: \tmovq\t(%rip), %rcx  # 0x3b <PIT_VileCheck+0x3b>\n3b: \tmovq\t(%rip), %rdx  # 0x42 <PIT_VileCheck+0x42>\n42: \tmovl\t(%rcx,%rdx,4), %r14d\n46: \taddl\t8(%rax), %r14d\n4a: \tmovq\t24(%rbx), %rdi\n4e: \tsubq\t(%rip), %rdi  # 0x55 <PIT_VileCheck+0x55>\n55: \tcallq\t0x5a <PIT_VileCheck+0x5a>\n5a: \tcmpl\t%r14d, %eax\n5d: \tjg\t0xa9 <PIT_VileCheck+0xa9>\n5f: \tmovq\t16(%rbx), %rdi\n63: \tsubq\t(%rip), %rdi  # 0x6a <PIT_VileCheck+0x6a>\n6a: \tcallq\t0x6f <PIT_VileCheck+0x6f>\n6f: \tcmpl\t%r14d, %eax\n72: \tjg\t0xa9 <PIT_VileCheck+0xa9>\n74: \tmovq\t%rbx, (%rip)  # 0x7b <PIT_VileCheck+0x7b>\n7b: \txorps\t%xmm0, %xmm0\n7e: \tmovups\t%xmm0, 32(%rbx)\n82: \tshll\t$2, 8(%rbx)\n86: \tmovq\t16(%rbx), %rdx\n8a: \tmovq\t24(%rbx), %rsi\n8e: \tmovq\t%rbx, %rdi\n91: \tcallq\t0x96 <PIT_VileCheck+0x96>\n96: \tmovq\t(%rip), %rcx  # 0x9d <PIT_VileCheck+0x9d>\n9d: \tsarl\t$2, 8(%rcx)\na1: \txorl\t%ebp, %ebp\na3: \ttestl\t%eax, %eax\na5: \tsete\t%bpl\na9: \tmovl\t%ebp, %eax\nab: \tpopq\t%rbx\nac: \tpopq\t%r14\nae: \tpopq\t%rbp\naf: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int flags; int tics; int height; scalar_t__ y; scalar_t__ x; scalar_t__ momy; scalar_t__ momx; TYPE_1__* info; } ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  int boolean ;\nstruct TYPE_9__ {int radius; } ;\nstruct TYPE_7__ {scalar_t__ raisestate; int radius; } ;\n\n/* Variables and functions */\nint MF_CORPSE ;\nsize_t MT_VILE ;\nint P_CheckPosition (TYPE_2__*,scalar_t__,scalar_t__) ;\nscalar_t__ S_NULL ;\nint abs (scalar_t__) ;\nTYPE_2__* corpsehit ;\nTYPE_3__* mobjinfo ;\nscalar_t__ viletryx ;\nscalar_t__ viletryy ;\n\nboolean PIT_VileCheck (mobj_t*\tthing)\n{\nint\t\tmaxdist;\nboolean\tcheck;\n\nif (!(thing->flags & MF_CORPSE) )\nreturn true;\t// not a monster\n\nif (thing->tics != -1)\nreturn true;\t// not lying still yet\n\nif (thing->info->raisestate == S_NULL)\nreturn true;\t// monster doesn't have a raise state\n\nmaxdist = thing->info->radius + mobjinfo[MT_VILE].radius;\n\nif ( abs(thing->x - viletryx) > maxdist\n|| abs(thing->y - viletryy) > maxdist )\nreturn true;\t\t// not actually touching\n\ncorpsehit = thing;\ncorpsehit->momx = corpsehit->momy = 0;\ncorpsehit->height <<= 2;\ncheck = P_CheckPosition (corpsehit, corpsehit->x, corpsehit->y);\ncorpsehit->height >>= 2;\n\nif (!check)\nreturn true;\t\t// doesn't fit here\n\nreturn false;\t\t// got one, so stop checking\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int flags; int /*<<< orphan*/  vile_time; int /*<<< orphan*/  vile_time_end; TYPE_2__* player; TYPE_1__* map; } ;\nstruct TYPE_9__ {scalar_t__ x; scalar_t__ y; } ;\nstruct TYPE_8__ {scalar_t__ width; scalar_t__ height; } ;\ntypedef  TYPE_3__ PIT_Context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PIT_VileDraw (TYPE_3__*,scalar_t__,scalar_t__) ;\nint PIT_VileFlags ;\nscalar_t__ PIT_VileTime ;\nscalar_t__ PIT_VileTimeEnd ;\nint /*<<< orphan*/  PIT_VileTimeStart ;\nint /*<<< orphan*/  PIT_VileTimeStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartEndEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartEndStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStart ;\nint /*<<< orphan*/  PIT_VileTimeStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartStartEnd ;\nint"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_ShutdownSound",
    "input":"\n0000000000000000 <I_ShutdownSound>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rdi  # 0x8 <I_ShutdownSound+0x8>\n8: \tmovl\t$0, %esi\nd: \tcallq\t0x12 <I_ShutdownSound+0x12>\n12: \tmovq\t(%rip), %rdi  # 0x19 <I_ShutdownSound+0x19>\n19: \tcallq\t0x1e <I_ShutdownSound+0x1e>\n1e: \tmovl\t(%rip), %edi  # 0x24 <I_ShutdownSound+0x24>\n24: \tpopq\t%rax\n25: \tjmp\t0x2a <I_ShutdownSound+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SoundDelTimer () ;\nint /*<<< orphan*/  audio_fd ;\nint /*<<< orphan*/ * channels ;\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fflush (scalar_t__) ;\nint /*<<< orphan*/  fprintf (scalar_t__,char*) ;\nscalar_t__ sndserver ;\nscalar_t__ stderr ;\n\nvoid I_ShutdownSound(void)\n{\n#ifdef SNDSERV\nif (sndserver)\n{\n// Send a \"quit\" command.\nfprintf(sndserver, \"q\\n\");\nfflush(sndserver);\n}\n#else\n// Wait till all pending sounds are finished.\nint done = 0;\nint i;\n\n\n// FIXME (below).\nfprintf( stderr, \"I_ShutdownSound: NOT finishing pending sounds\\n\");\nfflush( stderr );\n\nwhile ( !done )\n{\nfor( i=0 ; i<8 && !channels[i] ; i++);\n\n// FIXME. No proper channel output.\n//if (i==8)\ndone=1;\n}\n#ifdef SNDINTR\nI_SoundDelTimer();\n#endif\n\n// Cleaning up -releasing the DSP device.\nclose ( audio_fd );\n#endif\n\n// Done.\nreturn;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  D_Print (char*) ;\nint /*<<< orphan*/  I_ShutdownMusic () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Snd () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Sys () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Wav () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Midi () ;\nint /*<<< orphan*/  I_ShutdownSoundDevices_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Xm_Snd () ;\nint"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_lights.c_EV_TurnTagLightsOff",
    "input":"\n0000000000000000 <EV_TurnTagLightsOff>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t(%rip), %eax  # 0xe <EV_TurnTagLightsOff+0xe>\ne: \ttestl\t%eax, %eax\n10: \tjle\t0x8e <EV_TurnTagLightsOff+0x8e>\n12: \tmovq\t%rdi, %r14\n15: \txorl\t%r15d, %r15d\n18: \tmovq\t(%rip), %rbx  # 0x1f <EV_TurnTagLightsOff+0x1f>\n1f: \tjmp\t0x47 <EV_TurnTagLightsOff+0x47>\n21: \tnopw\t%cs:(%rax,%rax)\n2b: \tnopl\t(%rax,%rax)\n30: \tmovl\t(%rip), %eax  # 0x36 <EV_TurnTagLightsOff+0x36>\n36: \tmovl\t%r12d, 8(%rbx)\n3a: \taddl\t$1, %r15d\n3e: \taddq\t$24, %rbx\n42: \tcmpl\t%eax, %r15d\n45: \tjge\t0x8e <EV_TurnTagLightsOff+0x8e>\n47: \tmovq\t(%rbx), %rcx\n4a: \tcmpq\t(%r14), %rcx\n4d: \tjne\t0x3a <EV_TurnTagLightsOff+0x3a>\n4f: \tmovl\t8(%rbx), %r12d\n53: \tcmpl\t$0, 12(%rbx)\n57: \tjle\t0x36 <EV_TurnTagLightsOff+0x36>\n59: \txorl\t%ebp, %ebp\n5b: \tjmp\t0x6d <EV_TurnTagLightsOff+0x6d>\n5d: \tnopl\t(%rax)\n60: \taddq\t$1, %rbp\n64: \tmovslq\t12(%rbx), %rax\n68: \tcmpq\t%rax, %rbp\n6b: \tjge\t0x30 <EV_TurnTagLightsOff+0x30>\n6d: \tmovq\t16(%rbx), %rax\n71: \tmovq\t(%rax,%rbp,8), %rdi\n75: \tmovq\t%rbx, %rsi\n78: \tcallq\t0x7d <EV_TurnTagLightsOff+0x7d>\n7d: \ttestq\t%rax, %rax\n80: \tje\t0x60 <EV_TurnTagLightsOff+0x60>\n82: \tmovl\t8(%rax), %eax\n85: \tcmpl\t%r12d, %eax\n88: \tcmovlel\t%eax, %r12d\n8c: \tjmp\t0x60 <EV_TurnTagLightsOff+0x60>\n8e: \tpopq\t%rbx\n8f: \tpopq\t%r12\n91: \tpopq\t%r14\n93: \tpopq\t%r15\n95: \tpopq\t%rbp\n96: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ tag; int lightlevel; int linecount; TYPE_2__** lines; } ;\ntypedef  TYPE_1__ sector_t ;\nstruct TYPE_9__ {scalar_t__ tag; } ;\ntypedef  TYPE_2__ line_t ;\n\n/* Variables and functions */\nTYPE_1__* getNextSector (TYPE_2__*,TYPE_1__*) ;\nint numsectors ;\nTYPE_1__* sectors ;\n\nvoid EV_TurnTagLightsOff(line_t* line)\n{\nint\t\t\ti;\nint\t\t\tj;\nint\t\t\tmin;\nsector_t*\t\tsector;\nsector_t*\t\ttsec;\nline_t*\t\ttempline;\n\nsector = sectors;\n\nfor (j = 0;j < numsectors; j++, sector++)\n{\nif (sector->tag == line->tag)\n{\nmin = sector->lightlevel;\nfor (i = 0;i < sector->linecount; i++)\n{\ntempline = sector->lines[i];\ntsec = getNextSector(templine,sector);\nif (!tsec)\ncontinue;\nif (tsec->lightlevel < min)\nmin = tsec->lightlevel;\n}\nsector->lightlevel = min;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ tag; int /*<<< orphan*/  light; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  light; } ;\nstruct TYPE_8__ {scalar_t__ tag; int /*<<< orphan*/  light; TYPE_2__* lights; } ;\ntypedef  TYPE_1__ EV_TagLight ;\ntypedef  TYPE_2__ EV_Light ;\ntypedef  TYPE_3__ EV_Tag ;\n\n/* Variables and functions */\nint EV_NumTagLights ;\nTYPE_1__* TagLights ;\nTYPE_3__* Tags ;\nTYPE_1__* TurnTagLightOff (TYPE_2__*,TYPE_1__*) ;\n\nvoid EV_TurnTagLightsOff(EV_Tag *tag)\n{\nint i;\n\nfor (i = 0; i < EV_NumTagLights; i++)\n{\nEV_TagLight *tl = &TagLights[i];\n\nif (tl->tag == tag->tag)\n{\nint j;\n\nfor (j = 0; j < tl->light; j++)\n{\nEV_Light *light = &tl->lights[j];\n\nif (TurnTagLightOff(light, tl))\n{\ntl->light = light->light;\n}\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_addMessageToSText",
    "input":"\n0000000000000000 <HUlib_addMessageToSText>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %rbx\n8: \tmovq\t%rsi, %r15\nb: \tmovq\t%rdi, %r14\ne: \tcallq\t0x13 <HUlib_addMessageToSText+0x13>\n13: \ttestq\t%r15, %r15\n16: \tje\t0x4f <HUlib_addMessageToSText+0x4f>\n18: \tmovb\t(%r15), %al\n1b: \ttestb\t%al, %al\n1d: \tje\t0x4f <HUlib_addMessageToSText+0x4f>\n1f: \taddq\t$1, %r15\n23: \tnopw\t%cs:(%rax,%rax)\n2d: \tnopl\t(%rax)\n30: \tmovq\t(%r14), %rdi\n33: \tshlq\t$2, %rdi\n37: \taddq\t8(%r14), %rdi\n3b: \tmovsbl\t%al, %esi\n3e: \tcallq\t0x43 <HUlib_addMessageToSText+0x43>\n43: \tmovzbl\t(%r15), %eax\n47: \taddq\t$1, %r15\n4b: \ttestb\t%al, %al\n4d: \tjne\t0x30 <HUlib_addMessageToSText+0x30>\n4f: \tmovb\t(%rbx), %al\n51: \ttestb\t%al, %al\n53: \tje\t0x7e <HUlib_addMessageToSText+0x7e>\n55: \taddq\t$1, %rbx\n59: \tnopl\t(%rax)\n60: \tmovq\t(%r14), %rdi\n63: \tshlq\t$2, %rdi\n67: \taddq\t8(%r14), %rdi\n6b: \tmovsbl\t%al, %esi\n6e: \tcallq\t0x73 <HUlib_addMessageToSText+0x73>\n73: \tmovzbl\t(%rbx), %eax\n76: \taddq\t$1, %rbx\n7a: \ttestb\t%al, %al\n7c: \tjne\t0x60 <HUlib_addMessageToSText+0x60>\n7e: \tpopq\t%rbx\n7f: \tpopq\t%r14\n81: \tpopq\t%r15\n83: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t cl; int /*<<< orphan*/ * l; } ;\ntypedef  TYPE_1__ hu_stext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_addCharToTextLine (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HUlib_addLineToSText (TYPE_1__*) ;\n\nvoid\nHUlib_addMessageToSText\n( hu_stext_t*\ts,\nchar*\t\tprefix,\nchar*\t\tmsg )\n{\nHUlib_addLineToSText(s);\nif (prefix)\nwhile (*prefix)\nHUlib_addCharToTextLine(&s->l[s->cl], *(prefix++));\n\nwhile (*msg)\nHUlib_addCharToTextLine(&s->l[s->cl], *(msg++));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t sTextLen; int /*<<< orphan*/ * sText; } ;\ntypedef  TYPE_1__ HUCHAR_INFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_addCharToSText (int /*<<< orphan*/ *,char) ;\n\nvoid HUlib_addMessageToSText(HUCHAR_INFO *charInfo, char *message, char *messageEnd)\n{\nwhile (message < messageEnd)\n{\nHUlib_addCharToSText(&charInfo->sText[charInfo->sTextLen], *message++);\n}\n\nwhile (*message)\n{\nHUlib_addCharToSText(&charInfo->sText[charInfo->sTextLen], *message++);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_End",
    "input":"\n0000000000000000 <WI_End>:\n0: \tjmp\t0x5 <WI_End+0x5>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid WI_End(void)\n{\nvoid WI_unloadData(void);\nWI_unloadData();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WI ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_End_ (int /*<<< orphan*/ *) ;\n\nvoid WI_End(WI* wi)\n{\nWI_End_(wi);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_StopMusic",
    "input":"\n0000000000000000 <S_StopMusic>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <S_StopMusic+0x8>\n8: \ttestq\t%rax, %rax\nb: \tje\t0x6b <S_StopMusic+0x6b>\nd: \tcmpq\t$0, (%rip)    # 0x15 <S_StopMusic+0x15>\n15: \tje\t0x26 <S_StopMusic+0x26>\n17: \tmovl\t8(%rax), %edi\n1a: \tcallq\t0x1f <S_StopMusic+0x1f>\n1f: \tmovq\t(%rip), %rax  # 0x26 <S_StopMusic+0x26>\n26: \tmovl\t8(%rax), %edi\n29: \tcallq\t0x2e <S_StopMusic+0x2e>\n2e: \tmovq\t(%rip), %rax  # 0x35 <S_StopMusic+0x35>\n35: \tmovl\t8(%rax), %edi\n38: \tcallq\t0x3d <S_StopMusic+0x3d>\n3d: \tmovq\t(%rip), %rax  # 0x44 <S_StopMusic+0x44>\n44: \tmovq\t(%rax), %rdi\n47: \tmovl\t(%rip), %esi  # 0x4d <S_StopMusic+0x4d>\n4d: \tcallq\t0x52 <S_StopMusic+0x52>\n52: \tmovq\t(%rip), %rax  # 0x59 <S_StopMusic+0x59>\n59: \tmovq\t$0, (%rax)\n60: \tmovq\t$0, (%rip)    # 0x6b <S_StopMusic+0x6b>\n6b: \tpopq\t%rax\n6c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ data; int /*<<< orphan*/  handle; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ResumeSong (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  I_StopSong (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  I_UnRegisterSong (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  Z_ChangeTag (scalar_t__,int /*<<< orphan*/ ) ;\nscalar_t__ mus_paused ;\nTYPE_1__* mus_playing ;\n\nvoid S_StopMusic(void)\n{\nif (mus_playing)\n{\nif (mus_paused)\nI_ResumeSong(mus_playing->handle);\n\nI_StopSong(mus_playing->handle);\nI_UnRegisterSong(mus_playing->handle);\nZ_ChangeTag(mus_playing->data, PU_CACHE);\n\nmus_playing->data = 0;\nmus_playing = 0;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ handle; int /*<<< orphan*/  data; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DSound_Stop (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  DSound_Unload (scalar_t__) ;\nint /*<<< orphan*/  S_music ;\nTYPE_1__* S_music_data ;\nscalar_t__ S_music_paused ;\nscalar_t__ S_music_playing ;\n\nvoid S_StopMusic(void)\n{\nif (S_music_playing)\n{\nif (!S_music_paused)\n{\nDSound_Stop(S_music_data[0].data);\n}\n\nDSound_Stop(S_music_data[1].data);\nDSound_Stop(S_music_data[2].data);\n\nDSound_Unload(S_music_data[0].handle);\n\nS_music_playing = 0;\nS_music_paused = 0;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_CheckTextureNumForName",
    "input":"\n0000000000000000 <R_CheckTextureNumForName>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \txorl\t%r14d, %r14d\n7: \tcmpb\t$45, (%rdi)\na: \tje\t0x53 <R_CheckTextureNumForName+0x53>\nc: \tmovl\t$4294967295, %r14d # imm = 0xFFFFFFFF\n12: \tcmpl\t$0, (%rip)    # 0x19 <R_CheckTextureNumForName+0x19>\n19: \tjle\t0x53 <R_CheckTextureNumForName+0x53>\n1b: \tmovq\t%rdi, %rbx\n1e: \txorl\t%ebp, %ebp\n20: \tmovq\t(%rip), %rax  # 0x27 <R_CheckTextureNumForName+0x27>\n27: \tmovq\t(%rax,%rbp,8), %rax\n2b: \tmovl\t(%rax), %edi\n2d: \tmovq\t%rbx, %rsi\n30: \tmovl\t$8, %edx\n35: \tcallq\t0x3a <R_CheckTextureNumForName+0x3a>\n3a: \ttestl\t%eax, %eax\n3c: \tje\t0x50 <R_CheckTextureNumForName+0x50>\n3e: \taddq\t$1, %rbp\n42: \tmovslq\t(%rip), %rax  # 0x49 <R_CheckTextureNumForName+0x49>\n49: \tcmpq\t%rax, %rbp\n4c: \tjl\t0x20 <R_CheckTextureNumForName+0x20>\n4e: \tjmp\t0x53 <R_CheckTextureNumForName+0x53>\n50: \tmovl\t%ebp, %r14d\n53: \tmovl\t%r14d, %eax\n56: \tpopq\t%rbx\n57: \tpopq\t%r14\n59: \tpopq\t%rbp\n5a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  name; } ;\n\n/* Variables and functions */\nint numtextures ;\nint /*<<< orphan*/  strncasecmp (int /*<<< orphan*/ ,char*,int) ;\nTYPE_1__** textures ;\n\nint\tR_CheckTextureNumForName (char *name)\n{\nint\t\ti;\n\n// \"NoTexture\" marker.\nif (name[0] == '-')\nreturn 0;\n\nfor (i=0 ; i<numtextures ; i++)\nif (!strncasecmp (textures[i]->name, name, 8) )\nreturn i;\n\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  name; } ;\ntypedef  TYPE_1__ texture_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  strncmp (int /*<<< orphan*/ ,char const*,int) ;\nTYPE_1__** texture ;\nint numtextures ;\n\nint\nR_CheckTextureNumForName(const char *name)\n{\nint\t\t\ti;\n\nif (name[0] == '-')\nreturn -1;\n\nfor (i = 0; i < numtextures; i++)\nif (!strncmp(texture[i]->name, name, 8))\nreturn i;\n\nreturn -1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_Stop",
    "input":"\n0000000000000000 <ST_Stop>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <ST_Stop+0x8>\n8: \tje\t0xc <ST_Stop+0xc>\na: \tpopq\t%rax\nb: \tretq\nc: \tmovl\t(%rip), %edi  # 0x12 <ST_Stop+0x12>\n12: \tmovl\t(%rip), %esi  # 0x18 <ST_Stop+0x18>\n18: \tcallq\t0x1d <ST_Stop+0x1d>\n1d: \tmovl\t%eax, %edi\n1f: \tcallq\t0x24 <ST_Stop+0x24>\n24: \tmovl\t$1, (%rip)    # 0x2e <ST_Stop+0x2e>\n2e: \tpopq\t%rax\n2f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SetPalette (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  W_CacheLumpNum (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lu_palette ;\nint st_stopped ;\n\nvoid ST_Stop (void)\n{\nif (st_stopped)\nreturn;\n\nI_SetPalette (W_CacheLumpNum (lu_palette, PU_CACHE));\n\nst_stopped = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  CloseHandle (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ST_hThread ;\nint /*<<< orphan*/  ST_hThread_event ;\nint /*<<< orphan*/  ST_hThread_started ;\nint /*<<< orphan*/  WaitForSingleObject (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid ST_Stop(void)\n{\nif (!ST_hThread_started)\nreturn;\n\nWaitForSingleObject(ST_hThread_event, 0);\nCloseHandle(ST_hThread);\nST_hThread_started = 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SpawnSound",
    "input":"\n0000000000000000 <A_SpawnSound>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rip), %esi  # 0xa <A_SpawnSound+0xa>\na: \tcallq\t0xf <A_SpawnSound+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <A_SpawnSound+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SpawnFly (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_boscub ;\n\nvoid A_SpawnSound (mobj_t* mo)\n{\nS_StartSound (mo,sfx_boscub);\nA_SpawnFly(mo);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ARGUMENT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SpawnSound2 ;\nint /*<<< orphan*/  DoSound (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  P_SpawnMobj (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static VOID A_SpawnSound(ARGUMENT arg)\n{\nP_SpawnMobj(&arg, A_SpawnSound2);\nDoSound(&arg);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_plane.c_R_FindPlane",
    "input":"\n0000000000000000 <R_FindPlane>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edx, %r14d\na: \tmovl\t%esi, %r15d\nd: \txorl\t%eax, %eax\nf: \tcmpl\t%esi, (%rip)  # 0x15 <R_FindPlane+0x15>\n15: \tmovl\t$0, %ebp\n1a: \tcmovneq\t%rdi, %rbp\n1e: \tcmovel\t%eax, %r14d\n22: \tmovq\t(%rip), %rcx  # 0x29 <R_FindPlane+0x29>\n29: \tmovq\t(%rip), %rax  # 0x30 <R_FindPlane+0x30>\n30: \tmovq\t%rcx, %rbx\n33: \tcmpq\t%rax, %rcx\n36: \tjae\t0x5c <R_FindPlane+0x5c>\n38: \tmovq\t%rcx, %rbx\n3b: \tjmp\t0x49 <R_FindPlane+0x49>\n3d: \tnopl\t(%rax)\n40: \taddq\t$32, %rbx\n44: \tcmpq\t%rax, %rbx\n47: \tjae\t0x5c <R_FindPlane+0x5c>\n49: \tcmpq\t(%rbx), %rbp\n4c: \tjne\t0x40 <R_FindPlane+0x40>\n4e: \tcmpl\t%r15d, 8(%rbx)\n52: \tjne\t0x40 <R_FindPlane+0x40>\n54: \tcmpl\t12(%rbx), %r14d\n58: \tjne\t0x40 <R_FindPlane+0x40>\n5a: \tjmp\t0xbb <R_FindPlane+0xbb>\n5c: \tmovq\t%rax, %rdx\n5f: \tsubq\t%rcx, %rdx\n62: \tsarq\t$5, %rdx\n66: \tmovslq\t(%rip), %rcx  # 0x6d <R_FindPlane+0x6d>\n6d: \tcmpq\t%rcx, %rdx\n70: \tjne\t0x83 <R_FindPlane+0x83>\n72: \tmovl\t$0, %edi\n77: \tcallq\t0x7c <R_FindPlane+0x7c>\n7c: \tmovq\t(%rip), %rax  # 0x83 <R_FindPlane+0x83>\n83: \taddq\t$32, %rax\n87: \tmovq\t%rax, (%rip)  # 0x8e <R_FindPlane+0x8e>\n8e: \tmovq\t%rbp, (%rbx)\n91: \tmovl\t%r15d, 8(%rbx)\n95: \tmovl\t%r14d, 12(%rbx)\n99: \tmovl\t(%rip), %eax  # 0x9f <R_FindPlane+0x9f>\n9f: \tmovl\t%eax, 24(%rbx)\na2: \tmovl\t$4294967295, 16(%rbx)   # imm = 0xFFFFFFFF\na9: \tmovl\t20(%rbx), %edi\nac: \tmovl\t$255, %esi\nb1: \tmovl\t$4, %edx\nb6: \tcallq\t0xbb <R_FindPlane+0xbb>\nbb: \tmovq\t%rbx, %rax\nbe: \taddq\t$8, %rsp\nc2: \tpopq\t%rbx\nc3: \tpopq\t%r14\nc5: \tpopq\t%r15\nc7: \tpopq\t%rbp\nc8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ height; int picnum; int lightlevel; int maxx; int /*<<< orphan*/  top; int /*<<< orphan*/  minx; } ;\ntypedef  TYPE_1__ visplane_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint MAXVISPLANES ;\nint /*<<< orphan*/  SCREENWIDTH ;\nTYPE_1__* lastvisplane ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int,int) ;\nint skyflatnum ;\nTYPE_1__* visplanes ;\n\nvisplane_t*\nR_FindPlane\n( fixed_t\theight,\nint\t\tpicnum,\nint\t\tlightlevel )\n{\nvisplane_t*\tcheck;\n\nif (picnum == skyflatnum)\n{\nheight = 0;\t\t\t// all skys map together\nlightlevel = 0;\n}\n\nfor (check=visplanes; check<lastvisplane; check++)\n{\nif (height == check->height\n&& picnum == check->picnum\n&& lightlevel == check->lightlevel)\n{\nbreak;\n}\n}\n\n\nif (check < lastvisplane)\nreturn check;\n\nif (lastvisplane - visplanes == MAXVISPLANES)\nI_Error (\"R_FindPlane: no more visplanes\");\n\nlastvisplane++;\n\ncheck->height = height;\ncheck->picnum = picnum;\ncheck->lightlevel = lightlevel;\ncheck->minx = SCREENWIDTH;\ncheck->maxx = -1;\n\nmemset (check->top,0xff,sizeof(check->top));\n\nreturn check;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* plane; int /*<<< orphan*/  light; int /*<<< orphan*/  texture; int /*<<< orphan*/  lightnum; int /*<<< orphan*/  textureid; int /*<<< orphan*/  lightlevel; int /*<<< orphan*/  lighttype; } ;\ntypedef  TYPE_1__ plane_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  D_FatalError (char*) ;\nint MAXPLANES ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  r_light ;\nint /*<<< orphan*/  r_numplanes ;\nTYPE_1__* r_planes ;\nTYPE_1__* r_planelist ;\n\nplane_t *R_FindPlane (int *plane, int light, int lightlevel)\n{\nint\t\ti;\n\nif (light == r_light)\nlight = 0;\n\nfor (i=0 ; i<r_numplanes ; i++)\n{\nif (r_planelist[i].plane == plane)\n{\nif (r_planelist[i].light == light)\n{\nif (r_planelist[i].lightlevel == lightlevel)\n{\nreturn &r_planelist[i];\n}\n}\n}\n}\n\nif (r_numplanes == MAXPLANES)\n{\nD_FatalError (\"R_FindPlane: no more planes\");\n}\n\nr_planelist[r_numplanes].plane = plane;\nr_planelist[r_numplanes].light = light;\nr_planelist[r_numplanes].lightlevel = lightlevel;\nr_planelist[r_numplanes].lighttype = r_light;\nr_planelist[r_numplanes].lightnum = 255;\nr_planelist[r_numplanes].textureid = 0;\nr_planelist[r_numplanes].texture = 0;\nmemset (r_planelist[r_numplanes].texture, 0, 4);\n\nreturn &r_planelist[r_numplanes++];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_BeginRead",
    "input":"\n0000000000000000 <I_BeginRead>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_BeginRead(void)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  IStream_t ;\n\n/* Variables and functions */\n\nvoid I_BeginRead(IStream_t *stream)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_XScream",
    "input":"\n0000000000000000 <A_XScream>:\n0: \tmovl\t(%rip), %esi  # 0x6 <A_XScream+0x6>\n6: \tjmp\t0xb <A_XScream+0xb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_slop ;\n\nvoid A_XScream (mobj_t* actor)\n{\nS_StartSound (actor, sfx_slop);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_X ;\nint /*<<< orphan*/  method (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static var A_XScream(var self) {\nreturn method(self, A_X);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_BringUpWeapon",
    "input":"\n0000000000000000 <P_BringUpWeapon>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t(%rdi), %rax\n7: \tcmpq\t(%rip), %rax  # 0xe <P_BringUpWeapon+0xe>\ne: \tjne\t0x17 <P_BringUpWeapon+0x17>\n10: \tmovq\t8(%rbx), %rax\n14: \tmovq\t%rax, (%rbx)\n17: \tcmpq\t(%rip), %rax  # 0x1e <P_BringUpWeapon+0x1e>\n1e: \tjne\t0x31 <P_BringUpWeapon+0x31>\n20: \tmovl\t24(%rbx), %edi\n23: \tmovl\t(%rip), %esi  # 0x29 <P_BringUpWeapon+0x29>\n29: \tcallq\t0x2e <P_BringUpWeapon+0x2e>\n2e: \tmovq\t(%rbx), %rax\n31: \tmovq\t(%rip), %rcx  # 0x38 <P_BringUpWeapon+0x38>\n38: \tmovl\t(%rcx,%rax,4), %edx\n3b: \tmovq\t(%rip), %rax  # 0x42 <P_BringUpWeapon+0x42>\n42: \tmovq\t%rax, (%rbx)\n45: \tmovl\t(%rip), %eax  # 0x4b <P_BringUpWeapon+0x4b>\n4b: \tmovq\t16(%rbx), %rcx\n4f: \tmovq\t(%rip), %rsi  # 0x56 <P_BringUpWeapon+0x56>\n56: \tmovl\t%eax, (%rcx,%rsi,4)\n59: \tmovq\t%rbx, %rdi\n5c: \tpopq\t%rbx\n5d: \tjmp\t0x62 <P_BringUpWeapon+0x62>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  statenum_t ;\nstruct TYPE_7__ {size_t pendingweapon; size_t readyweapon; TYPE_1__* psprites; int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_2__ player_t ;\nstruct TYPE_8__ {int /*<<< orphan*/  upstate; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  sy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_SetPsprite (TYPE_2__*,size_t,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WEAPONBOTTOM ;\nsize_t ps_weapon ;\nint /*<<< orphan*/  sfx_sawup ;\nTYPE_3__* weaponinfo ;\nsize_t wp_chainsaw ;\nsize_t wp_nochange ;\n\nvoid P_BringUpWeapon (player_t* player)\n{\nstatenum_t\tnewstate;\n\nif (player->pendingweapon == wp_nochange)\nplayer->pendingweapon = player->readyweapon;\n\nif (player->pendingweapon == wp_chainsaw)\nS_StartSound (player->mo, sfx_sawup);\n\nnewstate = weaponinfo[player->pendingweapon].upstate;\n\nplayer->pendingweapon = wp_nochange;\nplayer->psprites[ps_weapon].sy = WEAPONBOTTOM;\n\nP_SetPsprite (player, ps_weapon, newstate);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct player_t {scalar_t__ p_weapon; scalar_t__ p_last_weapon; int /*<<< orphan*/  p_ammo_amount; int /*<<< orphan*/ * p_ammo_type; int /*<<< orphan*/  p_x; int /*<<< orphan*/  p_y; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  am_noise; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_NOISE ;\nint /*<<< orphan*/  P_Noise (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetPsprite (struct player_t*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_UnsetPsprite (struct player_t*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ps_weapon ;\nint /*<<< orphan*/  ps_weaponup ;\nint /*<<< orphan*/  ps_weaponup2 ;\nint /*<<< orphan*/  ps_weaponup3 ;\nint /*<<< orphan*/  ps_weaponup4 ;\nint /*<<< orphan*/  ps_weaponup5 ;\nint /*<<< orphan*/  ps_weaponup6 ;\nint /*<<< orphan*/  ps_weaponup7 ;\nint /*<<< orphan*/  ps_weaponup8 ;\nint /*<<< orphan*/  ps_weaponup9 ;\nint /*<<< orphan*/  ps_weaponupa ;\nint /*<<< orphan*/  ps_weaponupb ;\nint /*<<< orphan*/  ps_weaponupc ;\nint /*<<< orphan*/  ps_weaponupd ;\nint /*<<< orphan*/  ps_weaponeup ;\nint /*<<< orphan*/  ps_weaponupf ;\nint /*<<< orphan*/  ps_weaponglow ;\nint /*<<< orphan*/  ps_weaponupg ;\nint /*<<< orphan*/  ps_weaponuph ;\nint /*<<< orphan*/  ps_weaponupi ;\nint /*<<< orphan*/  ps_weaponupj ;\nint /*<<< orphan*/  ps_weaponupk ;\nint /*<<< orphan*/  ps_weaponupl ;\nint /*<<< orphan*/  ps_weaponupl ;\nint /*<<< orphan*/  ps_weaponupr ;\nint /*<<< orphan*/  ps_weaponups ;\nint /*<<< orphan*/  ps_weaponupt ;\nint /*<<< orphan*/  ps_weaponupu ;\nint /*<<< orphan*/  ps_weaponupv ;\nint /*<<< orphan*/  ps_weaponupw ;\nint /*<<< orphan*/  ps_weaponupx ;\nint /*<<< orphan*/  ps_weaponupy ;\nint /*<<< orphan*/  ps_weaponupz ;\nint /*<<< orphan*/  ps_weaponup1 ;\nint /*<<< orphan*/  ps_weaponup2 ;\nint /*<<< orphan*/  ps_weaponup3 ;\nint /*<<< orphan*/  ps_weaponup4 ;\nint /*<<< orphan*/  ps_weaponup5 ;\nint /*<<< orphan*/  ps_weaponup6 ;\nint /*<<< orphan*/  ps_weaponup7 ;\nint /*<<< orphan*/  ps_weaponup8 ;\nint /*<<< orphan*/  ps_weaponup9 ;\nint /*<<< orphan*/  ps_weaponupa ;\nint /*<<< orphan*/  ps_weaponupb ;\nint /*<<< orphan*/  ps_weaponupc ;\nint /*<<< orphan*/  ps_weaponupd ;\nint /*<<< orphan*/  ps_weaponeup ;\nint /*<<< orphan*/  ps_weaponupf ;\nint /*<<< orphan*/  ps_weaponglow ;\nint /*<<< orphan*/  ps_weaponupg ;\nint /*<<< orphan*/  ps_weaponuph ;\nint /*<<< orphan*/  ps_weaponupi ;\nint /*<<< orphan*/  ps_weaponupj ;\nint /*<<< orphan*/  ps_weaponupk ;\nint /*<<< orphan*/  ps_weaponupl ;\nint /*<<< orphan*/  ps_weaponupl ;\nint /*<<< orphan*/  ps_weaponupr ;\nint /*<<< orphan*/  ps_weaponups ;\nint /*<<< orphan*/  ps_weaponupt ;\nint /*<<< orphan*/  ps_weaponupu ;\nint /*<<< orphan*/  ps_weaponupv ;\nint /*<<< orphan*/  ps_weaponupw ;\nint /*<<< orphan*/  ps_weaponupx ;\nint /*<<< orphan*/  ps_weaponupy ;\nint /*<<< orphan*/  ps_weaponupz ;\nint /*<<< orphan*/  ps_weaponup1 ;\nint /*<<< orphan*/  ps_weaponup2 ;\nint /*<<< orphan*/  ps_weaponup3 ;\nint /*<<< orphan*/  ps_weaponup4 ;\nint /*<<< orphan*/  ps_weaponup5 ;\nint /*<<< orphan*/  ps_weaponup6 ;\nint /*<<< orphan*/  ps_weaponup7 ;\nint /*<<< orphan*/  ps_weaponup8 ;\nint /*<<< orphan*/  ps_weaponup9 ;\nint /*<<< orphan*/  ps_weaponupa ;\nint /*<<< orphan*/  ps_weaponupb ;\nint /*<<< orphan*/  ps_weaponupc ;\nint /*<<< orphan*/  ps_weaponupd ;\nint /*<<< orphan*/  ps_weaponeup ;\nint /*<<< orphan*/  ps_weaponupf ;\nint /*<<< orphan*/  ps_weaponglow ;\nint /*<<< orphan*/  ps_weaponupg ;\nint /*<<< orphan*/  ps_weaponuph ;\nint /*<<< orphan*/  ps_weaponupi ;\nint /*<<< orphan*/  ps_weaponupj ;\nint /*<<< orphan*/  ps_weaponupk ;\nint /*<<< orphan*/  ps_weaponupl ;\nint /*<<< orphan*/  ps_weaponupl ;\nint /*<<< orphan*/  ps_weaponupr ;\nint /*<<< orphan*/  ps_weaponups ;\nint /*<<< orphan*/  ps_weaponupt ;\nint /*<<< orphan*/  ps_weaponupu ;\nint /*<<< orphan*/  ps_weaponupv ;\nint /*<<< orphan*/  ps_weaponupw ;\nint /*<<< orphan*/  ps_weaponupx ;\nint /*<<< orphan*/  ps_weaponupy ;\nint /*<<< orphan*/  ps_weaponupz ;\nint /*<<< orphan*/  ps_weaponup1 ;\nint /*<<< orphan*/  ps_weaponup2 ;\nint /*<<< orphan*/  ps_weaponup3 ;\nint /*<<< orphan"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_OpenShotgun2",
    "input":"\n0000000000000000 <A_OpenShotgun2>:\n0: \tmovl\t(%rdi), %edi\n2: \tmovl\t(%rip), %esi  # 0x8 <A_OpenShotgun2+0x8>\n8: \tjmp\t0xd <A_OpenShotgun2+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_3__ {int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_dbopn ;\n\nvoid\nA_OpenShotgun2\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nS_StartSound (player->mo, sfx_dbopn);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  hwnd; } ;\ntypedef  TYPE_1__* PSHOTGUN2 ;\ntypedef  int /*<<< orphan*/  HWND ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_OpenShotgun2_WndProc ;\nint /*<<< orphan*/  SetWindowLongPtrW (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid A_OpenShotgun2(PSHOTGUN2 pShotgun2)\n{\nHWND hwnd = pShotgun2->hwnd;\nSetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR)A_OpenShotgun2_WndProc);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_HU_dequeueChatChar",
    "input":"\n0000000000000000 <HU_dequeueChatChar>:\n0: \tmovq\t(%rip), %rcx  # 0x7 <HU_dequeueChatChar+0x7>\n7: \tcmpq\t%rcx, (%rip)  # 0xe <HU_dequeueChatChar+0xe>\ne: \tjne\t0x13 <HU_dequeueChatChar+0x13>\n10: \txorl\t%eax, %eax\n12: \tretq\n13: \tmovq\t(%rip), %rax  # 0x1a <HU_dequeueChatChar+0x1a>\n1a: \tmovb\t(%rax,%rcx), %al\n1d: \taddq\t$1, %rcx\n21: \tmovslq\t(%rip), %rdx  # 0x28 <HU_dequeueChatChar+0x28>\n28: \taddq\t$-1, %rdx\n2c: \tandq\t%rcx, %rdx\n2f: \tmovq\t%rdx, (%rip)  # 0x36 <HU_dequeueChatChar+0x36>\n36: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint QUEUESIZE ;\nchar* chatchars ;\nsize_t head ;\nsize_t tail ;\n\nchar HU_dequeueChatChar(void)\n{\nchar c;\n\nif (head != tail)\n{\nc = chatchars[tail];\ntail = (tail + 1) & (QUEUESIZE-1);\n}\nelse\n{\nc = 0;\n}\n\nreturn c;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nsize_t HU_chatQueueHead ;\nsize_t HU_chatQueueTail ;\n\nchar HU_dequeueChatChar(void)\n{\nchar c;\n\nif (HU_chatQueueHead == HU_chatQueueTail)\nreturn 0;\n\nc = HU_chatQueue[HU_chatQueueHead];\nHU_chatQueueHead = (HU_chatQueueHead + 1) & (HU_CHAT_QUEUE_SIZE - 1);\nreturn c;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_drawIText",
    "input":"\n0000000000000000 <HUlib_drawIText>:\n0: \tmovq\t(%rdi), %rax\n3: \tcmpl\t$0, (%rax)\n6: \tje\t0x16 <HUlib_drawIText+0x16>\n8: \taddq\t$8, %rdi\nc: \tmovl\t$1, %esi\n11: \tjmp\t0x16 <HUlib_drawIText+0x16>\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  hu_textline_t ;\nstruct TYPE_3__ {int /*<<< orphan*/ * on; int /*<<< orphan*/  l; } ;\ntypedef  TYPE_1__ hu_itext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_drawTextLine (int /*<<< orphan*/ *,int) ;\n\nvoid HUlib_drawIText(hu_itext_t* it)\n{\n\nhu_textline_t *l = &it->l;\n\nif (!*it->on)\nreturn;\nHUlib_drawTextLine(l, true); // draw the line w/ cursor\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * font; } ;\ntypedef  TYPE_1__ HU_Font ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_drawIText (TYPE_1__*,int) ;\n\nvoid HUlib_drawIText(HU_Font *font, int x, int y)\n{\nif (font->font[0])\nHU_drawIText(font, 1);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_CPosAttack",
    "input":"\n0000000000000000 <A_CPosAttack>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tcmpl\t$0, 4(%rdi)\nb: \tje\t0x9e <A_CPosAttack+0x9e>\n11: \tmovq\t%rdi, %rbx\n14: \tmovl\t(%rip), %esi  # 0x1a <A_CPosAttack+0x1a>\n1a: \tcallq\t0x1f <A_CPosAttack+0x1f>\n1f: \tmovq\t%rbx, %rdi\n22: \tcallq\t0x27 <A_CPosAttack+0x27>\n27: \tmovl\t(%rbx), %r15d\n2a: \tmovl\t(%rip), %edx  # 0x30 <A_CPosAttack+0x30>\n30: \tmovq\t%rbx, %rdi\n33: \tmovl\t%r15d, %esi\n36: \tcallq\t0x3b <A_CPosAttack+0x3b>\n3b: \tmovl\t%eax, %r14d\n3e: \txorl\t%eax, %eax\n40: \tcallq\t0x45 <A_CPosAttack+0x45>\n45: \tmovl\t%eax, %ebp\n47: \txorl\t%eax, %eax\n49: \tcallq\t0x4e <A_CPosAttack+0x4e>\n4e: \tsubl\t%eax, %ebp\n50: \tshll\t$20, %ebp\n53: \taddl\t%ebp, %r15d\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <A_CPosAttack+0x5d>\n5d: \tcltq\n5f: \timulq\t$1717986919, %rax, %rcx # imm = 0x66666667\n66: \tmovq\t%rcx, %rdx\n69: \tshrq\t$63, %rdx\n6d: \tsarq\t$33, %rcx\n71: \taddl\t%edx, %ecx\n73: \tleal\t(%rcx,%rcx,4), %ecx\n76: \tsubl\t%ecx, %eax\n78: \tleal\t(%rax,%rax,2), %r8d\n7c: \taddl\t$3, %r8d\n80: \tmovl\t(%rip), %edx  # 0x86 <A_CPosAttack+0x86>\n86: \tmovq\t%rbx, %rdi\n89: \tmovl\t%r15d, %esi\n8c: \tmovl\t%r14d, %ecx\n8f: \taddq\t$8, %rsp\n93: \tpopq\t%rbx\n94: \tpopq\t%r14\n96: \tpopq\t%r15\n98: \tpopq\t%rbp\n99: \tjmp\t0x9e <A_CPosAttack+0x9e>\n9e: \taddq\t$8, %rsp\na2: \tpopq\t%rbx\na3: \tpopq\t%r14\na5: \tpopq\t%r15\na7: \tpopq\t%rbp\na8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int angle; int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  MISSILERANGE ;\nint P_AimLineAttack (TYPE_1__*,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_LineAttack (TYPE_1__*,int,int /*<<< orphan*/ ,int,int) ;\nint P_Random () ;\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_shotgn ;\n\nvoid A_CPosAttack (mobj_t* actor)\n{\nint\t\tangle;\nint\t\tbangle;\nint\t\tdamage;\nint\t\tslope;\n\nif (!actor->target)\nreturn;\n\nS_StartSound (actor, sfx_shotgn);\nA_FaceTarget (actor);\nbangle = actor->angle;\nslope = P_AimLineAttack (actor, bangle, MISSILERANGE);\n\nangle = bangle + ((P_Random()-P_Random())<<20);\ndamage = ((P_Random()%5)+1)*3;\nP_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  x; int /*<<< orphan*/  cpos; int /*<<< orphan*/  cpos_attack; } ;\ntypedef  TYPE_1__ Enemy ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_CPosAttack_ ;\nint /*<<< orphan*/  A_CPosAttack_1 ;\nint /*<<< orphan*/  A_CPosAttack_2 ;\nint /*<<< orphan*/  A_CPosAttack_3 ;\nint /*<<< orphan*/  A_CPosAttack_4 ;\nint /*<<< orphan*/  A_CPosAttack_5 ;\nint /*<<< orphan*/  A_CPosAttack_6 ;\nint /*<<< orphan*/  A_CPosAttack_7 ;\nint /*<<< orphan*/  A_CPosAttack_8 ;\nint /*<<< orphan*/  A_CPosAttack_9 ;\nint /*<<< orphan*/  A_CPosAttack_10 ;\nint /*<<< orphan*/  A_CPosAttack_11 ;\nint /*<<< orphan*/  A_CPosAttack_12 ;\nint /*<<< orphan*/  A_CPosAttack_13 ;\nint /*<<< orphan*/  A_CPosAttack_14 ;\nint /*<<< orphan*/  A_CPosAttack_15 ;\nint /*<<< orphan*/  A_CPosAttack_16 ;\nint /*<<< orphan*/  A_CPosAttack_17 ;\nint /*<<< orphan*/  A_CPosAttack_18 ;\nint /*<<< orphan*/  A_CPosAttack_19 ;\nint /*<<< orphan*/  A_CPosAttack_20 ;\nint /*<<< orphan*/  A_CPosAttack_21 ;\nint /*<<< orphan*/  A_CPosAttack_22 ;\nint /*<<< orphan*/  A_CPosAttack_23 ;\nint /*<<< orphan*/  A_CPosAttack_24 ;\nint /*<<< orphan*/  A_CPosAttack_25 ;\nint /*<<< orphan*/  A_CPosAttack_26 ;\nint /*<<< orphan*/  A_CPosAttack_27 ;\nint /*<<< orphan*/  A_CPosAttack_28 ;\nint /*<<< orphan*/  A_CPosAttack_29 ;\nint /*<<< orphan*/  A_CPosAttack_30 ;\nint /*<<< orphan*/  A_CPosAttack_31 ;\nint /*<<< orphan*/  A_CPosAttack_32 ;\nint /*<<< orphan*/  A_CPosAttack_33 ;\nint /*<<< orphan*/  A_CPosAttack_34 ;\nint /*<<< orphan*/  A_CPosAttack_35 ;\nint /*<<< orphan*/  A_CPosAttack_36 ;\nint /*<<< orphan*/  A_CPosAttack_37 ;\nint /*<<< orphan*/  A_CPosAttack_38 ;\nint /*<<< orphan*/  A_CPosAttack_39 ;\nint /*<<< orphan*/  A_CPosAttack_40 ;\nint /*<<< orphan*/  A_CPosAttack_41 ;\nint /*<<< orphan*/  A_CPosAttack_42 ;\nint /*<<< orphan*/  A_CPosAttack_43 ;\nint /*<<< orphan*/  A_CPosAttack_44 ;\nint /*<<< orphan*/  A_CPosAttack_45 ;\nint /*<<< orphan*/  A_CPosAttack_46 ;\nint /*<<< orphan*/  A_CPosAttack_47 ;\nint /*<<< orphan*/  A_CPosAttack_48 ;\nint /*<<< orphan*/  A_CPosAttack_49 ;\nint /*<<< orphan*/  A_CPosAttack_50 ;\nint /*<<< orphan*/  A_CPosAttack_51 ;\nint /*<<< orphan*/  A_CPosAttack_52 ;\nint /*<<< orphan*/  A_CPosAttack_53 ;\nint /*<<< orphan*/  A_CPosAttack_54 ;\nint /*<<< orphan*/  A_CPosAttack_55 ;\nint /*<<< orphan*/  A_CPosAttack_56 ;\nint /*<<< orphan*/  A_CPosAttack_57 ;\nint /*<<< orphan*/  A_CPosAttack_58 ;\nint /*<<< orphan*/  A_CPosAttack_59 ;\nint /*<<< orphan*/  A_CPosAttack_60 ;\nint /*<<< orphan*/  A_CPosAttack_61 ;\nint /*<<< orphan*/  A_CPosAttack_62 ;\nint /*<<< orphan*/  A_CPosAttack_63 ;\nint /*<<< orphan*/  A_CPosAttack_64 ;\nint /*<<< orphan*/  A_CPosAttack_65 ;\nint /*<<< orphan*/  A_CPosAttack_66 ;\nint /*<<< orphan*/  A_CPosAttack_67 ;\nint /*<<< orphan*/  A_CPosAttack_68 ;\nint /*<<< orphan*/  A_CPosAttack_69 ;\nint /*<<< orphan*/  A_CPosAttack_70 ;\nint /*<<< orphan*/  A_CPosAttack_71 ;\nint /*<<< orphan*/  A_CPosAttack_72 ;\nint /*<<< orphan*/  A_CPosAttack_73 ;\nint /*<<< orphan*/  A_CPosAttack_74 ;\nint /*<<< orphan*/  A_CPosAttack_75 ;\nint /*<<< orphan*/  A_CPosAttack_76 ;\nint /*<<< orphan*/  A_CPosAttack_77 ;\nint /*<<< orphan*/  A_CPosAttack_78 ;\nint /*<<< orphan*/  A_CPosAttack_79 ;\nint /*<<< orphan*/  A_CPosAttack_80 ;\nint /*<<< orphan*/  A_CPosAttack_81 ;\nint /*<<< orphan*/  A_CPosAttack_82 ;\nint /*<<< orphan*/  A_CPosAttack_83 ;\nint /*<<< orphan*/  A_CPosAttack_84 ;\nint /*<<< orphan*/  A_CPosAttack_85 ;\nint /*<<< orphan*/  A_CPosAttack_86 ;\nint /*<<< orphan*/  A_CPosAttack_87 ;\nint /*<<< orphan*/  A_CPosAttack_88 ;\nint /*<<< orphan*/  A_CPosAttack_89 ;\nint /*<<< orphan*/  A_CPosAttack_90 ;\nint /*<<< orphan*/  A_CPosAttack_91 ;\nint /*<<< orphan*/  A_CPosAttack_92 ;\nint /*<<< orphan*/  A_CPosAttack_93 ;\nint /*<<< orphan*/  A_CPosAttack_94 ;\nint /*<<< orphan*/  A_CPosAttack_95 ;\nint /*<<< orphan*/  A_CPosAttack_96 ;\nint /*<<< orphan*/  A_CPosAttack_97 ;\nint /*<<< or"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_argv.c_M_CheckParm",
    "input":"\n0000000000000000 <M_CheckParm>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \txorl\t%r14d, %r14d\n7: \tcmpl\t$2, (%rip)    # 0xe <M_CheckParm+0xe>\ne: \tjl\t0x4b <M_CheckParm+0x4b>\n10: \tmovq\t%rdi, %rbx\n13: \tmovl\t$1, %ebp\n18: \tnopl\t(%rax,%rax)\n20: \tmovq\t(%rip), %rax  # 0x27 <M_CheckParm+0x27>\n27: \tmovl\t(%rax,%rbp,4), %esi\n2a: \tmovq\t%rbx, %rdi\n2d: \tcallq\t0x32 <M_CheckParm+0x32>\n32: \ttestl\t%eax, %eax\n34: \tje\t0x48 <M_CheckParm+0x48>\n36: \taddq\t$1, %rbp\n3a: \tmovslq\t(%rip), %rax  # 0x41 <M_CheckParm+0x41>\n41: \tcmpq\t%rax, %rbp\n44: \tjl\t0x20 <M_CheckParm+0x20>\n46: \tjmp\t0x4b <M_CheckParm+0x4b>\n48: \tmovl\t%ebp, %r14d\n4b: \tmovl\t%r14d, %eax\n4e: \tpopq\t%rbx\n4f: \tpopq\t%r14\n51: \tpopq\t%rbp\n52: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint myargc ;\nint /*<<< orphan*/ * myargv ;\nint /*<<< orphan*/  strcasecmp (char*,int /*<<< orphan*/ ) ;\n\nint M_CheckParm (char *check)\n{\nint\t\ti;\n\nfor (i = 1;i<myargc;i++)\n{\nif ( !strcasecmp(check, myargv[i]) )\nreturn i;\n}\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/ * m_argv ;\nint m_argc ;\nint /*<<< orphan*/  strcmp (char const*,int /*<<< orphan*/ ) ;\n\nint M_CheckParm(const char *parm)\n{\nint i;\n\nfor (i = 1; i < m_argc; i++)\nif (!strcmp(parm, m_argv[i]))\nreturn i;\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_bsp.c_R_ClearDrawSegs",
    "input":"\n0000000000000000 <R_ClearDrawSegs>:\n0: \tmovl\t(%rip), %eax  # 0x6 <R_ClearDrawSegs+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <R_ClearDrawSegs+0xc>\nc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  drawsegs ;\nint /*<<< orphan*/  ds_p ;\n\nvoid R_ClearDrawSegs (void)\n{\nds_p = drawsegs;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  drawsegs ;\nint /*<<< orphan*/  segs ;\n\nvoid R_ClearDrawSegs(void)\n{\nsegs = drawsegs;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_UpdateSoundParams",
    "input":"\n0000000000000000 <I_UpdateSoundParams>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid\nI_UpdateSoundParams\n( int\thandle,\nint\tvol,\nint\tsep,\nint\tpitch)\n{\n// I fail too see that this is used.\n// Would be using the handle to identify\n//  on which channel the sound might be active,\n//  and resetting the channel parameters.\n\n// UNUSED.\nhandle = vol = sep = pitch = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_UpdateSoundParams(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_maputl.c_P_LineOpening",
    "input":"\n0000000000000000 <P_LineOpening>:\n0: \tmovq\t(%rdi), %rax\n3: \tcmpl\t$-1, 4(%rax)\n7: \tje\t0x54 <P_LineOpening+0x54>\n9: \tmovq\t8(%rdi), %rcx\nd: \tmovq\t16(%rdi), %rdx\n11: \tmovq\t(%rdx), %rsi\n14: \tmovq\t(%rcx), %rax\n17: \tcmpq\t%rax, %rsi\n1a: \tcmovleq\t%rsi, %rax\n1e: \tmovq\t%rax, (%rip)  # 0x25 <P_LineOpening+0x25>\n25: \tmovq\t8(%rdx), %rdx\n29: \tmovq\t8(%rcx), %rcx\n2d: \tcmpq\t%rcx, %rdx\n30: \tmovq\t%rcx, %rsi\n33: \tcmovgq\t%rdx, %rsi\n37: \tmovq\t%rsi, (%rip)  # 0x3e <P_LineOpening+0x3e>\n3e: \tcmovgq\t%rcx, %rdx\n42: \tmovq\t%rdx, (%rip)  # 0x49 <P_LineOpening+0x49>\n49: \tsubq\t%rsi, %rax\n4c: \tmovq\t%rax, (%rip)  # 0x53 <P_LineOpening+0x53>\n53: \tretq\n54: \txorl\t%eax, %eax\n56: \tmovq\t%rax, (%rip)  # 0x5d <P_LineOpening+0x5d>\n5d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ ceilingheight; scalar_t__ floorheight; } ;\ntypedef  TYPE_1__ sector_t ;\nstruct TYPE_5__ {int* sidenum; TYPE_1__* backsector; TYPE_1__* frontsector; } ;\ntypedef  TYPE_2__ line_t ;\n\n/* Variables and functions */\nscalar_t__ lowfloor ;\nscalar_t__ openbottom ;\nscalar_t__ openrange ;\nscalar_t__ opentop ;\n\nvoid P_LineOpening (line_t* linedef)\n{\nsector_t*\tfront;\nsector_t*\tback;\n\nif (linedef->sidenum[1] == -1)\n{\n// single sided line\nopenrange = 0;\nreturn;\n}\n\nfront = linedef->frontsector;\nback = linedef->backsector;\n\nif (front->ceilingheight < back->ceilingheight)\nopentop = front->ceilingheight;\nelse\nopentop = back->ceilingheight;\n\nif (front->floorheight > back->floorheight)\n{\nopenbottom = front->floorheight;\nlowfloor = back->floorheight;\n}\nelse\n{\nopenbottom = back->floorheight;\nlowfloor = front->floorheight;\n}\n\nopenrange = opentop - openbottom;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__* p; int /*<<< orphan*/  y; } ;\ntypedef  TYPE_1__* PLine ;\n\n/* Variables and functions */\nscalar_t__ P_LineOpening_x ;\nscalar_t__ P_LineOpening_y ;\nscalar_t__ P_LineOpening_y2 ;\nscalar_t__ P_LineOpening_y3 ;\n\n__attribute__((used)) static void P_LineOpening(PLine line)\n{\nif (line->y == -1)\n{\nP_LineOpening_x = 0;\nP_LineOpening_y = 0;\nP_LineOpening_y2 = 0;\nP_LineOpening_y3 = 0;\nreturn;\n}\n\nP_LineOpening_x = line->p[0] < line->p[1] ? line->p[0] : line->p[1];\nP_LineOpening_y = line->p[2] < line->p[3] ? line->p[2] : line->p[3];\nP_LineOpening_y2 = line->p[4] < line->p[5] ? line->p[4] : line->p[5];\nP_LineOpening_y3 = line->p[6] < line->p[7] ? line->p[6] : line->p[7];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_addCharToTextLine",
    "input":"\n0000000000000000 <HUlib_addCharToTextLine>:\n0: \tmovq\t(%rdi), %rcx\n3: \txorl\t%eax, %eax\n5: \tcmpq\t(%rip), %rcx  # 0xc <HUlib_addCharToTextLine+0xc>\nc: \tje\t0x34 <HUlib_addCharToTextLine+0x34>\ne: \tmovq\t8(%rdi), %rax\n12: \tleaq\t1(%rcx), %rdx\n16: \tmovq\t%rdx, (%rdi)\n19: \tmovb\t%sil, (%rax,%rcx)\n1d: \tmovq\t(%rdi), %rax\n20: \tmovq\t8(%rdi), %rcx\n24: \tmovb\t$0, (%rcx,%rax)\n28: \tmovl\t$4, 16(%rdi)\n2f: \tmovl\t$1, %eax\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t len; char* l; int needsupdate; } ;\ntypedef  TYPE_1__ hu_textline_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\nsize_t HU_MAXLINELENGTH ;\n\nboolean\nHUlib_addCharToTextLine\n( hu_textline_t*\tt,\nchar\t\t\tch )\n{\n\nif (t->len == HU_MAXLINELENGTH)\nreturn false;\nelse\n{\nt->l[t->len++] = ch;\nt->l[t->len] = 0;\nt->needsupdate = 4;\nreturn true;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ textLinePos; char* textLine; int /*<<< orphan*/  textLineLen; } ;\ntypedef  TYPE_1__ HUCHAR_INFO ;\n\n/* Variables and functions */\nscalar_t__ HU_MAX_TEXT_LINE_LEN ;\n\nint HUlib_addCharToTextLine(HUCHAR_INFO *charInfo, char c)\n{\nif (charInfo->textLinePos == HU_MAX_TEXT_LINE_LEN)\nreturn 0;\n\ncharInfo->textLine[charInfo->textLinePos++] = c;\ncharInfo->textLine[charInfo->textLinePos] = 0;\ncharInfo->textLineLen = 4;\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_addMark",
    "input":"\n0000000000000000 <AM_addMark>:\n0: \tmovl\t(%rip), %eax  # 0x6 <AM_addMark+0x6>\n6: \tmovl\t%eax, %ecx\n8: \tshrl\t$31, %ecx\nb: \taddl\t%eax, %ecx\nd: \tsarl\t%ecx\nf: \tmovslq\t%ecx, %rax\n12: \taddq\t(%rip), %rax  # 0x19 <AM_addMark+0x19>\n19: \tmovq\t(%rip), %rcx  # 0x20 <AM_addMark+0x20>\n20: \tmovq\t(%rip), %rdx  # 0x27 <AM_addMark+0x27>\n27: \tshlq\t$4, %rdx\n2b: \tmovq\t%rax, 8(%rcx,%rdx)\n30: \tmovl\t(%rip), %eax  # 0x36 <AM_addMark+0x36>\n36: \tmovl\t%eax, %edx\n38: \tshrl\t$31, %edx\n3b: \taddl\t%eax, %edx\n3d: \tsarl\t%edx\n3f: \tmovslq\t%edx, %rax\n42: \taddq\t(%rip), %rax  # 0x49 <AM_addMark+0x49>\n49: \tmovq\t(%rip), %rdx  # 0x50 <AM_addMark+0x50>\n50: \tshlq\t$4, %rdx\n54: \tmovq\t%rax, (%rcx,%rdx)\n58: \tmovq\t(%rip), %rax  # 0x5f <AM_addMark+0x5f>\n5f: \taddq\t$1, %rax\n63: \txorl\t%edx, %edx\n65: \tdivq\t(%rip)   # 0x6c <AM_addMark+0x6c>\n6c: \tmovq\t%rdx, (%rip)  # 0x73 <AM_addMark+0x73>\n73: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ y; scalar_t__ x; } ;\n\n/* Variables and functions */\nsize_t AM_NUMMARKPOINTS ;\nint m_h ;\nint m_w ;\nscalar_t__ m_x ;\nscalar_t__ m_y ;\nsize_t markpointnum ;\nTYPE_1__* markpoints ;\n\nvoid AM_addMark(void)\n{\nmarkpoints[markpointnum].x = m_x + m_w/2;\nmarkpoints[markpointnum].y = m_y + m_h/2;\nmarkpointnum = (markpointnum + 1) % AM_NUMMARKPOINTS;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ AM_MARK_SIZE ;\nscalar_t__ AM_MARK_SIZE_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t__ AM_MARK_SIZE_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG_LOG ;\nscalar_t"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_FatAttack3",
    "input":"\n0000000000000000 <A_FatAttack3>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r14\n8: \tcallq\t0xd <A_FatAttack3+0xd>\nd: \tmovl\t32(%r14), %esi\n11: \tmovl\t(%rip), %edx  # 0x17 <A_FatAttack3+0x17>\n17: \tmovq\t%r14, %rdi\n1a: \tcallq\t0x1f <A_FatAttack3+0x1f>\n1f: \tmovq\t%rax, %rbx\n22: \tmovl\t(%rip), %eax  # 0x28 <A_FatAttack3+0x28>\n28: \tmovl\t%eax, %ecx\n2a: \tshrl\t$31, %ecx\n2d: \taddl\t%eax, %ecx\n2f: \tsarl\t%ecx\n31: \tmovl\t(%rbx), %eax\n33: \tsubl\t%ecx, %eax\n35: \tmovl\t%eax, (%rbx)\n37: \tmovb\t(%rip), %cl   # 0x3d <A_FatAttack3+0x3d>\n3d: \tsarl\t%cl, %eax\n3f: \tmovq\t8(%rbx), %rcx\n43: \tmovl\t(%rcx), %edi\n45: \tmovq\t(%rip), %rcx  # 0x4c <A_FatAttack3+0x4c>\n4c: \tmovslq\t%eax, %r15\n4f: \tmovl\t(%rcx,%r15,4), %esi\n53: \tcallq\t0x58 <A_FatAttack3+0x58>\n58: \tmovq\t%rax, 24(%rbx)\n5c: \tmovq\t8(%rbx), %rax\n60: \tmovl\t(%rax), %edi\n62: \tmovq\t(%rip), %rax  # 0x69 <A_FatAttack3+0x69>\n69: \tmovl\t(%rax,%r15,4), %esi\n6d: \tcallq\t0x72 <A_FatAttack3+0x72>\n72: \tmovq\t%rax, 16(%rbx)\n76: \tmovl\t32(%r14), %esi\n7a: \tmovl\t(%rip), %edx  # 0x80 <A_FatAttack3+0x80>\n80: \tmovq\t%r14, %rdi\n83: \tcallq\t0x88 <A_FatAttack3+0x88>\n88: \tmovq\t%rax, %rbx\n8b: \tmovl\t(%rip), %eax  # 0x91 <A_FatAttack3+0x91>\n91: \tmovl\t%eax, %edx\n93: \tshrl\t$31, %edx\n96: \taddl\t%eax, %edx\n98: \tsarl\t%edx\n9a: \taddl\t(%rbx), %edx\n9c: \tmovl\t%edx, (%rbx)\n9e: \tmovb\t(%rip), %cl   # 0xa4 <A_FatAttack3+0xa4>\na4: \tsarl\t%cl, %edx\na6: \tmovq\t8(%rbx), %rax\naa: \tmovl\t(%rax), %edi\nac: \tmovq\t(%rip), %rax  # 0xb3 <A_FatAttack3+0xb3>\nb3: \tmovslq\t%edx, %r14\nb6: \tmovl\t(%rax,%r14,4), %esi\nba: \tcallq\t0xbf <A_FatAttack3+0xbf>\nbf: \tmovq\t%rax, 24(%rbx)\nc3: \tmovq\t8(%rbx), %rax\nc7: \tmovl\t(%rax), %edi\nc9: \tmovq\t(%rip), %rax  # 0xd0 <A_FatAttack3+0xd0>\nd0: \tmovl\t(%rax,%r14,4), %esi\nd4: \tcallq\t0xd9 <A_FatAttack3+0xd9>\nd9: \tmovq\t%rax, 16(%rbx)\ndd: \tpopq\t%rbx\nde: \tpopq\t%r14\ne0: \tpopq\t%r15\ne2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int angle; TYPE_1__* info; void* momy; void* momx; int /*<<< orphan*/  target; } ;\ntypedef  TYPE_2__ mobj_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  speed; } ;\n\n/* Variables and functions */\nint ANGLETOFINESHIFT ;\nint /*<<< orphan*/  A_FaceTarget (TYPE_2__*) ;\nint FATSPREAD ;\nvoid* FixedMul (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MT_FATSHOT ;\nTYPE_2__* P_SpawnMissile (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * finecosine ;\nint /*<<< orphan*/ * finesine ;\n\nvoid A_FatAttack3 (mobj_t*\tactor)\n{\nmobj_t*\tmo;\nint\t\tan;\n\nA_FaceTarget (actor);\n\nmo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\nmo->angle -= FATSPREAD/2;\nan = mo->angle >> ANGLETOFINESHIFT;\nmo->momx = FixedMul (mo->info->speed, finecosine[an]);\nmo->momy = FixedMul (mo->info->speed, finesine[an]);\n\nmo = P_SpawnMissile (actor, actor->target, MT_FATSHOT);\nmo->angle += FATSPREAD/2;\nan = mo->angle >> ANGLETOFINESHIFT;\nmo->momx = FixedMul (mo->info->speed, finecosine[an]);\nmo->momy = FixedMul (mo->info->speed, finesine[an]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  y; TYPE_1__* pActor; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  y; TYPE_1__* pActor; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  y; } ;\ntypedef  TYPE_1__* PANIMATOR ;\ntypedef  TYPE_2__* PANIMATETARGET ;\ntypedef  TYPE_3__* PANIMATE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FatAttack2 ;\nint /*<<< orphan*/  A_FatAttack3_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss ;\nint /*<<< orphan*/  A_FatAttack3_Boss_Boss_Boss_Boss_Boss_Boss_Boss_Boss"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_mobj.c_P_SpawnBlood",
    "input":"\n0000000000000000 <P_SpawnBlood>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t%ecx, %r14d\nb: \tmovl\t%edx, %ebx\nd: \tmovl\t%esi, %r15d\n10: \tmovl\t%edi, %r12d\n13: \txorl\t%eax, %eax\n15: \tcallq\t0x1a <P_SpawnBlood+0x1a>\n1a: \tmovl\t%eax, %ebp\n1c: \txorl\t%eax, %eax\n1e: \tcallq\t0x23 <P_SpawnBlood+0x23>\n23: \tsubl\t%eax, %ebp\n25: \tshll\t$10, %ebp\n28: \taddl\t%ebp, %ebx\n2a: \tmovl\t(%rip), %ecx  # 0x30 <P_SpawnBlood+0x30>\n30: \tmovl\t%r12d, %edi\n33: \tmovl\t%r15d, %esi\n36: \tmovl\t%ebx, %edx\n38: \tcallq\t0x3d <P_SpawnBlood+0x3d>\n3d: \tmovq\t%rax, %rbx\n40: \tmovl\t(%rip), %eax  # 0x46 <P_SpawnBlood+0x46>\n46: \taddl\t%eax, %eax\n48: \tmovl\t%eax, (%rbx)\n4a: \txorl\t%eax, %eax\n4c: \tcallq\t0x51 <P_SpawnBlood+0x51>\n51: \tandl\t$3, %eax\n54: \tmovl\t4(%rbx), %ecx\n57: \tsubl\t%eax, %ecx\n59: \ttestl\t%ecx, %ecx\n5b: \tmovl\t$1, %eax\n60: \tcmovgl\t%ecx, %eax\n63: \tmovl\t%eax, 4(%rbx)\n66: \tleal\t-9(%r14), %ecx\n6a: \tmovl\t$0, %eax\n6f: \tcmpl\t$4, %ecx\n72: \tjb\t0x7f <P_SpawnBlood+0x7f>\n74: \tmovl\t$0, %eax\n79: \tcmpl\t$8, %r14d\n7d: \tjg\t0x91 <P_SpawnBlood+0x91>\n7f: \tmovl\t(%rax), %esi\n81: \tmovq\t%rbx, %rdi\n84: \tpopq\t%rbx\n85: \tpopq\t%r12\n87: \tpopq\t%r14\n89: \tpopq\t%r15\n8b: \tpopq\t%rbp\n8c: \tjmp\t0x91 <P_SpawnBlood+0x91>\n91: \tpopq\t%rbx\n92: \tpopq\t%r12\n94: \tpopq\t%r14\n96: \tpopq\t%r15\n98: \tpopq\t%rbp\n99: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int momz; int tics; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int fixed_t ;\n\n/* Variables and functions */\nint FRACUNIT ;\nint /*<<< orphan*/  MT_BLOOD ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_1__*,int /*<<< orphan*/ ) ;\nTYPE_1__* P_SpawnMobj (int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_BLOOD2 ;\nint /*<<< orphan*/  S_BLOOD3 ;\n\nvoid\nP_SpawnBlood\n( fixed_t\tx,\nfixed_t\ty,\nfixed_t\tz,\nint\t\tdamage )\n{\nmobj_t*\tth;\n\nz += ((P_Random()-P_Random())<<10);\nth = P_SpawnMobj (x,y,z, MT_BLOOD);\nth->momz = FRACUNIT*2;\nth->tics -= P_Random()&3;\n\nif (th->tics < 1)\nth->tics = 1;\n\nif (damage <= 12 && damage >= 9)\nP_SetMobjState (th,S_BLOOD2);\nelse if (damage < 9)\nP_SetMobjState (th,S_BLOOD3);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int z; int /*<<< orphan*/  y; } ;\ntyped::type_t* P_SpawnMobj (int,int,int,int /*<<< orphan*/ ) ;\ntyped::type_t* P_SpawnPuff (int,int,int,int /*<<< orphan*/ ) ;\ntyped::type_t* P_SpawnThing (int,int,int,int /*<<< orphan*/ ) ;\n\n/* Variables and functions */\nint PUFF_SIZE ;\nint PUFF_SIZE_MAX ;\nint PUFF_SIZE_MIN ;\nint PUFF_SIZE_RANGE ;\nint PUFF_SIZE_RANGE_MAX ;\nint PUFF_SIZE_RANGE_MIN ;\nint PUFF_SIZE_RANGE_SHIFT ;\nint PUFF_SIZE_SHIFT ;\nint PUFF_SIZE_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MAX ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_RANGE_MIN ;\nint PUFF_SIZE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint PUFF_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_map.c_PIT_RadiusAttack",
    "input":"\n0000000000000000 <PIT_RadiusAttack>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %eax  # 0xa <PIT_RadiusAttack+0xa>\na: \ttestl\t%eax, (%rdi)\nc: \tje\t0xac <PIT_RadiusAttack+0xac>\n12: \tmovq\t%rdi, %rbx\n15: \tmovq\t8(%rdi), %rax\n19: \tcmpq\t(%rip), %rax  # 0x20 <PIT_RadiusAttack+0x20>\n20: \tje\t0xac <PIT_RadiusAttack+0xac>\n26: \tcmpq\t(%rip), %rax  # 0x2d <PIT_RadiusAttack+0x2d>\n2d: \tje\t0xac <PIT_RadiusAttack+0xac>\n2f: \tmovq\t24(%rbx), %rax\n33: \tmovq\t32(%rbx), %rcx\n37: \tmovq\t(%rip), %rsi  # 0x3e <PIT_RadiusAttack+0x3e>\n3e: \tsubq\t8(%rsi), %rcx\n42: \tmovq\t%rcx, %rdx\n45: \tnegq\t%rdx\n48: \tcmovlq\t%rcx, %rdx\n4c: \tsubq\t(%rsi), %rax\n4f: \tmovq\t%rax, %rdi\n52: \tnegq\t%rdi\n55: \tcmovlq\t%rax, %rdi\n59: \tcmpq\t%rdi, %rdx\n5c: \tcmovgeq\t%rdx, %rdi\n60: \tsubq\t16(%rbx), %rdi\n64: \tmovb\t(%rip), %cl   # 0x6a <PIT_RadiusAttack+0x6a>\n6a: \tsarq\t%cl, %rdi\n6d: \txorl\t%r14d, %r14d\n70: \ttestq\t%rdi, %rdi\n73: \tcmovnsq\t%rdi, %r14\n77: \tcmpq\t(%rip), %r14  # 0x7e <PIT_RadiusAttack+0x7e>\n7e: \tjge\t0xac <PIT_RadiusAttack+0xac>\n80: \tmovq\t%rbx, %rdi\n83: \tcallq\t0x88 <PIT_RadiusAttack+0x88>\n88: \ttestq\t%rax, %rax\n8b: \tje\t0xac <PIT_RadiusAttack+0xac>\n8d: \tmovq\t(%rip), %rsi  # 0x94 <PIT_RadiusAttack+0x94>\n94: \tmovl\t(%rip), %edx  # 0x9a <PIT_RadiusAttack+0x9a>\n9a: \tmovq\t(%rip), %rcx  # 0xa1 <PIT_RadiusAttack+0xa1>\na1: \tsubq\t%r14, %rcx\na4: \tmovq\t%rbx, %rdi\na7: \tcallq\t0xac <PIT_RadiusAttack+0xac>\nac: \tmovl\t$1, %eax\nb1: \taddq\t$8, %rsp\nb5: \tpopq\t%rbx\nb6: \tpopq\t%r14\nb8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int flags; scalar_t__ type; scalar_t__ radius; scalar_t__ y; scalar_t__ x; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  scalar_t__ fixed_t ;\ntypedef  int boolean ;\nstruct TYPE_9__ {scalar_t__ y; scalar_t__ x; } ;\n\n/* Variables and functions */\nscalar_t__ FRACBITS ;\nint MF_SHOOTABLE ;\nscalar_t__ MT_CYBORG ;\nscalar_t__ MT_SPIDER ;\nscalar_t__ P_CheckSight (TYPE_1__*,TYPE_2__*) ;\nint /*<<< orphan*/  P_DamageMobj (TYPE_1__*,TYPE_2__*,int /*<<< orphan*/ ,scalar_t__) ;\nscalar_t__ abs (scalar_t__) ;\nscalar_t__ bombdamage ;\nint /*<<< orphan*/  bombsource ;\nTYPE_2__* bombspot ;\n\nboolean PIT_RadiusAttack (mobj_t* thing)\n{\nfixed_t\tdx;\nfixed_t\tdy;\nfixed_t\tdist;\n\nif (!(thing->flags & MF_SHOOTABLE) )\nreturn true;\n\n// Boss spider and cyborg\n// take no damage from concussion.\nif (thing->type == MT_CYBORG\n|| thing->type == MT_SPIDER)\nreturn true;\n\ndx = abs(thing->x - bombspot->x);\ndy = abs(thing->y - bombspot->y);\n\ndist = dx>dy ? dx : dy;\ndist = (dist - thing->radius) >> FRACBITS;\n\nif (dist < 0)\ndist = 0;\n\nif (dist >= bombdamage)\nreturn true;\t// out of range\n\nif ( P_CheckSight (thing, bombspot) )\n{\n// must be in direct path\nP_DamageMobj (thing, bombspot, bombsource, bombdamage - dist);\n}\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int flags; scalar_t__ x; scalar_t__ y; scalar_t__ z; scalar_t__ radius; } ;\nstruct TYPE_4__ {scalar_t__ x; scalar_t__ y; scalar_t__ z; } ;\ntypedef  TYPE_1__ VECTOR ;\ntypedef  TYPE_2__ PIT ;\n\n/* Variables and functions */\nint PIT_FLAG_ACTIVE ;\nscalar_t__ PIT_TYPE_RADIUS ;\nscalar_t__ PIT_TYPE_RADIUS_ATTACK ;\nscalar_t__ PIT_TYPE_RADIUS_DEFENSE ;\nscalar_t__ PIT_TYPE_RADIUS_SPECIAL ;\nscalar_t__ PIT_TYPE_RADIUS_SPECIAL_ATTACK ;\nscalar_t__ PIT_TYPE_RADIUS_SPECIAL_DEFENSE ;\nscalar_t__ PIT_TYPE_RADIUS_SPECIAL_SPECIAL ;\nint /*<<< orphan*/  PIT_Update (TYPE_2__*) ;\nscalar_t__ PIT_is_active (TYPE_2__*) ;\nscalar_t__ PIT_is_special (TYPE_2__*) ;\nscalar_t__ PIT_is_special_attack (TYPE_2__*) ;\nscalar_t__ PIT_is_special_defense (TYPE_2__*) ;\nint /*<<< orphan*/  PIT_set_type (TYPE_2__*,scalar_t__,int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special_special_attack (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special_special_defense (TYPE_2__*,scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  PIT_update_radius_special_special_special_special_special_special_special_special_special_special_special (TYPE_2__*,scalar_t__,scalar_t"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_plane.c_R_InitPlanes",
    "input":"\n0000000000000000 <R_InitPlanes>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid R_InitPlanes (void)\n{\n// Doh!\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid R_InitPlanes(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_changeWindowLoc",
    "input":"\n0000000000000000 <AM_changeWindowLoc>:\n0: \tmovq\t(%rip), %rcx  # 0x7 <AM_changeWindowLoc+0x7>\n7: \tmovq\t(%rip), %rsi  # 0xe <AM_changeWindowLoc+0xe>\ne: \tmovq\t%rsi, %rax\n11: \torq\t%rcx, %rax\n14: \tje\t0x2d <AM_changeWindowLoc+0x2d>\n16: \tmovq\t$0, (%rip)    # 0x21 <AM_changeWindowLoc+0x21>\n21: \tmovl\t(%rip), %eax  # 0x27 <AM_changeWindowLoc+0x27>\n27: \tmovl\t%eax, (%rip)  # 0x2d <AM_changeWindowLoc+0x2d>\n2d: \taddq\t(%rip), %rcx  # 0x34 <AM_changeWindowLoc+0x34>\n34: \tmovq\t%rcx, (%rip)  # 0x3b <AM_changeWindowLoc+0x3b>\n3b: \taddq\t(%rip), %rsi  # 0x42 <AM_changeWindowLoc+0x42>\n42: \tmovq\t%rsi, (%rip)  # 0x49 <AM_changeWindowLoc+0x49>\n49: \tmovslq\t(%rip), %r8   # 0x50 <AM_changeWindowLoc+0x50>\n50: \tmovl\t%r8d, %eax\n53: \tshrl\t$31, %eax\n56: \taddl\t%r8d, %eax\n59: \tsarl\t%eax\n5b: \tcltq\n5d: \tleaq\t(%rcx,%rax), %rdx\n61: \tmovq\t(%rip), %rdi  # 0x68 <AM_changeWindowLoc+0x68>\n68: \tcmpq\t%rdi, %rdx\n6b: \tjg\t0x79 <AM_changeWindowLoc+0x79>\n6d: \tmovq\t(%rip), %rdi  # 0x74 <AM_changeWindowLoc+0x74>\n74: \tcmpq\t%rdi, %rdx\n77: \tjge\t0x86 <AM_changeWindowLoc+0x86>\n79: \tsubq\t%rax, %rdi\n7c: \tmovq\t%rdi, %rcx\n7f: \tmovq\t%rdi, (%rip)  # 0x86 <AM_changeWindowLoc+0x86>\n86: \tmovslq\t(%rip), %r10  # 0x8d <AM_changeWindowLoc+0x8d>\n8d: \tmovl\t%r10d, %eax\n90: \tshrl\t$31, %eax\n93: \taddl\t%r10d, %eax\n96: \tsarl\t%eax\n98: \tmovslq\t%eax, %rdi\n9b: \tleaq\t(%rsi,%rdi), %rdx\n9f: \tmovq\t(%rip), %rax  # 0xa6 <AM_changeWindowLoc+0xa6>\na6: \tcmpq\t%rax, %rdx\na9: \tjle\t0xb3 <AM_changeWindowLoc+0xb3>\nab: \tsubq\t%rdi, %rax\nae: \tmovq\t%rax, %rsi\nb1: \tjmp\t0xc5 <AM_changeWindowLoc+0xc5>\nb3: \tmovq\t(%rip), %r9   # 0xba <AM_changeWindowLoc+0xba>\nba: \tcmpq\t%r9, %rdx\nbd: \tjge\t0xcc <AM_changeWindowLoc+0xcc>\nbf: \tsubq\t%rdi, %r9\nc2: \tmovq\t%r9, %rsi\nc5: \tmovq\t%rsi, (%rip)  # 0xcc <AM_changeWindowLoc+0xcc>\ncc: \taddq\t%r8, %rcx\ncf: \tmovq\t%rcx, (%rip)  # 0xd6 <AM_changeWindowLoc+0xd6>\nd6: \taddq\t%r10, %rsi\nd9: \tmovq\t%rsi, (%rip)  # 0xe0 <AM_changeWindowLoc+0xe0>\ne0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  x; } ;\nstruct TYPE_3__ {scalar_t__ x; scalar_t__ y; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MAXINT ;\nTYPE_2__ f_oldloc ;\nscalar_t__ followplayer ;\nint m_h ;\nTYPE_1__ m_paninc ;\nint m_w ;\nscalar_t__ m_x ;\nscalar_t__ m_x2 ;\nscalar_t__ m_y ;\nscalar_t__ m_y2 ;\nscalar_t__ max_x ;\nscalar_t__ max_y ;\nscalar_t__ min_x ;\nscalar_t__ min_y ;\n\nvoid AM_changeWindowLoc(void)\n{\nif (m_paninc.x || m_paninc.y)\n{\nfollowplayer = 0;\nf_oldloc.x = MAXINT;\n}\n\nm_x += m_paninc.x;\nm_y += m_paninc.y;\n\nif (m_x + m_w/2 > max_x)\nm_x = max_x - m_w/2;\nelse if (m_x + m_w/2 < min_x)\nm_x = min_x - m_w/2;\n\nif (m_y + m_h/2 > max_y)\nm_y = max_y - m_h/2;\nelse if (m_y + m_h/2 < min_y)\nm_y = min_y - m_h/2;\n\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ AM_windowLoc ;\nscalar_t__ AM_windowSize ;\nint AM_windowSizeX ;\nint AM_windowSizeY ;\nscalar_t__ AM_windowTop ;\nscalar_t__ AM_windowX ;\nscalar_t__ AM_windowY ;\n\nvoid AM_changeWindowLoc(void)\n{\nif (AM_windowLoc || AM_windowSize)\n{\nAM_windowLoc = 0;\nAM_windowSize = 0;\nAM_windowX = AM_windowLoc + AM_windowSizeX/2;\nAM_windowY = AM_windowLoc + AM_windowSizeY/2;\nif (AM_windowX < AM_windowLoc)\n{\nAM_windowX = AM_windowLoc;\n}\nif (AM_windowX + AM_windowSizeX > AM_windowLoc + AM_windowSize)\n{\nAM_windowX = AM_windowLoc + AM_windowSize - AM_windowSizeX;\n}\nif (AM_windowY < AM_windowLoc)\n{\nAM_windowY = AM_windowLoc;\n}\nif (AM_windowY + AM_windowSizeY > AM_windowLoc + AM_windowSize)\n{\nAM_windowY = AM_windowLoc + AM_windowSize - AM_windowSizeY;\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_Ticker",
    "input":"\n0000000000000000 <ST_Ticker>:\n0: \tpushq\t%rax\n1: \taddl\t$1, (%rip)    # 0x8 <ST_Ticker+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <ST_Ticker+0xf>\nf: \tmovl\t%eax, (%rip)  # 0x15 <ST_Ticker+0x15>\n15: \txorl\t%eax, %eax\n17: \tcallq\t0x1c <ST_Ticker+0x1c>\n1c: \tmovq\t(%rip), %rax  # 0x23 <ST_Ticker+0x23>\n23: \tmovl\t(%rax), %eax\n25: \tmovl\t%eax, (%rip)  # 0x2b <ST_Ticker+0x2b>\n2b: \tpopq\t%rax\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  health; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Random () ;\nint /*<<< orphan*/  ST_updateWidgets () ;\nTYPE_1__* plyr ;\nint /*<<< orphan*/  st_clock ;\nint /*<<< orphan*/  st_oldhealth ;\nint /*<<< orphan*/  st_randomnumber ;\n\nvoid ST_Ticker (void)\n{\n\nst_clock++;\nst_randomnumber = M_Random();\nST_updateWidgets();\nst_oldhealth = plyr->health;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  st_ticker; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_Tick ;\nint /*<<< orphan*/  ST_TickCount ;\nint /*<<< orphan*/  ST_TickCount_old ;\nint /*<<< orphan*/  ST_TickCount_old2 ;\nint /*<<< orphan*/  ST_TickCount_old3 ;\nint /*<<< orphan*/  ST_TickCount_old4 ;\nint /*<<< orphan*/  ST_TickCount_old5 ;\nint /*<<< orphan*/  ST_TickCount_old6 ;\nint /*<<< orphan*/  ST_TickCount_old7 ;\nint /*<<< orphan*/  ST_TickCount_old8 ;\nint /*<<< orphan*/  ST_TickCount_old9 ;\nint /*<<< orphan*/  ST_TickCount_oldA ;\nint /*<<< orphan*/  ST_TickCount_oldB ;\nint /*<<< orphan*/  ST_TickCount_oldC ;\nint /*<<< orphan*/  ST_TickCount_oldD ;\nint /*<<< orphan*/  ST_TickCount_oldE ;\nint /*<<< orphan*/  ST_TickCount_oldF ;\nint /*<<< orphan*/  ST_TickCount_oldG ;\nint /*<<< orphan*/  ST_TickCount_oldH ;\nint /*<<< orphan*/  ST_TickCount_oldI ;\nint /*<<< orphan*/  ST_TickCount_oldJ ;\nint /*<<< orphan*/  ST_TickCount_oldK ;\nint /*<<< orphan*/  ST_TickCount_oldL ;\nint /*<<< orphan*/  ST_TickCount_oldM ;\nint /*<<< orphan*/  ST_TickCount_oldN ;\nint /*<<< orphan*/  ST_TickCount_oldO ;\nint /*<<< orphan*/  ST_TickCount_oldP ;\nint /*<<< orphan*/  ST_TickCount_oldQ ;\nint /*<<< orphan*/  ST_TickCount_oldR ;\nint /*<<< orphan*/  ST_TickCount_oldS ;\nint /*<<< orphan*/  ST_TickCount_oldT ;\nint /*<<< orphan*/  ST_TickCount_oldU ;\nint /*<<< orphan*/  ST_TickCount_oldV ;\nint /*<<< orphan*/  ST_TickCount_oldW ;\nint /*<<< orphan*/  ST_TickCount_oldX ;\nint /*<<< orphan*/  ST_TickCount_oldY ;\nint /*<<< orphan*/  ST_TickCount_oldZ ;\nint /*<<< orphan*/  ST_TickCount_olda ;\nint /*<<< orphan*/  ST_TickCount_oldb ;\nint /*<<< orphan*/  ST_TickCount_oldc ;\nint /*<<< orphan*/  ST_TickCount_oldd ;\nint /*<<< orphan*/  ST_TickCount_olde ;\nint /*<<< orphan*/  ST_TickCount_oldf ;\nint /*<<< orphan*/  ST_TickCount_oldg ;\nint /*<<< orphan*/  ST_TickCount_oldh ;\nint /*<<< orphan*/  ST_TickCount_oldi ;\nint /*<<< orphan*/  ST_TickCount_oldj ;\nint /*<<< orphan*/  ST_TickCount_oldk ;\nint /*<<< orphan*/  ST_TickCount_oldl ;\nint /*<<< orphan*/  ST_TickCount_oldm ;\nint /*<<< orphan*/  ST_TickCount_oldn ;\nint /*<<< orphan*/  ST_TickCount_oldo ;\nint /*<<< orphan*/  ST_TickCount_oldp ;\nint /*<<< orphan*/  ST_TickCount_oldq ;\nint /*<<< orphan*/  ST_TickCount_oldr ;\nint /*<<< orphan*/  ST_TickCount_olds ;\nint /*<<< orphan*/  ST_TickCount_oldt ;\nint /*<<< orphan*/  ST_TickCount_oldu ;\nint /*<<< orphan*/  ST_TickCount_oldv ;\nint /*<<< orphan*/  ST_TickCount_oldw ;\nint /*<<< orphan*/  ST_TickCount_oldx ;\nint /*<<< orphan*/  ST_TickCount_oldy ;\nint /*<<< orphan*/  ST_TickCount_oldz ;\nint /*<<< orphan*/  ST_TickCount_oldA ;\nint /*<<< orphan*/  ST_TickCount_oldB ;\nint /*<<< orphan*/  ST_TickCount_oldC ;\nint /*<<< orphan*/  ST_TickCount_oldD ;\nint /*<<< orphan*/  ST_TickCount_oldE ;\nint /*<<< orphan*/  ST_TickCount_oldF ;\nint /*<<< orphan*/  ST_TickCount_oldG ;\nint /*<<< orphan*/  ST_TickCount_oldH ;\nint /*<<< orphan*/  ST_TickCount_oldI ;\nint /*<<< orphan*/  ST_TickCount_oldJ ;\nint /*<<< orphan*/  ST_TickCount_oldK ;\nint /*<<< orphan*/  ST_TickCount_oldL ;\nint /*<<< orphan*/  ST_TickCount_oldM ;\nint /*<<< orphan*/  ST_TickCount_oldN ;\nint /*<<< orphan*/  ST_TickCount_oldO ;\nint /*<<< orphan*/  ST_TickCount_oldP ;\nint /*<<< orphan*/  ST_TickCount_oldQ ;\nint /*<<< orphan*/  ST_TickCount_oldR ;\nint /*<<< orphan*/  ST_TickCount_oldS ;\nint /*<<< orphan*/  ST_TickCount_oldT ;\nint /*<<< orphan*/  ST_TickCount_oldU ;\nint /*<<< orphan*/  ST_TickCount_oldV ;\nint /*<<< orphan*/  ST_TickCount_oldW ;\nint /*<<< orphan*/  ST_TickCount_oldX ;\nint /*<<< orphan*/  ST_TickCount_oldY ;\nint /*<<< orphan*/  ST_TickCount_oldZ ;\nint /*<<< orphan*/  ST_TickCount_olda ;\nint /*<<< orphan*/  ST_TickCount_oldb ;\nint /*<<< orphan*/  ST_TickCount_oldc ;\nint /*<<< orphan*/  ST_TickCount_oldd ;\nint /*<<< orphan*/  ST_TickCount_olde ;\nint /*<<< orphan*/  ST_TickCount_oldf ;\nint /*<<< orphan*/  ST_TickCount_oldg ;\nint /*<<< orphan*/  ST_TickCount_oldh ;\nint /*<<< orphan*/  ST_TickCount_oldi ;\nint /*<<< orphan*/  ST_TickCount_oldj ;\nint /*<<< orphan*/  ST_TickCount_oldk ;\nint /*<<< orphan*/  ST_TickCount_oldl ;\nint /*<<< orphan*/  ST_TickCount_oldm ;\nint /*<<< orphan*/  ST_TickCount_oldn ;\nint /*<<< orphan*/  ST_TickCount_oldo ;\nint /*<<< orphan*/  ST_TickCount_oldp ;\nint /*<<< orphan*/  ST_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_sky.c_R_InitSkyMap",
    "input":"\n0000000000000000 <R_InitSkyMap>:\n0: \timull\t$100, (%rip), %eax # 0x7 <R_InitSkyMap+0x7>\n7: \tmovl\t%eax, (%rip)  # 0xd <R_InitSkyMap+0xd>\nd: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint FRACUNIT ;\nint skytexturemid ;\n\nvoid R_InitSkyMap (void)\n{\n// skyflatnum = R_FlatNumForName ( SKYFLATNAME );\nskytexturemid = 100*FRACUNIT;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint sky_map_size ;\n\nvoid R_InitSkyMap(void)\n{\nsky_map_size = 100 * sizeof(int);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawSaveLoadBorder",
    "input":"\n0000000000000000 <M_DrawSaveLoadBorder>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r12\n7: \tpushq\t%rbx\n8: \tmovl\t%esi, %r15d\nb: \tmovl\t%edi, %r12d\ne: \tleal\t-8(%r12), %r14d\n13: \taddl\t$7, %r15d\n17: \tmovl\t(%rip), %esi  # 0x1d <M_DrawSaveLoadBorder+0x1d>\n1d: \tmovl\t$0, %edi\n22: \tcallq\t0x27 <M_DrawSaveLoadBorder+0x27>\n27: \txorl\t%ebx, %ebx\n29: \tmovl\t%r14d, %edi\n2c: \tmovl\t%r15d, %esi\n2f: \txorl\t%edx, %edx\n31: \tmovl\t%eax, %ecx\n33: \tcallq\t0x38 <M_DrawSaveLoadBorder+0x38>\n38: \tmovl\t(%rip), %esi  # 0x3e <M_DrawSaveLoadBorder+0x3e>\n3e: \tnop\n40: \tleal\t(%r12,%rbx), %ebp\n44: \tmovl\t$0, %edi\n49: \tcallq\t0x4e <M_DrawSaveLoadBorder+0x4e>\n4e: \tmovl\t%ebp, %edi\n50: \tmovl\t%r15d, %esi\n53: \txorl\t%edx, %edx\n55: \tmovl\t%eax, %ecx\n57: \tcallq\t0x5c <M_DrawSaveLoadBorder+0x5c>\n5c: \tmovl\t(%rip), %esi  # 0x62 <M_DrawSaveLoadBorder+0x62>\n62: \taddl\t$8, %ebx\n65: \tcmpl\t$192, %ebx\n6b: \tjne\t0x40 <M_DrawSaveLoadBorder+0x40>\n6d: \tmovl\t$0, %edi\n72: \tcallq\t0x77 <M_DrawSaveLoadBorder+0x77>\n77: \taddl\t%ebx, %r12d\n7a: \tmovl\t%r12d, %edi\n7d: \tmovl\t%r15d, %esi\n80: \txorl\t%edx, %edx\n82: \tmovl\t%eax, %ecx\n84: \tpopq\t%rbx\n85: \tpopq\t%r12\n87: \tpopq\t%r14\n89: \tpopq\t%r15\n8b: \tpopq\t%rbp\n8c: \tjmp\t0x91 <M_DrawSaveLoadBorder+0x91>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid M_DrawSaveLoadBorder(int x,int y)\n{\nint             i;\n\nV_DrawPatchDirect (x-8,y+7,0,W_CacheLumpName(\"M_LSLEFT\",PU_CACHE));\n\nfor (i = 0;i < 24;i++)\n{\nV_DrawPatchDirect (x,y+7,0,W_CacheLumpName(\"M_LSCNTR\",PU_CACHE));\nx += 8;\n}\n\nV_DrawPatchDirect (x,y+7,0,W_CacheLumpName(\"M_LSRGHT\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawHLine (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawVLine (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_FillRect (int,int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_GetColor (char*) ;\nint /*<<< orphan*/  M_GetColor (char*) ;\n\nvoid M_DrawSaveLoadBorder(UBYTE x, UBYTE y)\n{\nUBYTE i;\n\nM_FillRect(x-8, y-8, 16, 16, M_GetColor(\"black\"));\n\nfor (i=0; i<192; i+=8)\n{\nM_DrawHLine(x-8, y+i, 16, M_GetColor(\"black\"));\nM_DrawVLine(x+i, y-8, 16, M_GetColor(\"black\"));\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_checkForAccelerate",
    "input":"\n0000000000000000 <WI_checkForAccelerate>:\n0: \tcmpl\t$0, (%rip)    # 0x7 <WI_checkForAccelerate+0x7>\n7: \tjle\t0x85 <WI_checkForAccelerate+0x85>\n9: \tmovq\t(%rip), %rax  # 0x10 <WI_checkForAccelerate+0x10>\n10: \tmovq\t(%rip), %r8   # 0x17 <WI_checkForAccelerate+0x17>\n17: \txorl\t%edx, %edx\n19: \tjmp\t0x37 <WI_checkForAccelerate+0x37>\n1b: \tnopl\t(%rax,%rax)\n20: \tmovl\t%esi, 4(%rax)\n23: \taddq\t$1, %rdx\n27: \taddq\t$12, %rax\n2b: \tmovslq\t(%rip), %rcx  # 0x32 <WI_checkForAccelerate+0x32>\n32: \tcmpq\t%rcx, %rdx\n35: \tjge\t0x85 <WI_checkForAccelerate+0x85>\n37: \tcmpq\t$0, (%r8,%rdx,8)\n3c: \tje\t0x23 <WI_checkForAccelerate+0x23>\n3e: \tmovl\t8(%rax), %edi\n41: \txorl\t%esi, %esi\n43: \tmovl\t$0, %ecx\n48: \ttestl\t%edi, (%rip)  # 0x4e <WI_checkForAccelerate+0x4e>\n4e: \tje\t0x64 <WI_checkForAccelerate+0x64>\n50: \tmovl\t$1, %ecx\n55: \tcmpl\t$0, (%rax)\n58: \tjne\t0x64 <WI_checkForAccelerate+0x64>\n5a: \tmovl\t$1, (%rip)    # 0x64 <WI_checkForAccelerate+0x64>\n64: \tmovl\t%ecx, (%rax)\n66: \ttestl\t%edi, (%rip)  # 0x6c <WI_checkForAccelerate+0x6c>\n6c: \tje\t0x20 <WI_checkForAccelerate+0x20>\n6e: \tmovl\t$1, %esi\n73: \tcmpl\t$0, 4(%rax)\n77: \tjne\t0x20 <WI_checkForAccelerate+0x20>\n79: \tmovl\t$1, (%rip)    # 0x83 <WI_checkForAccelerate+0x83>\n83: \tjmp\t0x20 <WI_checkForAccelerate+0x20>\n85: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int buttons; } ;\nstruct TYPE_5__ {int attackdown; int usedown; TYPE_1__ cmd; } ;\ntypedef  TYPE_2__ player_t ;\n\n/* Variables and functions */\nint BT_ATTACK ;\nint BT_USE ;\nint MAXPLAYERS ;\nint acceleratestage ;\nscalar_t__* playeringame ;\nTYPE_2__* players ;\n\nvoid WI_checkForAccelerate(void)\n{\nint   i;\nplayer_t  *player;\n\n// check for button presses to skip delays\nfor (i=0, player = players ; i<MAXPLAYERS ; i++, player++)\n{\nif (playeringame[i])\n{\nif (player->cmd.buttons & BT_ATTACK)\n{\nif (!player->attackdown)\nacceleratestage = 1;\nplayer->attackdown = true;\n}\nelse\nplayer->attackdown = false;\nif (player->cmd.buttons & BT_USE)\n{\nif (!player->usedown)\nacceleratestage = 1;\nplayer->usedown = true;\n}\nelse\nplayer->usedown = false;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int accelerate; int accelerate_x; int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__ WINDOWPLACEMENT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WSF_ACCELERATE ;\nint /*<<< orphan*/  WSF_ACCELERATE_X ;\nint /*<<< orphan*/  WSF_ACCELERATE_Y ;\nint /*<<< orphan*/  WSF_ACCELERATE_Y_ONLY ;\nint /*<<< orphan*/  WSF_ACCELERATE_X_ONLY ;\nint /*<<< orphan*/ * WI_windowPlacement ;\nint WI_windowPlacementCount ;\n\n__attribute__((used)) static void\nWI_checkForAccelerate(void)\n{\nint i;\n\nfor (i = 0; i < WI_windowPlacementCount; i++)\n{\nWINDOWPLACEMENT *wp = &WI_windowPlacement[i];\n\nif (wp->flags & WSF_ACCELERATE)\n{\nif (wp->flags & WSF_ACCELERATE_Y)\n{\nif (!wp->accelerate)\n{\nwp->accelerate = 1;\n}\n}\nelse if (wp->flags & WSF_ACCELERATE_X)\n{\nif (!wp->accelerate_x)\n{\nwp->accelerate_x = 1;\n}\n}\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_SoundSetTimer",
    "input":"\n0000000000000000 <I_SoundSetTimer>:\n0: \tpushq\t%rbx\n1: \tsubq\t$80, %rsp\n5: \tmovl\t%edi, %ebx\n7: \tmovl\t(%rip), %eax  # 0xd <I_SoundSetTimer+0xd>\nd: \tmovl\t%eax, 4(%rsp)\n11: \tmovl\t(%rip), %eax  # 0x17 <I_SoundSetTimer+0x17>\n17: \tmovl\t%eax, (%rsp)\n1a: \tmovl\t(%rip), %edi  # 0x20 <I_SoundSetTimer+0x20>\n20: \tmovq\t%rsp, %rsi\n23: \tleaq\t40(%rsp), %rdx\n28: \tcallq\t0x2d <I_SoundSetTimer+0x2d>\n2d: \tmovq\t$0, 32(%rsp)\n36: \tmovl\t%ebx, 24(%rsp)\n3a: \tmovq\t$0, 16(%rsp)\n43: \tmovl\t%ebx, 8(%rsp)\n47: \tmovl\t(%rip), %edi  # 0x4d <I_SoundSetTimer+0x4d>\n4d: \tleaq\t8(%rsp), %rsi\n52: \tleaq\t48(%rsp), %rdx\n57: \tcallq\t0x5c <I_SoundSetTimer+0x5c>\n5c: \tmovl\t%eax, %ebx\n5e: \tcmpl\t$-1, %eax\n61: \tjne\t0x73 <I_SoundSetTimer+0x73>\n63: \tmovl\t(%rip), %edi  # 0x69 <I_SoundSetTimer+0x69>\n69: \tmovl\t$0, %esi\n6e: \tcallq\t0x73 <I_SoundSetTimer+0x73>\n73: \tmovl\t%ebx, %eax\n75: \taddq\t$80, %rsp\n79: \tpopq\t%rbx\n7a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sigaction {int /*<<< orphan*/  sa_flags; int /*<<< orphan*/  sa_handler; } ;\nstruct TYPE_4__ {int tv_usec; scalar_t__ tv_sec; } ;\nstruct TYPE_3__ {int tv_usec; scalar_t__ tv_sec; } ;\nstruct itimerval {TYPE_2__ it_value; TYPE_1__ it_interval; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_HandleSoundTimer ;\nint /*<<< orphan*/  SA_RESTART ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  itimer ;\nint setitimer (int /*<<< orphan*/ ,struct itimerval*,struct itimerval*) ;\nint /*<<< orphan*/  sig ;\nint /*<<< orphan*/  sigaction (int /*<<< orphan*/ ,struct sigaction*,struct sigaction*) ;\nint /*<<< orphan*/  stderr ;\n\nint I_SoundSetTimer( int duration_of_tick )\n{\n// Needed for gametick clockwork.\nstruct itimerval    value;\nstruct itimerval    ovalue;\nstruct sigaction    act;\nstruct sigaction    oact;\n\nint res;\n\n// This sets to SA_ONESHOT and SA_NOMASK, thus we can not use it.\n//     signal( _sig, handle_SIG_TICK );\n\n// Now we have to change this attribute for repeated calls.\nact.sa_handler = I_HandleSoundTimer;\n#ifndef sun\n//ac\tt.sa_mask = _sig;\n#endif\nact.sa_flags = SA_RESTART;\n\nsigaction( sig, &act, &oact );\n\nvalue.it_interval.tv_sec    = 0;\nvalue.it_interval.tv_usec   = duration_of_tick;\nvalue.it_value.tv_sec       = 0;\nvalue.it_value.tv_usec      = duration_of_tick;\n\n// Error is -1.\nres = setitimer( itimer, &value, &ovalue );\n\n// Debug.\nif ( res == -1 )\nfprintf( stderr, \"I_SoundSetTimer: interrupt n.a.\\n\");\n\nreturn res;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  wTimerID; int /*<<< orphan*/  wTimerSpec; int /*<<< orphan*/  wTimerType; int /*<<< orphan*/  wTimerData; int /*<<< orphan*/  wTimerFunc; } ;\ntypedef  int /*<<< orphan*/  WORD ;\ntypedef  TYPE_1__ TIMERPROC ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  I_Error (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  SetTimer (int /*<<< orphan*/ ,TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  TIMER_FUNC ;\nint /*<<< orphan*/  TIMER_MS ;\nint /*<<< orphan*/  TIMER_ONESHOT ;\nint /*<<< orphan*/  TIMER_PROC ;\nint /*<<< orphan*/  TIMER_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM ;\nint /*<<< orphan*/  TIMER_WPARAM_DATA ;\nint /*<<< orphan*/  TIMER_WPARAM_FUNC ;\nint /*<<< orphan*/  TIMER_WPARAM_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE ;\nint /*<<< orphan*/  TIMER_VALUE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_MS ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_ONESHOT ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_DATA ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_FUNC ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_MS ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_ONESHOT ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_DATA ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_FUNC ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_MS ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_ONESHOT ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_DATA ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_FUNC ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_MS ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_ONESHOT ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_DATA ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_FUNC ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_MS ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_ONESHOT ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_DATA ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_FUNC ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_TYPE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_MS ;\nint /*<<< orphan*/  TIMER_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_WPARAM_VALUE_ONESHOT ;\nint"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_calcPainOffset",
    "input":"\n0000000000000000 <ST_calcPainOffset>:\n0: \tmovq\t(%rip), %rax  # 0x7 <ST_calcPainOffset+0x7>\n7: \tmovl\t(%rax), %ecx\n9: \tcmpl\t$101, %ecx\nc: \tmovl\t$100, %eax\n11: \tcmovgel\t%eax, %ecx\n14: \tcmpl\t(%rip), %ecx  # 0x1a <ST_calcPainOffset+0x1a>\n1a: \tjne\t0x23 <ST_calcPainOffset+0x23>\n1c: \tmovl\t(%rip), %eax  # 0x22 <ST_calcPainOffset+0x22>\n22: \tretq\n23: \tsubl\t%ecx, %eax\n25: \timull\t(%rip), %eax  # 0x2c <ST_calcPainOffset+0x2c>\n2c: \tcltq\n2e: \timulq\t$680390859, %rax, %rax  # imm = 0x288DF0CB\n35: \tmovq\t%rax, %rdx\n38: \tshrq\t$63, %rdx\n3c: \tsarq\t$36, %rax\n40: \taddl\t%edx, %eax\n42: \timull\t(%rip), %eax  # 0x49 <ST_calcPainOffset+0x49>\n49: \tmovl\t%eax, (%rip)  # 0x4f <ST_calcPainOffset+0x4f>\n4f: \tmovl\t%ecx, (%rip)  # 0x55 <ST_calcPainOffset+0x55>\n55: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int health; } ;\n\n/* Variables and functions */\nint ST_FACESTRIDE ;\nint ST_NUMPAINFACES ;\nTYPE_1__* plyr ;\n\nint ST_calcPainOffset(void)\n{\nint\t\thealth;\nstatic int\tlastcalc;\nstatic int\toldhealth = -1;\n\nhealth = plyr->health > 100 ? 100 : plyr->health;\n\nif (health != oldhealth)\n{\nlastcalc = ST_FACESTRIDE * (((100 - health) * ST_NUMPAINFACES) / 101);\noldhealth = health;\n}\nreturn lastcalc;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int pain; } ;\n\n/* Variables and functions */\nint ST_painOffset ;\nint ST_painOffset2 ;\nint ST_painOffset3 ;\nint ST_painOffset4 ;\nint ST_painOffset5 ;\nint ST_painOffset6 ;\nint ST_painOffset7 ;\nint ST_painOffset8 ;\nint ST_painOffset9 ;\nTYPE_1__* ST_player ;\n\nvoid ST_calcPainOffset(void)\n{\nint i;\n\ni = ST_player->pain;\nif (i < 100)\ni = 100;\nif (i > ST_painOffset)\ni = ST_painOffset;\n\nST_painOffset = i;\n\nswitch (i)\n{\ncase 100:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 99:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 98:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 97:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 96:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 95:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 94:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 93:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 92:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 91:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 90:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 89:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 88:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 87:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 86:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 85:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 84:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_painOffset8 = 0;\nST_painOffset9 = 0;\nbreak;\ncase 83:\nST_painOffset2 = 0;\nST_painOffset3 = 0;\nST_painOffset4 = 0;\nST_painOffset5 = 0;\nST_painOffset6 = 0;\nST_painOffset7 = 0;\nST_pain"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_Responder",
    "input":"\n0000000000000000 <WI_Responder>:\n0: \txorl\t%eax, %eax\n2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  event_t ;\ntypedef  int boolean ;\n\n/* Variables and functions */\n\nboolean WI_Responder(event_t* ev)\n{\nreturn false;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WResponder ;\n\n/* Variables and functions */\n\nWResponder* WI_Responder(void) {\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_ScreenShot",
    "input":"\n0000000000000000 <G_ScreenShot>:\n0: \tmovl\t(%rip), %eax  # 0x6 <G_ScreenShot+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <G_ScreenShot+0xc>\nc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ga_screenshot ;\nint /*<<< orphan*/  gameaction ;\n\nvoid G_ScreenShot (void)\n{\ngameaction = ga_screenshot;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_ScreenShot_B ;\nint /*<<< orphan*/  G_ScreenShot_B_ ;\n\nvoid G_ScreenShot(void)\n{\nG_ScreenShot_B_ = G_ScreenShot_B;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_draw.c_R_DrawViewBorder",
    "input":"\n0000000000000000 <R_DrawViewBorder>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t(%rip), %esi  # 0xd <R_DrawViewBorder+0xd>\nd: \tmovl\t%esi, %eax\nf: \tsubl\t(%rip), %eax  # 0x15 <R_DrawViewBorder+0x15>\n15: \tjne\t0x22 <R_DrawViewBorder+0x22>\n17: \taddq\t$8, %rsp\n1b: \tpopq\t%rbx\n1c: \tpopq\t%r14\n1e: \tpopq\t%r15\n20: \tpopq\t%rbp\n21: \tretq\n22: \tmovl\t(%rip), %ecx  # 0x28 <R_DrawViewBorder+0x28>\n28: \tsubl\t(%rip), %ecx  # 0x2e <R_DrawViewBorder+0x2e>\n2e: \tsubl\t(%rip), %ecx  # 0x34 <R_DrawViewBorder+0x34>\n34: \tmovl\t%ecx, %ebx\n36: \tshrl\t$31, %ebx\n39: \taddl\t%ecx, %ebx\n3b: \tsarl\t%ebx\n3d: \tmovl\t%eax, %r15d\n40: \tshrl\t$31, %r15d\n44: \taddl\t%eax, %r15d\n47: \tmovl\t%r15d, %r14d\n4a: \tsarl\t%r14d\n4d: \timull\t%ebx, %esi\n50: \taddl\t%r14d, %esi\n53: \txorl\t%edi, %edi\n55: \tcallq\t0x5a <R_DrawViewBorder+0x5a>\n5a: \tmovl\t(%rip), %edi  # 0x60 <R_DrawViewBorder+0x60>\n60: \taddl\t%ebx, %edi\n62: \tmovl\t(%rip), %esi  # 0x68 <R_DrawViewBorder+0x68>\n68: \timull\t%esi, %edi\n6b: \tsubl\t%r14d, %edi\n6e: \timull\t%ebx, %esi\n71: \taddl\t%r14d, %esi\n74: \tcallq\t0x79 <R_DrawViewBorder+0x79>\n79: \tmovl\t(%rip), %edx  # 0x7f <R_DrawViewBorder+0x7f>\n7f: \tcmpl\t$2, (%rip)    # 0x86 <R_DrawViewBorder+0x86>\n86: \tjl\t0xbd <R_DrawViewBorder+0xbd>\n88: \tandl\t$-2, %r15d\n8c: \tmovl\t%edx, %eax\n8e: \tsubl\t%r14d, %eax\n91: \timull\t%edx, %ebx\n94: \taddl\t%eax, %ebx\n96: \tmovl\t$1, %ebp\n9b: \tnopl\t(%rax,%rax)\na0: \tmovl\t%ebx, %edi\na2: \tmovl\t%r15d, %esi\na5: \tcallq\t0xaa <R_DrawViewBorder+0xaa>\naa: \tmovl\t(%rip), %edx  # 0xb0 <R_DrawViewBorder+0xb0>\nb0: \taddl\t%edx, %ebx\nb2: \taddl\t$1, %ebp\nb5: \tcmpl\t(%rip), %ebp  # 0xbb <R_DrawViewBorder+0xbb>\nbb: \tjl\t0xa0 <R_DrawViewBorder+0xa0>\nbd: \tmovl\t(%rip), %ecx  # 0xc3 <R_DrawViewBorder+0xc3>\nc3: \tsubl\t(%rip), %ecx  # 0xc9 <R_DrawViewBorder+0xc9>\nc9: \txorl\t%edi, %edi\ncb: \txorl\t%esi, %esi\ncd: \taddq\t$8, %rsp\nd1: \tpopq\t%rbx\nd2: \tpopq\t%r14\nd4: \tpopq\t%r15\nd6: \tpopq\t%rbp\nd7: \tjmp\t0xdc <R_DrawViewBorder+0xdc>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_VideoErase (int,int) ;\nint SBARHEIGHT ;\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/  V_MarkRect (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint scaledviewwidth ;\nint viewheight ;\n\nvoid R_DrawViewBorder (void)\n{\nint\t\ttop;\nint\t\tside;\nint\t\tofs;\nint\t\ti;\n\nif (scaledviewwidth == SCREENWIDTH)\nreturn;\n\ntop = ((SCREENHEIGHT-SBARHEIGHT)-viewheight)/2;\nside = (SCREENWIDTH-scaledviewwidth)/2;\n\n// copy top and one line of left side\nR_VideoErase (0, top*SCREENWIDTH+side);\n\n// copy one line of right side and bottom\nofs = (viewheight+top)*SCREENWIDTH-side;\nR_VideoErase (ofs, top*SCREENWIDTH+side);\n\n// copy sides using wraparound\nofs = top*SCREENWIDTH + SCREENWIDTH-side;\nside <<= 1;\n\nfor (i=1 ; i<viewheight ; i++)\n{\nR_VideoErase (ofs, side);\nofs += SCREENWIDTH;\n}\n\n// ?\nV_MarkRect (0,0,SCREENWIDTH, SCREENHEIGHT-SBARHEIGHT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_DrawLine (int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  R_DrawRect (int,int,int,int /*<<< orphan*/ ) ;\nint R_VIEW_BORDER_HEIGHT ;\nint R_VIEW_BORDER_WIDTH ;\nint R_VIEW_HEIGHT ;\nint R_VIEW_WIDTH ;\nint R_VIEW_X ;\nint R_VIEW_Y ;\nint /*<<< orphan*/  R_VIEW_Y_OFFSET ;\nint R_VIEW_Y_OFFSET_TOP ;\nint R_VIEW_Y_OFFSET_TOP_2 ;\nint R_VIEW_Y_OFFSET_TOP_3 ;\nint R_VIEW_Y_OFFSET_TOP_4 ;\nint R_VIEW_Y_OFFSET_TOP_5 ;\nint R_VIEW_Y_OFFSET_TOP_6 ;\nint R_VIEW_Y_OFFSET_TOP_7 ;\nint R_VIEW_Y_OFFSET_TOP_8 ;\nint R_VIEW_Y_OFFSET_TOP_9 ;\nint R_VIEW_Y_OFFSET_TOP_10 ;\nint R_VIEW_Y_OFFSET_TOP_11 ;\nint R_VIEW_Y_OFFSET_TOP_12 ;\nint R_VIEW_Y_OFFSET_TOP_13 ;\nint R_VIEW_Y_OFFSET_TOP_14 ;\nint R_VIEW_Y_OFFSET_TOP_15 ;\nint R_VIEW_Y_OFFSET_TOP_16 ;\nint R_VIEW_Y_OFFSET_TOP_17 ;\nint R_VIEW_Y_OFFSET_TOP_18 ;\nint R_VIEW_Y_OFFSET_TOP_19 ;\nint R_VIEW_Y_OFFSET_TOP_20 ;\nint R_VIEW_Y_OFFSET_TOP_21 ;\nint R_VIEW_Y_OFFSET_TOP_22 ;\nint R_VIEW_Y_OFFSET_TOP_23 ;\nint R_VIEW_Y_OFFSET_TOP_24 ;\nint R_VIEW_Y_OFFSET_TOP_25 ;\nint R_VIEW_Y_OFFSET_TOP_26 ;\nint R_VIEW_Y_OFFSET_TOP_27 ;\nint R_VIEW_Y_OFFSET_TOP_28 ;\nint R_VIEW_Y_OFFSET_TOP_29 ;\nint R_VIEW_Y_OFFSET_TOP_30 ;\nint R_VIEW_Y_OFFSET_TOP_31 ;\nint R_VIEW_Y_OFFSET_TOP_32 ;\nint R_VIEW_Y_OFFSET_TOP_33 ;\nint R_VIEW_Y_OFFSET_TOP_34 ;\nint R_VIEW_Y_OFFSET_TOP_35 ;\nint R_VIEW_Y_OFFSET_TOP_36 ;\nint R_VIEW_Y_OFFSET_TOP_37 ;\nint R_VIEW_Y_OFFSET_TOP_38 ;\nint R_VIEW_Y_OFFSET_TOP_39 ;\nint R_VIEW_Y_OFFSET_TOP_40 ;\nint R_VIEW_Y_OFFSET_TOP_41 ;\nint R_VIEW_Y_OFFSET_TOP_42 ;\nint R_VIEW_Y_OFFSET_TOP_43 ;\nint R_VIEW_Y_OFFSET_TOP_44 ;\nint R_VIEW_Y_OFFSET_TOP_45 ;\nint R_VIEW_Y_OFFSET_TOP_46 ;\nint R_VIEW_Y_OFFSET_TOP_47 ;\nint R_VIEW_Y_OFFSET_TOP_48 ;\nint R_VIEW_Y_OFFSET_TOP_49 ;\nint R_VIEW_Y_OFFSET_TOP_50 ;\nint R_VIEW_Y_OFFSET_TOP_51 ;\nint R_VIEW_Y_OFFSET_TOP_52 ;\nint R_VIEW_Y_OFFSET_TOP_53 ;\nint R_VIEW_Y_OFFSET_TOP_54 ;\nint R_VIEW_Y_OFFSET_TOP_55 ;\nint R_VIEW_Y_OFFSET_TOP_56 ;\nint R_VIEW_Y_OFFSET_TOP_57 ;\nint R_VIEW_Y_OFFSET_TOP_58 ;\nint R_VIEW_Y_OFFSET_TOP_59 ;\nint R_VIEW_Y_OFFSET_TOP_60 ;\nint R_VIEW_Y_OFFSET_TOP_61 ;\nint R_VIEW_Y_OFFSET_TOP_62 ;\nint R_VIEW_Y_OFFSET_TOP_63 ;\nint R_VIEW_Y_OFFSET_TOP_64 ;\nint R_VIEW_Y_OFFSET_TOP_65 ;\nint R_VIEW_Y_OFFSET_TOP_66 ;\nint R_VIEW_Y_OFFSET_TOP_67 ;\nint R_VIEW_Y_OFFSET_TOP_68 ;\nint R_VIEW_Y_OFFSET_TOP_69 ;\nint R_VIEW_Y_OFFSET_TOP_70 ;\nint R_VIEW_Y_OFFSET_TOP_71 ;\nint R_VIEW_Y_OFFSET_TOP_72 ;\nint R_VIEW_Y_OFFSET_TOP_73 ;\nint R_VIEW_Y_OFFSET_TOP_74 ;\nint R_VIEW_Y_OFFSET_TOP_75 ;\nint R_VIEW_Y_OFFSET_TOP_76 ;\nint R_VIEW_Y_OFFSET_TOP_77 ;\nint R_VIEW_Y_OFFSET_TOP_78 ;\nint R_VIEW_Y_OFFSET_TOP_79 ;\nint R_VIEW_Y_OFFSET_TOP_80 ;\nint R_VIEW_Y_OFFSET_TOP_81 ;\nint R_VIEW_Y_OFFSET_TOP_82 ;\nint R_VIEW_Y_OFFSET_TOP_83 ;\nint R_VIEW_Y_OFFSET_TOP_84 ;\nint R_VIEW_Y_OFFSET_TOP_85 ;\nint R_VIEW_Y_OFFSET_TOP_86 ;\nint R_VIEW_Y_OFFSET_TOP_87 ;\nint R_VIEW_Y_OFFSET_TOP_88 ;\nint R_VIEW_Y_OFFSET_TOP_89 ;\nint R_VIEW_Y_OFFSET_TOP_90 ;\nint R_VIEW_Y_OFFSET_TOP_91 ;\nint R_VIEW_Y_OFFSET_TOP_92 ;\nint R_VIEW_Y_OFFSET_TOP_93 ;\nint R_VIEW_Y_OFFSET_TOP_94 ;\nint R_VIEW_Y_OFFSET_T"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_QrySongPlaying",
    "input":"\n0000000000000000 <I_QrySongPlaying>:\n0: \tcmpq\t$0, (%rip)    # 0x8 <I_QrySongPlaying+0x8>\n8: \tsetne\t%al\nb: \tmovq\t(%rip), %rcx  # 0x12 <I_QrySongPlaying+0x12>\n12: \tcmpq\t(%rip), %rcx  # 0x19 <I_QrySongPlaying+0x19>\n19: \tsetg\t%cl\n1c: \torb\t%al, %cl\n1e: \tmovzbl\t%cl, %eax\n21: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ gametic ;\nscalar_t__ looping ;\nscalar_t__ musicdies ;\n\nint I_QrySongPlaying(int handle)\n{\n// UNUSED.\nhandle = 0;\nreturn looping || musicdies > gametic;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ I_QrySongPlaying_P ;\nscalar_t__ I_QrySongPlaying_R ;\nscalar_t__ I_QrySongPlaying_W ;\nscalar_t__ I_QrySongPlaying_X ;\n\n__attribute__((used)) static int I_QrySongPlaying(void)\n{\nreturn (I_QrySongPlaying_R || I_QrySongPlaying_W || I_QrySongPlaying_X || I_QrySongPlaying_P);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_GetColumn",
    "input":"\n0000000000000000 <R_GetColumn>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t(%rip), %rax  # 0xb <R_GetColumn+0xb>\nb: \tmovslq\t%edi, %rbx\ne: \tandl\t(%rax,%rbx,4), %esi\n11: \tmovslq\t%esi, %rax\n14: \tmovq\t(%rip), %rcx  # 0x1b <R_GetColumn+0x1b>\n1b: \tmovq\t(%rcx,%rbx,8), %rcx\n1f: \tmovl\t(%rcx,%rax,4), %edi\n22: \tmovq\t(%rip), %rcx  # 0x29 <R_GetColumn+0x29>\n29: \tmovq\t(%rcx,%rbx,8), %rcx\n2d: \tmovslq\t(%rcx,%rax,4), %r14\n31: \ttestl\t%edi, %edi\n33: \tjle\t0x42 <R_GetColumn+0x42>\n35: \tmovl\t(%rip), %esi  # 0x3b <R_GetColumn+0x3b>\n3b: \tcallq\t0x40 <R_GetColumn+0x40>\n40: \tjmp\t0x64 <R_GetColumn+0x64>\n42: \tmovq\t(%rip), %rax  # 0x49 <R_GetColumn+0x49>\n49: \tmovq\t(%rax,%rbx,8), %rax\n4d: \ttestq\t%rax, %rax\n50: \tjne\t0x64 <R_GetColumn+0x64>\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <R_GetColumn+0x59>\n59: \tmovq\t(%rip), %rax  # 0x60 <R_GetColumn+0x60>\n60: \tmovq\t(%rax,%rbx,8), %rax\n64: \tleaq\t(%rax,%r14,4), %rax\n68: \taddq\t$8, %rsp\n6c: \tpopq\t%rbx\n6d: \tpopq\t%r14\n6f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  R_GenerateComposite (int) ;\nscalar_t__ W_CacheLumpNum (int,int /*<<< orphan*/ ) ;\nint** texturecolumnlump ;\nint** texturecolumnofs ;\nint /*<<< orphan*/ ** texturecomposite ;\nint* texturewidthmask ;\n\nbyte*\nR_GetColumn\n( int\t\ttex,\nint\t\tcol )\n{\nint\t\tlump;\nint\t\tofs;\n\ncol &= texturewidthmask[tex];\nlump = texturecolumnlump[tex][col];\nofs = texturecolumnofs[tex][col];\n\nif (lump > 0)\nreturn (byte *)W_CacheLumpNum(lump,PU_CACHE)+ofs;\n\nif (!texturecomposite[tex])\nR_GenerateComposite (tex);\n\nreturn texturecomposite[tex] + ofs;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int* column; int* column_size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_CheckColumn (int) ;\nint /*<<< orphan*/  R_CheckMatrix (int) ;\nTYPE_1__* R_ColumnInfo ;\nint* R_ColumnInfoSize ;\nint* R_MatrixInfo ;\nint* R_MatrixInfoSize ;\n\n__attribute__((used)) static int *R_GetColumn(int matrix, int column)\n{\nint *p, *q;\nint i, j;\n\nR_CheckMatrix(matrix);\n\ni = R_MatrixInfo[matrix] & column;\nj = R_ColumnInfo[matrix][i];\nif (R_MatrixInfo[matrix] > 0)\nR_CheckColumn(i);\nif (R_ColumnInfo[matrix][i] == 0)\n{\nR_CheckColumn(matrix);\n}\n\np = R_ColumnInfoSize[matrix] + i;\nq = R_ColumnInfo[matrix] + i;\nreturn p + j;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_Lower",
    "input":"\n0000000000000000 <A_Lower>:\n0: \tmovq\t(%rsi), %rcx\n3: \taddq\t(%rip), %rcx  # 0xa <A_Lower+0xa>\na: \tmovq\t%rcx, (%rsi)\nd: \tmovq\t(%rip), %rax  # 0x14 <A_Lower+0x14>\n14: \tcmpq\t%rax, %rcx\n17: \tjl\t0x28 <A_Lower+0x28>\n19: \tmovq\t(%rdi), %rcx\n1c: \tcmpq\t(%rip), %rcx  # 0x23 <A_Lower+0x23>\n23: \tjne\t0x29 <A_Lower+0x29>\n25: \tmovq\t%rax, (%rsi)\n28: \tretq\n29: \tcmpl\t$0, 16(%rdi)\n2d: \tje\t0x3a <A_Lower+0x3a>\n2f: \tmovl\t8(%rdi), %eax\n32: \tmovl\t%eax, 12(%rdi)\n35: \tjmp\t0x3a <A_Lower+0x3a>\n3a: \tmovl\t(%rip), %esi  # 0x40 <A_Lower+0x40>\n40: \tmovl\t(%rip), %edx  # 0x46 <A_Lower+0x46>\n46: \tjmp\t0x4b <A_Lower+0x4b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {scalar_t__ sy; } ;\ntypedef  TYPE_1__ pspdef_t ;\nstruct TYPE_8__ {scalar_t__ playerstate; int /*<<< orphan*/  pendingweapon; int /*<<< orphan*/  readyweapon; int /*<<< orphan*/  health; } ;\ntypedef  TYPE_2__ player_t ;\n\n/* Variables and functions */\nscalar_t__ LOWERSPEED ;\nscalar_t__ PST_DEAD ;\nint /*<<< orphan*/  P_BringUpWeapon (TYPE_2__*) ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_NULL ;\nscalar_t__ WEAPONBOTTOM ;\nint /*<<< orphan*/  ps_weapon ;\n\nvoid\nA_Lower\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\npsp->sy += LOWERSPEED;\n\n// Is already down.\nif (psp->sy < WEAPONBOTTOM )\nreturn;\n\n// Player is dead.\nif (player->playerstate == PST_DEAD)\n{\npsp->sy = WEAPONBOTTOM;\n\n// don't bring weapon back up\nreturn;\n}\n\n// The old weapon has been lowered off the screen,\n// so change the weapon and start raising it\nif (!player->health)\n{\n// Player is dead, so keep the weapon off screen.\nP_SetPsprite (player,  ps_weapon, S_NULL);\nreturn;\n}\n\nplayer->readyweapon = player->pendingweapon;\n\nP_BringUpWeapon (player);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ c; int /*<<< orphan*/  c_len; int /*<<< orphan*/  c_str; int /*<<< orphan*/  c_type; } ;\ntypedef  TYPE_1__* PARSE_STATE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Lower_Buf ;\nscalar_t__ A_Lower_Buf_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Len ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_Type ;\nint /*<<< orphan*/  A_Lower_Buf_Type_Str_Type_Str_Type_Str_Type_Str_Type_Str_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawTime",
    "input":"\n0000000000000000 <WI_drawTime>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \ttestl\t%edx, %edx\n9: \tjs\t0xab <WI_drawTime+0xab>\nf: \tmovl\t%edx, %r15d\n12: \tmovl\t%esi, %r14d\n15: \tmovl\t%edi, %ebp\n17: \tcmpl\t$3599, %edx   # imm = 0xE0F\n1d: \tjg\t0xb6 <WI_drawTime+0xb6>\n23: \tmovl\t$1, %ebx\n28: \tjmp\t0x53 <WI_drawTime+0x53>\n2a: \tnopw\t(%rax,%rax)\n30: \tsubl\t%ecx, %ebp\n32: \tmovl\t(%rip), %edx  # 0x38 <WI_drawTime+0x38>\n38: \tmovq\t(%rip), %rcx  # 0x3f <WI_drawTime+0x3f>\n3f: \tmovl\t%ebp, %edi\n41: \tmovl\t%r14d, %esi\n44: \tcallq\t0x49 <WI_drawTime+0x49>\n49: \tmovl\t%r15d, %eax\n4c: \tcltd\n4d: \tidivl\t%ebx\n4f: \ttestl\t%eax, %eax\n51: \tje\t0xab <WI_drawTime+0xab>\n53: \tmovl\t%r15d, %eax\n56: \tcltd\n57: \tidivl\t%ebx\n59: \tmovslq\t%eax, %rdx\n5c: \timulq\t$-2004318071, %rdx, %rax # imm = 0x88888889\n63: \tshrq\t$32, %rax\n67: \taddl\t%edx, %eax\n69: \tmovl\t%eax, %ecx\n6b: \tshrl\t$31, %ecx\n6e: \tsarl\t$5, %eax\n71: \taddl\t%ecx, %eax\n73: \timull\t$60, %eax, %eax\n76: \tsubl\t%eax, %edx\n78: \tmovl\t%ebp, %edi\n7a: \tmovl\t%r14d, %esi\n7d: \tmovl\t$2, %ecx\n82: \tcallq\t0x87 <WI_drawTime+0x87>\n87: \tmovl\t%eax, %ebp\n89: \tmovq\t(%rip), %rax  # 0x90 <WI_drawTime+0x90>\n90: \tmovl\t(%rax), %edi\n92: \tcallq\t0x97 <WI_drawTime+0x97>\n97: \tmovl\t%eax, %ecx\n99: \timull\t$60, %ebx, %ebx\n9c: \tcmpl\t$60, %ebx\n9f: \tje\t0x30 <WI_drawTime+0x30>\na1: \tmovl\t%r15d, %eax\na4: \tcltd\na5: \tidivl\t%ebx\na7: \ttestl\t%eax, %eax\na9: \tjne\t0x30 <WI_drawTime+0x30>\nab: \taddq\t$8, %rsp\naf: \tpopq\t%rbx\nb0: \tpopq\t%r14\nb2: \tpopq\t%r15\nb4: \tpopq\t%rbp\nb5: \tretq\nb6: \tmovq\t(%rip), %rax  # 0xbd <WI_drawTime+0xbd>\nbd: \tmovl\t(%rax), %edi\nbf: \tcallq\t0xc4 <WI_drawTime+0xc4>\nc4: \tsubl\t%eax, %ebp\nc6: \tmovl\t(%rip), %edx  # 0xcc <WI_drawTime+0xcc>\ncc: \tmovq\t(%rip), %rcx  # 0xd3 <WI_drawTime+0xd3>\nd3: \tmovl\t%ebp, %edi\nd5: \tmovl\t%r14d, %esi\nd8: \taddq\t$8, %rsp\ndc: \tpopq\t%rbx\ndd: \tpopq\t%r14\ndf: \tpopq\t%r15\ne1: \tpopq\t%rbp\ne2: \tjmp\t0xe7 <WI_drawTime+0xe7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  width; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FB ;\nint SHORT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,TYPE_1__*) ;\nint WI_drawNum (int,int,int,int) ;\nTYPE_1__* colon ;\nTYPE_1__* sucks ;\n\nvoid\nWI_drawTime\n( int\t\tx,\nint\t\ty,\nint\t\tt )\n{\n\nint\t\tdiv;\nint\t\tn;\n\nif (t<0)\nreturn;\n\nif (t <= 61*59)\n{\ndiv = 1;\n\ndo\n{\nn = (t / div) % 60;\nx = WI_drawNum(x, y, n, 2) - SHORT(colon->width);\ndiv *= 60;\n\n// draw\nif (div==60 || t / div)\nV_DrawPatch(x, y, FB, colon);\n\n} while (t / div);\n}\nelse\n{\n// \"sucks\"\nV_DrawPatch(x - SHORT(sucks->width), y, FB, sucks);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  time; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawDigit (int,int,int,int) ;\nint /*<<< orphan*/  WI_drawDigit2 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit3 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit4 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit5 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit6 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit7 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit8 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigit9 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitColon (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitDot (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitSpace (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero2 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero3 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero4 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero5 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero6 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero7 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero8 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZero9 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroColon (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroDot (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroSpace (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero2 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero3 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero4 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero5 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero6 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero7 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero8 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZero9 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroColon (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroDot (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroSpace (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero2 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero3 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero4 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero5 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero6 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero7 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero8 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZero9 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroColon (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroDot (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroSpace (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero2 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero3 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero4 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero5 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero6 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero7 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero8 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZero9 (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZeroColon (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  WI_drawDigitZeroZeroZeroZeroDot (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_SaveSelect",
    "input":"\n0000000000000000 <M_SaveSelect>:\n0: \tpushq\t%rbx\n1: \tmovl\t$1, (%rip)    # 0xb <M_SaveSelect+0xb>\nb: \tmovl\t%edi, (%rip)  # 0x11 <M_SaveSelect+0x11>\n11: \tmovl\t(%rip), %eax  # 0x17 <M_SaveSelect+0x17>\n17: \tmovq\t(%rip), %rcx  # 0x1e <M_SaveSelect+0x1e>\n1e: \tmovslq\t%edi, %rbx\n21: \tmovq\t(%rcx,%rbx,8), %rsi\n25: \tmovl\t%eax, %edi\n27: \tcallq\t0x2c <M_SaveSelect+0x2c>\n2c: \tmovq\t(%rip), %rax  # 0x33 <M_SaveSelect+0x33>\n33: \tmovq\t(%rax,%rbx,8), %rdi\n37: \tmovl\t(%rip), %esi  # 0x3d <M_SaveSelect+0x3d>\n3d: \tcallq\t0x42 <M_SaveSelect+0x42>\n42: \tmovq\t(%rip), %rcx  # 0x49 <M_SaveSelect+0x49>\n49: \tmovq\t(%rcx,%rbx,8), %rdi\n4d: \ttestl\t%eax, %eax\n4f: \tjne\t0x58 <M_SaveSelect+0x58>\n51: \tmovq\t$0, (%rdi)\n58: \tcallq\t0x5d <M_SaveSelect+0x5d>\n5d: \tmovl\t%eax, (%rip)  # 0x63 <M_SaveSelect+0x63>\n63: \tpopq\t%rbx\n64: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  EMPTYSTRING ;\nint /*<<< orphan*/  saveCharIndex ;\nint /*<<< orphan*/  saveOldString ;\nint saveSlot ;\nint saveStringEnter ;\nscalar_t__** savegamestrings ;\nint /*<<< orphan*/  strcmp (scalar_t__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strcpy (int /*<<< orphan*/ ,scalar_t__*) ;\nint /*<<< orphan*/  strlen (scalar_t__*) ;\n\nvoid M_SaveSelect(int choice)\n{\n// we are going to be intercepting all chars\nsaveStringEnter = 1;\n\nsaveSlot = choice;\nstrcpy(saveOldString,savegamestrings[choice]);\nif (!strcmp(savegamestrings[choice],EMPTYSTRING))\nsavegamestrings[choice][0] = 0;\nsaveCharIndex = strlen(savegamestrings[choice]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {char* name; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SaveSelect_ (int) ;\nint /*<<< orphan*/  M_SaveSelect_End () ;\nint /*<<< orphan*/  M_SaveSelect_Start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  M_SaveSelect_Write (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_SaveSelect_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_Start (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_Start (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_Start (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_Start (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_ (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_End () ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_Write (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteInt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString (char*) ;\nint /*<<< orphan*/  M_SaveSelect_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_WriteString_ (char"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_StartSound",
    "input":"\n0000000000000000 <I_StartSound>:\n0: \tmovl\t%edx, %eax\n2: \tmovq\t(%rip), %rdx  # 0x9 <I_StartSound+0x9>\n9: \tmovslq\t%ecx, %rcx\nc: \tmovl\t(%rdx,%rcx,4), %edx\nf: \tmovl\t%eax, %ecx\n11: \tjmp\t0x16 <I_StartSound+0x16>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint addsfx (int,int,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  fflush (scalar_t__) ;\nint /*<<< orphan*/  fprintf (scalar_t__,char*,int,int,int,int) ;\nscalar_t__ sndserver ;\nint /*<<< orphan*/ * steptable ;\n\nint\nI_StartSound\n( int\t\tid,\nint\t\tvol,\nint\t\tsep,\nint\t\tpitch,\nint\t\tpriority )\n{\n\n// UNUSED\npriority = 0;\n\n#ifdef SNDSERV\nif (sndserver)\n{\nfprintf(sndserver, \"p%2.2x%2.2x%2.2x%2.2x\\n\", id, pitch, vol, sep);\nfflush(sndserver);\n}\n// warning: control reaches end of non-void function.\nreturn id;\n#else\n// Debug.\n//fprintf( stderr, \"starting sound %d\", id );\n\n// Returns a handle (not used).\nid = addsfx( id, vol, steptable[pitch], sep );\n\n// fprintf( stderr, \"/handle is %d\\n\", id );\n\nreturn id;\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * SFX_Vol ;\nint /*<<< orphan*/  S_StartSound (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid I_StartSound(UBYTE channel, UBYTE note, UBYTE vol)\n{\nS_StartSound(channel, note, SFX_Vol[vol]);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_Sound",
    "input":"\n0000000000000000 <M_Sound>:\n0: \tmovl\t$0, %edi\n5: \tjmp\t0xa <M_Sound+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_SetupNextMenu (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SoundDef ;\n\nvoid M_Sound(int choice)\n{\nM_SetupNextMenu(&SoundDef);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  printf (char*) ;\n\nvoid M_Sound(void)\n{\nprintf(\"M_Sound()\\n\");\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DoSave",
    "input":"\n0000000000000000 <M_DoSave>:\n0: \tpushq\t%rbx\n1: \tmovl\t%edi, %ebx\n3: \tmovq\t(%rip), %rax  # 0xa <M_DoSave+0xa>\na: \tmovslq\t%edi, %rdi\nd: \tmovl\t(%rax,%rdi,4), %esi\n10: \tcallq\t0x15 <M_DoSave+0x15>\n15: \txorl\t%eax, %eax\n17: \tcallq\t0x1c <M_DoSave+0x1c>\n1c: \tcmpl\t$-2, (%rip)   # 0x23 <M_DoSave+0x23>\n23: \tjne\t0x2b <M_DoSave+0x2b>\n25: \tmovl\t%ebx, (%rip)  # 0x2b <M_DoSave+0x2b>\n2b: \tpopq\t%rbx\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_SaveGame (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_ClearMenus () ;\nint quickSaveSlot ;\nint /*<<< orphan*/ * savegamestrings ;\n\nvoid M_DoSave(int slot)\n{\nG_SaveGame (slot,savegamestrings[slot]);\nM_ClearMenus ();\n\n// PICK QUICKSAVE SLOT YET?\nif (quickSaveSlot == -2)\nquickSaveSlot = slot;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Save () ;\nint /*<<< orphan*/  M_SaveFile (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_SaveToFile (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * M_SaveToFile_Name ;\nint M_SaveToFile_Num ;\n\nvoid M_DoSave(int num)\n{\nM_SaveFile(num, M_SaveToFile_Name[num]);\nM_SaveToFile(M_SaveToFile_Num);\nif (M_SaveToFile_Num == -2)\nM_SaveToFile_Num = num;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_Ticker",
    "input":"\n0000000000000000 <M_Ticker>:\n0: \tmovq\t(%rip), %rax  # 0x7 <M_Ticker+0x7>\n7: \tleaq\t-1(%rax), %rcx\nb: \tmovq\t%rcx, (%rip)  # 0x12 <M_Ticker+0x12>\n12: \tcmpq\t$1, %rax\n16: \tjg\t0x2a <M_Ticker+0x2a>\n18: \txorb\t$1, (%rip)    # 0x1f <M_Ticker+0x1f>\n1f: \tmovq\t$8, (%rip)    # 0x2a <M_Ticker+0x2a>\n2a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ skullAnimCounter ;\nint whichSkull ;\n\nvoid M_Ticker (void)\n{\nif (--skullAnimCounter <= 0)\n{\nwhichSkull ^= 1;\nskullAnimCounter = 8;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ M_Tick ;\nscalar_t__ M_Tick_Count ;\nint M_Tick_Mode ;\n\nvoid M_Ticker(void)\n{\nM_Tick_Count--;\nif (M_Tick_Count==0)\n{\nM_Tick_Count=M_Tick;\nM_Tick_Mode^=1;\nM_Tick=8;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_GunShot",
    "input":"\n0000000000000000 <P_GunShot>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%esi, %ebx\n9: \tmovq\t%rdi, %r15\nc: \txorl\t%eax, %eax\ne: \tcallq\t0x13 <P_GunShot+0x13>\n13: \tcltq\n15: \timulq\t$1431655766, %rax, %rcx # imm = 0x55555556\n1c: \tmovq\t%rcx, %rdx\n1f: \tshrq\t$63, %rdx\n23: \tshrq\t$32, %rcx\n27: \taddl\t%edx, %ecx\n29: \tleal\t(%rcx,%rcx,2), %ecx\n2c: \tsubl\t%ecx, %eax\n2e: \tleal\t(%rax,%rax,4), %r14d\n32: \taddl\t$5, %r14d\n36: \tmovl\t(%r15), %ebp\n39: \ttestl\t%ebx, %ebx\n3b: \tjne\t0x54 <P_GunShot+0x54>\n3d: \txorl\t%eax, %eax\n3f: \tcallq\t0x44 <P_GunShot+0x44>\n44: \tmovl\t%eax, %ebx\n46: \txorl\t%eax, %eax\n48: \tcallq\t0x4d <P_GunShot+0x4d>\n4d: \tsubl\t%eax, %ebx\n4f: \tshll\t$18, %ebx\n52: \taddl\t%ebx, %ebp\n54: \tmovl\t(%rip), %edx  # 0x5a <P_GunShot+0x5a>\n5a: \tmovl\t(%rip), %ecx  # 0x60 <P_GunShot+0x60>\n60: \tmovq\t%r15, %rdi\n63: \tmovl\t%ebp, %esi\n65: \tmovl\t%r14d, %r8d\n68: \taddq\t$8, %rsp\n6c: \tpopq\t%rbx\n6d: \tpopq\t%r14\n6f: \tpopq\t%r15\n71: \tpopq\t%rbp\n72: \tjmp\t0x77 <P_GunShot+0x77>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int angle; } ;\ntypedef  TYPE_1__ mobj_t ;\ntypedef  int /*<<< orphan*/  boolean ;\ntypedef  int angle_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MISSILERANGE ;\nint /*<<< orphan*/  P_LineAttack (TYPE_1__*,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint P_Random () ;\nint /*<<< orphan*/  bulletslope ;\n\nvoid\nP_GunShot\n( mobj_t*\tmo,\nboolean\taccurate )\n{\nangle_t\tangle;\nint\t\tdamage;\n\ndamage = 5*(P_Random ()%3+1);\nangle = mo->angle;\n\nif (!accurate)\nangle += (P_Random()-P_Random())<<18;\n\nP_LineAttack (mo, angle, MISSILERANGE, bulletslope, damage);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  gun_pos; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckMissileSpawn (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_Random () ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnPlayerMissile (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnPlayerThing (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnThing (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeapon (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail2 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail3 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail4 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail5 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail6 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail7 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail8 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRail9 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailA (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailB (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailC (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailD (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailE (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailF (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailG (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailH (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailI (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailJ (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailK (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailL (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailM (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailN (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailO (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailP (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailQ (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailR (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailS (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailT (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailU (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailV (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailW (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailX (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  P_SpawnWeaponRailY (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\nint /*<<< or"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_diffDraw",
    "input":"\n0000000000000000 <ST_diffDraw>:\n0: \txorl\t%edi, %edi\n2: \tjmp\t0x7 <ST_diffDraw+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_drawWidgets (int) ;\n\nvoid ST_diffDraw(void)\n{\n// update all widgets\nST_drawWidgets(false);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ST_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_draw (int /*<<< orphan*/ *) ;\n\nvoid\nST_diffDraw(ST_State *st)\n{\nST_draw(st);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_CheckNumForName",
    "input":"\n0000000000000000 <W_CheckNumForName>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rsi\n8: \tmovq\t%rsp, %rbx\nb: \tmovq\t%rbx, %rdi\ne: \tmovl\t$8, %edx\n13: \tcallq\t0x18 <W_CheckNumForName+0x18>\n18: \tmovb\t$0, 8(%rsp)\n1d: \tmovq\t%rbx, %rdi\n20: \tcallq\t0x25 <W_CheckNumForName+0x25>\n25: \tmovslq\t(%rip), %rcx  # 0x2c <W_CheckNumForName+0x2c>\n2c: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n31: \ttestq\t%rcx, %rcx\n34: \tje\t0x7f <W_CheckNumForName+0x7f>\n36: \tmovl\t(%rsp), %edi\n39: \tmovl\t4(%rsp), %ebx\n3d: \tmovq\t(%rip), %r8   # 0x44 <W_CheckNumForName+0x44>\n44: \tleaq\t(%r8,%rcx,8), %rdx\n48: \taddq\t$-8, %rdx\n4c: \tshlq\t$3, %rcx\n50: \tnegq\t%rcx\n53: \tjmp\t0x6a <W_CheckNumForName+0x6a>\n55: \tnopw\t%cs:(%rax,%rax)\n5f: \tnop\n60: \taddq\t$-8, %rdx\n64: \taddq\t$8, %rcx\n68: \tje\t0x7f <W_CheckNumForName+0x7f>\n6a: \tmovq\t(%rdx), %rsi\n6d: \tcmpl\t%edi, (%rsi)\n6f: \tjne\t0x60 <W_CheckNumForName+0x60>\n71: \tcmpl\t%ebx, 16(%rsi)\n74: \tjne\t0x60 <W_CheckNumForName+0x60>\n76: \tsubq\t%r8, %rdx\n79: \tshrq\t$3, %rdx\n7d: \tmovl\t%edx, %eax\n7f: \taddq\t$16, %rsp\n83: \tpopq\t%rbx\n84: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * name; } ;\ntypedef  TYPE_1__ lumpinfo_t ;\n\n/* Variables and functions */\nTYPE_1__* lumpinfo ;\nint numlumps ;\nint /*<<< orphan*/  strncpy (char*,char*,int) ;\nint /*<<< orphan*/  strupr (char*) ;\n\nint W_CheckNumForName (char* name)\n{\nunion {\nchar\ts[9];\nint\tx[2];\n\n} name8;\n\nint\t\tv1;\nint\t\tv2;\nlumpinfo_t*\tlump_p;\n\n// make the name into two integers for easy compares\nstrncpy (name8.s,name,8);\n\n// in case the name was a fill 8 chars\nname8.s[8] = 0;\n\n// case insensitive\nstrupr (name8.s);\n\nv1 = name8.x[0];\nv2 = name8.x[1];\n\n\n// scan backwards so patch lump files take precedence\nlump_p = lumpinfo + numlumps;\n\nwhile (lump_p-- != lumpinfo)\n{\nif ( *(int *)lump_p->name == v1\n&& *(int *)&lump_p->name[4] == v2)\n{\nreturn lump_p - lumpinfo;\n}\n}\n\n// TFB. Not found.\nreturn -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  name; int /*<<< orphan*/  value; } ;\ntypedef  TYPE_1__ WResEntry ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memcpy (TYPE_1__*,char*,int) ;\nint /*<<< orphan*/  strcpy (char*,char const*) ;\nint wResNum ;\nTYPE_1__* wResTab ;\n\nint W_CheckNumForName(const char *name)\n{\nWResEntry entry;\nint i;\n\nstrcpy(entry.name, name);\nentry.name[8] = 0;\n\nfor (i = 0; i < wResNum; i++)\nif (wResTab[i].name == entry.name && wResTab[i].value == entry.value)\nreturn i;\n\nreturn -1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_drawSText",
    "input":"\n0000000000000000 <HUlib_drawSText>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t16(%rdi), %rax\n8: \tcmpl\t$0, (%rax)\nb: \tje\t0x4f <HUlib_drawSText+0x4f>\nd: \tmovq\t%rdi, %r14\n10: \tmovl\t(%rdi), %eax\n12: \ttestl\t%eax, %eax\n14: \tjle\t0x4f <HUlib_drawSText+0x4f>\n16: \txorl\t%ebx, %ebx\n18: \txorl\t%ebp, %ebp\n1a: \tnopw\t(%rax,%rax)\n20: \tmovl\t4(%r14), %ecx\n24: \tleal\t(%rbx,%rcx), %edx\n27: \tsarl\t$31, %edx\n2a: \tandl\t%eax, %edx\n2c: \taddl\t%ecx, %edx\n2e: \taddl\t%ebx, %edx\n30: \tmovslq\t%edx, %rdi\n33: \tshlq\t$2, %rdi\n37: \taddq\t8(%r14), %rdi\n3b: \txorl\t%esi, %esi\n3d: \tcallq\t0x42 <HUlib_drawSText+0x42>\n42: \taddl\t$1, %ebp\n45: \tmovl\t(%r14), %eax\n48: \taddl\t$-1, %ebx\n4b: \tcmpl\t%eax, %ebp\n4d: \tjl\t0x20 <HUlib_drawSText+0x20>\n4f: \tpopq\t%rbx\n50: \tpopq\t%r14\n52: \tpopq\t%rbp\n53: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  hu_textline_t ;\nstruct TYPE_3__ {int h; int cl; int /*<<< orphan*/ * l; int /*<<< orphan*/ * on; } ;\ntypedef  TYPE_1__ hu_stext_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_drawTextLine (int /*<<< orphan*/ *,int) ;\n\nvoid HUlib_drawSText(hu_stext_t* s)\n{\nint i, idx;\nhu_textline_t *l;\n\nif (!*s->on)\nreturn; // if not on, don't draw\n\n// draw everything\nfor (i=0 ; i<s->h ; i++)\n{\nidx = s->cl - i;\nif (idx < 0)\nidx += s->h; // handle queue of lines\n\nl = &s->l[idx];\n\n// need a decision made here on whether to skip the draw\nHUlib_drawTextLine(l, false); // no cursor, please\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  y; int /*<<< orphan*/  x; TYPE_1__* font; int /*<<< orphan*/ * screen; } ;\nstruct TYPE_4__ {int height; } ;\ntypedef  TYPE_2__ HUCharInfo ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_drawChar (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid HUlib_drawSText(HUCharInfo *ci)\n{\nint i;\n\nif (!ci->font->height)\nreturn;\n\nfor (i = 0; i < ci->y; i++)\nHU_drawChar(ci->screen, ci->x + i, ci->x + i + ci->font->height);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_plats.c_EV_StopPlat",
    "input":"\n0000000000000000 <EV_StopPlat>:\n0: \tmovl\t(%rip), %r8d  # 0x7 <EV_StopPlat+0x7>\n7: \ttestl\t%r8d, %r8d\na: \tjle\t0x5b <EV_StopPlat+0x5b>\nc: \tmovq\t(%rip), %r9   # 0x13 <EV_StopPlat+0x13>\n13: \txorl\t%edx, %edx\n15: \tjmp\t0x29 <EV_StopPlat+0x29>\n17: \tnopw\t(%rax,%rax)\n20: \taddq\t$1, %rdx\n24: \tcmpq\t%r8, %rdx\n27: \tjae\t0x5b <EV_StopPlat+0x5b>\n29: \tmovq\t(%r9,%rdx,8), %rsi\n2d: \ttestq\t%rsi, %rsi\n30: \tje\t0x20 <EV_StopPlat+0x20>\n32: \tmovq\t(%rsi), %r10\n35: \tmovq\t(%rip), %rcx  # 0x3c <EV_StopPlat+0x3c>\n3c: \tcmpq\t%rcx, %r10\n3f: \tje\t0x20 <EV_StopPlat+0x20>\n41: \tmovq\t8(%rsi), %rax\n45: \tcmpq\t(%rdi), %rax\n48: \tjne\t0x20 <EV_StopPlat+0x20>\n4a: \tmovq\t%r10, 16(%rsi)\n4e: \tmovq\t%rcx, (%rsi)\n51: \tmovq\t$0, 24(%rsi)\n59: \tjmp\t0x20 <EV_StopPlat+0x20>\n5b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ tag; } ;\ntypedef  TYPE_3__ line_t ;\ntypedef  scalar_t__ actionf_v ;\nstruct TYPE_6__ {scalar_t__ acv; } ;\nstruct TYPE_7__ {TYPE_1__ function; } ;\nstruct TYPE_9__ {scalar_t__ status; scalar_t__ tag; scalar_t__ oldstatus; TYPE_2__ thinker; } ;\n\n/* Variables and functions */\nint MAXPLATS ;\nTYPE_4__** activeplats ;\nscalar_t__ in_stasis ;\n\nvoid EV_StopPlat(line_t* line)\n{\nint\t\tj;\n\nfor (j = 0;j < MAXPLATS;j++)\nif (activeplats[j]\n&& ((activeplats[j])->status != in_stasis)\n&& ((activeplats[j])->tag == line->tag))\n{\n(activeplats[j])->oldstatus = (activeplats[j])->status;\n(activeplats[j])->status = in_stasis;\n(activeplats[j])->thinker.function.acv = (actionf_v)NULL;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ fd; scalar_t__ events; scalar_t__ revents; } ;\ntypedef  TYPE_1__ EV_P ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EV_MAXFD ;\nTYPE_1__** active ;\nscalar_t__ ev_io ;\n\n__attribute__((used)) static void\nEV_StopPlat (EV_P *loop, int fd)\n{\nEV_P *w;\nint i;\n\nfor (i = 0; i < (int)EV_MAXFD; ++i)\n{\nw = active[i];\n\nif (!w)\ncontinue;\n\nif (w->fd != fd || w->events != ev_io)\ncontinue;\n\nw->events = w->revents = 0;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_SkelWhoosh",
    "input":"\n0000000000000000 <A_SkelWhoosh>:\n0: \tpushq\t%rbx\n1: \tcmpl\t$0, (%rdi)\n4: \tje\t0x1d <A_SkelWhoosh+0x1d>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <A_SkelWhoosh+0xe>\ne: \tmovl\t(%rip), %esi  # 0x14 <A_SkelWhoosh+0x14>\n14: \tmovq\t%rbx, %rdi\n17: \tpopq\t%rbx\n18: \tjmp\t0x1d <A_SkelWhoosh+0x1d>\n1d: \tpopq\t%rbx\n1e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  target; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_FaceTarget (TYPE_1__*) ;\nint /*<<< orphan*/  S_StartSound (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  sfx_skeswg ;\n\nvoid A_SkelWhoosh (mobj_t*\tactor)\n{\nif (!actor->target)\nreturn;\nA_FaceTarget (actor);\nS_StartSound (actor,sfx_skeswg);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  bIsDead; } ;\ntypedef  TYPE_1__* PANIM_SKEL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_SkelWhoosh_B ;\nint /*<<< orphan*/  A_SetAnim (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_SkelWhoosh_B_Finish ;\n\nvoid A_SkelWhoosh(PANIM_SKEL skel)\n{\nif (!skel->bIsDead)\n{\nA_SetAnim(skel, A_SkelWhoosh_B);\nA_SkelWhoosh_B_Finish(skel);\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_SetViewSize",
    "input":"\n0000000000000000 <R_SetViewSize>:\n0: \tmovl\t$1, (%rip)    # 0xa <R_SetViewSize+0xa>\na: \tmovl\t%edi, (%rip)  # 0x10 <R_SetViewSize+0x10>\n10: \tmovl\t%esi, (%rip)  # 0x16 <R_SetViewSize+0x16>\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint setblocks ;\nint setdetail ;\nint setsizeneeded ;\n\nvoid\nR_SetViewSize\n( int\t\tblocks,\nint\t\tdetail )\n{\nsetsizeneeded = true;\nsetblocks = blocks;\nsetdetail = detail;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_VBL ;\nint /*<<< orphan*/  R_VBL_Count ;\n\nvoid R_SetViewSize(UBYTE width, UBYTE height)\n{\nR_VBL = 1;\nR_VBL_Count = width;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_video.c_I_UpdateNoBlit",
    "input":"\n0000000000000000 <I_UpdateNoBlit>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_UpdateNoBlit (void)\n{\n// what is this?\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_UpdateNoBlit(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_activateNewScale",
    "input":"\n0000000000000000 <AM_activateNewScale>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %eax  # 0x7 <AM_activateNewScale+0x7>\n7: \tmovl\t%eax, %ecx\n9: \tshrl\t$31, %ecx\nc: \taddl\t%eax, %ecx\ne: \tsarl\t%ecx\n10: \tmovslq\t%ecx, %rax\n13: \taddq\t%rax, (%rip)  # 0x1a <AM_activateNewScale+0x1a>\n1a: \tmovl\t(%rip), %eax  # 0x20 <AM_activateNewScale+0x20>\n20: \tmovl\t%eax, %ecx\n22: \tshrl\t$31, %ecx\n25: \taddl\t%eax, %ecx\n27: \tsarl\t%ecx\n29: \tmovslq\t%ecx, %rax\n2c: \taddq\t%rax, (%rip)  # 0x33 <AM_activateNewScale+0x33>\n33: \tmovl\t(%rip), %edi  # 0x39 <AM_activateNewScale+0x39>\n39: \tcallq\t0x3e <AM_activateNewScale+0x3e>\n3e: \tmovl\t%eax, (%rip)  # 0x44 <AM_activateNewScale+0x44>\n44: \tmovl\t(%rip), %edi  # 0x4a <AM_activateNewScale+0x4a>\n4a: \tcallq\t0x4f <AM_activateNewScale+0x4f>\n4f: \tmovl\t%eax, (%rip)  # 0x55 <AM_activateNewScale+0x55>\n55: \tmovslq\t(%rip), %rcx  # 0x5c <AM_activateNewScale+0x5c>\n5c: \tmovl\t%ecx, %edx\n5e: \tshrl\t$31, %edx\n61: \taddl\t%ecx, %edx\n63: \tsarl\t%edx\n65: \tmovslq\t%edx, %rdx\n68: \tmovq\t(%rip), %rsi  # 0x6f <AM_activateNewScale+0x6f>\n6f: \tsubq\t%rdx, %rsi\n72: \tmovq\t%rsi, (%rip)  # 0x79 <AM_activateNewScale+0x79>\n79: \tmovl\t%eax, %edx\n7b: \tshrl\t$31, %edx\n7e: \taddl\t%eax, %edx\n80: \tsarl\t%edx\n82: \tmovslq\t%edx, %rdx\n85: \tmovq\t(%rip), %rdi  # 0x8c <AM_activateNewScale+0x8c>\n8c: \tsubq\t%rdx, %rdi\n8f: \tmovq\t%rdi, (%rip)  # 0x96 <AM_activateNewScale+0x96>\n96: \taddq\t%rcx, %rsi\n99: \tmovq\t%rsi, (%rip)  # 0xa0 <AM_activateNewScale+0xa0>\na0: \tcltq\na2: \taddq\t%rdi, %rax\na5: \tmovq\t%rax, (%rip)  # 0xac <AM_activateNewScale+0xac>\nac: \tpopq\t%rax\nad: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint FTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  f_h ;\nint /*<<< orphan*/  f_w ;\nint m_h ;\nint m_w ;\nscalar_t__ m_x ;\nscalar_t__ m_x2 ;\nscalar_t__ m_y ;\nscalar_t__ m_y2 ;\n\nvoid AM_activateNewScale(void)\n{\nm_x += m_w/2;\nm_y += m_h/2;\nm_w = FTOM(f_w);\nm_h = FTOM(f_h);\nm_x -= m_w/2;\nm_y -= m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint AM_scale ;\nint AM_scale_x ;\nint AM_scale_y ;\nscalar_t__ AM_x ;\nscalar_t__ AM_y ;\nint AM_zoom ;\nint AM_zoom_x ;\nint AM_zoom_y ;\nscalar_t__ AM_zoom_x_center ;\nscalar_t__ AM_zoom_y_center ;\nint /*<<< orphan*/  AM_zoom_y_center_set () ;\nint /*<<< orphan*/  AM_zoom_x_center_set () ;\n\nvoid AM_activateNewScale(void)\n{\nAM_zoom_x_center_set();\nAM_zoom_y_center_set();\nAM_zoom = AM_scale * AM_zoom;\nAM_zoom_x = AM_scale_x * AM_zoom;\nAM_zoom_y = AM_scale_y * AM_zoom;\nAM_x = AM_zoom_x_center - (AM_zoom_x / 2);\nAM_y = AM_zoom_y_center - (AM_zoom_y / 2);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_doFollowPlayer",
    "input":"\n0000000000000000 <AM_doFollowPlayer>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rax  # 0x8 <AM_doFollowPlayer+0x8>\n8: \tmovq\t(%rax), %rax\nb: \tmovq\t(%rax), %rdi\ne: \tcmpq\t%rdi, (%rip)  # 0x15 <AM_doFollowPlayer+0x15>\n15: \tjne\t0x28 <AM_doFollowPlayer+0x28>\n17: \tmovq\t(%rip), %rcx  # 0x1e <AM_doFollowPlayer+0x1e>\n1e: \tcmpq\t8(%rax), %rcx\n22: \tje\t0xbe <AM_doFollowPlayer+0xbe>\n28: \tcallq\t0x2d <AM_doFollowPlayer+0x2d>\n2d: \tmovl\t%eax, %edi\n2f: \tcallq\t0x34 <AM_doFollowPlayer+0x34>\n34: \tmovl\t(%rip), %ecx  # 0x3a <AM_doFollowPlayer+0x3a>\n3a: \tmovl\t%ecx, %edx\n3c: \tshrl\t$31, %edx\n3f: \taddl\t%ecx, %edx\n41: \tsarl\t%edx\n43: \tnegl\t%edx\n45: \tmovslq\t%edx, %rcx\n48: \taddq\t%rax, %rcx\n4b: \tmovq\t%rcx, (%rip)  # 0x52 <AM_doFollowPlayer+0x52>\n52: \tmovq\t(%rip), %rax  # 0x59 <AM_doFollowPlayer+0x59>\n59: \tmovq\t(%rax), %rax\n5c: \tmovq\t8(%rax), %rdi\n60: \tcallq\t0x65 <AM_doFollowPlayer+0x65>\n65: \tmovl\t%eax, %edi\n67: \tcallq\t0x6c <AM_doFollowPlayer+0x6c>\n6c: \tmovslq\t(%rip), %rcx  # 0x73 <AM_doFollowPlayer+0x73>\n73: \tmovl\t%ecx, %edx\n75: \tshrl\t$31, %edx\n78: \taddl\t%ecx, %edx\n7a: \tsarl\t%edx\n7c: \tnegl\t%edx\n7e: \tmovslq\t%edx, %rdx\n81: \taddq\t%rax, %rdx\n84: \tmovslq\t(%rip), %rax  # 0x8b <AM_doFollowPlayer+0x8b>\n8b: \taddq\t(%rip), %rax  # 0x92 <AM_doFollowPlayer+0x92>\n92: \tmovq\t%rdx, (%rip)  # 0x99 <AM_doFollowPlayer+0x99>\n99: \tmovq\t%rax, (%rip)  # 0xa0 <AM_doFollowPlayer+0xa0>\na0: \taddq\t%rcx, %rdx\na3: \tmovq\t%rdx, (%rip)  # 0xaa <AM_doFollowPlayer+0xaa>\naa: \tmovq\t(%rip), %rax  # 0xb1 <AM_doFollowPlayer+0xb1>\nb1: \tmovq\t(%rax), %rax\nb4: \tmovups\t(%rax), %xmm0\nb7: \tmovups\t%xmm0, (%rip) # 0xbe <AM_doFollowPlayer+0xbe>\nbe: \tpopq\t%rax\nbf: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ x; scalar_t__ y; } ;\nstruct TYPE_5__ {TYPE_1__* mo; } ;\nstruct TYPE_4__ {scalar_t__ x; scalar_t__ y; } ;\n\n/* Variables and functions */\nvoid* FTOM (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MTOF (scalar_t__) ;\nTYPE_3__ f_oldloc ;\nint m_h ;\nint m_w ;\nvoid* m_x ;\nvoid* m_x2 ;\nvoid* m_y ;\nvoid* m_y2 ;\nTYPE_2__* plr ;\n\nvoid AM_doFollowPlayer(void)\n{\n\nif (f_oldloc.x != plr->mo->x || f_oldloc.y != plr->mo->y)\n{\nm_x = FTOM(MTOF(plr->mo->x)) - m_w/2;\nm_y = FTOM(MTOF(plr->mo->y)) - m_h/2;\nm_x2 = m_x + m_w;\nm_y2 = m_y + m_h;\nf_oldloc.x = plr->mo->x;\nf_oldloc.y = plr->mo->y;\n\n//  m_x = FTOM(MTOF(plr->mo->x - m_w/2));\n//  m_y = FTOM(MTOF(plr->mo->y - m_h/2));\n//  m_x = plr->mo->x - m_w/2;\n//  m_y = plr->mo->y - m_h/2;\n\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* actor; } ;\nstruct TYPE_9__ {scalar_t__ x; scalar_t__ y; } ;\nstruct TYPE_8__ {scalar_t__ x; scalar_t__ y; } ;\n\n/* Variables and functions */\nint AM_ANGLE ;\nint AM_ANGLE_MAX ;\nint AM_ANGLE_MIN ;\nint AM_ANGLE_RATE ;\nint AM_ANGLE_RATE_MAX ;\nint AM_ANGLE_RATE_MIN ;\nint AM_ANGLE_RATE_RANDOM ;\nint AM_ANGLE_RATE_RANDOM_MAX ;\nint AM_ANGLE_RATE_RANDOM_MIN ;\nint AM_ANGLE_RANDOM ;\nint AM_ANGLE_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE ;\nint AM_ANGLE_RANDOM_RATE_MAX ;\nint AM_ANGLE_RANDOM_RATE_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MIN ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM ;\nint AM_ANGLE_RANDOM_RATE_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_RANDOM_MAX ;\nint AM_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_stuff.c_ST_Drawer",
    "input":"\n0000000000000000 <ST_Drawer>:\n0: \tpushq\t%rax\n1: \ttestq\t%rdi, %rdi\n4: \tsete\t%al\n7: \tcmpq\t$0, (%rip)    # 0xf <ST_Drawer+0xf>\nf: \tsetne\t%cl\n12: \torb\t%al, %cl\n14: \tmovzbl\t%cl, %eax\n17: \tmovl\t%eax, (%rip)  # 0x1d <ST_Drawer+0x1d>\n1d: \tcmpl\t$0, (%rip)    # 0x24 <ST_Drawer+0x24>\n24: \tsetne\t%al\n27: \ttestq\t%rsi, %rsi\n2a: \tsetne\t%cl\n2d: \torb\t%al, %cl\n2f: \tmovzbl\t%cl, %eax\n32: \tmovl\t%eax, (%rip)  # 0x38 <ST_Drawer+0x38>\n38: \txorl\t%eax, %eax\n3a: \tcallq\t0x3f <ST_Drawer+0x3f>\n3f: \tcmpl\t$0, (%rip)    # 0x46 <ST_Drawer+0x46>\n46: \tje\t0x50 <ST_Drawer+0x50>\n48: \txorl\t%eax, %eax\n4a: \tpopq\t%rcx\n4b: \tjmp\t0x50 <ST_Drawer+0x50>\n50: \txorl\t%eax, %eax\n52: \tpopq\t%rcx\n53: \tjmp\t0x58 <ST_Drawer+0x58>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ boolean ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ST_diffDraw () ;\nint /*<<< orphan*/  ST_doPaletteStuff () ;\nint /*<<< orphan*/  ST_doRefresh () ;\nscalar_t__ automapactive ;\nint st_firsttime ;\nint st_statusbaron ;\n\nvoid ST_Drawer (boolean fullscreen, boolean refresh)\n{\n\nst_statusbaron = (!fullscreen) || automapactive;\nst_firsttime = st_firsttime || refresh;\n\n// Do red-/gold-shifts from damage/items\nST_doPaletteStuff();\n\n// If just after ST_Start(), refresh all\nif (st_firsttime) ST_doRefresh();\n// Otherwise, update as little as possible\nelse ST_diffDraw();\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  var ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Drawer (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  Drawer_ (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ST_Drawer_ ;\nint /*<<< orphan*/  ST_Drawer_1 ;\nint /*<<< orphan*/  ST_Drawer_2 ;\nint /*<<< orphan*/  ST_Drawer_3 ;\nint /*<<< orphan*/  ST_Drawer_4 ;\nint /*<<< orphan*/  ST_Drawer_5 ;\nint /*<<< orphan*/  ST_Drawer_6 ;\nint /*<<< orphan*/  ST_Drawer_7 ;\nint /*<<< orphan*/  ST_Drawer_8 ;\nint /*<<< orphan*/  ST_Drawer_9 ;\nint /*<<< orphan*/  ST_Drawer_A ;\nint /*<<< orphan*/  ST_Drawer_B ;\nint /*<<< orphan*/  ST_Drawer_C ;\nint /*<<< orphan*/  ST_Drawer_D ;\nint /*<<< orphan*/  ST_Drawer_E ;\nint /*<<< orphan*/  ST_Drawer_F ;\nint /*<<< orphan*/  ST_Drawer_G ;\nint /*<<< orphan*/  ST_Drawer_H ;\nint /*<<< orphan*/  ST_Drawer_I ;\nint /*<<< orphan*/  ST_Drawer_J ;\nint /*<<< orphan*/  ST_Drawer_K ;\nint /*<<< orphan*/  ST_Drawer_L ;\nint /*<<< orphan*/  ST_Drawer_M ;\nint /*<<< orphan*/  ST_Drawer_N ;\nint /*<<< orphan*/  ST_Drawer_O ;\nint /*<<< orphan*/  ST_Drawer_P ;\nint /*<<< orphan*/  ST_Drawer_Q ;\nint /*<<< orphan*/  ST_Drawer_R ;\nint /*<<< orphan*/  ST_Drawer_S ;\nint /*<<< orphan*/  ST_Drawer_T ;\nint /*<<< orphan*/  ST_Drawer_U ;\nint /*<<< orphan*/  ST_Drawer_V ;\nint /*<<< orphan*/  ST_Drawer_W ;\nint /*<<< orphan*/  ST_Drawer_X ;\nint /*<<< orphan*/  ST_Drawer_Y ;\nint /*<<< orphan*/  ST_Drawer_Z ;\nint /*<<< orphan*/  ST_Drawer_a ;\nint /*<<< orphan*/  ST_Drawer_b ;\nint /*<<< orphan*/  ST_Drawer_c ;\nint /*<<< orphan*/  ST_Drawer_d ;\nint /*<<< orphan*/  ST_Drawer_e ;\nint /*<<< orphan*/  ST_Drawer_f ;\nint /*<<< orphan*/  ST_Drawer_g ;\nint /*<<< orphan*/  ST_Drawer_h ;\nint /*<<< orphan*/  ST_Drawer_i ;\nint /*<<< orphan*/  ST_Drawer_j ;\nint /*<<< orphan*/  ST_Drawer_k ;\nint /*<<< orphan*/  ST_Drawer_l ;\nint /*<<< orphan*/  ST_Drawer_m ;\nint /*<<< orphan*/  ST_Drawer_n ;\nint /*<<< orphan*/  ST_Drawer_o ;\nint /*<<< orphan*/  ST_Drawer_p ;\nint /*<<< orphan*/  ST_Drawer_q ;\nint /*<<< orphan*/  ST_Drawer_r ;\nint /*<<< orphan*/  ST_Drawer_s ;\nint /*<<< orphan*/  ST_Drawer_t ;\nint /*<<< orphan*/  ST_Drawer_u ;\nint /*<<< orphan*/  ST_Drawer_v ;\nint /*<<< orphan*/  ST_Drawer_w ;\nint /*<<< orphan*/  ST_Drawer_x ;\nint /*<<< orphan*/  ST_Drawer_y ;\nint /*<<< orphan*/  ST_Drawer_z ;\n\n__attribute__((used)) static var ST_Drawer(var self, var args) {\nST_Drawer_ = (args == 0);\nST_Drawer_1 = (args == 1);\nST_Drawer_2 = (args == 2);\nST_Drawer_3 = (args == 3);\nST_Drawer_4 = (args == 4);\nST_Drawer_5 = (args == 5);\nST_Drawer_6 = (args == 6);\nST_Drawer_7 = (args == 7);\nST_Drawer_8 = (args == 8);\nST_Drawer_9 = (args == 9);\nST_Drawer_A = (args == 10);\nST_Drawer_B = (args == 11);\nST_Drawer_C = (args == 12);\nST_Drawer_D = (args == 13);\nST_Drawer_E = (args == 14);\nST_Drawer_F = (args == 15);\nST_Drawer_G = (args == 16);\nST_Drawer_H = (args == 17);\nST_Drawer_I = (args == 18);\nST_Drawer_J = (args == 19);\nST_Drawer_K = (args == 20);\nST_Drawer_L = (args == 21);\nST_Drawer_M = (args == 22);\nST_Drawer_N = (args == 23);\nST_Drawer_O = (args == 24);\nST_Drawer_P = (args == 25);\nST_Drawer_Q = (args == 26);\nST_Drawer_R = (args == 27);\nST_Drawer_S = (args == 28);\nST_Drawer_T = (args == 29);\nST_Drawer_U = (args == 30);\nST_Drawer_V = (args == 31);\nST_Drawer_W = (args == 32);\nST_Drawer_X = (args == 33);\nST_Drawer_Y = (args == 34);\nST_Drawer_Z = (args == 35);\nST_Drawer_a = (args == 36);\nST_Drawer_b = (args == 37);\nST_Drawer_c = (args == 38);\nST_Drawer_d = (args == 39);\nST_Drawer_e = (args == 40);\nST_Drawer_f = (args == 41);\nST_Drawer_g = (args == 42);\nST_Drawer_h = (args == 43);\nST_Drawer_i = (args == 44);\nST_Drawer_j = (args == 45);\nST_Drawer_k = (args == 46);\nST_Drawer_l = (args == 47);\nST_Drawer_m = (args == 48);\nST_Drawer_n = (args == 49);\nST_Drawer_o = (args == 50);\nST_Drawer_p = (args == 51);\nST_Drawer_q = (args == 52);\nST_Drawer_r = (args == 53);\nST_Drawer_s = (args == 54);\nST_Drawer_t = (args == 55);\nST_Drawer_u = (args == 56);\nST_Drawer_v = (args == 57);\nST_Drawer_w = (args == 58);\nST_Drawer_x = (args == 59);\nST_Drawer_y = (args == 60);\nST_Drawer_z = (args == 61);\nif (ST_Drawer_) {\nreturn Drawer_((var)self);\n}\nreturn Drawer(self);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_PauseSong",
    "input":"\n0000000000000000 <I_PauseSong>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_PauseSong (int handle)\n{\n// UNUSED.\nhandle = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_PauseSong(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_v_video.c_V_Init",
    "input":"\n0000000000000000 <V_Init>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %edi  # 0x7 <V_Init+0x7>\n7: \timull\t(%rip), %edi  # 0xe <V_Init+0xe>\ne: \tshll\t$2, %edi\n11: \tcallq\t0x16 <V_Init+0x16>\n16: \tmovslq\t(%rip), %rcx  # 0x1d <V_Init+0x1d>\n1d: \tmovslq\t(%rip), %rdx  # 0x24 <V_Init+0x24>\n24: \tmovq\t(%rip), %rsi  # 0x2b <V_Init+0x2b>\n2b: \tmovq\t%rax, (%rsi)\n2e: \timulq\t%rcx, %rdx\n32: \tleaq\t(%rax,%rdx,4), %rcx\n36: \tmovq\t(%rip), %rsi  # 0x3d <V_Init+0x3d>\n3d: \tmovq\t%rcx, 8(%rsi)\n41: \tleaq\t(%rax,%rdx,8), %rcx\n45: \tmovq\t%rcx, 16(%rsi)\n49: \tleaq\t(%rdx,%rdx,2), %rcx\n4d: \tleaq\t(%rax,%rcx,4), %rax\n51: \tmovq\t%rax, 24(%rsi)\n55: \tpopq\t%rax\n56: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * I_AllocLow (int) ;\nint SCREENHEIGHT ;\nint SCREENWIDTH ;\nint /*<<< orphan*/ ** screens ;\n\nvoid V_Init (void)\n{\nint\t\ti;\nbyte*\tbase;\n\n// stick these in low dos memory on PCs\n\nbase = I_AllocLow (SCREENWIDTH*SCREENHEIGHT*4);\n\nfor (i=0 ; i<4 ; i++)\nscreens[i] = base + i*SCREENWIDTH*SCREENHEIGHT;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  ULONG ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HEAP_ZERO_MEMORY ;\nint /*<<< orphan*/  GetProcessHeap () ;\nint /*<<< orphan*/ * HeapAlloc (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/ * V_Buffer ;\nint V_BufferSize ;\nint V_BufferSizeInBytes ;\nint V_BufferSizeInWords ;\n\nVOID\nV_Init(VOID)\n{\nV_Buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, V_BufferSizeInBytes);\nV_Buffer[0] = V_Buffer[1] = V_Buffer[2] = V_Buffer[3] = 0;\nV_Buffer[4] = V_Buffer[5] = V_Buffer[6] = V_Buffer[7] = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_StopSong",
    "input":"\n0000000000000000 <I_StopSong>:\n0: \tmovq\t$0, (%rip)    # 0xb <I_StopSong+0xb>\nb: \tmovq\t$0, (%rip)    # 0x16 <I_StopSong+0x16>\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ looping ;\nscalar_t__ musicdies ;\n\nvoid I_StopSong(int handle)\n{\n// UNUSED.\nhandle = 0;\n\nlooping = 0;\nmusicdies = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ I_SongIsPlaying ;\nscalar_t__ I_SongPaused ;\n\nvoid I_StopSong(void)\n{\nI_SongIsPlaying = 0;\nI_SongPaused = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_UnRegisterSong",
    "input":"\n0000000000000000 <I_UnRegisterSong>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_UnRegisterSong(int handle)\n{\n// UNUSED.\nhandle = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_UnRegisterSong(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_P_FireWeapon",
    "input":"\n0000000000000000 <P_FireWeapon>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <P_FireWeapon+0x9>\n9: \ttestl\t%eax, %eax\nb: \tje\t0x41 <P_FireWeapon+0x41>\nd: \tmovl\t8(%rbx), %edi\n10: \tmovl\t(%rip), %esi  # 0x16 <P_FireWeapon+0x16>\n16: \tcallq\t0x1b <P_FireWeapon+0x1b>\n1b: \tmovq\t(%rip), %rax  # 0x22 <P_FireWeapon+0x22>\n22: \tmovq\t(%rbx), %rcx\n25: \tmovl\t(%rax,%rcx,4), %edx\n28: \tmovl\t(%rip), %esi  # 0x2e <P_FireWeapon+0x2e>\n2e: \tmovq\t%rbx, %rdi\n31: \tcallq\t0x36 <P_FireWeapon+0x36>\n36: \tmovl\t8(%rbx), %edi\n39: \tmovl\t%edi, %esi\n3b: \tpopq\t%rbx\n3c: \tjmp\t0x41 <P_FireWeapon+0x41>\n41: \tpopq\t%rbx\n42: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  statenum_t ;\nstruct TYPE_6__ {size_t readyweapon; int /*<<< orphan*/  mo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_7__ {int /*<<< orphan*/  atkstate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckAmmo (TYPE_1__*) ;\nint /*<<< orphan*/  P_NoiseAlert (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetMobjState (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  S_PLAY_ATK1 ;\nint /*<<< orphan*/  ps_weapon ;\nTYPE_2__* weaponinfo ;\n\nvoid P_FireWeapon (player_t* player)\n{\nstatenum_t\tnewstate;\n\nif (!P_CheckAmmo (player))\nreturn;\n\nP_SetMobjState (player->mo, S_PLAY_ATK1);\nnewstate = weaponinfo[player->readyweapon].atkstate;\nP_SetPsprite (player, ps_weapon, newstate);\nP_NoiseAlert (player->mo, player->mo);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct player_t {int /*<<< orphan*/  player; int /*<<< orphan*/  ps; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  weapon; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_FireWeapon (struct player_t*) ;\nint /*<<< orphan*/  P_SetPsprite (struct player_t*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_SetWeapon (struct player_t*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ps_weapon ;\nTYPE_1__* weaponinfo ;\nint /*<<< orphan*/  weaponstate ;\n\nvoid P_FireWeapon(struct player_t *p)\n{\nif (!P_CheckAmmo(p))\nreturn;\n\nP_SetPsprite(p, p->ps, weaponinfo[p->player.weapon].weapon);\nP_SetWeapon(p, p->ps, weaponstate);\nP_FireWeapon(p);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_fixed.c_FixedDiv2",
    "input":"\n0000000000000000 <FixedDiv2>:\n0: \tpushq\t%rax\n1: \tcvtsi2sd\t%rdi, %xmm1\n6: \tcvtsi2sd\t%rsi, %xmm0\nb: \tdivsd\t%xmm0, %xmm1\nf: \tmulsd\t(%rip), %xmm1 # 0x17 <FixedDiv2+0x17>\n17: \tucomisd\t(%rip), %xmm1 # 0x1f <FixedDiv2+0x1f>\n1f: \tjae\t0x2f <FixedDiv2+0x2f>\n21: \tmovsd\t(%rip), %xmm0 # xmm0 = mem[0],zero\n# 0x29 <FixedDiv2+0x29>\n29: \tucomisd\t%xmm1, %xmm0\n2d: \tjbe\t0x43 <FixedDiv2+0x43>\n2f: \tmovl\t$0, %edi\n34: \tmovsd\t%xmm1, (%rsp)\n39: \tcallq\t0x3e <FixedDiv2+0x3e>\n3e: \tmovsd\t(%rsp), %xmm1 # xmm1 = mem[0],zero\n43: \tcvttsd2si\t%xmm1, %rax\n48: \tpopq\t%rcx\n49: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\ndouble FRACUNIT ;\nint /*<<< orphan*/  I_Error (char*) ;\n\nfixed_t\nFixedDiv2\n( fixed_t\ta,\nfixed_t\tb )\n{\n#if 0\nlong long c;\nc = ((long long)a<<16) / ((long long)b);\nreturn (fixed_t) c;\n#endif\n\ndouble c;\n\nc = ((double)a) / ((double)b) * FRACUNIT;\n\nif (c >= 2147483648.0 || c < -2147483648.0)\nI_Error(\"FixedDiv: divide by zero\");\nreturn (fixed_t) c;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  cmsUInt32Number ;\ntypedef  double cmsFloat64Number ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FatalError (char*,double) ;\n\n__attribute__((used)) static\ncmsUInt32Number FixedDiv2(cmsUInt32Number a, cmsUInt32Number b)\n{\ncmsFloat64Number r = (cmsFloat64Number) a / (cmsFloat64Number) b;\n\nif (r < 0.0)\nFatalError(\"FixedDiv2: Negative result\");\n\nif (r > 0xFFFF)\nFatalError(\"FixedDiv2: Overflow\");\n\nreturn (cmsUInt32Number) r;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_s_sound.c_S_StopSound",
    "input":"\n0000000000000000 <S_StopSound>:\n0: \tmovl\t(%rip), %ecx  # 0x6 <S_StopSound+0x6>\n6: \ttestl\t%ecx, %ecx\n8: \tjle\t0x40 <S_StopSound+0x40>\na: \tmovq\t(%rip), %rdx  # 0x11 <S_StopSound+0x11>\n11: \taddq\t$8, %rdx\n15: \txorl\t%eax, %eax\n17: \tjmp\t0x2d <S_StopSound+0x2d>\n19: \tnopl\t(%rax)\n20: \taddq\t$1, %rax\n24: \taddq\t$16, %rdx\n28: \tcmpq\t%rcx, %rax\n2b: \tjae\t0x40 <S_StopSound+0x40>\n2d: \tcmpq\t$0, (%rdx)\n31: \tje\t0x20 <S_StopSound+0x20>\n33: \tcmpq\t%rdi, -8(%rdx)\n37: \tjne\t0x20 <S_StopSound+0x20>\n39: \tmovl\t%eax, %edi\n3b: \tjmp\t0x40 <S_StopSound+0x40>\n40: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {void* origin; scalar_t__ sfxinfo; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  S_StopChannel (int) ;\nTYPE_1__* channels ;\nint numChannels ;\n\nvoid S_StopSound(void *origin)\n{\n\nint cnum;\n\nfor (cnum=0 ; cnum<numChannels ; cnum++)\n{\nif (channels[cnum].sfxinfo && channels[cnum].origin == origin)\n{\nS_StopChannel(cnum);\nbreak;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ handle; scalar_t__ channel; } ;\ntypedef  TYPE_1__ channel_t ;\n\n/* Variables and functions */\nint NUM_CHANNELS ;\nint /*<<< orphan*/  S_StopChannel (int) ;\nTYPE_1__* channels ;\n\nvoid S_StopSound(int handle)\n{\nint\t\ti;\n\nfor (i=0 ; i<NUM_CHANNELS ; i++)\n{\nif (channels[i].handle && channels[i].channel == handle)\n{\nS_StopChannel(i);\n}\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_SizeDisplay",
    "input":"\n0000000000000000 <M_SizeDisplay>:\n0: \tcmpl\t$1, %edi\n3: \tje\t0x1f <M_SizeDisplay+0x1f>\n5: \ttestl\t%edi, %edi\n7: \tjne\t0x3a <M_SizeDisplay+0x3a>\n9: \tmovl\t(%rip), %eax  # 0xf <M_SizeDisplay+0xf>\nf: \ttestl\t%eax, %eax\n11: \tjle\t0x3a <M_SizeDisplay+0x3a>\n13: \taddl\t$-1, (%rip)   # 0x1a <M_SizeDisplay+0x1a>\n1a: \taddl\t$-1, %eax\n1d: \tjmp\t0x34 <M_SizeDisplay+0x34>\n1f: \tmovl\t(%rip), %eax  # 0x25 <M_SizeDisplay+0x25>\n25: \tcmpl\t$7, %eax\n28: \tjg\t0x3a <M_SizeDisplay+0x3a>\n2a: \taddl\t$1, (%rip)    # 0x31 <M_SizeDisplay+0x31>\n31: \taddl\t$1, %eax\n34: \tmovl\t%eax, (%rip)  # 0x3a <M_SizeDisplay+0x3a>\n3a: \tmovl\t(%rip), %edi  # 0x40 <M_SizeDisplay+0x40>\n40: \tmovl\t(%rip), %esi  # 0x46 <M_SizeDisplay+0x46>\n46: \tjmp\t0x4b <M_SizeDisplay+0x4b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_SetViewSize (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  detailLevel ;\nint screenSize ;\nint /*<<< orphan*/  screenblocks ;\n\nvoid M_SizeDisplay(int choice)\n{\nswitch(choice)\n{\ncase 0:\nif (screenSize > 0)\n{\nscreenblocks--;\nscreenSize--;\n}\nbreak;\ncase 1:\nif (screenSize < 8)\n{\nscreenblocks++;\nscreenSize++;\n}\nbreak;\n}\n\n\nR_SetViewSize (screenblocks, detailLevel);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_Size ;\nint /*<<< orphan*/  M_Size_Display ;\nint /*<<< orphan*/  M_Size_Display_B ;\nint /*<<< orphan*/  M_Size_Display_KB ;\nint /*<<< orphan*/  M_Size_Display_MB ;\nint /*<<< orphan*/  M_Size_Display_TB ;\nint /*<<< orphan*/  M_Size_Display_i ;\nint /*<<< orphan*/  M_Size_Display_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_i_B ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_i_KB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_i_MB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_i_TB ;\nint /*<<< orphan*/  M_Size_Display_i_i_i_i_i_i_i_i_i_i_i_i_i ;\nint /*<<< orphan*/  M_Size_Display_i_i_i"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_initShowNextLoc",
    "input":"\n0000000000000000 <WI_initShowNextLoc>:\n0: \tmovl\t(%rip), %eax  # 0x6 <WI_initShowNextLoc+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <WI_initShowNextLoc+0xc>\nc: \tmovq\t$0, (%rip)    # 0x17 <WI_initShowNextLoc+0x17>\n17: \tmovl\t(%rip), %eax  # 0x1d <WI_initShowNextLoc+0x1d>\n1d: \timull\t(%rip), %eax  # 0x24 <WI_initShowNextLoc+0x24>\n24: \tmovl\t%eax, (%rip)  # 0x2a <WI_initShowNextLoc+0x2a>\n2a: \txorl\t%eax, %eax\n2c: \tjmp\t0x31 <WI_initShowNextLoc+0x31>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SHOWNEXTLOCDELAY ;\nint /*<<< orphan*/  ShowNextLoc ;\nint TICRATE ;\nint /*<<< orphan*/  WI_initAnimatedBack () ;\nscalar_t__ acceleratestage ;\nint cnt ;\nint /*<<< orphan*/  state ;\n\nvoid WI_initShowNextLoc(void)\n{\nstate = ShowNextLoc;\nacceleratestage = 0;\ncnt = SHOWNEXTLOCDELAY * TICRATE;\n\nWI_initAnimatedBack();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  FALSE ;\nint /*<<< orphan*/  WI_showNextLoc ;\nint /*<<< orphan*/  WI_showNextLoc_last ;\nint /*<<< orphan*/  WI_showNextLoc_last_set ;\nint WI_showNextLoc_max ;\nint WI_showNextLoc_min ;\nint /*<<< orphan*/  WI_showNextLoc_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_last ;\nint /*<<< orphan*/  WI_showNextLoc_set_last_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  WI_showNextLoc_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_EndScreen",
    "input":"\n0000000000000000 <wipe_EndScreen>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%ecx, %r14d\na: \tmovl\t%edx, %r15d\nd: \tmovl\t%esi, %ebx\nf: \tmovl\t%edi, %ebp\n11: \tmovq\t(%rip), %rax  # 0x18 <wipe_EndScreen+0x18>\n18: \tmovl\t12(%rax), %edi\n1b: \tmovl\t%edi, (%rip)  # 0x21 <wipe_EndScreen+0x21>\n21: \tcallq\t0x26 <wipe_EndScreen+0x26>\n26: \tmovl\t(%rip), %r9d  # 0x2d <wipe_EndScreen+0x2d>\n2d: \tmovl\t%ebp, %edi\n2f: \tmovl\t%ebx, %esi\n31: \txorl\t%edx, %edx\n33: \tmovl\t%r15d, %ecx\n36: \tmovl\t%r14d, %r8d\n39: \tcallq\t0x3e <wipe_EndScreen+0x3e>\n3e: \txorl\t%eax, %eax\n40: \taddq\t$8, %rsp\n44: \tpopq\t%rbx\n45: \tpopq\t%r14\n47: \tpopq\t%r15\n49: \tpopq\t%rbp\n4a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ReadScreen (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawBlock (int,int,int /*<<< orphan*/ ,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * screens ;\nint /*<<< orphan*/  wipe_scr_end ;\nint /*<<< orphan*/  wipe_scr_start ;\n\nint\nwipe_EndScreen\n( int\tx,\nint\ty,\nint\twidth,\nint\theight )\n{\nwipe_scr_end = screens[3];\nI_ReadScreen(wipe_scr_end);\nV_DrawBlock(x, y, 0, width, height, wipe_scr_start); // restore start scr.\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  wipe_x; int /*<<< orphan*/  wipe_y; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WIPE_END ;\nint /*<<< orphan*/  WIPE_NONE ;\nint /*<<< orphan*/  WIPE_Y ;\nint /*<<< orphan*/  wipe_Draw (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__* wipe_info ;\n\nint wipe_EndScreen(int x, int y, int w, int h)\n{\nwipe_info->wipe_y = wipe_info->wipe_x;\nwipe_Draw(x, y, 0, w, h, WIPE_END);\n\nwipe_info->wipe_y = WIPE_NONE;\nwipe_Draw(x, y, 0, w, h, WIPE_Y);\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_filelength",
    "input":"\n0000000000000000 <filelength>:\n0: \tpushq\t%rax\n1: \tmovq\t%rsp, %rsi\n4: \tcallq\t0x9 <filelength+0x9>\n9: \tcmpl\t$-1, %eax\nc: \tjne\t0x18 <filelength+0x18>\ne: \tmovl\t$0, %edi\n13: \tcallq\t0x18 <filelength+0x18>\n18: \tmovl\t(%rsp), %eax\n1b: \tpopq\t%rcx\n1c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {int st_size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint fstat (int,struct stat*) ;\n\nint filelength (int handle)\n{\nstruct stat\tfileinfo;\n\nif (fstat (handle,&fileinfo) == -1)\nI_Error (\"Error fstating\");\n\nreturn fileinfo.st_size;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  off_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  perror (char*) ;\nint stat (char const*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static off_t filelength(const char *filename)\n{\nstruct stat statbuf;\n\nif (stat(filename, &statbuf) == -1) {\nperror(\"stat\");\nreturn -1;\n}\nreturn statbuf.st_size;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_ReFire",
    "input":"\n0000000000000000 <A_ReFire>:\n0: \tmovl\t(%rip), %eax  # 0x6 <A_ReFire+0x6>\n6: \ttestl\t%eax, 24(%rdi)\n9: \tje\t0x28 <A_ReFire+0x28>\nb: \tmovq\t(%rdi), %rax\ne: \tcmpq\t(%rip), %rax  # 0x15 <A_ReFire+0x15>\n15: \tjne\t0x28 <A_ReFire+0x28>\n17: \tcmpq\t$0, 16(%rdi)\n1c: \tje\t0x28 <A_ReFire+0x28>\n1e: \taddq\t$1, 8(%rdi)\n23: \tjmp\t0x28 <A_ReFire+0x28>\n28: \tmovq\t$0, 8(%rdi)\n30: \tjmp\t0x35 <A_ReFire+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_6__ {int buttons; } ;\nstruct TYPE_7__ {scalar_t__ pendingweapon; scalar_t__ refire; scalar_t__ health; TYPE_1__ cmd; } ;\ntypedef  TYPE_2__ player_t ;\n\n/* Variables and functions */\nint BT_ATTACK ;\nint /*<<< orphan*/  P_CheckAmmo (TYPE_2__*) ;\nint /*<<< orphan*/  P_FireWeapon (TYPE_2__*) ;\nscalar_t__ wp_nochange ;\n\nvoid A_ReFire\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\n\n// check for fire\n//  (if a weaponchange is pending, let it go through instead)\nif ( (player->cmd.buttons & BT_ATTACK)\n&& player->pendingweapon == wp_nochange\n&& player->health)\n{\nplayer->refire++;\nP_FireWeapon (player);\n}\nelse\n{\nplayer->refire = 0;\nP_CheckAmmo (player);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ type; scalar_t__ state; int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__* PACL ;\ntypedef  int /*<<< orphan*/  PVOID ;\ntypedef  int /*<<< orphan*/  NTSTATUS ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_Fire (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  A_ReFire (TYPE_1__*,int /*<<< orphan*/ ) ;\nscalar_t__ A_TYPE_TIMER ;\nint /*<<< orphan*/  A_TYPE_TIMER_REPEAT ;\n\n__attribute__((used)) static NTSTATUS A_ReFire(PACL Acl, PVOID Data)\n{\nif (Acl->flags & A_TYPE_TIMER_REPEAT)\n{\nif (Acl->type == A_TYPE_TIMER && Acl->state)\n{\nAcl->state++;\n}\n}\nelse\n{\nAcl->state = 0;\n}\n\nreturn A_Fire(Acl, Data);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_DrawMainMenu",
    "input":"\n0000000000000000 <M_DrawMainMenu>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <M_DrawMainMenu+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <M_DrawMainMenu+0x11>\n11: \tmovl\t$94, %edi\n16: \tmovl\t$2, %esi\n1b: \txorl\t%edx, %edx\n1d: \tmovl\t%eax, %ecx\n1f: \tpopq\t%rax\n20: \tjmp\t0x25 <M_DrawMainMenu+0x25>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_CACHE ;\nint /*<<< orphan*/  V_DrawPatchDirect (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  W_CacheLumpName (char*,int /*<<< orphan*/ ) ;\n\nvoid M_DrawMainMenu(void)\n{\nV_DrawPatchDirect (94,2,0,W_CacheLumpName(\"M_DOOM\",PU_CACHE));\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  M_DrawMenu (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  M_DrawMenuText (char*,int) ;\nint /*<<< orphan*/  M_MainMenu ;\n\nvoid M_DrawMainMenu(void)\n{\nM_DrawMenuText(\"Main Menu\", 94);\nM_DrawMenu(94, 2, 0, M_MainMenu);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_system.c_I_Tactile",
    "input":"\n0000000000000000 <I_Tactile>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid\nI_Tactile\n( int\ton,\nint\toff,\nint\ttotal )\n{\n// UNUSED.\non = off = total = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_Tactile(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_data.c_R_InitData",
    "input":"\n0000000000000000 <R_InitData>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <R_InitData+0x8>\n8: \tmovl\t$0, %edi\nd: \tcallq\t0x12 <R_InitData+0x12>\n12: \txorl\t%eax, %eax\n14: \tcallq\t0x19 <R_InitData+0x19>\n19: \tmovl\t$0, %edi\n1e: \tcallq\t0x23 <R_InitData+0x23>\n23: \txorl\t%eax, %eax\n25: \tcallq\t0x2a <R_InitData+0x2a>\n2a: \tmovl\t$0, %edi\n2f: \tcallq\t0x34 <R_InitData+0x34>\n34: \txorl\t%eax, %eax\n36: \tcallq\t0x3b <R_InitData+0x3b>\n3b: \tmovl\t$0, %edi\n40: \tpopq\t%rax\n41: \tjmp\t0x46 <R_InitData+0x46>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_InitColormaps () ;\nint /*<<< orphan*/  R_InitFlats () ;\nint /*<<< orphan*/  R_InitSpriteLumps () ;\nint /*<<< orphan*/  R_InitTextures () ;\nint /*<<< orphan*/  printf (char*) ;\n\nvoid R_InitData (void)\n{\nR_InitTextures ();\nprintf (\"\\nInitTextures\");\nR_InitFlats ();\nprintf (\"\\nInitFlats\");\nR_InitSpriteLumps ();\nprintf (\"\\nInitSprites\");\nR_InitColormaps ();\nprintf (\"\\nInitColormaps\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  R_InitData_Rand () ;\nint /*<<< orphan*/  R_InitData_Time () ;\nint /*<<< orphan*/  R_InitData_User () ;\nint /*<<< orphan*/  R_InitData_Version () ;\nint /*<<< orphan*/  R_InitData_Wall () ;\n\nvoid R_InitData(void)\n{\nR_InitData_Version();\nR_InitData_User();\nR_InitData_Wall();\nR_InitData_Time();\nR_InitData_Rand();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_mobj.c_P_RemoveMobj",
    "input":"\n0000000000000000 <P_RemoveMobj>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t(%rdi), %eax\n6: \ttestl\t%eax, (%rip)  # 0xc <P_RemoveMobj+0xc>\nc: \tje\t0x16 <P_RemoveMobj+0x16>\ne: \ttestl\t%eax, (%rip)  # 0x14 <P_RemoveMobj+0x14>\n14: \tje\t0x2f <P_RemoveMobj+0x2f>\n16: \tmovq\t%rbx, %rdi\n19: \tcallq\t0x1e <P_RemoveMobj+0x1e>\n1e: \tmovq\t%rbx, %rdi\n21: \tcallq\t0x26 <P_RemoveMobj+0x26>\n26: \tmovq\t%rbx, %rdi\n29: \tpopq\t%rbx\n2a: \tjmp\t0x2f <P_RemoveMobj+0x2f>\n2f: \tmovq\t8(%rbx), %rax\n33: \tcmpq\t(%rip), %rax  # 0x3a <P_RemoveMobj+0x3a>\n3a: \tje\t0x16 <P_RemoveMobj+0x16>\n3c: \tcmpq\t(%rip), %rax  # 0x43 <P_RemoveMobj+0x43>\n43: \tje\t0x16 <P_RemoveMobj+0x16>\n45: \tmovl\t16(%rbx), %ecx\n48: \tmovq\t(%rip), %rdx  # 0x4f <P_RemoveMobj+0x4f>\n4f: \tmovq\t(%rip), %rax  # 0x56 <P_RemoveMobj+0x56>\n56: \tmovl\t%ecx, (%rdx,%rax,4)\n59: \tmovl\t(%rip), %ecx  # 0x5f <P_RemoveMobj+0x5f>\n5f: \tmovq\t(%rip), %rdx  # 0x66 <P_RemoveMobj+0x66>\n66: \tmovl\t%ecx, (%rdx,%rax,4)\n69: \taddq\t$1, %rax\n6d: \tmovslq\t(%rip), %rcx  # 0x74 <P_RemoveMobj+0x74>\n74: \taddq\t$-1, %rcx\n78: \tandq\t%rcx, %rax\n7b: \tmovq\t%rax, (%rip)  # 0x82 <P_RemoveMobj+0x82>\n82: \tcmpq\t(%rip), %rax  # 0x89 <P_RemoveMobj+0x89>\n89: \tjne\t0x16 <P_RemoveMobj+0x16>\n8b: \taddq\t$1, %rax\n8f: \tandq\t%rcx, %rax\n92: \tmovq\t%rax, (%rip)  # 0x99 <P_RemoveMobj+0x99>\n99: \tjmp\t0x16 <P_RemoveMobj+0x16>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  thinker_t ;\nstruct TYPE_5__ {int flags; scalar_t__ type; int /*<<< orphan*/  spawnpoint; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint ITEMQUESIZE ;\nint MF_DROPPED ;\nint MF_SPECIAL ;\nscalar_t__ MT_INS ;\nscalar_t__ MT_INV ;\nint /*<<< orphan*/  P_RemoveThinker (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  P_UnsetThingPosition (TYPE_1__*) ;\nint /*<<< orphan*/  S_StopSound (TYPE_1__*) ;\nsize_t iquehead ;\nsize_t iquetail ;\nint /*<<< orphan*/ * itemrespawnque ;\nint /*<<< orphan*/ * itemrespawntime ;\nint /*<<< orphan*/  leveltime ;\n\nvoid P_RemoveMobj (mobj_t* mobj)\n{\nif ((mobj->flags & MF_SPECIAL)\n&& !(mobj->flags & MF_DROPPED)\n&& (mobj->type != MT_INV)\n&& (mobj->type != MT_INS))\n{\nitemrespawnque[iquehead] = mobj->spawnpoint;\nitemrespawntime[iquehead] = leveltime;\niquehead = (iquehead+1)&(ITEMQUESIZE-1);\n\n// lose one off the end?\nif (iquehead == iquetail)\niquetail = (iquetail+1)&(ITEMQUESIZE-1);\n}\n\n// unlink from sector and block lists\nP_UnsetThingPosition (mobj);\n\n// stop any playing sound\nS_StopSound (mobj);\n\n// free block\nP_RemoveThinker ((thinker_t*)mobj);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int flags; int /*<<< orphan*/  type; int /*<<< orphan*/  sector; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MF_SHADOW ;\nint /*<<< orphan*/  MF_SKULLFLY ;\nint /*<<< orphan*/  MF_SPECIAL ;\nint /*<<< orphan*/  MF_SPAWNCEILING ;\nint /*<<< orphan*/  MF_SPAWNFLOOR ;\nint /*<<< orphan*/  MF_TRANSSHADOW ;\nint /*<<< orphan*/  MF_TRANSSKY ;\nint /*<<< orphan*/  MF_TRANSSPRITE ;\nint /*<<< orphan*/  MF_TRANSTARGET ;\nint /*<<< orphan*/  MF_TRANSTELE ;\nint /*<<< orphan*/  MF_TRANSTELEPORT ;\nint /*<<< orphan*/  MF_TRANSTRIGGER ;\nint /*<<< orphan*/  MF_TRANSTRIGGERNOMESSAGE ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLY ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE2 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE3 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE4 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE5 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE6 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE7 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE8 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE9 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE10 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE11 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE12 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE13 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE14 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE15 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE16 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE17 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE18 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE19 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE20 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE21 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE22 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE23 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE24 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE25 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE26 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE27 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE28 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE29 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE30 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE31 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE32 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE33 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE34 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE35 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE36 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE37 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE38 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE39 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE40 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE41 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE42 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE43 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE44 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE45 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE46 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE47 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE48 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE49 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE50 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE51 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE52 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE53 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE54 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE55 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE56 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE57 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE58 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE59 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE60 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE61 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE62 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE63 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE64 ;\nint /*<<< orphan*/  MF_TRANSTRIGGERONLYNOMESSAGE65 ;\nint /*"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_g_game.c_G_RecordDemo",
    "input":"\n0000000000000000 <G_RecordDemo>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rsi\n4: \tmovl\t$0, (%rip)    # 0xe <G_RecordDemo+0xe>\ne: \tmovl\t(%rip), %edi  # 0x14 <G_RecordDemo+0x14>\n14: \tcallq\t0x19 <G_RecordDemo+0x19>\n19: \tmovl\t(%rip), %edi  # 0x1f <G_RecordDemo+0x1f>\n1f: \tmovl\t$0, %esi\n24: \tcallq\t0x29 <G_RecordDemo+0x29>\n29: \tmovl\t$0, %edi\n2e: \tcallq\t0x33 <G_RecordDemo+0x33>\n33: \tmovl\t$131072, %ebx # imm = 0x20000\n38: \ttestl\t%eax, %eax\n3a: \tje\t0x60 <G_RecordDemo+0x60>\n3c: \tmovl\t(%rip), %ecx  # 0x42 <G_RecordDemo+0x42>\n42: \taddl\t$-1, %ecx\n45: \tcmpl\t%ecx, %eax\n47: \tjge\t0x60 <G_RecordDemo+0x60>\n49: \tmovq\t(%rip), %rcx  # 0x50 <G_RecordDemo+0x50>\n50: \tcltq\n52: \tmovl\t4(%rcx,%rax,4), %edi\n56: \tcallq\t0x5b <G_RecordDemo+0x5b>\n5b: \tmovl\t%eax, %ebx\n5d: \tshll\t$10, %ebx\n60: \tmovl\t(%rip), %esi  # 0x66 <G_RecordDemo+0x66>\n66: \tmovl\t%ebx, %edi\n68: \txorl\t%edx, %edx\n6a: \tcallq\t0x6f <G_RecordDemo+0x6f>\n6f: \tmovq\t%rax, (%rip)  # 0x76 <G_RecordDemo+0x76>\n76: \tmovslq\t%ebx, %rcx\n79: \taddq\t%rax, %rcx\n7c: \tmovq\t%rcx, (%rip)  # 0x83 <G_RecordDemo+0x83>\n83: \tmovl\t$1, (%rip)    # 0x8d <G_RecordDemo+0x8d>\n8d: \tpopq\t%rbx\n8e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint M_CheckParm (char*) ;\nint /*<<< orphan*/  PU_STATIC ;\nscalar_t__ Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint atoi (int /*<<< orphan*/ ) ;\nscalar_t__ demobuffer ;\nscalar_t__ demoend ;\nint /*<<< orphan*/  demoname ;\nint demorecording ;\nint myargc ;\nint /*<<< orphan*/ * myargv ;\nint /*<<< orphan*/  strcat (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  strcpy (int /*<<< orphan*/ ,char*) ;\nint usergame ;\n\nvoid G_RecordDemo (char* name)\n{\nint             i;\nint\t\t\t\tmaxsize;\n\nusergame = false;\nstrcpy (demoname, name);\nstrcat (demoname, \".lmp\");\nmaxsize = 0x20000;\ni = M_CheckParm (\"-maxdemo\");\nif (i && i<myargc-1)\nmaxsize = atoi(myargv[i+1])*1024;\ndemobuffer = Z_Malloc (maxsize,PU_STATIC,NULL);\ndemoend = demobuffer + maxsize;\n\ndemorecording = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  lumpname; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  DEMO_HEADER_LUMP ;\nint /*<<< orphan*/  DEMO_HEADER_SIZE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_NUMBER ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_LITTLE ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET ;\nint /*<<< orphan*/  DEMO_HEADER_VERSION_STRING_SIZE_WAD_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_SWAP_NET_LITTLE ;\nint"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_st_lib.c_STlib_updateBinIcon",
    "input":"\n0000000000000000 <STlib_updateBinIcon>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t32(%rdi), %rax\nf: \tcmpq\t$0, (%rax)\n13: \tje\t0xdd <STlib_updateBinIcon+0xdd>\n19: \tmovq\t%rdi, %rbx\n1c: \ttestq\t%rsi, %rsi\n1f: \tjne\t0x31 <STlib_updateBinIcon+0x31>\n21: \tmovq\t8(%rbx), %rax\n25: \tmovq\t(%rax), %rax\n28: \tcmpq\t%rax, (%rbx)\n2b: \tje\t0xdd <STlib_updateBinIcon+0xdd>\n31: \tmovl\t16(%rbx), %r13d\n35: \tmovq\t24(%rbx), %rax\n39: \tmovl\t12(%rax), %edi\n3c: \tcallq\t0x41 <STlib_updateBinIcon+0x41>\n41: \tmovl\t%eax, %r14d\n44: \tmovl\t20(%rbx), %ebp\n47: \tmovq\t24(%rbx), %rax\n4b: \tmovl\t8(%rax), %edi\n4e: \tcallq\t0x53 <STlib_updateBinIcon+0x53>\n53: \tsubl\t%eax, %ebp\n55: \tmovq\t24(%rbx), %rax\n59: \tmovl\t4(%rax), %edi\n5c: \tcallq\t0x61 <STlib_updateBinIcon+0x61>\n61: \tmovl\t%eax, %r15d\n64: \tmovq\t24(%rbx), %rax\n68: \tmovl\t(%rax), %edi\n6a: \tcallq\t0x6f <STlib_updateBinIcon+0x6f>\n6f: \tmovl\t%eax, %r12d\n72: \tcmpl\t(%rip), %ebp  # 0x78 <STlib_updateBinIcon+0x78>\n78: \tjge\t0x84 <STlib_updateBinIcon+0x84>\n7a: \tmovl\t$0, %edi\n7f: \tcallq\t0x84 <STlib_updateBinIcon+0x84>\n84: \tmovq\t8(%rbx), %rax\n88: \tcmpq\t$0, (%rax)\n8c: \tje\t0xa5 <STlib_updateBinIcon+0xa5>\n8e: \tmovl\t16(%rbx), %edi\n91: \tmovl\t20(%rbx), %esi\n94: \tmovl\t(%rip), %edx  # 0x9a <STlib_updateBinIcon+0x9a>\n9a: \tmovq\t24(%rbx), %rcx\n9e: \tcallq\t0xa3 <STlib_updateBinIcon+0xa3>\na3: \tjmp\t0xd3 <STlib_updateBinIcon+0xd3>\na5: \tsubl\t%r14d, %r13d\na8: \tmovl\t%ebp, %esi\naa: \tsubl\t(%rip), %esi  # 0xb0 <STlib_updateBinIcon+0xb0>\nb0: \tmovl\t(%rip), %edx  # 0xb6 <STlib_updateBinIcon+0xb6>\nb6: \tmovl\t(%rip), %eax  # 0xbc <STlib_updateBinIcon+0xbc>\nbc: \tmovl\t%r13d, %edi\nbf: \tmovl\t%r15d, %ecx\nc2: \tmovl\t%r12d, %r8d\nc5: \tmovl\t%r13d, %r9d\nc8: \tpushq\t%rax\nc9: \tpushq\t%rbp\nca: \tcallq\t0xcf <STlib_updateBinIcon+0xcf>\ncf: \taddq\t$16, %rsp\nd3: \tmovq\t8(%rbx), %rax\nd7: \tmovq\t(%rax), %rax\nda: \tmovq\t%rax, (%rbx)\ndd: \taddq\t$8, %rsp\ne1: \tpopq\t%rbx\ne2: \tpopq\t%r12\ne4: \tpopq\t%r13\ne6: \tpopq\t%r14\ne8: \tpopq\t%r15\nea: \tpopq\t%rbp\neb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ oldval; scalar_t__* val; int x; int y; TYPE_2__* p; scalar_t__* on; } ;\ntypedef  TYPE_1__ st_binicon_t ;\ntypedef  scalar_t__ boolean ;\nstruct TYPE_5__ {int /*<<< orphan*/  height; int /*<<< orphan*/  width; int /*<<< orphan*/  topoffset; int /*<<< orphan*/  leftoffset; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BG ;\nint /*<<< orphan*/  FG ;\nint /*<<< orphan*/  I_Error (char*) ;\nint SHORT (int /*<<< orphan*/ ) ;\nint ST_Y ;\nint /*<<< orphan*/  V_CopyRect (int,int,int /*<<< orphan*/ ,int,int,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  V_DrawPatch (int,int,int /*<<< orphan*/ ,TYPE_2__*) ;\n\nvoid\nSTlib_updateBinIcon\n( st_binicon_t*\t\tbi,\nboolean\t\trefresh )\n{\nint\t\t\tx;\nint\t\t\ty;\nint\t\t\tw;\nint\t\t\th;\n\nif (*bi->on\n&& (bi->oldval != *bi->val || refresh))\n{\nx = bi->x - SHORT(bi->p->leftoffset);\ny = bi->y - SHORT(bi->p->topoffset);\nw = SHORT(bi->p->width);\nh = SHORT(bi->p->height);\n\nif (y - ST_Y < 0)\nI_Error(\"updateBinIcon: y - ST_Y < 0\");\n\nif (*bi->val)\nV_DrawPatch(bi->x, bi->y, FG, bi->p);\nelse\nV_CopyRect(x, y-ST_Y, BG, w, h, x, y, FG);\n\nbi->oldval = *bi->val;\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ hIcon; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  hWnd; TYPE_4__* pIcon; int /*<<< orphan*/  hInst; int /*<<< orphan*/  hModule; TYPE_2__* pClass; } ;\nstruct TYPE_8__ {TYPE_1__* pIcon; } ;\nstruct TYPE_7__ {scalar_t__ hIcon; } ;\ntypedef  TYPE_3__ STLBDATA ;\ntypedef  int /*<<< orphan*/  HICON ;\ntypedef  int /*<<< orphan*/  HINSTANCE ;\ntypedef  int /*<<< orphan*/  HWND ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GetSystemMetrics (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  IDI_APPLICATION ;\nint /*<<< orphan*/  IDI_STANDARD ;\nint /*<<< orphan*/  IMAGE_ICON ;\nint /*<<< orphan*/  LoadImageA (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  LoadIconMetric (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  LoadLibraryA (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  MAKEINTRESOURCEA (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SNDMSG (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  STLB_SETICON ;\nint /*<<< orphan*/  TRACE (char*) ;\n\n__attribute__((used)) static void STlib_updateBinIcon(STLBDATA *data, HWND hWnd)\n{\nHICON hIcon;\nHINSTANCE hInst;\n\nif (data->pIcon->hIcon)\n{\nif (hWnd != data->pClass->hWnd || data->pIcon->hIcon != data->pClass->pIcon->hIcon)\n{\nhInst = data->hInst;\nhIcon = LoadIconMetric(hInst, IDI_STANDARD,\nGetSystemMetrics(SM_CXICON) - GetSystemMetrics(SM_CXSMICON));\nif (hIcon)\n{\nSNDMSG(hWnd, STLB_SETICON, (WPARAM)hIcon, 0);\n}\nelse\n{\nTRACE(\"Couldn't load icon\\n\");\n}\n}\n}\nelse\n{\nhInst = LoadLibraryA(data->hModule);\nhIcon = LoadImageA(hInst, MAKEINTRESOURCEA(IDI_APPLICATION),\nIMAGE_ICON,\nGetSystemMetrics(SM_CXICON) - GetSystemMetrics(SM_CXSMICON),\nGetSystemMetrics(SM_CYICON) - GetSystemMetrics(SM_CYSMICON),\n0);\nif (hIcon)\n{\nSNDMSG(hWnd, STLB_SETICON, (WPARAM)hIcon, 0);\n}\nelse\n{\nTRACE(\"Couldn't load icon\\n\");\n}\n}\ndata->pClass->pIcon->hIcon = data->pIcon->hIcon;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_pspr.c_A_FirePlasma",
    "input":"\n0000000000000000 <A_FirePlasma>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdi, %rbx\n7: \tmovq\t(%rdi), %rax\na: \tmovq\t16(%rdi), %rcx\ne: \tmovq\t(%rip), %rdx  # 0x15 <A_FirePlasma+0x15>\n15: \tshlq\t$4, %rax\n19: \tmovq\t(%rdx,%rax), %rsi\n1d: \taddl\t$-1, (%rcx,%rsi,4)\n21: \tmovl\t(%rip), %r14d # 0x28 <A_FirePlasma+0x28>\n28: \tmovq\t8(%rdx,%rax), %rbp\n2d: \txorl\t%eax, %eax\n2f: \tcallq\t0x34 <A_FirePlasma+0x34>\n34: \tandl\t$1, %eax\n37: \taddq\t%rax, %rbp\n3a: \tmovq\t%rbx, %rdi\n3d: \tmovl\t%r14d, %esi\n40: \tmovq\t%rbp, %rdx\n43: \tcallq\t0x48 <A_FirePlasma+0x48>\n48: \tmovl\t8(%rbx), %edi\n4b: \tmovl\t(%rip), %esi  # 0x51 <A_FirePlasma+0x51>\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tpopq\t%rbp\n55: \tjmp\t0x5a <A_FirePlasma+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  pspdef_t ;\nstruct TYPE_5__ {size_t readyweapon; int /*<<< orphan*/  mo; int /*<<< orphan*/ * ammo; } ;\ntypedef  TYPE_1__ player_t ;\nstruct TYPE_6__ {size_t ammo; scalar_t__ flashstate; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MT_PLASMA ;\nint P_Random () ;\nint /*<<< orphan*/  P_SetPsprite (TYPE_1__*,int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  P_SpawnPlayerMissile (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ps_flash ;\nTYPE_2__* weaponinfo ;\n\nvoid\nA_FirePlasma\n( player_t*\tplayer,\npspdef_t*\tpsp )\n{\nplayer->ammo[weaponinfo[player->readyweapon].ammo]--;\n\nP_SetPsprite (player,\nps_flash,\nweaponinfo[player->readyweapon].flashstate+(P_Random ()&1) );\n\nP_SpawnPlayerMissile (player->mo, MT_PLASMA);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  x; int /*<<< orphan*/  y; TYPE_1__* act; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  act_flags; int /*<<< orphan*/ * act_number; } ;\ntypedef  TYPE_2__ Actor ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ACTOR_FLAGS_BUSY ;\nint /*<<< orphan*/  ACTOR_FLAGS_BUSY_ALWAYS ;\nint /*<<< orphan*/  ACTOR_FLAGS_BUSY_ALWAYS_NO_SHOOT ;\nint /*<<< orphan*/  A_FirePlasma_1 ;\nint /*<<< orphan*/  A_FirePlasma_2 ;\nint /*<<< orphan*/  A_FirePlasma_3 ;\nint /*<<< orphan*/  A_FirePlasma_4 ;\nint /*<<< orphan*/  A_FirePlasma_5 ;\nint /*<<< orphan*/  A_FirePlasma_6 ;\nint /*<<< orphan*/  A_FirePlasma_7 ;\nint /*<<< orphan*/  A_FirePlasma_8 ;\nint /*<<< orphan*/  A_FirePlasma_9 ;\nint /*<<< orphan*/  A_FirePlasma_10 ;\nint /*<<< orphan*/  A_FirePlasma_11 ;\nint /*<<< orphan*/  A_FirePlasma_12 ;\nint /*<<< orphan*/  A_FirePlasma_13 ;\nint /*<<< orphan*/  A_FirePlasma_14 ;\nint /*<<< orphan*/  A_FirePlasma_15 ;\nint /*<<< orphan*/  A_FirePlasma_16 ;\nint /*<<< orphan*/  A_FirePlasma_17 ;\nint /*<<< orphan*/  A_FirePlasma_18 ;\nint /*<<< orphan*/  A_FirePlasma_19 ;\nint /*<<< orphan*/  A_FirePlasma_20 ;\nint /*<<< orphan*/  A_FirePlasma_21 ;\nint /*<<< orphan*/  A_FirePlasma_22 ;\nint /*<<< orphan*/  A_FirePlasma_23 ;\nint /*<<< orphan*/  A_FirePlasma_24 ;\nint /*<<< orphan*/  A_FirePlasma_25 ;\nint /*<<< orphan*/  A_FirePlasma_26 ;\nint /*<<< orphan*/  A_FirePlasma_27 ;\nint /*<<< orphan*/  A_FirePlasma_28 ;\nint /*<<< orphan*/  A_FirePlasma_29 ;\nint /*<<< orphan*/  A_FirePlasma_30 ;\nint /*<<< orphan*/  A_FirePlasma_31 ;\nint /*<<< orphan*/  A_FirePlasma_32 ;\nint /*<<< orphan*/  A_FirePlasma_33 ;\nint /*<<< orphan*/  A_FirePlasma_34 ;\nint /*<<< orphan*/  A_FirePlasma_35 ;\nint /*<<< orphan*/  A_FirePlasma_36 ;\nint /*<<< orphan*/  A_FirePlasma_37 ;\nint /*<<< orphan*/  A_FirePlasma_38 ;\nint /*<<< orphan*/  A_FirePlasma_39 ;\nint /*<<< orphan*/  A_FirePlasma_40 ;\nint /*<<< orphan*/  A_FirePlasma_41 ;\nint /*<<< orphan*/  A_FirePlasma_42 ;\nint /*<<< orphan*/  A_FirePlasma_43 ;\nint /*<<< orphan*/  A_FirePlasma_44 ;\nint /*<<< orphan*/  A_FirePlasma_45 ;\nint /*<<< orphan*/  A_FirePlasma_46 ;\nint /*<<< orphan*/  A_FirePlasma_47 ;\nint /*<<< orphan*/  A_FirePlasma_48 ;\nint /*<<< orphan*/  A_FirePlasma_49 ;\nint /*<<< orphan*/  A_FirePlasma_50 ;\nint /*<<< orphan*/  A_FirePlasma_51 ;\nint /*<<< orphan*/  A_FirePlasma_52 ;\nint /*<<< orphan*/  A_FirePlasma_53 ;\nint /*<<< orphan*/  A_FirePlasma_54 ;\nint /*<<< orphan*/  A_FirePlasma_55 ;\nint /*<<< orphan*/  A_FirePlasma_56 ;\nint /*<<< orphan*/  A_FirePlasma_57 ;\nint /*<<< orphan*/  A_FirePlasma_58 ;\nint /*<<< orphan*/  A_FirePlasma_59 ;\nint /*<<< orphan*/  A_FirePlasma_60 ;\nint /*<<< orphan*/  A_FirePlasma_61 ;\nint /*<<< orphan*/  A_FirePlasma_62 ;\nint /*<<< orphan*/  A_FirePlasma_63 ;\nint /*<<< orphan*/  A_FirePlasma_64 ;\nint /*<<< orphan*/  A_FirePlasma_65 ;\nint /*<<< orphan*/  A_FirePlasma_66 ;\nint /*<<< orphan*/  A_FirePlasma_67 ;\nint /*<<< orphan*/  A_FirePlasma_68 ;\nint /*<<< orphan*/  A_FirePlasma_69 ;\nint /*<<< orphan*/  A_FirePlasma_70 ;\nint /*<<< orphan*/  A_FirePlasma_71 ;\nint /*<<< orphan*/  A_FirePlasma_72 ;\nint /*<<< orphan*/  A_FirePlasma_73 ;\nint /*<<< orphan*/  A_FirePlasma_74 ;\nint /*<<< orphan*/  A_FirePlasma_75 ;\nint /*<<< orphan*/  A_FirePlasma_76 ;\nint /*<<< orphan*/  A_FirePlasma_77 ;\nint /*<<< orphan*/  A_FirePlasma_78 ;\nint /*<<< orphan*/  A_FirePlasma_79 ;\nint /*<<< orphan*/  A_FirePlasma_80 ;\nint /*<<< orphan*/  A_FirePlasma_81 ;\nint /*<<< orphan*/  A_FirePlasma_82 ;\nint /*<<< orphan*/  A_FirePlasma_83 ;\nint /*<<< orphan*/  A_FirePlasma_84 ;\nint /*<<< orphan*/  A_FirePlasma_85 ;\nint /*<<< orphan*/  A_FirePlasma_86 ;\nint /*<<< orphan*/  A_FirePlasma_87 ;\nint /*<<< orphan*/  A_FirePlasma_88 ;\nint /*<<< orphan*/  A_FirePlasma_89 ;\nint /*<<< orphan*/  A_FirePlasma_90 ;\nint /*<<< orphan*/  A_FirePlasma_91 ;\nint /*<<< orphan*/  A_FirePlasma_92 ;\nint /*<<< orphan*/  A_FirePlasma_93 ;\nint /*<<< orphan*/  A_FirePlasma_94 ;\nint /*<<< orphan*/  A_FirePlasma_95 ;\nint /*<<< orphan*/  A_FirePlasma_96 ;\nint /*<<< orphan*/  A_FirePlasma_97 ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_updateNoState",
    "input":"\n0000000000000000 <WI_updateNoState>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <WI_updateNoState+0x8>\n8: \taddl\t$-1, (%rip)   # 0xf <WI_updateNoState+0xf>\nf: \tje\t0x13 <WI_updateNoState+0x13>\n11: \tpopq\t%rax\n12: \tretq\n13: \txorl\t%eax, %eax\n15: \tcallq\t0x1a <WI_updateNoState+0x1a>\n1a: \txorl\t%eax, %eax\n1c: \tpopq\t%rcx\n1d: \tjmp\t0x22 <WI_updateNoState+0x22>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  G_WorldDone () ;\nint /*<<< orphan*/  WI_End () ;\nint /*<<< orphan*/  WI_updateAnimatedBack () ;\nint /*<<< orphan*/  cnt ;\n\nvoid WI_updateNoState(void) {\n\nWI_updateAnimatedBack();\n\nif (!--cnt)\n{\nWI_End();\nG_WorldDone();\n}\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WResInfo ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_updateState (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  WI_updateState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState () ;\nint /*<<< orphan*/  WI_updateState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState_NoState"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_wi_stuff.c_WI_drawShowNextLoc",
    "input":"\n0000000000000000 <WI_drawShowNextLoc>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <WI_drawShowNextLoc+0xa>\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <WI_drawShowNextLoc+0x11>\n11: \tmovq\t(%rip), %rax  # 0x18 <WI_drawShowNextLoc+0x18>\n18: \tcmpq\t(%rip), %rax  # 0x1f <WI_drawShowNextLoc+0x1f>\n1f: \tje\t0xa0 <WI_drawShowNextLoc+0xa0>\n21: \tmovq\t(%rip), %rax  # 0x28 <WI_drawShowNextLoc+0x28>\n28: \tcmpl\t$2, (%rax)\n2b: \tjg\t0xc4 <WI_drawShowNextLoc+0xc4>\n31: \tmovl\t4(%rax), %ebp\n34: \tcmpl\t$8, %ebp\n37: \tjne\t0x3f <WI_drawShowNextLoc+0x3f>\n39: \tmovl\t8(%rax), %ebp\n3c: \taddl\t$-1, %ebp\n3f: \ttestl\t%ebp, %ebp\n41: \tjs\t0x6a <WI_drawShowNextLoc+0x6a>\n43: \taddl\t$1, %ebp\n46: \txorl\t%ebx, %ebx\n48: \tnopl\t(%rax,%rax)\n50: \tmovl\t$0, %esi\n55: \tmovl\t%ebx, %edi\n57: \tcallq\t0x5c <WI_drawShowNextLoc+0x5c>\n5c: \taddl\t$1, %ebx\n5f: \tcmpl\t%ebx, %ebp\n61: \tjne\t0x50 <WI_drawShowNextLoc+0x50>\n63: \tmovq\t(%rip), %rax  # 0x6a <WI_drawShowNextLoc+0x6a>\n6a: \tcmpq\t$0, 16(%rax)\n6f: \tje\t0x80 <WI_drawShowNextLoc+0x80>\n71: \tmovl\t$0, %esi\n76: \tmovl\t$8, %edi\n7b: \tcallq\t0x80 <WI_drawShowNextLoc+0x80>\n80: \tcmpq\t$0, (%rip)    # 0x88 <WI_drawShowNextLoc+0x88>\n88: \tje\t0xa0 <WI_drawShowNextLoc+0xa0>\n8a: \tmovq\t(%rip), %rax  # 0x91 <WI_drawShowNextLoc+0x91>\n91: \tmovl\t8(%rax), %edi\n94: \tmovq\t(%rip), %rsi  # 0x9b <WI_drawShowNextLoc+0x9b>\n9b: \tcallq\t0xa0 <WI_drawShowNextLoc+0xa0>\na0: \tmovq\t(%rip), %rax  # 0xa7 <WI_drawShowNextLoc+0xa7>\na7: \tcmpq\t(%rip), %rax  # 0xae <WI_drawShowNextLoc+0xae>\nae: \tjne\t0xc4 <WI_drawShowNextLoc+0xc4>\nb0: \tmovq\t(%rip), %rax  # 0xb7 <WI_drawShowNextLoc+0xb7>\nb7: \tcmpl\t$30, 8(%rax)\nbb: \tjne\t0xc4 <WI_drawShowNextLoc+0xc4>\nbd: \taddq\t$8, %rsp\nc1: \tpopq\t%rbx\nc2: \tpopq\t%rbp\nc3: \tretq\nc4: \txorl\t%eax, %eax\nc6: \taddq\t$8, %rsp\nca: \tpopq\t%rbx\ncb: \tpopq\t%rbp\ncc: \tjmp\t0xd1 <WI_drawShowNextLoc+0xd1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int epsd; int last; int next; scalar_t__ didsecret; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WI_drawAnimatedBack () ;\nint /*<<< orphan*/  WI_drawEL () ;\nint /*<<< orphan*/  WI_drawOnLnode (int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  WI_slamBackground () ;\nscalar_t__ commercial ;\nscalar_t__ gamemode ;\nscalar_t__ snl_pointeron ;\nint /*<<< orphan*/  splat ;\nTYPE_1__* wbs ;\nint /*<<< orphan*/ * yah ;\n\nvoid WI_drawShowNextLoc(void)\n{\n\nint\t\ti;\nint\t\tlast;\n\nWI_slamBackground();\n\n// draw animated background\nWI_drawAnimatedBack();\n\nif ( gamemode != commercial)\n{\nif (wbs->epsd > 2)\n{\nWI_drawEL();\nreturn;\n}\n\nlast = (wbs->last == 8) ? wbs->next - 1 : wbs->last;\n\n// draw a splat on taken cities.\nfor (i=0 ; i<=last ; i++)\nWI_drawOnLnode(i, &splat);\n\n// splat the secret level?\nif (wbs->didsecret)\nWI_drawOnLnode(8, &splat);\n\n// draw flashing ptr\nif (snl_pointeron)\nWI_drawOnLnode(wbs->next, yah);\n}\n\n// draws which level you are entering..\nif ( (gamemode != commercial)\n|| wbs->next != 30)\nWI_drawEL();\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int show_next_loc; int show_next_loc_len; int show_next_loc_pos; scalar_t__ show_next_loc_x; scalar_t__ show_next_loc_y; } ;\n\n/* Variables and functions */\nTYPE_1__* WI ;\nscalar_t__ WI_drawShowNextLoc_draw_next_loc ;\nscalar_t__ WI_drawShowNextLoc_draw_next_loc_x ;\nscalar_t__ WI_drawShowNextLoc_draw_next_loc_y ;\nscalar_t__ WI_drawShowNextLoc_draw_next_loc_y_end ;\nscalar_t__ WI_drawShowNextLoc_draw_next_loc_y_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_start ;\nint /*<<< orphan*/  WI_drawShowNextLoc_draw_next_loc_y_start_start_start_start_start_start_start_start_start_start_start_start_end ;\nint /*<<< orphan*/  W"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_misc.c_M_ReadFile",
    "input":"\n0000000000000000 <M_ReadFile>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rsi, %r14\ne: \tmovq\t%rdi, %r15\n11: \tmovl\t(%rip), %esi  # 0x17 <M_ReadFile+0x17>\n17: \torl\t(%rip), %esi  # 0x1d <M_ReadFile+0x1d>\n1d: \tmovl\t$438, %edx    # imm = 0x1B6\n22: \tcallq\t0x27 <M_ReadFile+0x27>\n27: \tmovl\t%eax, %r13d\n2a: \tcmpl\t$-1, %eax\n2d: \tjne\t0x3c <M_ReadFile+0x3c>\n2f: \tmovl\t$0, %edi\n34: \tmovq\t%r15, %rsi\n37: \tcallq\t0x3c <M_ReadFile+0x3c>\n3c: \tmovq\t%rsp, %rsi\n3f: \tmovl\t%r13d, %edi\n42: \tcallq\t0x47 <M_ReadFile+0x47>\n47: \tcmpl\t$-1, %eax\n4a: \tjne\t0x59 <M_ReadFile+0x59>\n4c: \tmovl\t$0, %edi\n51: \tmovq\t%r15, %rsi\n54: \tcallq\t0x59 <M_ReadFile+0x59>\n59: \tmovl\t(%rsp), %ebx\n5c: \tmovl\t(%rip), %esi  # 0x62 <M_ReadFile+0x62>\n62: \tmovl\t%ebx, %edi\n64: \txorl\t%edx, %edx\n66: \tcallq\t0x6b <M_ReadFile+0x6b>\n6b: \tmovq\t%rax, %r12\n6e: \tmovl\t%r13d, %edi\n71: \tmovq\t%rax, %rsi\n74: \tmovl\t%ebx, %edx\n76: \tcallq\t0x7b <M_ReadFile+0x7b>\n7b: \tmovl\t%eax, %ebp\n7d: \tmovl\t%r13d, %edi\n80: \tcallq\t0x85 <M_ReadFile+0x85>\n85: \tcmpl\t%ebx, %ebp\n87: \tjge\t0x96 <M_ReadFile+0x96>\n89: \tmovl\t$0, %edi\n8e: \tmovq\t%r15, %rsi\n91: \tcallq\t0x96 <M_ReadFile+0x96>\n96: \tmovq\t%r12, (%r14)\n99: \tmovl\t%ebx, %eax\n9b: \taddq\t$8, %rsp\n9f: \tpopq\t%rbx\na0: \tpopq\t%r12\na2: \tpopq\t%r13\na4: \tpopq\t%r14\na6: \tpopq\t%r15\na8: \tpopq\t%rbp\na9: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {int st_size; } ;\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*,char const*) ;\nint O_BINARY ;\nint O_RDONLY ;\nint /*<<< orphan*/  PU_STATIC ;\nint /*<<< orphan*/ * Z_Malloc (int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  close (int) ;\nint fstat (int,struct stat*) ;\nint open (char const*,int,int) ;\nint read (int,int /*<<< orphan*/ *,int) ;\n\nint\nM_ReadFile\n( char const*\tname,\nbyte**\tbuffer )\n{\nint\thandle, count, length;\nstruct stat\tfileinfo;\nbyte\t\t*buf;\n\nhandle = open (name, O_RDONLY | O_BINARY, 0666);\nif (handle == -1)\nI_Error (\"Couldn't read file %s\", name);\nif (fstat (handle,&fileinfo) == -1)\nI_Error (\"Couldn't read file %s\", name);\nlength = fileinfo.st_size;\nbuf = Z_Malloc (length, PU_STATIC, NULL);\ncount = read (handle, buf, length);\nclose (handle);\n\nif (count < length)\nI_Error (\"Couldn't read file %s\", name);\n\n*buffer = buf;\nreturn length;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint O_BINARY ;\nint O_RDONLY ;\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*,char const*) ;\nint /*<<< orphan*/  fread (void*,int,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fseek (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ftell (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char const*,char*) ;\nint /*<<< orphan*/  stderr ;\n\nint M_ReadFile(const char *filename, void **data)\n{\nFILE *f;\nint size;\n\nf = fopen(filename, \"rb\");\nif (f == NULL)\n{\nfprintf(stderr, \"Error opening file %s\\n\", filename);\nreturn -1;\n}\n\nfseek(f, 0, SEEK_END);\nsize = ftell(f);\nfseek(f, 0, SEEK_SET);\n\n*data = malloc(size);\nif (*data == NULL)\n{\nfprintf(stderr, \"Error allocating memory for file %s\\n\", filename);\nreturn -1;\n}\n\nif (fread(*data, 1, size, f) != size)\n{\nfprintf(stderr, \"Error reading file %s\\n\", filename);\nreturn -1;\n}\n\nfclose(f);\n\nreturn size;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_cheat.c_cht_CheckCheat",
    "input":"\n0000000000000000 <cht_CheckCheat>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%esi, %r14d\n7: \tmovq\t%rdi, %rbx\na: \tcmpq\t$0, (%rip)    # 0x12 <cht_CheckCheat+0x12>\n12: \tje\t0x4e <cht_CheckCheat+0x4e>\n14: \tmovq\t$0, (%rip)    # 0x1f <cht_CheckCheat+0x1f>\n1f: \txorl\t%ebp, %ebp\n21: \tnopw\t%cs:(%rax,%rax)\n2b: \tnopl\t(%rax,%rax)\n30: \tmovl\t%ebp, %edi\n32: \tcallq\t0x37 <cht_CheckCheat+0x37>\n37: \tmovq\t(%rip), %rcx  # 0x3e <cht_CheckCheat+0x3e>\n3e: \tmovl\t%eax, (%rcx,%rbp,4)\n41: \taddq\t$1, %rbp\n45: \tcmpq\t$256, %rbp    # imm = 0x100\n4c: \tjne\t0x30 <cht_CheckCheat+0x30>\n4e: \tmovq\t(%rbx), %rax\n51: \ttestq\t%rax, %rax\n54: \tjne\t0x5d <cht_CheckCheat+0x5d>\n56: \tmovq\t8(%rbx), %rax\n5a: \tmovq\t%rax, (%rbx)\n5d: \tmovl\t(%rax), %ecx\n5f: \ttestl\t%ecx, %ecx\n61: \tje\t0x7f <cht_CheckCheat+0x7f>\n63: \tmovq\t(%rip), %rdx  # 0x6a <cht_CheckCheat+0x6a>\n6a: \tmovzbl\t%r14b, %esi\n6e: \tcmpl\t%ecx, (%rdx,%rsi,4)\n71: \tjne\t0x8e <cht_CheckCheat+0x8e>\n73: \taddq\t$4, %rax\n77: \tmovq\t%rax, (%rbx)\n7a: \tmovq\t%rax, %rcx\n7d: \tjmp\t0x95 <cht_CheckCheat+0x95>\n7f: \tmovsbl\t%r14b, %edx\n83: \tleaq\t4(%rax), %rcx\n87: \tmovq\t%rcx, (%rbx)\n8a: \tmovl\t%edx, (%rax)\n8c: \tjmp\t0x95 <cht_CheckCheat+0x95>\n8e: \tmovq\t8(%rbx), %rcx\n92: \tmovq\t%rcx, (%rbx)\n95: \tmovl\t(%rcx), %edx\n97: \tcmpl\t$255, %edx\n9d: \tje\t0xaf <cht_CheckCheat+0xaf>\n9f: \txorl\t%eax, %eax\na1: \tcmpl\t$1, %edx\na4: \tjne\t0xbb <cht_CheckCheat+0xbb>\na6: \taddq\t$4, %rcx\naa: \tmovq\t%rcx, (%rbx)\nad: \tjmp\t0xbb <cht_CheckCheat+0xbb>\naf: \tmovq\t8(%rbx), %rax\nb3: \tmovq\t%rax, (%rbx)\nb6: \tmovl\t$1, %eax\nbb: \tpopq\t%rbx\nbc: \tpopq\t%r14\nbe: \tpopq\t%rbp\nbf: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* p; int* sequence; } ;\ntypedef  TYPE_1__ cheatseq_t ;\n\n/* Variables and functions */\nint SCRAMBLE (int) ;\nint* cheat_xlate_table ;\nscalar_t__ firsttime ;\n\nint\ncht_CheckCheat\n( cheatseq_t*\tcht,\nchar\t\tkey )\n{\nint i;\nint rc = 0;\n\nif (firsttime)\n{\nfirsttime = 0;\nfor (i=0;i<256;i++) cheat_xlate_table[i] = SCRAMBLE(i);\n}\n\nif (!cht->p)\ncht->p = cht->sequence; // initialize if first time\n\nif (*cht->p == 0)\n*(cht->p++) = key;\nelse if\n(cheat_xlate_table[(unsigned char)key] == *cht->p) cht->p++;\nelse\ncht->p = cht->sequence;\n\nif (*cht->p == 1)\ncht->p++;\nelse if (*cht->p == 0xff) // end of sequence character\n{\ncht->p = cht->sequence;\nrc = 1;\n}\n\nreturn rc;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int* data; int* p; } ;\ntypedef  TYPE_1__ cht_t ;\n\n/* Variables and functions */\nint* cht_table ;\nint /*<<< orphan*/  cht_update (int) ;\n\nint cht_CheckCheat(cht_t *cht, int key)\n{\nint i;\n\nif (cht_table)\n{\nfor (i = 0; i < 256; i++)\ncht_table[i] = cht->data[i];\ncht->data = NULL;\n}\n\nif (!cht->data)\ncht->data = cht->p;\n\nif (cht->data[0])\n{\nif (cht->data[0] == key)\n{\ncht->p += 4;\nreturn 1;\n}\nelse\n{\ncht->data[0] = key;\nreturn 0;\n}\n}\nelse\n{\ncht->p++;\nreturn 0;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_inter.c_P_GiveBody",
    "input":"\n0000000000000000 <P_GiveBody>:\n0: \tmovq\t(%rdi), %rcx\n3: \txorl\t%eax, %eax\n5: \tcmpq\t(%rip), %rcx  # 0xc <P_GiveBody+0xc>\nc: \tjge\t0x34 <P_GiveBody+0x34>\ne: \tmovslq\t%esi, %rax\n11: \taddq\t%rax, %rcx\n14: \tmovq\t%rcx, (%rdi)\n17: \tmovq\t(%rip), %rax  # 0x1e <P_GiveBody+0x1e>\n1e: \tcmpq\t%rax, %rcx\n21: \tcmovgq\t%rax, %rcx\n25: \tmovq\t%rcx, (%rdi)\n28: \tmovq\t8(%rdi), %rax\n2c: \tmovq\t%rcx, (%rax)\n2f: \tmovl\t$1, %eax\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ health; TYPE_1__* mo; } ;\ntypedef  TYPE_2__ player_t ;\ntypedef  int boolean ;\nstruct TYPE_4__ {scalar_t__ health; } ;\n\n/* Variables and functions */\nscalar_t__ MAXHEALTH ;\n\nboolean\nP_GiveBody\n( player_t*\tplayer,\nint\t\tnum )\n{\nif (player->health >= MAXHEALTH)\nreturn false;\n\nplayer->health += num;\nif (player->health > MAXHEALTH)\nplayer->health = MAXHEALTH;\nplayer->mo->health = player->health;\n\nreturn true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ body_offset; scalar_t__* body; } ;\ntypedef  TYPE_1__ player_t ;\n\n/* Variables and functions */\nscalar_t__ PLAYER_BODY_SIZE ;\n\nint P_GiveBody(player_t *p, int amount)\n{\nif (p->body_offset + amount >= PLAYER_BODY_SIZE)\n{\np->body_offset = PLAYER_BODY_SIZE;\np->body[p->body_offset] = 0;\n}\nelse\n{\np->body_offset += amount;\np->body[p->body_offset] = 0;\n}\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_StopSound",
    "input":"\n0000000000000000 <I_StopSound>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_StopSound (int handle)\n{\n// You need the handle returned by StartSound.\n// Would be looping all channels,\n//  tracking down the handle,\n//  an setting the channel to zero.\n\n// UNUSED.\nhandle = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_StopSound(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_changeWindowScale",
    "input":"\n0000000000000000 <AM_changeWindowScale>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rdi  # 0x8 <AM_changeWindowScale+0x8>\n8: \tmovl\t(%rip), %esi  # 0xe <AM_changeWindowScale+0xe>\ne: \tcallq\t0x13 <AM_changeWindowScale+0x13>\n13: \tmovq\t%rax, (%rip)  # 0x1a <AM_changeWindowScale+0x1a>\n1a: \tmovl\t(%rip), %edi  # 0x20 <AM_changeWindowScale+0x20>\n20: \tmovq\t%rax, %rsi\n23: \tcallq\t0x28 <AM_changeWindowScale+0x28>\n28: \tmovl\t%eax, (%rip)  # 0x2e <AM_changeWindowScale+0x2e>\n2e: \tmovq\t(%rip), %rax  # 0x35 <AM_changeWindowScale+0x35>\n35: \tcmpq\t(%rip), %rax  # 0x3c <AM_changeWindowScale+0x3c>\n3c: \tjge\t0x46 <AM_changeWindowScale+0x46>\n3e: \txorl\t%eax, %eax\n40: \tpopq\t%rcx\n41: \tjmp\t0x46 <AM_changeWindowScale+0x46>\n46: \tcmpq\t(%rip), %rax  # 0x4d <AM_changeWindowScale+0x4d>\n4d: \tjle\t0x57 <AM_changeWindowScale+0x57>\n4f: \txorl\t%eax, %eax\n51: \tpopq\t%rcx\n52: \tjmp\t0x57 <AM_changeWindowScale+0x57>\n57: \txorl\t%eax, %eax\n59: \tpopq\t%rcx\n5a: \tjmp\t0x5f <AM_changeWindowScale+0x5f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_activateNewScale () ;\nint /*<<< orphan*/  AM_maxOutWindowScale () ;\nint /*<<< orphan*/  AM_minOutWindowScale () ;\nint /*<<< orphan*/  FRACUNIT ;\nint /*<<< orphan*/  FixedDiv (int /*<<< orphan*/ ,scalar_t__) ;\nscalar_t__ FixedMul (scalar_t__,int /*<<< orphan*/ ) ;\nscalar_t__ max_scale_mtof ;\nscalar_t__ min_scale_mtof ;\nint /*<<< orphan*/  mtof_zoommul ;\nint /*<<< orphan*/  scale_ftom ;\nscalar_t__ scale_mtof ;\n\nvoid AM_changeWindowScale(void)\n{\n\n// Change the scaling multipliers\nscale_mtof = FixedMul(scale_mtof, mtof_zoommul);\nscale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n\nif (scale_mtof < min_scale_mtof)\nAM_minOutWindowScale();\nelse if (scale_mtof > max_scale_mtof)\nAM_maxOutWindowScale();\nelse\nAM_activateNewScale();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_changeWindowScale_ ;\nscalar_t__ AM_windowScale ;\nscalar_t__ AM_windowScaleMax ;\nscalar_t__ AM_windowScaleMin ;\nint /*<<< orphan*/  AM_windowScale_ ;\nscalar_t__ AM_windowScale_get (scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  AM_windowScale_set (int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  AM_windowScale_update () ;\n\nvoid AM_changeWindowScale(UBYTE delta)\n{\nAM_windowScale = AM_windowScale_get(AM_windowScale, AM_changeWindowScale_);\nAM_windowScale_set(AM_windowScale, AM_changeWindowScale_);\nAM_windowScale_update();\nif (AM_windowScale < AM_windowScaleMin)\nreturn;\nif (AM_windowScale > AM_windowScaleMax)\nreturn;\nAM_windowScale_update();\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_saveScaleAndLoc",
    "input":"\n0000000000000000 <AM_saveScaleAndLoc>:\n0: \tmovl\t(%rip), %eax  # 0x6 <AM_saveScaleAndLoc+0x6>\n6: \tmovl\t%eax, (%rip)  # 0xc <AM_saveScaleAndLoc+0xc>\nc: \tmovl\t(%rip), %eax  # 0x12 <AM_saveScaleAndLoc+0x12>\n12: \tmovl\t%eax, (%rip)  # 0x18 <AM_saveScaleAndLoc+0x18>\n18: \tmovl\t(%rip), %eax  # 0x1e <AM_saveScaleAndLoc+0x1e>\n1e: \tmovl\t%eax, (%rip)  # 0x24 <AM_saveScaleAndLoc+0x24>\n24: \tmovl\t(%rip), %eax  # 0x2a <AM_saveScaleAndLoc+0x2a>\n2a: \tmovl\t%eax, (%rip)  # 0x30 <AM_saveScaleAndLoc+0x30>\n30: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  m_h ;\nint /*<<< orphan*/  m_w ;\nint /*<<< orphan*/  m_x ;\nint /*<<< orphan*/  m_y ;\nint /*<<< orphan*/  old_m_h ;\nint /*<<< orphan*/  old_m_w ;\nint /*<<< orphan*/  old_m_x ;\nint /*<<< orphan*/  old_m_y ;\n\nvoid AM_saveScaleAndLoc(void)\n{\nold_m_x = m_x;\nold_m_y = m_y;\nold_m_w = m_w;\nold_m_h = m_h;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint AM_scaleX ;\nint AM_scaleY ;\nint AM_x ;\nint AM_y ;\n\nvoid AM_saveScaleAndLoc(void)\n{\nAM_scaleX = AM_scaleY;\nAM_x = AM_y;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_tick.c_P_InitThinkers",
    "input":"\n0000000000000000 <P_InitThinkers>:\n0: \tmovq\t$0, (%rip)    # 0xb <P_InitThinkers+0xb>\nb: \tmovq\t$0, (%rip)    # 0x16 <P_InitThinkers+0x16>\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {struct TYPE_2__* next; struct TYPE_2__* prev; } ;\n\n/* Variables and functions */\nTYPE_1__ thinkercap ;\n\nvoid P_InitThinkers (void)\n{\nthinkercap.prev = thinkercap.next  = &thinkercap;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/ * thinkercap ;\nint /*<<< orphan*/ * thinkertail ;\n\nvoid P_InitThinkers (void)\n{\nthinkertail = thinkercap = NULL;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_user.c_P_MovePlayer",
    "input":"\n0000000000000000 <P_MovePlayer>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t8(%rdi), %eax\n7: \tshll\t$16, %eax\na: \tmovslq\t%eax, %rsi\nd: \tmovq\t(%rdi), %rcx\n10: \taddq\t24(%rcx), %rsi\n14: \tmovq\t%rsi, 24(%rcx)\n18: \tmovq\t(%rcx), %rdx\n1b: \txorl\t%eax, %eax\n1d: \tcmpq\t8(%rcx), %rdx\n21: \tsetle\t%al\n24: \tmovl\t%eax, (%rip)  # 0x2a <P_MovePlayer+0x2a>\n2a: \tjg\t0x44 <P_MovePlayer+0x44>\n2c: \tmovl\t12(%rbx), %edx\n2f: \ttestl\t%edx, %edx\n31: \tje\t0x44 <P_MovePlayer+0x44>\n33: \tshll\t$11, %edx\n36: \tmovq\t%rbx, %rdi\n39: \tcallq\t0x3e <P_MovePlayer+0x3e>\n3e: \tmovl\t(%rip), %eax  # 0x44 <P_MovePlayer+0x44>\n44: \tmovl\t16(%rbx), %edx\n47: \ttestl\t%edx, %edx\n49: \tje\t0x68 <P_MovePlayer+0x68>\n4b: \ttestl\t%eax, %eax\n4d: \tje\t0x68 <P_MovePlayer+0x68>\n4f: \tmovq\t(%rbx), %rax\n52: \tmovq\t24(%rax), %rsi\n56: \tsubq\t(%rip), %rsi  # 0x5d <P_MovePlayer+0x5d>\n5d: \tshll\t$11, %edx\n60: \tmovq\t%rbx, %rdi\n63: \tcallq\t0x68 <P_MovePlayer+0x68>\n68: \tcmpl\t$0, 12(%rbx)\n6c: \tjne\t0x74 <P_MovePlayer+0x74>\n6e: \tcmpl\t$0, 16(%rbx)\n72: \tje\t0x8f <P_MovePlayer+0x8f>\n74: \tmovq\t(%rbx), %rdi\n77: \tmovq\t(%rip), %rax  # 0x7e <P_MovePlayer+0x7e>\n7e: \tshlq\t$2, %rax\n82: \taddq\t(%rip), %rax  # 0x89 <P_MovePlayer+0x89>\n89: \tcmpq\t%rax, 16(%rdi)\n8d: \tje\t0x91 <P_MovePlayer+0x91>\n8f: \tpopq\t%rbx\n90: \tretq\n91: \tmovl\t(%rip), %esi  # 0x97 <P_MovePlayer+0x97>\n97: \tpopq\t%rbx\n98: \tjmp\t0x9d <P_MovePlayer+0x9d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int angleturn; int forwardmove; int sidemove; } ;\ntypedef  TYPE_1__ ticcmd_t ;\nstruct TYPE_7__ {TYPE_4__* mo; TYPE_1__ cmd; } ;\ntypedef  TYPE_2__ player_t ;\nstruct TYPE_8__ {scalar_t__ z; scalar_t__ floorz; int /*<<< orphan*/ * state; scalar_t__ angle; } ;\n\n/* Variables and functions */\nscalar_t__ ANG90 ;\nint /*<<< orphan*/  P_SetMobjState (TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  P_Thrust (TYPE_2__*,scalar_t__,int) ;\nsize_t S_PLAY ;\nint /*<<< orphan*/  S_PLAY_RUN1 ;\nint onground ;\nint /*<<< orphan*/ * states ;\n\nvoid P_MovePlayer (player_t* player)\n{\nticcmd_t*\t\tcmd;\n\ncmd = &player->cmd;\n\nplayer->mo->angle += (cmd->angleturn<<16);\n\n// Do not let the player control movement\n//  if not onground.\nonground = (player->mo->z <= player->mo->floorz);\n\nif (cmd->forwardmove && onground)\nP_Thrust (player, player->mo->angle, cmd->forwardmove*2048);\n\nif (cmd->sidemove && onground)\nP_Thrust (player, player->mo->angle-ANG90, cmd->sidemove*2048);\n\nif ( (cmd->forwardmove || cmd->sidemove)\n&& player->mo->state == &states[S_PLAY] )\n{\nP_SetMobjState (player->mo, S_PLAY_RUN1);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_1__* player; int /*<<< orphan*/  ym1; int /*<<< orphan*/  xm1; int /*<<< orphan*/  ym2; int /*<<< orphan*/  xm2; } ;\nstruct TYPE_9__ {scalar_t__ y; scalar_t__ x; scalar_t__ bottom; scalar_t__ top; } ;\nstruct TYPE_8__ {TYPE_2__* mo; } ;\ntypedef  TYPE_1__ player_t ;\ntypedef  TYPE_2__ mobj_t ;\ntypedef  TYPE_3__ playermove_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_CheckMissileSpawn (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckSpriteSpawn (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTeleport (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrap (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapLine (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTrigger (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerLine (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSight (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine2 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine3 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine4 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine5 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine6 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine7 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine8 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine9 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine10 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine11 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine12 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine13 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine14 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine15 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine16 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine17 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine18 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine19 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine20 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine21 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine22 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine23 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine24 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine25 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine26 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine27 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine28 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine29 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine30 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine31 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine32 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine33 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine34 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine35 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine36 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine37 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine38 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine39 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine40 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine41 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine42 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine43 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine44 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine45 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine46 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine47 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine48 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine49 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine50 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine51 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine52 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine53 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine54 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine55 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine56 (TYPE_3__*) ;\nint /*<<< orphan*/  P_CheckTrapTriggerSightLine57 (TYPE_3__*) ;\nint /*"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_tables.c_SlopeDiv",
    "input":"\n0000000000000000 <SlopeDiv>:\n0: \tcmpl\t$511, %esi    # imm = 0x1FF\n6: \tja\t0xf <SlopeDiv+0xf>\n8: \tmovl\t(%rip), %eax  # 0xe <SlopeDiv+0xe>\ne: \tretq\nf: \tshll\t$3, %edi\n12: \tshrl\t$8, %esi\n15: \tmovl\t%edi, %eax\n17: \txorl\t%edx, %edx\n19: \tdivl\t%esi\n1b: \tmovl\t(%rip), %ecx  # 0x21 <SlopeDiv+0x21>\n21: \tcmpl\t%ecx, %eax\n23: \tcmoval\t%ecx, %eax\n26: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SLOPERANGE ;\n\nint\nSlopeDiv\n( unsigned\tnum,\nunsigned\tden)\n{\nunsigned \tans;\n\nif (den < 512)\nreturn SLOPERANGE;\n\nans = (num<<3)/(den>>8);\n\nreturn ans <= SLOPERANGE ? ans : SLOPERANGE;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int cmsUInt32Number ;\ntypedef  int cmsFloat64Number ;\n\n/* Variables and functions */\nint INT_MAX ;\n\n__attribute__((used)) static\ncmsFloat64Number SlopeDiv(cmsUInt32Number n, cmsUInt32Number d)\n{\nif (d > 511) return INT_MAX;\n\nreturn (cmsFloat64Number) n / (cmsFloat64Number) (d << 3) / 256.0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_lib.c_HUlib_initTextLine",
    "input":"\n0000000000000000 <HUlib_initTextLine>:\n0: \tmovl\t%esi, (%rdi)\n2: \tmovl\t%edx, 4(%rdi)\n5: \tmovq\t%rcx, 16(%rdi)\n9: \tmovl\t%r8d, 8(%rdi)\nd: \tjmp\t0x12 <HUlib_initTextLine+0x12>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  patch_t ;\nstruct TYPE_4__ {int x; int y; int sc; int /*<<< orphan*/ ** f; } ;\ntypedef  TYPE_1__ hu_textline_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUlib_clearTextLine (TYPE_1__*) ;\n\nvoid\nHUlib_initTextLine\n( hu_textline_t*\tt,\nint\t\t\tx,\nint\t\t\ty,\npatch_t**\t\tf,\nint\t\t\tsc )\n{\nt->x = x;\nt->y = y;\nt->f = f;\nt->sc = sc;\nHUlib_clearTextLine(t);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  color; int /*<<< orphan*/  font; int /*<<< orphan*/ * text; int /*<<< orphan*/  x; int /*<<< orphan*/  y; } ;\ntypedef  TYPE_1__ HUTextLine ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HU_clearTextLine (TYPE_1__*) ;\n\nvoid HUlib_initTextLine(HUTextLine *tl, int x, int y, int font, int color)\n{\ntl->x = x;\ntl->y = y;\ntl->font = font;\ntl->color = color;\ntl->text = NULL;\nHU_clearTextLine(tl);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_FindLowestCeilingSurrounding",
    "input":"\n0000000000000000 <P_FindLowestCeilingSurrounding>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t(%rip), %r14  # 0xc <P_FindLowestCeilingSurrounding+0xc>\nc: \tcmpl\t$0, (%rdi)\nf: \tjle\t0x4e <P_FindLowestCeilingSurrounding+0x4e>\n11: \tmovq\t%rdi, %r15\n14: \txorl\t%ebx, %ebx\n16: \tjmp\t0x2c <P_FindLowestCeilingSurrounding+0x2c>\n18: \tnopl\t(%rax,%rax)\n20: \taddq\t$1, %rbx\n24: \tmovslq\t(%r15), %rax\n27: \tcmpq\t%rax, %rbx\n2a: \tjge\t0x4e <P_FindLowestCeilingSurrounding+0x4e>\n2c: \tmovq\t16(%r15), %rax\n30: \tmovq\t(%rax,%rbx,8), %rdi\n34: \tmovq\t%r15, %rsi\n37: \tcallq\t0x3c <P_FindLowestCeilingSurrounding+0x3c>\n3c: \ttestq\t%rax, %rax\n3f: \tje\t0x20 <P_FindLowestCeilingSurrounding+0x20>\n41: \tmovq\t8(%rax), %rax\n45: \tcmpq\t%r14, %rax\n48: \tcmovleq\t%rax, %r14\n4c: \tjmp\t0x20 <P_FindLowestCeilingSurrounding+0x20>\n4e: \tmovq\t%r14, %rax\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tpopq\t%r15\n56: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int linecount; scalar_t__ ceilingheight; int /*<<< orphan*/ ** lines; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nscalar_t__ MAXINT ;\nTYPE_1__* getNextSector (int /*<<< orphan*/ *,TYPE_1__*) ;\n\nfixed_t\nP_FindLowestCeilingSurrounding(sector_t* sec)\n{\nint\t\t\ti;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\theight = MAXINT;\n\nfor (i=0 ;i < sec->linecount ; i++)\n{\ncheck = sec->lines[i];\nother = getNextSector(check,sec);\n\nif (!other)\ncontinue;\n\nif (other->ceilingheight < height)\nheight = other->ceilingheight;\n}\nreturn height;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  numsectors; TYPE_2__* sectors; } ;\nstruct TYPE_9__ {TYPE_1__* floorheight; } ;\nstruct TYPE_8__ {scalar_t__ ceilingheight; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  TYPE_2__ subsector_t ;\ntypedef  TYPE_3__ mapthing_t ;\n\n/* Variables and functions */\nscalar_t__ P_CheckSector (TYPE_1__*,TYPE_3__*) ;\nscalar_t__ P_FindLowestCeilingSurrounding (TYPE_1__*) ;\n\n__attribute__((used)) static sector_t *\nP_FindLowestCeilingSurrounding\n( mapthing_t *mthing )\n{\nsector_t\t*sec;\nint\t\t\ti;\n\nsec = NULL;\n\nfor (i=0 ; i<mthing->numsectors ; i++)\n{\nsec = mthing->sectors[i].floorheight;\n\nif (P_CheckSector(sec, mthing))\n{\nif (sec->ceilingheight < (scalar_t__)P_FindLowestCeilingSurrounding(sec))\nsec = sec->ceilingheight;\n}\n}\n\nreturn sec;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_z_zone.c_Z_ClearZone",
    "input":"\n0000000000000000 <Z_ClearZone>:\n0: \tleaq\t192(%rdi), %rax\n7: \tleaq\t8(%rdi), %rcx\nb: \tmovq\t%rax, 24(%rdi)\nf: \tmovq\t%rax, 32(%rdi)\n13: \tmovq\t%rdi, 16(%rdi)\n17: \tmovl\t(%rip), %edx  # 0x1d <Z_ClearZone+0x1d>\n1d: \tmovl\t%edx, 8(%rdi)\n20: \tmovq\t%rax, 40(%rdi)\n24: \tmovq\t%rcx, 208(%rdi)\n2b: \tmovq\t%rcx, 216(%rdi)\n32: \tmovq\t$0, 200(%rdi)\n3d: \tmovq\t(%rdi), %rax\n40: \taddq\t$-48, %rax\n44: \tmovq\t%rax, 192(%rdi)\n4b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  tag; void* user; TYPE_3__* prev; TYPE_3__* next; } ;\nstruct TYPE_6__ {scalar_t__ size; TYPE_1__ blocklist; TYPE_3__* rover; } ;\ntypedef  TYPE_2__ memzone_t ;\nstruct TYPE_7__ {scalar_t__ size; int /*<<< orphan*/ * user; TYPE_1__* next; TYPE_1__* prev; } ;\ntypedef  TYPE_3__ memblock_t ;\ntypedef  int /*<<< orphan*/  byte ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PU_STATIC ;\n\nvoid Z_ClearZone (memzone_t* zone)\n{\nmemblock_t*\t\tblock;\n\n// set the entire zone to one free block\nzone->blocklist.next =\nzone->blocklist.prev =\nblock = (memblock_t *)( (byte *)zone + sizeof(memzone_t) );\n\nzone->blocklist.user = (void *)zone;\nzone->blocklist.tag = PU_STATIC;\nzone->rover = block;\n\nblock->prev = block->next = &zone->blocklist;\n\n// NULL indicates a free block.\nblock->user = NULL;\n\nblock->size = zone->size - sizeof(memzone_t);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ z_magic; scalar_t__ z_size; scalar_t__ z_free; scalar_t__ z_next; scalar_t__ z_prev; int /*<<< orphan*/  z_ref; scalar_t__ z_magic2; scalar_t__ z_magic3; } ;\ntypedef  TYPE_1__* ZHeader ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Z_MAGIC ;\n\nvoid Z_ClearZone(ZHeader z)\n{\nz->z_magic = z->z_magic2 = z->z_magic3 = z->z_size = z->z_free = z->z_next = z->z_prev = 0;\nz->z_ref = Z_MAGIC;\nz->z_magic = z->z_magic2 = z->z_magic3 = z->z_size = z->z_free = z->z_next = z->z_prev = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_PointInSubsector",
    "input":"\n0000000000000000 <R_PointInSubsector>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t(%rip), %eax  # 0xd <R_PointInSubsector+0xd>\nd: \ttestl\t%eax, %eax\nf: \tje\t0x70 <R_PointInSubsector+0x70>\n11: \taddl\t$-1, %eax\n14: \tmovl\t(%rip), %ecx  # 0x1a <R_PointInSubsector+0x1a>\n1a: \ttestl\t%eax, %ecx\n1c: \tjne\t0x5c <R_PointInSubsector+0x5c>\n1e: \tmovl\t%esi, %r14d\n21: \tmovl\t%edi, %r15d\n24: \tnopw\t%cs:(%rax,%rax)\n2e: \tnop\n30: \tmovq\t(%rip), %rbx  # 0x37 <R_PointInSubsector+0x37>\n37: \tmovslq\t%eax, %rbp\n3a: \tleaq\t(%rbx,%rbp,8), %rdx\n3e: \tmovl\t%r15d, %edi\n41: \tmovl\t%r14d, %esi\n44: \tcallq\t0x49 <R_PointInSubsector+0x49>\n49: \tmovq\t(%rbx,%rbp,8), %rcx\n4d: \tcltq\n4f: \tmovl\t(%rcx,%rax,4), %eax\n52: \tmovl\t(%rip), %ecx  # 0x58 <R_PointInSubsector+0x58>\n58: \ttestl\t%eax, %ecx\n5a: \tje\t0x30 <R_PointInSubsector+0x30>\n5c: \tnotl\t%ecx\n5e: \tandl\t%eax, %ecx\n60: \tmovslq\t%ecx, %rax\n63: \tshlq\t$2, %rax\n67: \taddq\t(%rip), %rax  # 0x6e <R_PointInSubsector+0x6e>\n6e: \tjmp\t0x77 <R_PointInSubsector+0x77>\n70: \tmovq\t(%rip), %rax  # 0x77 <R_PointInSubsector+0x77>\n77: \taddq\t$8, %rsp\n7b: \tpopq\t%rbx\n7c: \tpopq\t%r14\n7e: \tpopq\t%r15\n80: \tpopq\t%rbp\n81: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  subsector_t ;\nstruct TYPE_4__ {int* children; } ;\ntypedef  TYPE_1__ node_t ;\ntypedef  int /*<<< orphan*/  fixed_t ;\n\n/* Variables and functions */\nint NF_SUBSECTOR ;\nint R_PointOnSide (int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_1__*) ;\nTYPE_1__* nodes ;\nint numnodes ;\nint /*<<< orphan*/ * subsectors ;\n\nsubsector_t*\nR_PointInSubsector\n( fixed_t\tx,\nfixed_t\ty )\n{\nnode_t*\tnode;\nint\t\tside;\nint\t\tnodenum;\n\n// single subsector is a special case\nif (!numnodes)\nreturn subsectors;\n\nnodenum = numnodes-1;\n\nwhile (! (nodenum & NF_SUBSECTOR) )\n{\nnode = &nodes[nodenum];\nside = R_PointOnSide (x, y, node);\nnodenum = node->children[side];\n}\n\nreturn &subsectors[nodenum & ~NF_SUBSECTOR];\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * sectors; } ;\ntypedef  int /*<<< orphan*/  fixed_t ;\ntypedef  int /*<<< orphan*/  subsector_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  R_CheckBBox (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  R_Subsector ;\nint /*<<< orphan*/  R_SubsectorNum ;\nTYPE_1__* subsectors ;\nint /*<<< orphan*/ ** ssectors ;\n\nsubsector_t *\nR_PointInSubsector\n( fixed_t\tx,\nfixed_t\ty )\n{\nint\t\t\ti;\n\nif (!R_SubsectorNum)\nreturn ssectors[0];\n\nfor (i=0 ; i<R_SubsectorNum ; i++)\nif (R_CheckBBox(x,y,&subsectors[i]))\nreturn ssectors[i];\n\nreturn ssectors[0];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_ScaleFromGlobalAngle",
    "input":"\n0000000000000000 <R_ScaleFromGlobalAngle>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \taddl\t(%rip), %edi  # 0x9 <R_ScaleFromGlobalAngle+0x9>\n9: \tmovl\t%edi, %eax\nb: \tsubl\t(%rip), %eax  # 0x11 <R_ScaleFromGlobalAngle+0x11>\n11: \tsubl\t(%rip), %edi  # 0x17 <R_ScaleFromGlobalAngle+0x17>\n17: \tmovq\t(%rip), %rdx  # 0x1e <R_ScaleFromGlobalAngle+0x1e>\n1e: \tmovb\t(%rip), %cl   # 0x24 <R_ScaleFromGlobalAngle+0x24>\n24: \tsarl\t%cl, %eax\n26: \tcltq\n28: \tsarl\t%cl, %edi\n2a: \tmovl\t(%rdx,%rax,4), %ebp\n2d: \tmovslq\t%edi, %rax\n30: \tmovl\t(%rdx,%rax,4), %esi\n33: \tmovl\t(%rip), %edi  # 0x39 <R_ScaleFromGlobalAngle+0x39>\n39: \tcallq\t0x3e <R_ScaleFromGlobalAngle+0x3e>\n3e: \tmovl\t%eax, %ebx\n40: \tmovb\t(%rip), %cl   # 0x46 <R_ScaleFromGlobalAngle+0x46>\n46: \tshll\t%cl, %ebx\n48: \tmovl\t(%rip), %edi  # 0x4e <R_ScaleFromGlobalAngle+0x4e>\n4e: \tmovl\t%ebp, %esi\n50: \tcallq\t0x55 <R_ScaleFromGlobalAngle+0x55>\n55: \tmovl\t%ebx, %ecx\n57: \tsarl\t$16, %ecx\n5a: \tcmpl\t%ecx, %eax\n5c: \tjle\t0x86 <R_ScaleFromGlobalAngle+0x86>\n5e: \tmovl\t%ebx, %edi\n60: \tmovl\t%eax, %esi\n62: \tcallq\t0x67 <R_ScaleFromGlobalAngle+0x67>\n67: \tmovl\t%eax, %ecx\n69: \tmovl\t(%rip), %eax  # 0x6f <R_ScaleFromGlobalAngle+0x6f>\n6f: \tshll\t$6, %eax\n72: \tcmpl\t%eax, %ecx\n74: \tjg\t0x8f <R_ScaleFromGlobalAngle+0x8f>\n76: \tcmpl\t$255, %ecx\n7c: \tmovl\t$256, %eax    # imm = 0x100\n81: \tcmovgl\t%ecx, %eax\n84: \tjmp\t0x8f <R_ScaleFromGlobalAngle+0x8f>\n86: \tmovl\t(%rip), %eax  # 0x8c <R_ScaleFromGlobalAngle+0x8c>\n8c: \tshll\t$6, %eax\n8f: \taddq\t$8, %rsp\n93: \tpopq\t%rbx\n94: \tpopq\t%rbp\n95: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int fixed_t ;\ntypedef  size_t angle_t ;\n\n/* Variables and functions */\nsize_t ANG90 ;\nsize_t ANGLETOFINESHIFT ;\nint FRACUNIT ;\nint FixedDiv (int,int) ;\nint FixedMul (int,int) ;\nint abs (int) ;\nint detailshift ;\nint* finecosine ;\nint* finesine ;\nint projection ;\nint rw_distance ;\nsize_t rw_normalangle ;\nsize_t viewangle ;\n\nfixed_t R_ScaleFromGlobalAngle (angle_t visangle)\n{\nfixed_t\t\tscale;\nint\t\t\tanglea;\nint\t\t\tangleb;\nint\t\t\tsinea;\nint\t\t\tsineb;\nfixed_t\t\tnum;\nint\t\t\tden;\n\n// UNUSED\n#if 0\n{\nfixed_t\t\tdist;\nfixed_t\t\tz;\nfixed_t\t\tsinv;\nfixed_t\t\tcosv;\n\nsinv = finesine[(visangle-rw_normalangle)>>ANGLETOFINESHIFT];\ndist = FixedDiv (rw_distance, sinv);\ncosv = finecosine[(viewangle-visangle)>>ANGLETOFINESHIFT];\nz = abs(FixedMul (dist, cosv));\nscale = FixedDiv(projection, z);\nreturn scale;\n}\n#endif\n\nanglea = ANG90 + (visangle-viewangle);\nangleb = ANG90 + (visangle-rw_normalangle);\n\n// both sines are allways positive\nsinea = finesine[anglea>>ANGLETOFINESHIFT];\nsineb = finesine[angleb>>ANGLETOFINESHIFT];\nnum = FixedMul(projection,sineb)<<detailshift;\nden = FixedMul(rw_distance,sinea);\n\nif (den > num>>16)\n{\nscale = FixedDiv (num, den);\n\nif (scale > 64*FRACUNIT)\nscale = 64*FRACUNIT;\nelse if (scale < 256)\nscale = 256;\n}\nelse\nscale = 64*FRACUNIT;\n\nreturn scale;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int UBYTE ;\n\n/* Variables and functions */\nint ANGLE_BITS ;\nint ANGLE_MAX ;\nint ANGLE_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SIZE_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_BITS_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT_MASK ;\nint /*<<< orphan*/  ANGLE_TABLE_SHIFT_SHIFT_SHIFT_SHIFT_SHIFT"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_SubmitSound",
    "input":"\n0000000000000000 <I_SubmitSound>:\n0: \tmovl\t(%rip), %edi  # 0x6 <I_SubmitSound+0x6>\n6: \tmovl\t(%rip), %esi  # 0xc <I_SubmitSound+0xc>\nc: \tmovl\t(%rip), %edx  # 0x12 <I_SubmitSound+0x12>\n12: \timull\t(%rip), %edx  # 0x19 <I_SubmitSound+0x19>\n19: \tjmp\t0x1e <I_SubmitSound+0x1e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint BUFMUL ;\nint SAMPLECOUNT ;\nint /*<<< orphan*/  audio_fd ;\nint /*<<< orphan*/  mixbuffer ;\nint /*<<< orphan*/  write (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\n\nvoid\nI_SubmitSound(void)\n{\n// Write it to DSP device.\nwrite(audio_fd, mixbuffer, SAMPLECOUNT*BUFMUL);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SubmitSound_ ;\nint /*<<< orphan*/  I_SubmitSound_Data ;\nint /*<<< orphan*/  I_SubmitSound_Len ;\nint /*<<< orphan*/  I_SubmitSound_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Rate ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_ ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Data ;\nint /*<<< orphan*/  I_SubmitSound_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Volume_Len ;"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_spec.c_P_FindLowestFloorSurrounding",
    "input":"\n0000000000000000 <P_FindLowestFloorSurrounding>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t(%rdi), %r14\n8: \tcmpl\t$0, 8(%rdi)\nc: \tjle\t0x4e <P_FindLowestFloorSurrounding+0x4e>\ne: \tmovq\t%rdi, %r15\n11: \txorl\t%ebx, %ebx\n13: \tjmp\t0x2d <P_FindLowestFloorSurrounding+0x2d>\n15: \tnopw\t%cs:(%rax,%rax)\n1f: \tnop\n20: \taddq\t$1, %rbx\n24: \tmovslq\t8(%r15), %rax\n28: \tcmpq\t%rax, %rbx\n2b: \tjge\t0x4e <P_FindLowestFloorSurrounding+0x4e>\n2d: \tmovq\t16(%r15), %rax\n31: \tmovq\t(%rax,%rbx,8), %rdi\n35: \tmovq\t%r15, %rsi\n38: \tcallq\t0x3d <P_FindLowestFloorSurrounding+0x3d>\n3d: \ttestq\t%rax, %rax\n40: \tje\t0x20 <P_FindLowestFloorSurrounding+0x20>\n42: \tmovq\t(%rax), %rax\n45: \tcmpq\t%r14, %rax\n48: \tcmovleq\t%rax, %r14\n4c: \tjmp\t0x20 <P_FindLowestFloorSurrounding+0x20>\n4e: \tmovq\t%r14, %rax\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tpopq\t%r15\n56: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ floorheight; int linecount; int /*<<< orphan*/ ** lines; } ;\ntypedef  TYPE_1__ sector_t ;\ntypedef  int /*<<< orphan*/  line_t ;\ntypedef  scalar_t__ fixed_t ;\n\n/* Variables and functions */\nTYPE_1__* getNextSector (int /*<<< orphan*/ *,TYPE_1__*) ;\n\nfixed_t\tP_FindLowestFloorSurrounding(sector_t* sec)\n{\nint\t\t\ti;\nline_t*\t\tcheck;\nsector_t*\t\tother;\nfixed_t\t\tfloor = sec->floorheight;\n\nfor (i=0 ;i < sec->linecount ; i++)\n{\ncheck = sec->lines[i];\nother = getNextSector(check,sec);\n\nif (!other)\ncontinue;\n\nif (other->floorheight < floor)\nfloor = other->floorheight;\n}\nreturn floor;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/ * floors; int numfloors; TYPE_2__* sectors; } ;\nstruct TYPE_9__ {TYPE_1__* floors; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  floorpic; } ;\ntypedef  TYPE_1__* PFloorData ;\ntypedef  TYPE_2__* PSectorData ;\ntypedef  TYPE_3__* PMapData ;\n\n/* Variables and functions */\nTYPE_1__* P_FindLowestFloorSurrounding (int /*<<< orphan*/ *,TYPE_3__*) ;\n\nPFloorData P_FindLowestFloorSurrounding(PMapData map, PSectorData sector)\n{\nPFloorData floor;\nint i;\n\nfor (i = 0; i < map->numfloors; i++)\n{\nfloor = P_FindLowestFloorSurrounding(&sector->floors[i], map);\nif (floor != NULL && floor->floorpic < map->sectors[i]->floors[0].floorpic)\n{\nmap->sectors[i]->floors[0].floorpic = floor->floorpic;\n}\n}\n\nreturn &map->sectors[0]->floors[0];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_r_main.c_R_InitLightTables",
    "input":"\n0000000000000000 <R_InitLightTables>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t(%rip), %edi  # 0xd <R_InitLightTables+0xd>\nd: \ttestl\t%edi, %edi\nf: \tjle\t0xdd <R_InitLightTables+0xdd>\n15: \tmovl\t(%rip), %ecx  # 0x1b <R_InitLightTables+0x1b>\n1b: \tmovl\t(%rip), %esi  # 0x21 <R_InitLightTables+0x21>\n21: \txorl\t%r14d, %r14d\n24: \tjmp\t0x46 <R_InitLightTables+0x46>\n26: \tnopw\t%cs:(%rax,%rax)\n30: \tmovl\t(%rip), %edi  # 0x36 <R_InitLightTables+0x36>\n36: \taddq\t$1, %r14\n3a: \tmovslq\t%edi, %rax\n3d: \tcmpq\t%rax, %r14\n40: \tjge\t0xdd <R_InitLightTables+0xdd>\n46: \tmovl\t%r14d, %eax\n49: \tnotl\t%eax\n4b: \taddl\t%edi, %eax\n4d: \timull\t%ecx, %eax\n50: \taddl\t%eax, %eax\n52: \tcltd\n53: \tidivl\t%edi\n55: \ttestl\t%esi, %esi\n57: \tjle\t0x36 <R_InitLightTables+0x36>\n59: \tmovl\t%eax, %r15d\n5c: \txorl\t%ebx, %ebx\n5e: \tjmp\t0x8b <R_InitLightTables+0x8b>\n60: \tshll\t$8, %edx\n63: \tmovslq\t%edx, %rax\n66: \taddq\t(%rip), %rax  # 0x6d <R_InitLightTables+0x6d>\n6d: \tmovq\t(%rip), %rdx  # 0x74 <R_InitLightTables+0x74>\n74: \tmovq\t(%rdx,%r14,8), %rdx\n78: \tmovq\t%rax, (%rdx,%rbx,8)\n7c: \tmovslq\t(%rip), %rsi  # 0x83 <R_InitLightTables+0x83>\n83: \tmovq\t%rbp, %rbx\n86: \tcmpq\t%rsi, %rbp\n89: \tjge\t0x30 <R_InitLightTables+0x30>\n8b: \tmovl\t(%rip), %eax  # 0x91 <R_InitLightTables+0x91>\n91: \tmovl\t%eax, %edi\n93: \tshrl\t$31, %edi\n96: \taddl\t%eax, %edi\n98: \tsarl\t%edi\n9a: \timull\t(%rip), %edi  # 0xa1 <R_InitLightTables+0xa1>\na1: \tleaq\t1(%rbx), %rbp\na5: \tmovzbl\t(%rip), %ecx  # 0xac <R_InitLightTables+0xac>\nac: \tmovl\t%ebp, %esi\nae: \tshll\t%cl, %esi\nb0: \tcallq\t0xb5 <R_InitLightTables+0xb5>\nb5: \tmovzbl\t(%rip), %ecx  # 0xbc <R_InitLightTables+0xbc>\nbc: \tsarl\t%cl, %eax\nbe: \tcltd\nbf: \tidivl\t(%rip)   # 0xc5 <R_InitLightTables+0xc5>\nc5: \tmovl\t%r15d, %edx\nc8: \tsubl\t%eax, %edx\nca: \tjns\t0xce <R_InitLightTables+0xce>\ncc: \txorl\t%edx, %edx\nce: \tmovl\t(%rip), %ecx  # 0xd4 <R_InitLightTables+0xd4>\nd4: \tcmpl\t%ecx, %edx\nd6: \tjl\t0x60 <R_InitLightTables+0x60>\nd8: \tleal\t-1(%rcx), %edx\ndb: \tjmp\t0x60 <R_InitLightTables+0x60>\ndd: \taddq\t$8, %rsp\ne1: \tpopq\t%rbx\ne2: \tpopq\t%r14\ne4: \tpopq\t%r15\ne6: \tpopq\t%rbp\ne7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint DISTMAP ;\nint FRACUNIT ;\nint FixedDiv (int,int) ;\nint LIGHTLEVELS ;\nint LIGHTSCALESHIFT ;\nint LIGHTZSHIFT ;\nint MAXLIGHTZ ;\nint NUMCOLORMAPS ;\nint SCREENWIDTH ;\nscalar_t__ colormaps ;\nscalar_t__** zlight ;\n\nvoid R_InitLightTables (void)\n{\nint\t\ti;\nint\t\tj;\nint\t\tlevel;\nint\t\tstartmap;\nint\t\tscale;\n\n// Calculate the light levels to use\n//  for each level / distance combination.\nfor (i=0 ; i< LIGHTLEVELS ; i++)\n{\nstartmap = ((LIGHTLEVELS-1-i)*2)*NUMCOLORMAPS/LIGHTLEVELS;\nfor (j=0 ; j<MAXLIGHTZ ; j++)\n{\nscale = FixedDiv ((SCREENWIDTH/2*FRACUNIT), (j+1)<<LIGHTZSHIFT);\nscale >>= LIGHTSCALESHIFT;\nlevel = startmap - scale/DISTMAP;\n\nif (level < 0)\nlevel = 0;\n\nif (level >= NUMCOLORMAPS)\nlevel = NUMCOLORMAPS-1;\n\nzlight[i][j] = colormaps + level*256;\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int GLint ;\n\n/* Variables and functions */\nint LIGHT_MAX ;\nint LIGHT_MAX_DISTANCE ;\nint LIGHT_MAX_EXPONENT ;\nint LIGHT_MAX_LINEAR ;\nint LIGHT_MAX_QUADRATIC ;\nint LIGHT_MAX_SPOT_CUTOFF ;\nint LIGHT_MAX_SPOT_EXPONENT ;\nint LIGHT_MAX_SPOT_FALLOFF ;\nint LIGHT_MAX_SPOT_DIRECTION ;\nint LIGHT_MAX_SPOT_DIRECTION_X ;\nint LIGHT_MAX_SPOT_DIRECTION_Y ;\nint LIGHT_MAX_SPOT_DIRECTION_Z ;\nint LIGHT_MAX_SPOT_DIRECTION_W ;\nint LIGHT_MAX_SPOT_EXPONENT_X ;\nint LIGHT_MAX_SPOT_EXPONENT_Y ;\nint LIGHT_MAX_SPOT_EXPONENT_Z ;\nint LIGHT_MAX_SPOT_EXPONENT_W ;\nint LIGHT_MAX_SPOT_FALLOFF_X ;\nint LIGHT_MAX_SPOT_FALLOFF_Y ;\nint LIGHT_MAX_SPOT_FALLOFF_Z ;\nint LIGHT_MAX_SPOT_FALLOFF_W ;\nint LIGHT_MAX_SPOT_CUTOFF_X ;\nint LIGHT_MAX_SPOT_CUTOFF_Y ;\nint LIGHT_MAX_SPOT_CUTOFF_Z ;\nint LIGHT_MAX_SPOT_CUTOFF_W ;\nint LIGHT_MAX_SPOT_DIRECTION_X_X ;\nint LIGHT_MAX_SPOT_DIRECTION_X_Y ;\nint LIGHT_MAX_SPOT_DIRECTION_X_Z ;\nint LIGHT_MAX_SPOT_DIRECTION_X_W ;\nint LIGHT_MAX_SPOT_DIRECTION_Y_X ;\nint LIGHT_MAX_SPOT_DIRECTION_Y_Y ;\nint LIGHT_MAX_SPOT_DIRECTION_Y_Z ;\nint LIGHT_MAX_SPOT_DIRECTION_Y_W ;\nint LIGHT_MAX_SPOT_DIRECTION_Z_X ;\nint LIGHT_MAX_SPOT_DIRECTION_Z_Y ;\nint LIGHT_MAX_SPOT_DIRECTION_Z_Z ;\nint LIGHT_MAX_SPOT_DIRECTION_Z_W ;\nint LIGHT_MAX_SPOT_DIRECTION_W_X ;\nint LIGHT_MAX_SPOT_DIRECTION_W_Y ;\nint LIGHT_MAX_SPOT_DIRECTION_W_Z ;\nint LIGHT_MAX_SPOT_DIRECTION_W_W ;\nint LIGHT_MAX_SPOT_EXPONENT_X_X ;\nint LIGHT_MAX_SPOT_EXPONENT_X_Y ;\nint LIGHT_MAX_SPOT_EXPONENT_X_Z ;\nint LIGHT_MAX_SPOT_EXPONENT_X_W ;\nint LIGHT_MAX_SPOT_EXPONENT_Y_X ;\nint LIGHT_MAX_SPOT_EXPONENT_Y_Y ;\nint LIGHT_MAX_SPOT_EXPONENT_Y_Z ;\nint LIGHT_MAX_SPOT_EXPONENT_Y_W ;\nint LIGHT_MAX_SPOT_EXPONENT_Z_X ;\nint LIGHT_MAX_SPOT_EXPONENT_Z_Y ;\nint LIGHT_MAX_SPOT_EXPONENT_Z_Z ;\nint LIGHT_MAX_SPOT_EXPONENT_Z_W ;\nint LIGHT_MAX_SPOT_EXPONENT_W_X ;\nint LIGHT_MAX_SPOT_EXPONENT_W_Y ;\nint LIGHT_MAX_SPOT_EXPONENT_W_Z ;\nint LIGHT_MAX_SPOT_EXPONENT_W_W ;\nint LIGHT_MAX_SPOT_FALLOFF_X_X ;\nint LIGHT_MAX_SPOT_FALLOFF_X_Y ;\nint LIGHT_MAX_SPOT_FALLOFF_X_Z ;\nint LIGHT_MAX_SPOT_FALLOFF_X_W ;\nint LIGHT_MAX_SPOT_FALLOFF_Y_X ;\nint LIGHT_MAX_SPOT_FALLOFF_Y_Y ;\nint LIGHT_MAX_SPOT_FALLOFF_Y_Z ;\nint LIGHT_MAX_SPOT_FALLOFF_Y_W ;\nint LIGHT_MAX_SPOT_FALLOFF_Z_X ;\nint LIGHT_MAX_SPOT_FALLOFF_Z_Y ;\nint LIGHT_MAX_SPOT_FALLOFF_Z_Z ;\nint LIGHT_MAX_SPOT_FALLOFF_Z_W ;\nint LIGHT_MAX_SPOT_FALLOFF_W_X ;\nint LIGHT_MAX_SPOT_FALLOFF_W_Y ;\nint LIGHT_MAX_SPOT_FALLOFF_W_Z ;\nint LIGHT_MAX_SPOT_FALLOFF_W_W ;\nint LIGHT_MAX_SPOT_CUTOFF_X_X ;\nint LIGHT_MAX_SPOT_CUTOFF_X_Y ;\nint LIGHT_MAX_SPOT_CUTOFF_X_Z ;\nint LIGHT_MAX_SPOT_CUTOFF_X_W ;\nint LIGHT_MAX_SPOT_CUTOFF_Y_X ;\nint LIGHT_MAX_SPOT_CUTOFF_Y_Y ;\nint LIGHT_MAX_SPOT_CUTOFF_Y_Z ;\nint LIGHT_MAX_SPOT_CUTOFF_Y_W ;\nint LIGHT_MAX_SPOT_CUTOFF_Z_X ;\nint LIGHT_MAX_SPOT_CUTOFF_Z_Y ;\nint LIGHT_MAX_SPOT_CUTOFF_Z_Z ;\nint LIGHT_MAX_SPOT_CUTOFF_Z_W ;\nint LIGHT_MAX_SPOT_CUTOFF_W_X ;\nint LIGHT_MAX_SPOT_CUTOFF_W_Y ;\nint LIGHT_MAX_SPOT_CUTOFF_W_Z ;\nint LIGHT_MAX_SPOT_CUTOFF_W_W ;\nint LIGHT_MAX_LINEAR_X ;\nint LIGHT_MAX_LINEAR_Y ;\nint LIGHT_MAX_LINEAR_Z ;\nint LIGHT_MAX_LINEAR_W ;\nint LIGHT_MAX_QUADRATIC_X ;\nint LIGHT_MAX_QUADRATIC_Y ;\nint LIGHT_MAX_QUADRATIC_Z ;\nint LIGHT_MAX_QUADRATIC_W ;\nint LIGHT_MAX_DISTANCE_X ;\nint LIGHT_MAX_DISTANCE_Y ;\nint LIGHT_MAX_DISTANCE_Z ;\nint LIGHT_MAX_DISTANCE_W ;\nint LIGHT_MAX_EXPONENT_X ;\nint LIGHT_MAX_EXPONENT_Y ;\nint LIGHT_MAX_EXPONENT_Z ;\nint LIGHT_MAX_EXPONENT_W ;\nint LIGHT_MAX_DIRECTION_X ;\nint LIGHT_MAX_DIRECTION_Y ;\nint LIGHT_MAX_DIRECTION_Z ;\nint LIGHT_MAX_DIRECTION_W ;\nint LIGHT_MAX_COLOR_X ;\nint LIGHT_MAX_COLOR_Y ;\nint LIGHT_MAX_COLOR_Z ;\nint LIGHT_MAX_COLOR_W ;\nint LIGHT_MAX_AMBIENT_X ;\nint LIGHT_MAX_AMBIENT_Y ;\nint LIGHT_MAX_AMBIENT_Z ;\nint LIGHT_MAX_AMBIENT"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_f_wipe.c_wipe_exitColorXForm",
    "input":"\n0000000000000000 <wipe_exitColorXForm>:\n0: \txorl\t%eax, %eax\n2: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nint\nwipe_exitColorXForm\n( int\twidth,\nint\theight,\nint\tticks )\n{\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void *wipe_exitColorXForm(fz_context *ctx) { return NULL; }</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_w_wad.c_W_InitMultipleFiles",
    "input":"\n0000000000000000 <W_InitMultipleFiles>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t$0, (%rip)    # 0xe <W_InitMultipleFiles+0xe>\ne: \tmovl\t$1, %edi\n13: \tcallq\t0x18 <W_InitMultipleFiles+0x18>\n18: \tmovq\t%rax, (%rip)  # 0x1f <W_InitMultipleFiles+0x1f>\n1f: \tmovq\t(%rbx), %rdi\n22: \ttestq\t%rdi, %rdi\n25: \tje\t0x4b <W_InitMultipleFiles+0x4b>\n27: \taddq\t$8, %rbx\n2b: \tnopl\t(%rax,%rax)\n30: \tcallq\t0x35 <W_InitMultipleFiles+0x35>\n35: \tmovq\t(%rbx), %rdi\n38: \taddq\t$8, %rbx\n3c: \ttestq\t%rdi, %rdi\n3f: \tjne\t0x30 <W_InitMultipleFiles+0x30>\n41: \tmovl\t(%rip), %ebx  # 0x47 <W_InitMultipleFiles+0x47>\n47: \ttestl\t%ebx, %ebx\n49: \tjne\t0x5b <W_InitMultipleFiles+0x5b>\n4b: \tmovl\t$0, %edi\n50: \tcallq\t0x55 <W_InitMultipleFiles+0x55>\n55: \tmovl\t(%rip), %ebx  # 0x5b <W_InitMultipleFiles+0x5b>\n5b: \tmovl\t%ebx, %edi\n5d: \tcallq\t0x62 <W_InitMultipleFiles+0x62>\n62: \tmovq\t%rax, (%rip)  # 0x69 <W_InitMultipleFiles+0x69>\n69: \ttestq\t%rax, %rax\n6c: \tjne\t0x7f <W_InitMultipleFiles+0x7f>\n6e: \tmovl\t$0, %edi\n73: \tcallq\t0x78 <W_InitMultipleFiles+0x78>\n78: \tmovq\t(%rip), %rax  # 0x7f <W_InitMultipleFiles+0x7f>\n7f: \tmovq\t%rax, %rdi\n82: \txorl\t%esi, %esi\n84: \tmovl\t%ebx, %edx\n86: \tpopq\t%rbx\n87: \tjmp\t0x8c <W_InitMultipleFiles+0x8c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (char*) ;\nint /*<<< orphan*/  W_AddFile (char*) ;\nvoid* lumpcache ;\nvoid* lumpinfo ;\nvoid* malloc (int) ;\nint /*<<< orphan*/  memset (void*,int /*<<< orphan*/ ,int) ;\nint numlumps ;\n\nvoid W_InitMultipleFiles (char** filenames)\n{\nint\t\tsize;\n\n// open all the files, load headers, and count lumps\nnumlumps = 0;\n\n// will be realloced as lumps are added\nlumpinfo = malloc(1);\n\nfor ( ; *filenames ; filenames++)\nW_AddFile (*filenames);\n\nif (!numlumps)\nI_Error (\"W_InitFiles: no files found\");\n\n// set up caching\nsize = numlumps * sizeof(*lumpcache);\nlumpcache = malloc (size);\n\nif (!lumpcache)\nI_Error (\"Couldn't allocate lumpcache\");\n\nmemset (lumpcache,0, size);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  WRes ;\ntypedef  int /*<<< orphan*/  CFileItem ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CFileItem_Free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  CFileItem_Init (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetPath (int /*<<< orphan*/ *,char const*) ;\nint /*<<< orphan*/  CFileItem_SetSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetTime (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetType (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolume (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumePath (int /*<<< orphan*/ *,char const*) ;\nint /*<<< orphan*/  CFileItem_SetVolumeSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeType (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackSize (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUnpackVer (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CFileItem_SetVolumeUn"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_i_sound.c_I_SetSfxVolume",
    "input":"\n0000000000000000 <I_SetSfxVolume>:\n0: \tmovl\t%edi, (%rip)  # 0x6 <I_SetSfxVolume+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint snd_SfxVolume ;\n\nvoid I_SetSfxVolume(int volume)\n{\n// Identical to DOS.\n// Basically, this should propagate\n//  the menu/config file setting\n//  to the state variable used in\n//  the mixing.\nsnd_SfxVolume = volume;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint sfx_volume ;\n\nvoid I_SetSfxVolume(int volume)\n{\nsfx_volume = volume;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_menu.c_M_ClearMenus",
    "input":"\n0000000000000000 <M_ClearMenus>:\n0: \tmovq\t$0, (%rip)    # 0xb <M_ClearMenus+0xb>\nb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ menuactive ;\n\nvoid M_ClearMenus (void)\n{\nmenuactive = 0;\n// if (!netgame && usergame && paused)\n//       sendpause = true;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ M_Menu ;\n\nvoid M_ClearMenus(void)\n{\nM_Menu = 0;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_m_random.c_P_Random",
    "input":"\n0000000000000000 <P_Random>:\n0: \tmovl\t(%rip), %eax  # 0x6 <P_Random+0x6>\n6: \taddl\t$1, %eax\n9: \tmovzbl\t%al, %eax\nc: \tmovl\t%eax, (%rip)  # 0x12 <P_Random+0x12>\n12: \tmovq\t(%rip), %rcx  # 0x19 <P_Random+0x19>\n19: \tmovl\t(%rcx,%rax,4), %eax\n1c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint prndindex ;\nint* rndtable ;\n\nint P_Random (void)\n{\nprndindex = (prndindex+1)&0xff;\nreturn rndtable[prndindex];\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint P_Random_Seed ;\nint* P_Random_Table ;\n\nint P_Random(void)\n{\nP_Random_Seed = (P_Random_Seed + 1) & 0xff;\nreturn P_Random_Table[P_Random_Seed];\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_hu_stuff.c_HU_queueChatChar",
    "input":"\n0000000000000000 <HU_queueChatChar>:\n0: \tmovslq\t(%rip), %rax  # 0x7 <HU_queueChatChar+0x7>\n7: \tleal\t1(%rax), %ecx\na: \tmovl\t(%rip), %edx  # 0x10 <HU_queueChatChar+0x10>\n10: \taddl\t$-1, %edx\n13: \tandl\t%ecx, %edx\n15: \tcmpl\t(%rip), %edx  # 0x1b <HU_queueChatChar+0x1b>\n1b: \tjne\t0x2d <HU_queueChatChar+0x2d>\n1d: \tmovl\t(%rip), %eax  # 0x23 <HU_queueChatChar+0x23>\n23: \tmovq\t(%rip), %rcx  # 0x2a <HU_queueChatChar+0x2a>\n2a: \tmovl\t%eax, (%rcx)\n2c: \tretq\n2d: \tmovq\t(%rip), %rcx  # 0x34 <HU_queueChatChar+0x34>\n34: \tmovb\t%dil, (%rcx,%rax)\n38: \tmovl\t(%rip), %eax  # 0x3e <HU_queueChatChar+0x3e>\n3e: \taddl\t$1, %eax\n41: \tmovl\t(%rip), %ecx  # 0x47 <HU_queueChatChar+0x47>\n47: \taddl\t$-1, %ecx\n4a: \tandl\t%eax, %ecx\n4c: \tmovl\t%ecx, (%rip)  # 0x52 <HU_queueChatChar+0x52>\n52: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  message; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  HUSTR_MSGU ;\nint QUEUESIZE ;\nchar* chatchars ;\nint head ;\nTYPE_1__* plr ;\nint tail ;\n\nvoid HU_queueChatChar(char c)\n{\nif (((head + 1) & (QUEUESIZE-1)) == tail)\n{\nplr->message = HUSTR_MSGU;\n}\nelse\n{\nchatchars[head] = c;\nhead = (head + 1) & (QUEUESIZE-1);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint HU_chatQueue ;\nint HU_chatQueueSize ;\nchar* HU_chatQueueTail ;\nint HU_chatQueueTailIndex ;\nint HU_chatQueueTailIndexMask ;\n\nvoid HU_queueChatChar(char c)\n{\nHU_chatQueueTail[HU_chatQueueTailIndex] = c;\nHU_chatQueueTailIndex = (HU_chatQueueTailIndex + 1) & HU_chatQueueTailIndexMask;\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_enemy.c_A_BrainDie",
    "input":"\n0000000000000000 <A_BrainDie>:\n0: \txorl\t%eax, %eax\n2: \tjmp\t0x7 <A_BrainDie+0x7>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  G_ExitLevel () ;\n\nvoid A_BrainDie (mobj_t*\tmo)\n{\nG_ExitLevel ();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  PEHANDLE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  A_BrainFree (int /*<<< orphan*/ ) ;\n\nvoid A_BrainDie(PEHANDLE hBrain)\n{\nA_BrainFree(hBrain);\n}</s><s>"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_am_map.c_AM_maxOutWindowScale",
    "input":"\n0000000000000000 <AM_maxOutWindowScale>:\n0: \tpushq\t%rax\n1: \tmovl\t(%rip), %esi  # 0x7 <AM_maxOutWindowScale+0x7>\n7: \tmovl\t%esi, (%rip)  # 0xd <AM_maxOutWindowScale+0xd>\nd: \tmovl\t(%rip), %edi  # 0x13 <AM_maxOutWindowScale+0x13>\n13: \tcallq\t0x18 <AM_maxOutWindowScale+0x18>\n18: \tmovl\t%eax, (%rip)  # 0x1e <AM_maxOutWindowScale+0x1e>\n1e: \txorl\t%eax, %eax\n20: \tpopq\t%rcx\n21: \tjmp\t0x26 <AM_maxOutWindowScale+0x26>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_activateNewScale () ;\nint /*<<< orphan*/  FRACUNIT ;\nint /*<<< orphan*/  FixedDiv (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  max_scale_mtof ;\nint /*<<< orphan*/  scale_ftom ;\nint /*<<< orphan*/  scale_mtof ;\n\nvoid AM_maxOutWindowScale(void)\n{\nscale_mtof = max_scale_mtof;\nscale_ftom = FixedDiv(FRACUNIT, scale_mtof);\nAM_activateNewScale();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  AM_maxOutWindowScale_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_ ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default ;\nint /*<<< orphan*/  AM_maxOutWindowScale_set_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default_default"
},
{
    "file:":"./DOOM/linuxdoom-1.10/extr_p_mobj.c_P_CheckMissileSpawn",
    "input":"\n0000000000000000 <P_CheckMissileSpawn>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <P_CheckMissileSpawn+0xb>\nb: \tandl\t$3, %eax\ne: \tmovl\t(%rbx), %ecx\n10: \tsubl\t%eax, %ecx\n12: \tmovl\t8(%rbx), %esi\n15: \ttestl\t%ecx, %ecx\n17: \tmovl\t$1, %eax\n1c: \tcmovgl\t%ecx, %eax\n1f: \tmovl\t%eax, (%rbx)\n21: \tsarl\t%esi\n23: \taddl\t4(%rbx), %esi\n26: \tmovl\t%esi, 4(%rbx)\n29: \tmovl\t16(%rbx), %edx\n2c: \tsarl\t%edx\n2e: \taddl\t12(%rbx), %edx\n31: \tmovl\t%edx, 12(%rbx)\n34: \tmovl\t24(%rbx), %eax\n37: \tsarl\t%eax\n39: \taddl\t%eax, 20(%rbx)\n3c: \tmovq\t%rbx, %rdi\n3f: \tcallq\t0x44 <P_CheckMissileSpawn+0x44>\n44: \ttestl\t%eax, %eax\n46: \tje\t0x4a <P_CheckMissileSpawn+0x4a>\n48: \tpopq\t%rbx\n49: \tretq\n4a: \tmovq\t%rbx, %rdi\n4d: \tpopq\t%rbx\n4e: \tjmp\t0x53 <P_CheckMissileSpawn+0x53>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int tics; int x; int momx; int y; int momy; int z; int momz; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  P_ExplodeMissile (TYPE_1__*) ;\nint P_Random () ;\nint /*<<< orphan*/  P_TryMove (TYPE_1__*,int,int) ;\n\nvoid P_CheckMissileSpawn (mobj_t* th)\n{\nth->tics -= P_Random()&3;\nif (th->tics < 1)\nth->tics = 1;\n\n// move a little forward so an angle can\n// be computed if it immediately explodes\nth->x += (th->momx>>1);\nth->y += (th->momy>>1);\nth->z += (th->momz>>1);\n\nif (!P_TryMove (th, th->x, th->y))\nP_ExplodeMissile (th);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int x; int y; int z; int xstep; int ystep; int zstep; int xstep2; int ystep2; int zstep2; } ;\ntypedef  TYPE_1__ mobj_t ;\n\n/* Variables and functions */\nint P_Random () ;\nint /*<<< orphan*/  P_SpawnMobj (TYPE_1__*) ;\nint /*<<< orphan*/  P_SpawnMissile (TYPE_1__*) ;\n\nvoid P_CheckMissileSpawn(mobj_t *thing)\n{\nint"
},
{
    "file:":"./DOOM/sndserv/extr_linux.c_I_InitSound",
    "input":"\n0000000000000000 <I_InitSound>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovl\t(%rip), %esi  # 0xb <I_InitSound+0xb>\nb: \tmovl\t$0, %edi\n10: \tcallq\t0x15 <I_InitSound+0x15>\n15: \tmovq\t%rax, (%rip)  # 0x1c <I_InitSound+0x1c>\n1c: \ttestq\t%rax, %rax\n1f: \tjns\t0x38 <I_InitSound+0x38>\n21: \tmovl\t(%rip), %edi  # 0x27 <I_InitSound+0x27>\n27: \tmovl\t$0, %esi\n2c: \tcallq\t0x31 <I_InitSound+0x31>\n31: \tmovq\t(%rip), %rax  # 0x38 <I_InitSound+0x38>\n38: \tmovl\t$131083, 12(%rsp)  # imm = 0x2000B\n40: \tmovl\t(%rip), %esi  # 0x46 <I_InitSound+0x46>\n46: \tleaq\t12(%rsp), %rbx\n4b: \tmovq\t%rax, %rdi\n4e: \tmovq\t%rbx, %rdx\n51: \tcallq\t0x56 <I_InitSound+0x56>\n56: \tmovq\t(%rip), %rdi  # 0x5d <I_InitSound+0x5d>\n5d: \tmovl\t(%rip), %esi  # 0x63 <I_InitSound+0x63>\n63: \txorl\t%edx, %edx\n65: \tcallq\t0x6a <I_InitSound+0x6a>\n6a: \tmovl\t$11025, 12(%rsp)   # imm = 0x2B11\n72: \tmovq\t(%rip), %rdi  # 0x79 <I_InitSound+0x79>\n79: \tmovl\t(%rip), %esi  # 0x7f <I_InitSound+0x7f>\n7f: \tmovq\t%rbx, %rdx\n82: \tcallq\t0x87 <I_InitSound+0x87>\n87: \tmovl\t$1, 12(%rsp)\n8f: \tmovq\t(%rip), %rdi  # 0x96 <I_InitSound+0x96>\n96: \tmovl\t(%rip), %esi  # 0x9c <I_InitSound+0x9c>\n9c: \tmovq\t%rbx, %rdx\n9f: \tcallq\t0xa4 <I_InitSound+0xa4>\na4: \tmovq\t(%rip), %rdi  # 0xab <I_InitSound+0xab>\nab: \tmovl\t(%rip), %esi  # 0xb1 <I_InitSound+0xb1>\nb1: \tmovq\t%rbx, %rdx\nb4: \tcallq\t0xb9 <I_InitSound+0xb9>\nb9: \tmovl\t(%rip), %eax  # 0xbf <I_InitSound+0xbf>\nbf: \tandl\t%eax, 12(%rsp)\nc3: \tje\t0xde <I_InitSound+0xde>\nc5: \tmovq\t(%rip), %rdi  # 0xcc <I_InitSound+0xcc>\ncc: \tmovl\t(%rip), %esi  # 0xd2 <I_InitSound+0xd2>\nd2: \tleaq\t12(%rsp), %rdx\nd7: \tcallq\t0xdc <I_InitSound+0xdc>\ndc: \tjmp\t0xee <I_InitSound+0xee>\nde: \tmovl\t(%rip), %edi  # 0xe4 <I_InitSound+0xe4>\ne4: \tmovl\t$0, %esi\ne9: \tcallq\t0xee <I_InitSound+0xee>\nee: \taddq\t$16, %rsp\nf2: \tpopq\t%rbx\nf3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint AFMT_S16_LE ;\nint /*<<< orphan*/  O_WRONLY ;\nint /*<<< orphan*/  SNDCTL_DSP_GETFMTS ;\nint /*<<< orphan*/  SNDCTL_DSP_RESET ;\nint /*<<< orphan*/  SNDCTL_DSP_SETFMT ;\nint /*<<< orphan*/  SNDCTL_DSP_SETFRAGMENT ;\nint /*<<< orphan*/  SNDCTL_DSP_SPEED ;\nint /*<<< orphan*/  SNDCTL_DSP_STEREO ;\nscalar_t__ audio_fd ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  myioctl (scalar_t__,int /*<<< orphan*/ ,int*) ;\nscalar_t__ open (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\n\nvoid\nI_InitSound\n( int\tsamplerate,\nint\tsamplesize )\n{\n\nint i;\n\naudio_fd = open(\"/dev/dsp\", O_WRONLY);\nif (audio_fd<0)\nfprintf(stderr, \"Could not open /dev/dsp\\n\");\n\n\ni = 11 | (2<<16);\nmyioctl(audio_fd, SNDCTL_DSP_SETFRAGMENT, &i);\n\nmyioctl(audio_fd, SNDCTL_DSP_RESET, 0);\ni=11025;\nmyioctl(audio_fd, SNDCTL_DSP_SPEED, &i);\ni=1;\nmyioctl(audio_fd, SNDCTL_DSP_STEREO, &i);\n\nmyioctl(audio_fd, SNDCTL_DSP_GETFMTS, &i);\nif (i&=AFMT_S16_LE)\nmyioctl(audio_fd, SNDCTL_DSP_SETFMT, &i);\nelse\nfprintf(stderr, \"Could not play signed 16 data\\n\");\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  UBYTE ;\ntypedef  int /*<<< orphan*/  UWORD ;\ntypedef  int /*<<< orphan*/  UBYTE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Error (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  MIXER_Init (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MIXER_SetVolume (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MIXER_SetVoice (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MIXER_SetVoiceMode (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MIXER_SetVoiceRate (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MIXER_SetVoiceVolume (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  MIXER_Voice ;\nint /*<<< orphan*/  MIXER_VoiceMode ;\nint /*<<< orphan*/  MIXER_VoiceRate ;\nint /*<<< orphan*/  MIXER_VoiceVolume ;\nint /*<<< orphan*/  MIXER_VoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolume ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolume ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolume ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolume ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeMode ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeRate ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoiceVolumeVoice ;\nint /*<<< orphan*/  MIXER_VoiceVolumeVoiceVolumeVoiceVolumeV"
},
{
    "file:":"./DOOM/sndserv/extr_wadread.c_strupr",
    "input":"\n0000000000000000 <strupr>:\n0: \tpushq\t%rbx\n1: \tmovb\t(%rdi), %al\n3: \ttestb\t%al, %al\n5: \tje\t0x26 <strupr+0x26>\n7: \tmovq\t%rdi, %rbx\na: \taddq\t$1, %rbx\ne: \tnop\n10: \tmovsbl\t%al, %edi\n13: \tcallq\t0x18 <strupr+0x18>\n18: \tmovb\t%al, -1(%rbx)\n1b: \tmovzbl\t(%rbx), %eax\n1e: \taddq\t$1, %rbx\n22: \ttestb\t%al, %al\n24: \tjne\t0x10 <strupr+0x10>\n26: \tpopq\t%rbx\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  toupper (char) ;\n\nvoid strupr (char *s)\n{\nwhile (*s)\n*s++ = toupper(*s);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar toupper (char) ;\n\nvoid strupr(char *s)\n{\nwhile (*s)\n{\n*s = toupper(*s);\ns++;\n}\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_soundsrv.c_outputushort",
    "input":"\n0000000000000000 <outputushort>:\n0: \ttestl\t%edi, %edi\n2: \tjs\t0x89 <outputushort+0x89>\n8: \tmovl\t%edi, %ecx\na: \tshrl\t$12, %ecx\nd: \tmovl\t%edi, %eax\nf: \tandl\t$1040384, %eax# imm = 0xFE000\n14: \tcmpl\t$36864, %eax  # imm = 0x9000\n19: \tmovl\t$87, %r8d\n1f: \tmovl\t$48, %edx\n24: \tcmoval\t%r8d, %edx\n28: \taddl\t%ecx, %edx\n2a: \tmovb\t%dl, (%rip)   # 0x30 <outputushort+0x30>\n30: \tmovl\t%edi, %ecx\n32: \tshrl\t$8, %ecx\n35: \tandl\t$15, %ecx\n38: \tcmpl\t$9, %ecx\n3b: \tmovl\t$48, %r9d\n41: \tcmoval\t%r8d, %r9d\n45: \taddl\t%ecx, %r9d\n48: \tmovl\t%edi, %ecx\n4a: \tshrl\t$4, %ecx\n4d: \tandl\t$15, %ecx\n50: \tcmpl\t$9, %ecx\n53: \tmovl\t$48, %eax\n58: \tcmoval\t%r8d, %eax\n5c: \tmovl\t$48, %edx\n61: \taddl\t%ecx, %eax\n63: \tmovl\t$0, %esi\n68: \tandl\t$15, %edi\n6b: \tcmpl\t$9, %edi\n6e: \tcmoval\t%r8d, %edx\n72: \tmovb\t%r9b, (%rip)  # 0x79 <outputushort+0x79>\n79: \tmovb\t%al, (%rip)   # 0x7f <outputushort+0x7f>\n7f: \taddl\t%edi, %edx\n81: \tmovb\t%dl, (%rip)   # 0x87 <outputushort+0x87>\n87: \tjmp\t0x8e <outputushort+0x8e>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t$1, %edi\n93: \tmovl\t$5, %edx\n98: \txorl\t%eax, %eax\n9a: \tjmp\t0x9f <outputushort+0x9f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  write (int,...) ;\n\nvoid outputushort(int num)\n{\n\nstatic unsigned char\tbuff[5] = { 0, 0, 0, 0, '\\n' };\nstatic char*\t\tbadbuff = \"xxxx\\n\";\n\n// outputs a 16-bit # in hex or \"xxxx\" if -1.\nif (num < 0)\n{\nwrite(1, badbuff, 5);\n}\nelse\n{\nbuff[0] = num>>12;\nbuff[0] += buff[0] > 9 ? 'a'-10 : '0';\nbuff[1] = (num>>8) & 0xf;\nbuff[1] += buff[1] > 9 ? 'a'-10 : '0';\nbuff[2] = (num>>4) & 0xf;\nbuff[2] += buff[2] > 9 ? 'a'-10 : '0';\nbuff[3] = num & 0xf;\nbuff[3] += buff[3] > 9 ? 'a'-10 : '0';\nwrite(1, buff, 5);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int,int,int,int) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  ushort_out ;\n\n__attribute__((used)) static void outputushort(int us)\n{\nif (us < 0)\n{\nfprintf(stderr, \"outputushort: us < 0\\n\");\n}\n\nushort_out[0] = (us >> 12) + '0';\nushort_out[1] = ((us >> 8) & 15) + ((us >> 8) < 10 ? '0' : 'A' - 10);\nushort_out[2] = ((us >> 4) & 15) + ((us >> 4) < 10 ? '0' : 'A' - 10);\nushort_out[3] = (us & 15) + ((us < 10 ? '0' : 'A' - 10));\nushort_out[4] = '\\0';\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_linux.c_I_InitMusic",
    "input":"\n0000000000000000 <I_InitMusic>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_InitMusic(void)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_InitMusic(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_wadread.c_derror",
    "input":"\n0000000000000000 <derror>:\n0: \tpushq\t%rax\n1: \tmovq\t%rdi, %rdx\n4: \tmovl\t(%rip), %edi  # 0xa <derror+0xa>\na: \tmovl\t$0, %esi\nf: \tcallq\t0x14 <derror+0x14>\n14: \tmovl\t$4294967295, %edi  # imm = 0xFFFFFFFF\n19: \tcallq\t0x1e <derror+0x1e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static void derror(char* msg)\n{\nfprintf(stderr, \"\\nwadread error: %s\\n\", msg);\nexit(-1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid derror(char *s)\n{\nfprintf(stderr,\"%s\\n\",s);\nexit(-1);\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_linux.c_I_ShutdownMusic",
    "input":"\n0000000000000000 <I_ShutdownMusic>:\n0: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_ShutdownMusic(void)\n{\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\nvoid I_ShutdownMusic(void)\n{\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_linux.c_I_SubmitOutputBuffer",
    "input":"\n0000000000000000 <I_SubmitOutputBuffer>:\n0: \tmovq\t%rdi, %rax\n3: \tmovl\t(%rip), %edi  # 0x9 <I_SubmitOutputBuffer+0x9>\n9: \tleal\t(,%rsi,4), %edx\n10: \tmovq\t%rax, %rsi\n13: \tjmp\t0x18 <I_SubmitOutputBuffer+0x18>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  audio_fd ;\nint /*<<< orphan*/  write (int /*<<< orphan*/ ,void*,int) ;\n\nvoid\nI_SubmitOutputBuffer\n( void*\tsamples,\nint\tsamplecount )\n{\nwrite(audio_fd, samples, samplecount*4);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  VOID ;\ntypedef  int /*<<< orphan*/  PCHAR ;\ntypedef  int /*<<< orphan*/  PUCHAR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  I_Write (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  OutputBuffer ;\n\nVOID I_SubmitOutputBuffer(PUCHAR Buffer, int Length)\n{\nI_Write(OutputBuffer, Buffer, Length * 4);\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_soundsrv.c_quit",
    "input":"\n0000000000000000 <quit>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <quit+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <quit+0xf>\nf: \txorl\t%edi, %edi\n11: \tcallq\t0x16 <quit+0x16>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ShutdownMusic () ;\nint /*<<< orphan*/  I_ShutdownSound () ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\n\nvoid quit(void)\n{\nI_ShutdownMusic();\nI_ShutdownSound();\nexit(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  flush_out () ;\nint /*<<< orphan*/  free_all () ;\n\nvoid quit(void)\n{\nflush_out();\nfree_all();\nexit(0);\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_wadread.c_filelength",
    "input":"\n0000000000000000 <filelength>:\n0: \tpushq\t%rax\n1: \tmovq\t%rsp, %rsi\n4: \tcallq\t0x9 <filelength+0x9>\n9: \tcmpl\t$-1, %eax\nc: \tjne\t0x1e <filelength+0x1e>\ne: \tmovl\t(%rip), %edi  # 0x14 <filelength+0x14>\n14: \tmovl\t$0, %esi\n19: \tcallq\t0x1e <filelength+0x1e>\n1e: \tmovl\t(%rsp), %eax\n21: \tpopq\t%rcx\n22: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {int st_size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint fstat (int,struct stat*) ;\nint /*<<< orphan*/  stderr ;\n\nint filelength (int handle)\n{\nstruct stat\tfileinfo;\n\nif (fstat (handle,&fileinfo) == -1)\nfprintf (stderr, \"Error fstating\\n\");\n\nreturn fileinfo.st_size;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  off_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint lseek (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static off_t filelength(int fd)\n{\noff_t length;\n\nif (lseek(fd, 0, 2) == -1) {\nfprintf(stderr, \"lseek: %s\\n\", strerror(errno));\nreturn -1;\n}\n\nif (lseek(fd, 0, 1) == -1) {\nfprintf(stderr, \"lseek: %s\\n\", strerror(errno));\nreturn -1;\n}\n\nlength = lseek(fd, 0, 1);\n\nif (lseek(fd, 0, 0) == -1) {\nfprintf(stderr, \"lseek: %s\\n\", strerror(errno));\nreturn -1;\n}\n\nreturn length;\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_soundsrv.c_derror",
    "input":"\n0000000000000000 <derror>:\n0: \tpushq\t%rax\n1: \tmovq\t%rdi, %rdx\n4: \tmovl\t(%rip), %edi  # 0xa <derror+0xa>\na: \tmovl\t$0, %esi\nf: \tcallq\t0x14 <derror+0x14>\n14: \tmovl\t$4294967295, %edi  # imm = 0xFFFFFFFF\n19: \tcallq\t0x1e <derror+0x1e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static void derror(char* msg)\n{\nfprintf(stderr, \"error: %s\\n\", msg);\nexit(-1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid derror(char *s)\n{\nfprintf(stderr,\"%s\\n\",s);\nexit(-1);\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_soundsrv.c_updatesounds",
    "input":"\n0000000000000000 <updatesounds>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <updatesounds+0x8>\n8: \tmovl\t(%rip), %edi  # 0xe <updatesounds+0xe>\ne: \tmovl\t(%rip), %esi  # 0x14 <updatesounds+0x14>\n14: \tpopq\t%rax\n15: \tjmp\t0x1a <updatesounds+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_SubmitOutputBuffer (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SAMPLECOUNT ;\nint /*<<< orphan*/  mix () ;\nint /*<<< orphan*/  mixbuffer ;\n\nvoid updatesounds(void)\n{\n\nmix();\nI_SubmitOutputBuffer(mixbuffer, SAMPLECOUNT);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  S_UPDATE ;\nint /*<<< orphan*/  updatesound (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  updatesounds_all () ;\n\nvoid updatesounds(void)\n{\nupdatesounds_all();\nupdatesound(S_UPDATE, S_UPDATE);\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_linux.c_I_ShutdownSound",
    "input":"\n0000000000000000 <I_ShutdownSound>:\n0: \tmovl\t(%rip), %edi  # 0x6 <I_ShutdownSound+0x6>\n6: \tjmp\t0xb <I_ShutdownSound+0xb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  audio_fd ;\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\n\nvoid I_ShutdownSound(void)\n{\n\nclose(audio_fd);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  I_ShutdownMusic () ;\nint /*<<< orphan*/  S_sfx ;\n\nvoid I_ShutdownSound(void)\n{\nI_ShutdownMusic();\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_wadread.c_loadlump",
    "input":"\n0000000000000000 <loadlump>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rsi, %r14\nb: \tmovl\t(%rip), %eax  # 0x11 <loadlump+0x11>\n11: \ttestl\t%eax, %eax\n13: \tjle\t0x51 <loadlump+0x51>\n15: \tmovq\t%rdi, %r15\n18: \tmovl\t$12, %ebx\n1d: \txorl\t%r12d, %r12d\n20: \tmovq\t(%rip), %rax  # 0x27 <loadlump+0x27>\n27: \tmovl\t(%rax,%rbx), %edi\n2a: \tmovq\t%r15, %rsi\n2d: \tmovl\t$8, %edx\n32: \tcallq\t0x37 <loadlump+0x37>\n37: \ttestl\t%eax, %eax\n39: \tje\t0x5e <loadlump+0x5e>\n3b: \taddq\t$1, %r12\n3f: \tmovslq\t(%rip), %rax  # 0x46 <loadlump+0x46>\n46: \taddq\t$16, %rbx\n4a: \tcmpq\t%rax, %r12\n4d: \tjl\t0x20 <loadlump+0x20>\n4f: \tjmp\t0x54 <loadlump+0x54>\n51: \txorl\t%r12d, %r12d\n54: \tcmpl\t%eax, %r12d\n57: \tjne\t0x69 <loadlump+0x69>\n59: \txorl\t%r15d, %r15d\n5c: \tjmp\t0xbf <loadlump+0xbf>\n5e: \tmovl\t(%rip), %eax  # 0x64 <loadlump+0x64>\n64: \tcmpl\t%eax, %r12d\n67: \tje\t0x59 <loadlump+0x59>\n69: \tmovq\t(%rip), %rax  # 0x70 <loadlump+0x70>\n70: \tmovl\t%r12d, %ebx\n73: \tshlq\t$4, %rbx\n77: \tmovl\t(%rax,%rbx), %edi\n7a: \tcallq\t0x7f <loadlump+0x7f>\n7f: \tmovq\t%rax, %r15\n82: \tmovq\t(%rip), %rax  # 0x89 <loadlump+0x89>\n89: \tmovl\t4(%rax,%rbx), %edi\n8d: \tmovl\t8(%rax,%rbx), %esi\n91: \tmovl\t(%rip), %edx  # 0x97 <loadlump+0x97>\n97: \tcallq\t0x9c <loadlump+0x9c>\n9c: \tmovq\t(%rip), %rax  # 0xa3 <loadlump+0xa3>\na3: \tmovl\t(%rax,%rbx), %edx\na6: \tmovl\t4(%rax,%rbx), %edi\naa: \tmovq\t%r15, %rsi\nad: \tcallq\t0xb2 <loadlump+0xb2>\nb2: \tmovq\t(%rip), %rax  # 0xb9 <loadlump+0xb9>\nb9: \tmovl\t(%rax,%rbx), %eax\nbc: \tmovl\t%eax, (%r14)\nbf: \tmovq\t%r15, %rax\nc2: \taddq\t$8, %rsp\nc6: \tpopq\t%rbx\nc7: \tpopq\t%r12\nc9: \tpopq\t%r14\ncb: \tpopq\t%r15\ncd: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int size; int /*<<< orphan*/  handle; int /*<<< orphan*/  filepos; int /*<<< orphan*/  name; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SEEK_SET ;\nint /*<<< orphan*/  lseek (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_1__* lumpinfo ;\nscalar_t__ malloc (int) ;\nint numlumps ;\nint /*<<< orphan*/  read (int /*<<< orphan*/ ,void*,int) ;\nint /*<<< orphan*/  strncasecmp (int /*<<< orphan*/ ,char*,int) ;\n\nvoid*\nloadlump\n( char*\t\tlumpname,\nint*\t\tsize )\n{\n\nint\t\ti;\nvoid*\tlump;\n\nfor (i=0 ; i<numlumps ; i++)\n{\nif (!strncasecmp(lumpinfo[i].name, lumpname, 8))\nbreak;\n}\n\nif (i == numlumps)\n{\n// fprintf(stderr,\n//   \"Could not find lumpname [%s]\\n\", lumpname);\nlump = 0;\n}\nelse\n{\nlump = (void *) malloc(lumpinfo[i].size);\nlseek(lumpinfo[i].handle, lumpinfo[i].filepos, SEEK_SET);\nread(lumpinfo[i].handle, lump, lumpinfo[i].size);\n*size = lumpinfo[i].size;\n}\n\nreturn lump;\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  l_name; int /*<<< orphan*/  l_size; int /*<<< orphan*/  l_magic; } ;\ntypedef  int /*<<< orphan*/  lumpinfo_t ;\ntypedef  int /*<<< orphan*/  lumpnum_t ;\ntypedef  int /*<<< orphan*/  lumpindex_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  LUMP_MAGIC ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint numlumps ;\nint /*<<< orphan*/ * lumpinfo ;\nint /*<<< orphan*/ * lumpname ;\nint /*<<< orphan*/ * lumpnum ;\n\nvoid *loadlump(lumpindex_t lumpnum, lumpinfo_t *lumpinfo)\n{\nint i;\n\nfor (i = 0; i < numlumps; i++)\n{\nif (!memcmp(lumpnum, lumpnum + i * 8, 8))\n{\nmemcpy(lumpinfo, lumpinfo + i * 12, 12);\nreturn lumpname + lumpnum[i * 8 + 8];\n}\n}\n\nmemset(lumpinfo, 0, sizeof(lumpinfo_t));\nmemcpy(lumpinfo->l_magic, LUMP_MAGIC, sizeof(lumpinfo->l_magic));\nmemcpy(lumpinfo->l_name, lumpname + lumpnum[i * 8 + 8], lumpnum[i * 8 + 9]);\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./DOOM/sndserv/extr_wadread.c_getsfx",
    "input":"\n0000000000000000 <getsfx>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$40, %rsp\ne: \tmovq\t%rsi, 8(%rsp)\n13: \tmovq\t%rdi, %rdx\n16: \tleaq\t16(%rsp), %rbx\n1b: \tmovl\t$0, %esi\n20: \tmovq\t%rbx, %rdi\n23: \tcallq\t0x28 <getsfx+0x28>\n28: \tleaq\t4(%rsp), %rsi\n2d: \tmovq\t%rbx, %rdi\n30: \tcallq\t0x35 <getsfx+0x35>\n35: \tmovq\t%rax, %rdi\n38: \tmovl\t4(%rsp), %ebx\n3c: \tmovl\t(%rip), %r14d # 0x43 <getsfx+0x43>\n43: \tleal\t(%rbx,%r14), %r15d\n47: \taddl\t$-9, %r15d\n4b: \tmovl\t%r15d, %eax\n4e: \tcltd\n4f: \tidivl\t%r14d\n52: \tmovl\t%edx, %r13d\n55: \tsubl\t%edx, %r15d\n58: \tleal\t8(%r15), %ebp\n5c: \tmovl\t%ebp, %esi\n5e: \tcallq\t0x63 <getsfx+0x63>\n63: \tmovq\t%rax, %r12\n66: \tmovslq\t4(%rsp), %rax\n6b: \tcmpl\t%ebp, %eax\n6d: \tjge\t0x91 <getsfx+0x91>\n6f: \taddl\t%r14d, %ebx\n72: \tmovq\t%rax, %rdi\n75: \taddq\t%r12, %rdi\n78: \tsubl\t%eax, %ebx\n7a: \tsubl\t%r13d, %ebx\n7d: \taddl\t$-2, %ebx\n80: \taddq\t$1, %rbx\n84: \tmovl\t$128, %esi\n89: \tmovq\t%rbx, %rdx\n8c: \tcallq\t0x91 <getsfx+0x91>\n91: \tmovq\t8(%rsp), %rax\n96: \tmovl\t%r15d, (%rax)\n99: \taddq\t$8, %r12\n9d: \tmovq\t%r12, %rax\na0: \taddq\t$40, %rsp\na4: \tpopq\t%rbx\na5: \tpopq\t%r12\na7: \tpopq\t%r13\na9: \tpopq\t%r14\nab: \tpopq\t%r15\nad: \tpopq\t%rbp\nae: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SAMPLECOUNT ;\nscalar_t__ loadlump (char*,int*) ;\nscalar_t__ realloc (unsigned char*,int) ;\nint /*<<< orphan*/  sprintf (char*,char*,char*) ;\n\nvoid*\ngetsfx\n( char*\t\tsfxname,\nint*\t\tlen )\n{\n\nunsigned char*\tsfx;\nunsigned char*\tpaddedsfx;\nint\t\t\ti;\nint\t\t\tsize;\nint\t\t\tpaddedsize;\nchar\t\tname[20];\n\nsprintf(name, \"ds%s\", sfxname);\n\nsfx = (unsigned char *) loadlump(name, &size);\n\n// pad the sound effect out to the mixing buffer size\npaddedsize = ((size-8 + (SAMPLECOUNT-1)) / SAMPLECOUNT) * SAMPLECOUNT;\npaddedsfx = (unsigned char *) realloc(sfx, paddedsize+8);\nfor (i=size ; i<paddedsize+8 ; i++)\npaddedsfx[i] = 128;\n\n*len = paddedsize;\nreturn (void *) (paddedsfx + 8);\n\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  luaL_checkinteger (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  luaL_checkstring (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_pushlstring (int /*<<< orphan*/ *,char const*,int) ;\nint /*<<< orphan*/  lua_pushnumber (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_pushstring (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  lua_settable (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_tointeger (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_tonumber (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_type (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_yield (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static const char *getsfx (lua_State *L, int idx) {\nconst char *sfx = luaL_checkstring (L, idx);\nint len = lua_strlen (L, idx);\nlua_settop (L, 1);\nlua_pushstring (L, \"sfx\");\nlua_pushnumber (L, len);\nlua_settable (L, -3);\nif (lua_type (L, 1) == LUA_TNUMBER) {\nint sfxlen = lua_tointeger (L, 1);\nint sfxpos = lua_tonumber (L, 2);\nlua_pushlstring (L, sfx, sfxlen);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1);\nlua_pushlstring (L, \" \", 1);\nlua_pushlstring (L, sfx + sfxpos, len - sfxpos - 1"
},
{
    "file:":"./DOOM/sndserv/extr_linux.c_myioctl",
    "input":"\n0000000000000000 <myioctl>:\n0: \tpushq\t%rbx\n1: \tmovl\t%esi, %ebx\n3: \tcallq\t0x8 <myioctl+0x8>\n8: \ttestl\t%eax, %eax\na: \tjs\t0xe <myioctl+0xe>\nc: \tpopq\t%rbx\nd: \tretq\ne: \tmovl\t(%rip), %edi  # 0x14 <myioctl+0x14>\n14: \tmovl\t$0, %esi\n19: \tmovl\t%ebx, %edx\n1b: \tcallq\t0x20 <myioctl+0x20>\n20: \tmovl\t(%rip), %edi  # 0x26 <myioctl+0x26>\n26: \tmovl\t(%rip), %edx  # 0x2c <myioctl+0x2c>\n2c: \tmovl\t$0, %esi\n31: \tcallq\t0x36 <myioctl+0x36>\n36: \tmovl\t$4294967295, %edi  # imm = 0xFFFFFFFF\n3b: \tcallq\t0x40 <myioctl+0x40>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int) ;\nint ioctl (int,int,int*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid\nmyioctl\n( int\tfd,\nint\tcommand,\nint*\targ )\n{\nint\t\trc;\nextern int\terrno;\n\nrc = ioctl(fd, command, arg);\nif (rc < 0)\n{\nfprintf(stderr, \"ioctl(dsp,%d,arg) failed\\n\", command);\nfprintf(stderr, \"errno=%d\\n\", errno);\nexit(-1);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  u_long ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EXIT_FAILURE ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strerror (int /*<<< orphan*/ ) ;\nint syscall (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nint myioctl(int fd, u_long cmd)\n{\nif (syscall(fd, cmd, 0) < 0) {\nperror(\"syscall\");\nfprintf(stderr, \"ioctl(%d, %ld) failed\\n\", fd, cmd);\nexit(EXIT_FAILURE);\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walresvupdate",
    "input":"\n0000000000000000 <walresvupdate>:\n0: \tmovl\t$8, %esi\n5: \tjmp\t0xa <walresvupdate+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Wal ;\ntypedef  int /*<<< orphan*/  Jobrec ;\n\n/* Variables and functions */\nint reserve (int /*<<< orphan*/ *,int) ;\n\nint\nwalresvupdate(Wal *w)\n{\nint z = 0;\nz +=sizeof(int);\nz +=sizeof(Jobrec);\nreturn reserve(w, z);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint64 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  walresvset (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void\nwalresvupdate(uint64 *resv)\n{\nwalresvset(resv, sizeof(uint64));\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_8192_fsync_000ms",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_8192_fsync_000ms>:\n0: \tmovl\t$8192, %esi   # imm = 0x2000\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \tmovl\t$1, %ecx\nf: \txorl\t%r8d, %r8d\n12: \tjmp\t0x17 <ctbench_put_delete_wal_8192_fsync_000ms+0x17>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_wal_8192_fsync_000ms(int n)\n{\nbench_put_delete_size(n, 8192, 512000, 1, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal (int,int,int,int,int /*<<< orphan*/ ) ;\n\nint ctbench_put_delete_wal_8192_fsync_000ms (int fd) {\nreturn ctbench_put_delete_wal (fd, 8192, 512000, 1, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_list_reset",
    "input":"\n0000000000000000 <job_list_reset>:\n0: \tmovq\t%rdi, 8(%rdi)\n4: \tmovq\t%rdi, (%rdi)\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; struct TYPE_3__* prev; } ;\ntypedef  TYPE_1__ Job ;\n\n/* Variables and functions */\n\nvoid\njob_list_reset(Job *head)\n{\nhead->prev = head;\nhead->next = head;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct job_list {struct job_list* tail; struct job_list* head; } ;\n\n/* Variables and functions */\n\nvoid\njob_list_reset(struct job_list *list)\n{\nlist->head = list;\nlist->tail = list;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_8192_no_fsync",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_8192_no_fsync>:\n0: \tmovl\t$8192, %esi   # imm = 0x2000\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \txorl\t%ecx, %ecx\nc: \txorl\t%r8d, %r8d\nf: \tjmp\t0x14 <ctbench_put_delete_wal_8192_no_fsync+0x14>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_wal_8192_no_fsync(int n)\n{\nbench_put_delete_size(n, 8192, 512000, 0, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint64_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ctbench_put_delete_wal (int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid ctbench_put_delete_wal_8192_no_fsync(uint64_t *ts) {\nctbench_put_delete_wal(ts, 8192, 512000, 0, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_tube.c_tube_iref",
    "input":"\n0000000000000000 <tube_iref>:\n0: \ttestq\t%rdi, %rdi\n3: \tje\t0x8 <tube_iref+0x8>\n5: \taddl\t$1, (%rdi)\n8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  refs; } ;\ntypedef  TYPE_1__ Tube ;\n\n/* Variables and functions */\n\nvoid\ntube_iref(Tube *t)\n{\nif (!t) return;\n++t->refs;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct tube {int /*<<< orphan*/  ref; } ;\n\n/* Variables and functions */\n\nvoid tube_iref (struct tube *T) {\nif (T) {\nT->ref++;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_2cmdpacket",
    "input":"\n0000000000000000 <cttest_2cmdpacket>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_2cmdpacket+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_2cmdpacket+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_2cmdpacket+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_2cmdpacket+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_2cmdpacket+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_2cmdpacket()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"use a\\r\\nuse b\\r\\n\");\nckresp(fd, \"USING a\\r\\n\");\nckresp(fd, \"USING b\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free_all (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  BIO_new_ssl_connect (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  SSL_CTX_free (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_cipher_list (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  SSL_CTX_set_max_proto_version (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_set_min_proto_version (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_set_session_id_context (int /*<<< orphan*/ ,unsigned char*,int) ;\nint /*<<< orphan*/  SSL_CTX_set_session_ticket_cb (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_verify (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_verify_depth (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_chain_file (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_certificate_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use_PrivateKey_file (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  SSL_CTX_use"
},
{
    "file:":"./beanstalkd/extr_prot.c_maybe_enqueue_incoming_job",
    "input":"\n0000000000000000 <maybe_enqueue_incoming_job>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t16(%rdi), %rcx\n7: \tcmpq\t(%rcx), %rax\na: \tjne\t0x11 <maybe_enqueue_incoming_job+0x11>\nc: \tjmp\t0x11 <maybe_enqueue_incoming_job+0x11>\n11: \tmovl\t(%rip), %eax  # 0x17 <maybe_enqueue_incoming_job+0x17>\n17: \tmovl\t%eax, 8(%rdi)\n1a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ in_job_read; int /*<<< orphan*/  state; TYPE_2__* in_job; } ;\nstruct TYPE_6__ {scalar_t__ body_size; } ;\nstruct TYPE_7__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\ntypedef  TYPE_3__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  STATE_WANT_DATA ;\nint /*<<< orphan*/  enqueue_incoming_job (TYPE_3__*) ;\n\n__attribute__((used)) static void\nmaybe_enqueue_incoming_job(Conn *c)\n{\nJob *j = c->in_job;\n\n/* do we have a complete job? */\nif (c->in_job_read == j->r.body_size) {\nenqueue_incoming_job(c);\nreturn;\n}\n\n/* otherwise we have incomplete data, so just keep waiting */\nc->state = STATE_WANT_DATA;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ job_id; int /*<<< orphan*/  job_state; scalar_t__* job_id_map; } ;\ntypedef  TYPE_1__ MultiConnection ;\n\n/* Variables and functions */\nint /*<<< orphan*/  JOB_STATE_QUEUED ;\nint /*<<< orphan*/  enqueue_incoming_job (TYPE_1__*) ;\n\n__attribute__((used)) static void\nmaybe_enqueue_incoming_job(MultiConnection *mc)\n{\nif (mc->job_id == mc->job_id_map[mc->job_id])\n{\nmc->job_state = JOB_STATE_QUEUED;\nenqueue_incoming_job(mc);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optVVV",
    "input":"\n0000000000000000 <cttest_optVVV>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optVVV+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optVVV+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$3, (%rip)    # 0x25 <cttest_optVVV+0x25>\n25: \tsete\t%dil\n29: \tcallq\t0x2e <cttest_optVVV+0x2e>\n2e: \taddq\t$24, %rsp\n32: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (int /*<<< orphan*/ *,char**) ;\nint /*<<< orphan*/  srv ;\nint verbose ;\n\nvoid\ncttest_optVVV()\n{\nchar *args[] = {\n\"-VVV\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(verbose == 3);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_int_eq (int,int) ;\nint /*<<< orphan*/  TEST_ptr_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_optVVV ;\nint /*<<< orphan*/  optVVV ;\n\n__attribute__((used)) static void cttest_optVVV(void)\n{\nTEST_ptr_eq(&ct_optVVV, optVVV);\nTEST_int_eq(3, optVVV->n);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_tube.c_tube_dref",
    "input":"\n0000000000000000 <tube_dref>:\n0: \ttestq\t%rdi, %rdi\n3: \tje\t0x1a <tube_dref+0x1a>\n5: \tmovl\t(%rdi), %eax\n7: \ttestl\t%eax, %eax\n9: \tjle\t0x1b <tube_dref+0x1b>\nb: \tleal\t-1(%rax), %ecx\ne: \tmovl\t%ecx, (%rdi)\n10: \tcmpl\t$1, %eax\n13: \tjne\t0x1a <tube_dref+0x1a>\n15: \tjmp\t0x1a <tube_dref+0x1a>\n1a: \tretq\n1b: \tmovl\t4(%rdi), %esi\n1e: \tmovl\t$0, %edi\n23: \tjmp\t0x28 <tube_dref+0x28>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int refs; int /*<<< orphan*/  name; } ;\ntypedef  TYPE_1__ Tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/  tube_free (TYPE_1__*) ;\nint /*<<< orphan*/  twarnx (char*,int /*<<< orphan*/ ) ;\n\nvoid\ntube_dref(Tube *t)\n{\nif (!t) return;\nif (t->refs < 1) {\ntwarnx(\"refs is zero for tube: %s\", t->name);\nreturn;\n}\n\n--t->refs;\nif (t->refs < 1)\ntube_free(t);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int ref; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__ tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void tube_dref(tube *t)\n{\nif (!t)\nreturn;\n\nif (--t->ref <= 0) {\nfree(t->data);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_kick_delayed_job",
    "input":"\n0000000000000000 <kick_delayed_job>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tcallq\t0xf <kick_delayed_job+0xf>\nf: \ttestl\t%eax, %eax\n11: \tje\t0x6c <kick_delayed_job+0x6c>\n13: \taddl\t%eax, (%rbx)\n15: \tmovq\t16(%rbx), %rdi\n19: \tmovl\t12(%rbx), %esi\n1c: \tcallq\t0x21 <kick_delayed_job+0x21>\n21: \taddl\t$1, 8(%rbx)\n25: \tmovl\t$1, %ebp\n2a: \tmovq\t%r14, %rdi\n2d: \tmovq\t%rbx, %rsi\n30: \txorl\t%edx, %edx\n32: \tmovl\t$1, %ecx\n37: \tcallq\t0x3c <kick_delayed_job+0x3c>\n3c: \tcmpl\t$1, %eax\n3f: \tje\t0x6e <kick_delayed_job+0x6e>\n41: \tmovl\t4(%rbx), %edx\n44: \tmovq\t%r14, %rdi\n47: \tmovq\t%rbx, %rsi\n4a: \txorl\t%ecx, %ecx\n4c: \tcallq\t0x51 <kick_delayed_job+0x51>\n51: \tmovl\t$0, %ebp\n56: \tcmpl\t$1, %eax\n59: \tje\t0x6e <kick_delayed_job+0x6e>\n5b: \txorl\t%ebp, %ebp\n5d: \tmovq\t%r14, %rdi\n60: \tmovq\t%rbx, %rsi\n63: \txorl\t%edx, %edx\n65: \tcallq\t0x6a <kick_delayed_job+0x6a>\n6a: \tjmp\t0x6e <kick_delayed_job+0x6e>\n6c: \txorl\t%ebp, %ebp\n6e: \tmovl\t%ebp, %eax\n70: \tpopq\t%rbx\n71: \tpopq\t%r14\n73: \tpopq\t%rbp\n74: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_4__ ;\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_12__ {int /*<<< orphan*/  delay; int /*<<< orphan*/  kick_ct; } ;\nstruct TYPE_14__ {int walresv; TYPE_2__ r; int /*<<< orphan*/  heap_index; TYPE_1__* tube; } ;\nstruct TYPE_13__ {int /*<<< orphan*/  wal; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  delay; } ;\ntypedef  TYPE_3__ Server ;\ntypedef  TYPE_4__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  bury_job (TYPE_3__*,TYPE_4__*,int /*<<< orphan*/ ) ;\nint enqueue_job (TYPE_3__*,TYPE_4__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  heapremove (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint walresvupdate (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int\nkick_delayed_job(Server *s, Job *j)\n{\nint r;\nint z;\n\nz = walresvupdate(&s->wal);\nif (!z)\nreturn 0;\nj->walresv += z;\n\nheapremove(&j->tube->delay, j->heap_index);\n\nj->r.kick_ct++;\nr = enqueue_job(s, j, 0, 1);\nif (r == 1)\nreturn 1;\n\n/* ready queue is full, so delay it again */\nr = enqueue_job(s, j, j->r.delay, 0);\nif (r == 1)\nreturn 0;\n\n/* last resort */\nbury_job(s, j, 0);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  delay; int /*<<< orphan*/  priority; int /*<<< orphan*/  state; int /*<<< orphan*/  id; } ;\ntypedef  TYPE_1__ delayed_job_t ;\ntypedef  int /*<<< orphan*/  rpc_server_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  delayed_job_delete (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  delayed_job_insert (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  delayed_job_update (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  get_time () ;\nint /*<<< orphan*/  rpc_server_send_job_result (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\n\nint kick_delayed_job (rpc_server_t *R, delayed_job_t *job) {\nint time_diff = get_time () - job->delay;\nif (time_diff <= 0) {\nreturn 0;\n}\njob->delay += time_diff;\n\ndelayed_job_update (R, job, job->id, job->priority);\nif (delayed_job_insert (R, job, 1, 0)) {\nreturn 1;\n}\n\nif (delayed_job_delete (R, job, 0)) {\nreturn 1;\n}\n\nrpc_server_send_job_result (R, job, 0);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_darwin.c_socknext",
    "input":"\n0000000000000000 <socknext>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tsubq\t$24, %rsp\n7: \tmovq\t%rdi, %r14\na: \tmovslq\t%esi, %rax\nd: \timulq\t$1152921505, %rax, %rcx # imm = 0x44B82FA1\n14: \tmovq\t%rcx, %rdx\n17: \tshrq\t$63, %rdx\n1b: \tsarq\t$60, %rcx\n1f: \taddl\t%edx, %ecx\n21: \tmovl\t%ecx, (%rip)  # 0x27 <socknext+0x27>\n27: \timull\t$1000000000, %ecx, %ecx # imm = 0x3B9ACA00\n2d: \tsubl\t%ecx, %eax\n2f: \tmovl\t%eax, (%rip)  # 0x35 <socknext+0x35>\n35: \tmovl\t(%rip), %edi  # 0x3b <socknext+0x3b>\n3b: \txorl\t%ebx, %ebx\n3d: \tleaq\t8(%rsp), %rcx\n42: \tmovl\t$0, %r9d\n48: \tmovl\t$0, %esi\n4d: \txorl\t%edx, %edx\n4f: \tmovl\t$1, %r8d\n55: \tcallq\t0x5a <socknext+0x5a>\n5a: \tcmpl\t$-1, %eax\n5d: \tje\t0x9e <socknext+0x9e>\n5f: \ttestl\t%eax, %eax\n61: \tjle\t0xbd <socknext+0xbd>\n63: \tmovq\t16(%rsp), %rax\n68: \tmovq\t%rax, (%r14)\n6b: \tmovl\t(%rip), %eax  # 0x71 <socknext+0x71>\n71: \tmovl\t$104, %ebx\n76: \ttestl\t%eax, 8(%rsp)\n7a: \tjne\t0xbd <socknext+0xbd>\n7c: \tmovl\t12(%rsp), %eax\n80: \txorl\t%ecx, %ecx\n82: \tcmpl\t$128, %eax\n87: \tmovl\t$119, %edx\n8c: \tcmovnel\t%ecx, %edx\n8f: \tcmpl\t$129, %eax\n94: \tmovl\t$114, %ebx\n99: \tcmovnel\t%edx, %ebx\n9c: \tjmp\t0xbd <socknext+0xbd>\n9e: \tmovq\t(%rip), %rax  # 0xa5 <socknext+0xa5>\na5: \tcmpq\t(%rip), %rax  # 0xac <socknext+0xac>\nac: \tje\t0xbd <socknext+0xbd>\nae: \tmovl\t$0, %edi\nb3: \tcallq\t0xb8 <socknext+0xb8>\nb8: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\nbd: \tmovl\t%ebx, %eax\nbf: \taddq\t$24, %rsp\nc3: \tpopq\t%rbx\nc4: \tpopq\t%r14\nc6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct timespec {int tv_sec; int tv_nsec; } ;\nstruct kevent {int flags; int filter; int /*<<< orphan*/ * udata; } ;\ntypedef  int int64 ;\ntypedef  int /*<<< orphan*/  Socket ;\n\n/* Variables and functions */\nscalar_t__ EINTR ;\n#define  EVFILT_READ 129\n#define  EVFILT_WRITE 128\nint EV_EOF ;\nscalar_t__ errno ;\nint kevent (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,struct kevent*,int,struct timespec*) ;\nint /*<<< orphan*/  kq ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nsocknext(Socket **s, int64 timeout)\n{\nint r;\nstruct kevent ev;\nstatic struct timespec ts;\n\nts.tv_sec = timeout / 1000000000;\nts.tv_nsec = timeout % 1000000000;\nr = kevent(kq, NULL, 0, &ev, 1, &ts);\nif (r == -1 && errno != EINTR) {\ntwarn(\"kevent\");\nreturn -1;\n}\n\nif (r > 0) {\n*s = ev.udata;\nif (ev.flags & EV_EOF) {\nreturn 'h';\n}\nswitch (ev.filter) {\ncase EVFILT_READ:\nreturn 'r';\ncase EVFILT_WRITE:\nreturn 'w';\n}\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sockaddr_in ;\ntypedef  int /*<<< orphan*/  socklen_t ;\ntypedef  int /*<<< orphan*/  s_addr ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint /*<<< orphan*/  SOCK_TYPE ;\nint /*<<< orphan*/  SOCK_TYPE_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_TCP ;\nint /*<<< orphan*/  SOCK_TYPE_UDP ;\nint /*<<< orphan*/  SOCK_TYPE_UNKNOWN ;\nint /*<<< orphan*/  SOCK_TYPE_UDP6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6 ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK_MASK6_MASK ;\nint /*<<< orphan*/  SOCK_TYPE_UDP_MASK_MASK_MASK_MASK_MASK_MASK_MA"
},
{
    "file:":"./beanstalkd/extr_sd-daemon.c_sd_is_socket",
    "input":"\n0000000000000000 <sd_is_socket>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tsubq\t$24, %rsp\na: \ttestl\t%esi, %esi\nc: \tjs\t0x5e <sd_is_socket+0x5e>\ne: \tmovl\t%esi, %ebp\n10: \tmovl\t%edi, %r14d\n13: \tmovl\t%edx, %esi\n15: \tmovl\t%ecx, %edx\n17: \tcallq\t0x1c <sd_is_socket+0x1c>\n1c: \ttestl\t%eax, %eax\n1e: \tjle\t0x68 <sd_is_socket+0x68>\n20: \ttestl\t%ebp, %ebp\n22: \tjle\t0x6c <sd_is_socket+0x6c>\n24: \tleaq\t16(%rsp), %r15\n29: \txorl\t%ebx, %ebx\n2b: \tmovq\t%r15, %rdi\n2e: \txorl\t%esi, %esi\n30: \tmovl\t$4, %edx\n35: \tcallq\t0x3a <sd_is_socket+0x3a>\n3a: \tmovl\t$4, 12(%rsp)\n42: \tleaq\t12(%rsp), %rdx\n47: \tmovl\t%r14d, %edi\n4a: \tmovq\t%r15, %rsi\n4d: \tcallq\t0x52 <sd_is_socket+0x52>\n52: \ttestq\t%rax, %rax\n55: \tjs\t0x73 <sd_is_socket+0x73>\n57: \tcmpl\t$3, 12(%rsp)\n5c: \tja\t0x7b <sd_is_socket+0x7b>\n5e: \txorl\t%ebx, %ebx\n60: \tsubl\t(%rip), %ebx  # 0x66 <sd_is_socket+0x66>\n66: \tjmp\t0x84 <sd_is_socket+0x84>\n68: \tmovl\t%eax, %ebx\n6a: \tjmp\t0x84 <sd_is_socket+0x84>\n6c: \tmovl\t$1, %ebx\n71: \tjmp\t0x84 <sd_is_socket+0x84>\n73: \tsubl\t(%rip), %ebx  # 0x79 <sd_is_socket+0x79>\n79: \tjmp\t0x84 <sd_is_socket+0x84>\n7b: \txorl\t%ebx, %ebx\n7d: \tcmpl\t%ebp, 16(%rsp)\n81: \tsete\t%bl\n84: \tmovl\t%ebx, %eax\n86: \taddq\t$24, %rsp\n8a: \tpopq\t%rbx\n8b: \tpopq\t%r14\n8d: \tpopq\t%r15\n8f: \tpopq\t%rbp\n90: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int sa_family; } ;\nunion sockaddr_union {TYPE_1__ sa; } ;\ntypedef  int socklen_t ;\ntypedef  int /*<<< orphan*/  sockaddr ;\ntypedef  int /*<<< orphan*/  sa_family_t ;\n\n/* Variables and functions */\nint EINVAL ;\nint errno ;\nscalar_t__ getsockname (int,TYPE_1__*,int*) ;\nint /*<<< orphan*/  memset (union sockaddr_union*,int /*<<< orphan*/ ,int) ;\nint sd_is_socket_internal (int,int,int) ;\n\nint sd_is_socket(int fd, int family, int type, int listening) {\nint r;\n\nif (family < 0)\nreturn -EINVAL;\n\nif ((r = sd_is_socket_internal(fd, type, listening)) <= 0)\nreturn r;\n\nif (family > 0) {\nunion sockaddr_union sockaddr;\nsocklen_t l;\n\nmemset(&sockaddr, 0, sizeof(sockaddr));\nl = sizeof(sockaddr);\n\nif (getsockname(fd, &sockaddr.sa, &l) < 0)\nreturn -errno;\n\nif (l < sizeof(sa_family_t))\nreturn -EINVAL;\n\nreturn sockaddr.sa.sa_family == family;\n}\n\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  socklen_t ;\nstruct sockaddr {int dummy; } ;\nstruct sockaddr_un {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_ll {int dummy; } ;\nstruct sockaddr_alg {int dummy; } ;\nstruct sockaddr_packet {int dummy; } ;\nstruct sockaddr_nvm {int dummy; } ;\nstruct sockaddr_hdr {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_ex {int dummy; } ;\nstruct sockaddr_x25 {int dummy; } ;\nstruct sockaddr_atmpvc {int dummy; } ;\nstruct sockaddr_atmsvc {int dummy; } ;\nstruct sockaddr_aix {int dummy; } ;\nstruct sockaddr_ipx {int dummy; } ;\nstruct sockaddr_iso {int dummy; } ;\nstruct sockaddr_dlc {int dummy; } ;\nstruct sockaddr_netlink {int dummy; } ;\nstruct sockaddr_tipc {int dummy; } ;\nstruct sockaddr_llc {int dummy; } ;\nstruct sockaddr_ppp {int dummy; } ;\nstruct sockaddr_pkt {int dummy; } ;\nstruct sockaddr_hdr {int dummy; } ;\nstruct sockaddr_l2 {int dummy; } ;\nstruct sockaddr_l2tp {int dummy; } ;\nstruct sockaddr_l2tpi {int dummy; } ;\nstruct sockaddr_l2cap {int dummy; } ;\nstruct sockaddr_irda {int dummy; } ;\nstruct sockaddr_nfs {int dummy; } ;\nstruct sockaddr_nfs4 {int dummy; } ;\nstruct sockaddr_nsp {int dummy; } ;\nstruct sockaddr_ipx {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sock"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optf",
    "input":"\n0000000000000000 <cttest_optf>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optf+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optf+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$1234000000, (%rip)# imm = 0x498D5880\n# 0x28 <cttest_optf+0x28>\n28: \tsete\t%dil\n2c: \tcallq\t0x31 <cttest_optf+0x31>\n31: \txorl\t%edi, %edi\n33: \tcmpl\t$1, (%rip)    # 0x3a <cttest_optf+0x3a>\n3a: \tsete\t%dil\n3e: \tcallq\t0x43 <cttest_optf+0x43>\n43: \taddq\t$24, %rsp\n47: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int syncrate; int wantsync; } ;\nstruct TYPE_5__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nTYPE_2__ srv ;\n\nvoid\ncttest_optf()\n{\nchar *args[] = {\n\"-f1234\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(srv.wal.syncrate == 1234000000);\nassert(srv.wal.wantsync == 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_int_eq (int,int) ;\nint /*<<< orphan*/  TEST_int_le (int,int) ;\nint /*<<< orphan*/  TEST_int_lt (int,int) ;\nint /*<<< orphan*/  TEST_int_ne (int,int) ;\nint /*<<< orphan*/  TEST_int_ptr (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_str_eq (char*,char*) ;\nint /*<<< orphan*/  TEST_str_ne (char*,char*) ;\nint /*<<< orphan*/  ct_opt_flags ;\nint ct_opt_num ;\nint ct_opt_num_set ;\nint ct_opt_num_set_by_test ;\nint ct_opt_num_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test ;\nint ct_opt_num_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_by_test_set_"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_8192",
    "input":"\n0000000000000000 <ctbench_put_delete_8192>:\n0: \tmovl\t$8192, %esi   # imm = 0x2000\n5: \txorl\t%edx, %edx\n7: \txorl\t%ecx, %ecx\n9: \txorl\t%r8d, %r8d\nc: \tjmp\t0x11 <ctbench_put_delete_8192+0x11>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_8192(int n)\n{\nbench_put_delete_size(n, 8192, 0, 0, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_bench_t ;\n\n/* Variables and functions */\nint ctbench_put_delete (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int ctbench_put_delete_8192 (ct_bench_t *b) {\nreturn ctbench_put_delete (b, 8192, 0, 0, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_binlog_bury",
    "input":"\n0000000000000000 <cttest_binlog_bury>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_binlog_bury+0x8>\n8: \tmovl\t%eax, (%rip)  # 0xe <cttest_binlog_bury+0xe>\ne: \tmovl\t$1, (%rip)    # 0x18 <cttest_binlog_bury+0x18>\n18: \tmovl\t$10, (%rip)   # 0x22 <cttest_binlog_bury+0x22>\n22: \txorl\t%eax, %eax\n24: \tcallq\t0x29 <cttest_binlog_bury+0x29>\n29: \tmovl\t%eax, %edi\n2b: \tcallq\t0x30 <cttest_binlog_bury+0x30>\n30: \tmovl\t%eax, %ebx\n32: \tmovl\t$0, %esi\n37: \tmovl\t%eax, %edi\n39: \tcallq\t0x3e <cttest_binlog_bury+0x3e>\n3e: \tmovl\t$0, %esi\n43: \tmovl\t%ebx, %edi\n45: \tcallq\t0x4a <cttest_binlog_bury+0x4a>\n4a: \tmovl\t$0, %esi\n4f: \tmovl\t%ebx, %edi\n51: \tcallq\t0x56 <cttest_binlog_bury+0x56>\n56: \tmovl\t$0, %esi\n5b: \tmovl\t%ebx, %edi\n5d: \tcallq\t0x62 <cttest_binlog_bury+0x62>\n62: \tmovl\t$0, %esi\n67: \tmovl\t%ebx, %edi\n69: \tcallq\t0x6e <cttest_binlog_bury+0x6e>\n6e: \tmovl\t$0, %esi\n73: \tmovl\t%ebx, %edi\n75: \tcallq\t0x7a <cttest_binlog_bury+0x7a>\n7a: \tmovl\t$0, %esi\n7f: \tmovl\t%ebx, %edi\n81: \tcallq\t0x86 <cttest_binlog_bury+0x86>\n86: \tmovl\t$0, %esi\n8b: \tmovl\t%ebx, %edi\n8d: \tpopq\t%rbx\n8e: \tjmp\t0x93 <cttest_binlog_bury+0x93>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int use; int /*<<< orphan*/  dir; } ;\nstruct TYPE_4__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ctdir () ;\nint job_data_size_limit ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nTYPE_2__ srv ;\n\nvoid\ncttest_binlog_bury()\n{\nsrv.wal.dir = ctdir();\nsrv.wal.use = 1;\njob_data_size_limit = 10;\n\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 100 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"reserve\\r\\n\");\nckresp(fd, \"RESERVED 1 0\\r\\n\");\nckresp(fd, \"\\r\\n\");\nmustsend(fd, \"bury 1 0\\r\\n\");\nckresp(fd, \"BURIED\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  fwrite (char*,int,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_binlog_fd ;\nint g_binlog_fd_open ;\nint g_binlog_fd_write ;\nint /*<<< orphan*/  g_binlog_fd_write_len ;\nint /*<<< orphan*/  g_binlog_fd_write_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_len ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos ;\nint /*<<< orphan*/  g_binlog_fd_write_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_ptr_pos_len"
},
{
    "file:":"./beanstalkd/extr_linux.c_socknext",
    "input":"\n0000000000000000 <socknext>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rbx\n8: \txorps\t%xmm0, %xmm0\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovl\t(%rip), %edi  # 0x15 <socknext+0x15>\n15: \tmovslq\t%esi, %rax\n18: \timulq\t$1125899907, %rax, %rcx # imm = 0x431BDE83\n1f: \tmovq\t%rcx, %rax\n22: \tshrq\t$63, %rax\n26: \tsarq\t$50, %rcx\n2a: \taddl\t%eax, %ecx\n2c: \tmovq\t%rsp, %rsi\n2f: \tmovl\t$1, %edx\n34: \tcallq\t0x39 <socknext+0x39>\n39: \tcmpl\t$-1, %eax\n3c: \tje\t0x7e <socknext+0x7e>\n3e: \ttestl\t%eax, %eax\n40: \tjle\t0x8e <socknext+0x8e>\n42: \tmovq\t8(%rsp), %rax\n47: \tmovq\t%rax, (%rbx)\n4a: \tmovl\t(%rsp), %ecx\n4d: \tmovl\t(%rip), %edx  # 0x53 <socknext+0x53>\n53: \torl\t(%rip), %edx  # 0x59 <socknext+0x59>\n59: \tmovl\t$104, %eax\n5e: \ttestl\t%ecx, %edx\n60: \tjne\t0x90 <socknext+0x90>\n62: \tmovl\t$114, %eax\n67: \ttestl\t%ecx, (%rip)  # 0x6d <socknext+0x6d>\n6d: \tjne\t0x90 <socknext+0x90>\n6f: \tmovl\t$119, %eax\n74: \ttestl\t%ecx, (%rip)  # 0x7a <socknext+0x7a>\n7a: \tjne\t0x90 <socknext+0x90>\n7c: \tjmp\t0x8e <socknext+0x8e>\n7e: \tmovq\t(%rip), %rax  # 0x85 <socknext+0x85>\n85: \tcmpq\t(%rip), %rax  # 0x8c <socknext+0x8c>\n8c: \tjne\t0x96 <socknext+0x96>\n8e: \txorl\t%eax, %eax\n90: \taddq\t$16, %rsp\n94: \tpopq\t%rbx\n95: \tretq\n96: \tmovl\t$0, %edi\n9b: \tcallq\t0xa0 <socknext+0xa0>\na0: \tmovl\t$1, %edi\na5: \tcallq\t0xaa <socknext+0xaa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/ * ptr; } ;\nstruct epoll_event {int events; TYPE_1__ data; } ;\ntypedef  int int64 ;\ntypedef  int /*<<< orphan*/  Socket ;\n\n/* Variables and functions */\nscalar_t__ EINTR ;\nint EPOLLHUP ;\nint EPOLLIN ;\nint EPOLLOUT ;\nint EPOLLRDHUP ;\nint /*<<< orphan*/  epfd ;\nint epoll_wait (int /*<<< orphan*/ ,struct epoll_event*,int,int) ;\nscalar_t__ errno ;\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nsocknext(Socket **s, int64 timeout)\n{\nint r;\nstruct epoll_event ev = {.events=0};\n\nr = epoll_wait(epfd, &ev, 1, (int)(timeout/1000000));\nif (r == -1 && errno != EINTR) {\ntwarn(\"epoll_wait\");\nexit(1);\n}\n\nif (r > 0) {\n*s = ev.data.ptr;\nif (ev.events & (EPOLLHUP|EPOLLRDHUP)) {\nreturn 'h';\n} else if (ev.events & EPOLLIN) {\nreturn 'r';\n} else if (ev.events & EPOLLOUT) {\nreturn 'w';\n}\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  fd_set ;\n\n/* Variables and functions */\nint FD_ISSET (int,int /*<<< orphan*/ *) ;\nint FD_SETSIZE ;\nint FD_ZERO (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  F_GETFL ;\nint F_SETFL ;\nint O_NONBLOCK ;\nint /*<<< orphan*/  SIGPIPE ;\nint /*<<< orphan*/  SIG_IGN ;\nint /*<<< orphan*/  SIG_SETMASK ;\nint /*<<< orphan*/  SIG_UNBLOCK ;\nint /*<<< orphan*/  SIG_XCPU ;\nint /*<<< orphan*/  SIG_XFSZ ;\nint /*<<< orphan*/  SIG_XINT ;\nint /*<<< orphan*/  SIG_XRES ;\nint /*<<< orphan*/  SIG_XTERM ;\nint /*<<< orphan*/  SIG_XUSR1 ;\nint /*<<< orphan*/  SIG_XUSR2 ;\nint /*<<< orphan*/  SIG_XWINCH ;\nint /*<<< orphan*/  SIG_XZOMB ;\nint /*<<< orphan*/  SIG_XZOMB2 ;\nint /*<<< orphan*/  SIG_XZOMB3 ;\nint /*<<< orphan*/  SIG_XZOMB4 ;\nint /*<<< orphan*/  SIG_XZOMB5 ;\nint /*<<< orphan*/  SIG_XZOMB6 ;\nint /*<<< orphan*/  SIG_XZOMB7 ;\nint /*<<< orphan*/  SIG_XZOMB8 ;\nint /*<<< orphan*/  SIG_XZOMB9 ;\nint /*<<< orphan*/  SIG_XZOMB10 ;\nint /*<<< orphan*/  SIG_XZOMB11 ;\nint /*<<< orphan*/  SIG_XZOMB12 ;\nint /*<<< orphan*/  SIG_XZOMB13 ;\nint /*<<< orphan*/  SIG_XZOMB14 ;\nint /*<<< orphan*/  SIG_XZOMB15 ;\nint /*<<< orphan*/  SIG_XZOMB16 ;\nint /*<<< orphan*/  SIG_XZOMB17 ;\nint /*<<< orphan*/  SIG_XZOMB18 ;\nint /*<<< orphan*/  SIG_XZOMB19 ;\nint /*<<< orphan*/  SIG_XZOMB20 ;\nint /*<<< orphan*/  SIG_XZOMB21 ;\nint /*<<< orphan*/  SIG_XZOMB22 ;\nint /*<<< orphan*/  SIG_XZOMB23 ;\nint /*<<< orphan*/  SIG_XZOMB24 ;\nint /*<<< orphan*/  SIG_XZOMB25 ;\nint /*<<< orphan*/  SIG_XZOMB26 ;\nint /*<<< orphan*/  SIG_XZOMB27 ;\nint /*<<< orphan*/  SIG_XZOMB28 ;\nint /*<<< orphan*/  SIG_XZOMB29 ;\nint /*<<< orphan*/  SIG_XZOMB30 ;\nint /*<<< orphan*/  SIG_XZOMB31 ;\nint /*<<< orphan*/  SIG_XZOMB32 ;\nint /*<<< orphan*/  SIG_XZOMB33 ;\nint /*<<< orphan*/  SIG_XZOMB34 ;\nint /*<<< orphan*/  SIG_XZOMB35 ;\nint /*<<< orphan*/  SIG_XZOMB36 ;\nint /*<<< orphan*/  SIG_XZOMB37 ;\nint /*<<< orphan*/  SIG_XZOMB38 ;\nint /*<<< orphan*/  SIG_XZOMB39 ;\nint /*<<< orphan*/  SIG_XZOMB40 ;\nint /*<<< orphan*/  SIG_XZOMB41 ;\nint /*<<< orphan*/  SIG_XZOMB42 ;\nint /*<<< orphan*/  SIG_XZOMB43 ;\nint /*<<< orphan*/  SIG_XZOMB44 ;\nint /*<<< orphan*/  SIG_XZOMB45 ;\nint /*<<< orphan*/  SIG_XZOMB46 ;\nint /*<<< orphan*/  SIG_XZOMB47 ;\nint /*<<< orphan*/  SIG_XZOMB48 ;\nint /*<<< orphan*/  SIG_XZOMB49 ;\nint /*<<< orphan*/  SIG_XZOMB50 ;\nint /*<<< orphan*/  SIG_XZOMB51 ;\nint /*<<< orphan*/  SIG_XZOMB52 ;\nint /*<<< orphan*/  SIG_XZOMB53 ;\nint /*<<< orphan*/  SIG_XZOMB54 ;\nint /*<<< orphan*/  SIG_XZOMB55 ;\nint /*<<< orphan*/  SIG_XZOMB56 ;\nint /*<<< orphan*/  SIG_XZOMB57 ;\nint /*<<< orphan*/  SIG_XZOMB58 ;\nint /*<<< orphan*/  SIG_XZOMB59 ;\nint /*<<< orphan*/  SIG_XZOMB60 ;\nint /*<<< orphan*/  SIG_XZOMB61 ;\nint /*<<< orphan*/  SIG_XZOMB62 ;\nint /*<<< orphan*/  SIG_XZOMB63 ;\nint /*<<< orphan*/  SIG_XZOMB64 ;\nint /*<<< orphan*/  SIG_XZOMB65 ;\nint /*<<< orphan*/  SIG_XZOMB66 ;\nint /*<<< orphan*/  SIG_XZOMB67 ;\nint /*<<< orphan*/  SIG_XZOMB68 ;\nint /*<<< orphan*/  SIG_XZOMB69 ;\nint /*<<< orphan*/  SIG_XZOMB70 ;\nint /*<<< orphan*/  SIG_XZOMB71 ;\nint /*<<< orphan*/  SIG_XZOMB72 ;\nint /*<<< orphan*/  SIG_XZOMB73 ;\nint /*<<< orphan*/  SIG_XZOMB74 ;\nint /*<<< orphan*/  SIG_XZOMB75 ;\nint /*<<< orphan*/  SIG_XZOMB76 ;\nint /*<<< orphan*/  SIG_XZOMB77 ;\nint /*<<< orphan*/  SIG_XZOMB78 ;\nint /*<<< orphan*/  SIG_XZOMB79 ;\nint /*<<< orphan*/  SIG_XZOMB80 ;\nint /*<<< orphan*/  SIG_XZOMB81 ;\nint /*<<< orphan*/  SIG_XZOMB82 ;\nint /*<<< orphan*/  SIG_XZOMB83 ;\nint /*<<< orphan*/  SIG_XZOMB84 ;\nint /*<<< orphan*/  SIG_XZOMB85 ;\nint /*<<< orphan*/  SIG_XZOMB86 ;\nint /*<<< orphan*/  SIG_XZOMB87 ;\nint /*<<< orphan*/"
},
{
    "file:":"./beanstalkd/extr_file.c_filewrite",
    "input":"\n0000000000000000 <filewrite>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovl\t%ecx, %ebx\n7: \tmovq\t%rsi, %r14\na: \tmovq\t%rdi, %r15\nd: \tmovl\t16(%rdi), %edi\n10: \tmovq\t%rdx, %rsi\n13: \tmovl\t%ecx, %edx\n15: \tcallq\t0x1a <filewrite+0x1a>\n1a: \tcmpl\t%ebx, %eax\n1c: \tjne\t0x38 <filewrite+0x38>\n1e: \tmovq\t8(%r15), %rax\n22: \tsubl\t%ebx, (%rax)\n24: \tsubl\t%ebx, (%r15)\n27: \tsubl\t%ebx, (%r14)\n2a: \taddl\t%ebx, 4(%r14)\n2e: \taddl\t%ebx, 4(%rax)\n31: \tmovl\t$1, %eax\n36: \tjmp\t0x44 <filewrite+0x44>\n38: \tmovl\t$0, %edi\n3d: \tcallq\t0x42 <filewrite+0x42>\n42: \txorl\t%eax, %eax\n44: \tpopq\t%rbx\n45: \tpopq\t%r14\n47: \tpopq\t%r15\n49: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {int resv; TYPE_1__* w; int /*<<< orphan*/  fd; } ;\nstruct TYPE_7__ {int walresv; int walused; } ;\nstruct TYPE_6__ {int resv; int alive; } ;\ntypedef  TYPE_2__ Job ;\ntypedef  TYPE_3__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  twarn (char*) ;\nint write (int /*<<< orphan*/ ,void*,int) ;\n\n__attribute__((used)) static int\nfilewrite(File *f, Job *j, void *buf, int len)\n{\nint r;\n\nr = write(f->fd, buf, len);\nif (r != len) {\ntwarn(\"write\");\nreturn 0;\n}\n\nf->w->resv -= r;\nf->resv -= r;\nj->walresv -= r;\nj->walused += r;\nf->w->alive += r;\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  fd_out; int /*<<< orphan*/  fd_in; } ;\ntypedef  TYPE_1__ FILE_INFO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  perror (char*) ;\nint write (int /*<<< orphan*/ ,char const*,int) ;\n\n__attribute__((used)) static int filewrite(FILE_INFO *info, FILE_INFO *info_out, const char *buf, int len)\n{\nint ret;\n\nret = write(info->fd_out, buf, len);\nif (ret != len) {\nperror(\"write\");\nreturn 0;\n}\ninfo->fd_in -= len;\ninfo->fd -= len;\ninfo_out->fd_in -= len;\ninfo_out->fd -= len;\ninfo_out->fd_out += len;\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_filewclose",
    "input":"\n0000000000000000 <filewclose>:\n0: \tpushq\t%rbx\n1: \ttestq\t%rdi, %rdi\n4: \tje\t0x6b <filewclose+0x6b>\n6: \tmovq\t%rdi, %rbx\n9: \tcmpq\t$0, (%rdi)\nd: \tje\t0x6b <filewclose+0x6b>\nf: \tmovq\t16(%rbx), %rax\n13: \ttestq\t%rax, %rax\n16: \tje\t0x44 <filewclose+0x44>\n18: \tmovq\t$0, (%rip)    # 0x23 <filewclose+0x23>\n23: \tmovl\t8(%rbx), %edi\n26: \tmovq\t24(%rbx), %rcx\n2a: \tmovq\t(%rcx), %rsi\n2d: \tsubq\t%rax, %rsi\n30: \tcallq\t0x35 <filewclose+0x35>\n35: \ttestq\t%rax, %rax\n38: \tje\t0x44 <filewclose+0x44>\n3a: \tmovl\t$0, %edi\n3f: \tcallq\t0x44 <filewclose+0x44>\n44: \tmovl\t8(%rbx), %edi\n47: \tcallq\t0x4c <filewclose+0x4c>\n4c: \tcmpl\t$-1, %eax\n4f: \tjne\t0x5b <filewclose+0x5b>\n51: \tmovl\t$0, %edi\n56: \tcallq\t0x5b <filewclose+0x5b>\n5b: \tmovq\t$0, (%rbx)\n62: \tmovq\t%rbx, %rdi\n65: \tpopq\t%rbx\n66: \tjmp\t0x6b <filewclose+0x6b>\n6b: \tpopq\t%rbx\n6c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ iswopen; int /*<<< orphan*/  fd; scalar_t__ free; TYPE_1__* w; } ;\nstruct TYPE_5__ {scalar_t__ filesize; } ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\nint close (int /*<<< orphan*/ ) ;\nscalar_t__ errno ;\nint /*<<< orphan*/  filedecref (TYPE_2__*) ;\nscalar_t__ ftruncate (int /*<<< orphan*/ ,scalar_t__) ;\nint /*<<< orphan*/  twarn (char*) ;\n\nvoid\nfilewclose(File *f)\n{\nif (!f) return;\nif (!f->iswopen) return;\nif (f->free) {\nerrno = 0;\nif (ftruncate(f->fd, f->w->filesize - f->free) != 0) {\ntwarn(\"ftruncate\");\n}\n}\nif (close(f->fd) == -1)\ntwarn(\"close\");\nf->iswopen = 0;\nfiledecref(f);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ fd; int /*<<< orphan*/  fname; scalar_t__ fd_start; int /*<<< orphan*/ * fd_buf; } ;\ntypedef  TYPE_1__ filew ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nscalar_t__ lseek (int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\n\nvoid filewclose(filew *f)\n{\nif (f && f->fd) {\nif (f->fd_buf) {\nf->fd_buf[0] = 0;\nif (lseek(f->fd, f->fd_start, 1) == -1) {\nfprintf(stderr, \"lseek failed: %s\\n\", errno);\n}\n}\nclose(f->fd);\nf->fd = 0;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_wait_for_job",
    "input":"\n0000000000000000 <wait_for_job>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%esi, %ebp\n5: \tmovq\t%rdi, %rbx\n8: \tmovl\t(%rip), %eax  # 0xe <wait_for_job+0xe>\ne: \tmovl\t%eax, 4(%rdi)\n11: \tcallq\t0x16 <wait_for_job+0x16>\n16: \tmovl\t%ebp, (%rbx)\n18: \tmovq\t%rbx, %rdi\n1b: \tmovl\t$104, %esi\n20: \taddq\t$8, %rsp\n24: \tpopq\t%rbx\n25: \tpopq\t%rbp\n26: \tjmp\t0x2b <wait_for_job+0x2b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int pending_timeout; int /*<<< orphan*/  state; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  STATE_WAIT ;\nint /*<<< orphan*/  enqueue_waiting_conn (TYPE_1__*) ;\nint /*<<< orphan*/  epollq_add (TYPE_1__*,char) ;\n\n__attribute__((used)) static void\nwait_for_job(Conn *c, int timeout)\n{\nc->state = STATE_WAIT;\nenqueue_waiting_conn(c);\n\n/* Set the pending timeout to the requested timeout amount */\nc->pending_timeout = timeout;\n\n// only care if they hang up\nepollq_add(c, 'h');\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  job_id; int /*<<< orphan*/  status; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  JOB_STATUS_WAITING ;\nint /*<<< orphan*/  get_job_status (TYPE_1__*) ;\nint /*<<< orphan*/  set_job_status (TYPE_1__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nwait_for_job(job_t *job, int job_id)\n{\njob->status = JOB_STATUS_WAITING;\nget_job_status(job);\njob->job_id = job_id;\nset_job_status(job, JOB_STATUS_WAITING);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optz",
    "input":"\n0000000000000000 <cttest_optz>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optz+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optz+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$1234, (%rip) # imm = 0x4D2\n# 0x28 <cttest_optz+0x28>\n28: \tsete\t%dil\n2c: \tcallq\t0x31 <cttest_optz+0x31>\n31: \taddq\t$24, %rsp\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint job_data_size_limit ;\nint /*<<< orphan*/  optparse (int /*<<< orphan*/ *,char**) ;\nint /*<<< orphan*/  srv ;\n\nvoid\ncttest_optz()\n{\nchar *args[] = {\n\"-z1234\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(job_data_size_limit == 1234);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_int_eq (int,int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_optz (char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  optz ;\n\n__attribute__((used)) static void cttest_optz(void)\n{\nint rv;\n\nrv = ct_test_optz(\"-optz\", &optz);\nTEST_ptr(rv == 0);\nTEST_int_eq(optz, 1234);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_waldirlock",
    "input":"\n0000000000000000 <waldirlock>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$32, %rsp\n8: \tmovq\t(%rdi), %r14\nb: \tmovq\t%r14, %rdi\ne: \tcallq\t0x13 <waldirlock+0x13>\n13: \taddl\t$6, %eax\n16: \tmovslq\t%eax, %rbp\n19: \tmovq\t%rbp, %rdi\n1c: \tcallq\t0x21 <waldirlock+0x21>\n21: \ttestq\t%rax, %rax\n24: \tje\t0x9a <waldirlock+0x9a>\n26: \tmovq\t%rax, %rbx\n29: \tmovl\t$0, %edx\n2e: \tmovq\t%rax, %rdi\n31: \tmovq\t%rbp, %rsi\n34: \tmovq\t%r14, %rcx\n37: \tcallq\t0x3c <waldirlock+0x3c>\n3c: \tmovl\t(%rip), %esi  # 0x42 <waldirlock+0x42>\n42: \torl\t(%rip), %esi  # 0x48 <waldirlock+0x48>\n48: \tmovq\t%rbx, %rdi\n4b: \tmovl\t$384, %edx    # imm = 0x180\n50: \tcallq\t0x55 <waldirlock+0x55>\n55: \tmovl\t%eax, %ebp\n57: \tmovq\t%rbx, %rdi\n5a: \tcallq\t0x5f <waldirlock+0x5f>\n5f: \tcmpl\t$-1, %ebp\n62: \tje\t0xa1 <waldirlock+0xa1>\n64: \tmovl\t(%rip), %eax  # 0x6a <waldirlock+0x6a>\n6a: \tmovl\t%eax, 20(%rsp)\n6e: \tmovl\t(%rip), %eax  # 0x74 <waldirlock+0x74>\n74: \tmovl\t%eax, 16(%rsp)\n78: \txorps\t%xmm0, %xmm0\n7b: \tmovaps\t%xmm0, (%rsp)\n7f: \tmovl\t(%rip), %esi  # 0x85 <waldirlock+0x85>\n85: \tmovq\t%rsp, %rdx\n88: \tmovl\t%ebp, %edi\n8a: \tcallq\t0x8f <waldirlock+0x8f>\n8f: \ttestl\t%eax, %eax\n91: \tje\t0xb6 <waldirlock+0xb6>\n93: \tmovl\t$0, %edi\n98: \tjmp\t0xa6 <waldirlock+0xa6>\n9a: \tmovl\t$0, %edi\n9f: \tjmp\t0xa6 <waldirlock+0xa6>\na1: \tmovl\t$0, %edi\na6: \tcallq\t0xab <waldirlock+0xab>\nab: \txorl\t%eax, %eax\nad: \taddq\t$32, %rsp\nb1: \tpopq\t%rbx\nb2: \tpopq\t%r14\nb4: \tpopq\t%rbp\nb5: \tretq\nb6: \tmovl\t$1, %eax\nbb: \tjmp\t0xad <waldirlock+0xad>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct flock {scalar_t__ l_len; scalar_t__ l_start; int /*<<< orphan*/  l_whence; int /*<<< orphan*/  l_type; } ;\nstruct TYPE_3__ {char* dir; } ;\ntypedef  TYPE_1__ Wal ;\n\n/* Variables and functions */\nint /*<<< orphan*/  F_SETLK ;\nint /*<<< orphan*/  F_WRLCK ;\nint O_CREAT ;\nint O_WRONLY ;\nint /*<<< orphan*/  SEEK_SET ;\nint fcntl (int,int /*<<< orphan*/ ,struct flock*) ;\nint /*<<< orphan*/  free (char*) ;\nchar* malloc (size_t) ;\nint open (char*,int,int) ;\nint /*<<< orphan*/  snprintf (char*,size_t,char*,char*) ;\nint strlen (char*) ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nwaldirlock(Wal *w)\n{\nint r;\nint fd;\nstruct flock lk;\nchar *path;\nsize_t path_length;\n\npath_length = strlen(w->dir) + strlen(\"/lock\") + 1;\nif ((path = malloc(path_length)) == NULL) {\ntwarn(\"malloc\");\nreturn 0;\n}\nsnprintf(path, path_length, \"%s/lock\", w->dir);\n\nfd = open(path, O_WRONLY|O_CREAT, 0600);\nfree(path);\nif (fd == -1) {\ntwarn(\"open\");\nreturn 0;\n}\n\nlk.l_type = F_WRLCK;\nlk.l_whence = SEEK_SET;\nlk.l_start = 0;\nlk.l_len = 0;\nr = fcntl(fd, F_SETLK, &lk);\nif (r) {\ntwarn(\"fcntl\");\nreturn 0;\n}\n\n// intentionally leak fd, since we never want to close it\n// and we'll never need it again\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {char* dir; } ;\ntypedef  TYPE_1__ WalSnd ;\ntypedef  int /*<<< orphan*/  XLogRecPtr ;\ntypedef  int /*<<< orphan*/  XLogSegNo ;\ntypedef  int /*<<< orphan*/  WalSndState ;\ntypedef  int /*<<< orphan*/  WalSndStateChange ;\ntypedef  int /*<<< orphan*/  WalSndStateChangeResult ;\ntypedef  int /*<<< orphan*/  WalSndStateChangeCause ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Assert (int) ;\nint /*<<< orphan*/  FIO_NO_LOCK ;\nint /*<<< orphan*/  FIO_NO_SEEK ;\nint /*<<< orphan*/  FIO_NO_WRITER ;\nint /*<<< orphan*/  FIO_RDWR ;\nint /*<<< orphan*/  FIO_SEG_SIZE ;\nint /*<<< orphan*/  FIO_USE_O_DIRECT ;\nint /*<<< orphan*/  FIO_USE_O_DIRECT_EXCL ;\nint /*<<< orphan*/  FIO_USE_UNLINK ;\nint /*<<< orphan*/  FIO_USE_UNLINK_IF_EXISTS ;\nint /*<<< orphan*/  FIO_USE_UNLINK_IF_EXISTS_OK ;\nint /*<<< orphan*/  FIO_USE_UNLINK_OK ;\nint /*<<< orphan*/  FIO_WRITER ;\nint /*<<< orphan*/  FIO_WRITER_CLEANUP ;\nint /*<<< orphan*/  FIO_WRITER_CREATE ;\nint /*<<< orphan*/  FIO_WRITER_DATA ;\nint /*<<< orphan*/  FIO_WRITER_DATA_SYNC ;\nint /*<<< orphan*/  FIO_WRITER_FINAL_SYNC ;\nint /*<<< orphan*/  FIO_WRITER_SYNC ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_DATA ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_FINAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL ;\nint /*<<< orphan*/  FIO_WRITER_SYNC_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMAL_NORMA"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_binlog_basic",
    "input":"\n0000000000000000 <cttest_binlog_basic>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_binlog_basic+0x8>\n8: \tmovl\t%eax, (%rip)  # 0xe <cttest_binlog_basic+0xe>\ne: \tmovl\t$1, (%rip)    # 0x18 <cttest_binlog_basic+0x18>\n18: \tmovl\t$10, (%rip)   # 0x22 <cttest_binlog_basic+0x22>\n22: \txorl\t%eax, %eax\n24: \tcallq\t0x29 <cttest_binlog_basic+0x29>\n29: \tmovl\t%eax, %edi\n2b: \tcallq\t0x30 <cttest_binlog_basic+0x30>\n30: \tmovl\t%eax, %ebx\n32: \tmovl\t$0, %esi\n37: \tmovl\t%eax, %edi\n39: \tcallq\t0x3e <cttest_binlog_basic+0x3e>\n3e: \tmovl\t$0, %esi\n43: \tmovl\t%ebx, %edi\n45: \tcallq\t0x4a <cttest_binlog_basic+0x4a>\n4a: \tmovl\t$0, %esi\n4f: \tmovl\t%ebx, %edi\n51: \tcallq\t0x56 <cttest_binlog_basic+0x56>\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <cttest_binlog_basic+0x5d>\n5d: \txorl\t%eax, %eax\n5f: \tcallq\t0x64 <cttest_binlog_basic+0x64>\n64: \tmovl\t%eax, %edi\n66: \tcallq\t0x6b <cttest_binlog_basic+0x6b>\n6b: \tmovl\t%eax, %ebx\n6d: \tmovl\t$0, %esi\n72: \tmovl\t%eax, %edi\n74: \tcallq\t0x79 <cttest_binlog_basic+0x79>\n79: \tmovl\t$0, %esi\n7e: \tmovl\t%ebx, %edi\n80: \tpopq\t%rbx\n81: \tjmp\t0x86 <cttest_binlog_basic+0x86>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int use; int /*<<< orphan*/  dir; } ;\nstruct TYPE_4__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ctdir () ;\nint job_data_size_limit ;\nint /*<<< orphan*/  kill_srvpid () ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nTYPE_2__ srv ;\n\nvoid\ncttest_binlog_basic()\n{\nsrv.wal.dir = ctdir();\nsrv.wal.use = 1;\njob_data_size_limit = 10;\n\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 100 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nkill_srvpid();\n\nport = SERVER();\nfd = mustdiallocal(port);\nmustsend(fd, \"delete 1\\r\\n\");\nckresp(fd, \"DELETED\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BINLOG_TEST_FILE ;\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fwrite (int /*<<< orphan*/ ,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  test_binlog_basic () ;\nint /*<<< orphan*/  test_binlog_basic_file ;\n\n__attribute__((used)) static void cttest_binlog_basic(void)\n{\nFILE *fp;\n\nmemset(test_binlog_basic_file, 0, sizeof(test_binlog_basic_file));\ntest_binlog_basic();\n\nfp = fopen(BINLOG_TEST_FILE, \"r\");\nfprintf(fp, \"BINLOG_TEST_FILE\\n\");\nfclose(fp);\n\nfp = fopen(BINLOG_TEST_FILE, \"r\");\nfprintf(fp, \"BINLOG_TEST_FILE\\n\");\nfclose(fp);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_read_u32",
    "input":"\n0000000000000000 <read_u32>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdx, %r15\na: \tmovq\t%rsi, %rbx\nd: \tmovq\t%rdi, %r14\n10: \tmovq\t$0, (%rip)    # 0x1b <read_u32+0x1b>\n1b: \taddq\t$-1, %rbx\n1f: \tnop\n20: \tmovzbl\t1(%rbx), %eax\n24: \taddq\t$1, %rbx\n28: \tcmpb\t$32, %al\n2a: \tje\t0x20 <read_u32+0x20>\n2c: \taddb\t$-48, %al\n2e: \tmovl\t$4294967295, %ebp  # imm = 0xFFFFFFFF\n33: \tcmpb\t$9, %al\n35: \tjbe\t0x44 <read_u32+0x44>\n37: \tmovl\t%ebp, %eax\n39: \taddq\t$8, %rsp\n3d: \tpopq\t%rbx\n3e: \tpopq\t%r14\n40: \tpopq\t%r15\n42: \tpopq\t%rbp\n43: \tretq\n44: \tmovq\t%rsp, %rsi\n47: \tmovq\t%rbx, %rdi\n4a: \tmovl\t$10, %edx\n4f: \tcallq\t0x54 <read_u32+0x54>\n54: \tmovq\t(%rsp), %rcx\n58: \tcmpq\t%rbx, %rcx\n5b: \tje\t0x37 <read_u32+0x37>\n5d: \tcmpq\t$0, (%rip)    # 0x65 <read_u32+0x65>\n65: \tjne\t0x37 <read_u32+0x37>\n67: \ttestq\t%r15, %r15\n6a: \tje\t0x89 <read_u32+0x89>\n6c: \tcmpq\t(%rip), %rax  # 0x73 <read_u32+0x73>\n73: \tjg\t0x37 <read_u32+0x37>\n75: \ttestq\t%r14, %r14\n78: \tje\t0x7d <read_u32+0x7d>\n7a: \tmovq\t%rax, (%r14)\n7d: \txorl\t%ebp, %ebp\n7f: \ttestq\t%r15, %r15\n82: \tje\t0x37 <read_u32+0x37>\n84: \tmovq\t%rcx, (%r15)\n87: \tjmp\t0x37 <read_u32+0x37>\n89: \tcmpb\t$0, (%rcx)\n8c: \tjne\t0x37 <read_u32+0x37>\n8e: \tjmp\t0x6c <read_u32+0x6c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uintmax_t ;\ntypedef  scalar_t__ uint32 ;\n\n/* Variables and functions */\nscalar_t__ UINT32_MAX ;\nscalar_t__ errno ;\nscalar_t__ strtoumax (char const*,char**,int) ;\n\n__attribute__((used)) static int\nread_u32(uint32 *num, const char *buf, char **end)\n{\nuintmax_t tnum;\nchar *tend;\n\nerrno = 0;\nwhile (buf[0] == ' ')\nbuf++;\nif (buf[0] < '0' || '9' < buf[0])\nreturn -1;\ntnum = strtoumax(buf, &tend, 10);\nif (tend == buf)\nreturn -1;\nif (errno)\nreturn -1;\nif (!end && tend[0] != '\\0')\nreturn -1;\nif (tnum > UINT32_MAX)\nreturn -1;\n\nif (num) *num = (uint32)tnum;\nif (end) *end = tend;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uint32_t ;\n\n/* Variables and functions */\nscalar_t__ UINT32_MAX ;\nint /*<<< orphan*/  sscanf (char const*,char*,scalar_t__*) ;\nscalar_t__ strlen (char const*) ;\nscalar_t__ strtoul (char const*,char**,int) ;\n\n__attribute__((used)) static int read_u32(const char *str, size_t len, uint32_t *val)\n{\nuint32_t ret = 0;\nchar *end;\n\nwhile (len > 0 && *str == ' ') {\nstr++;\nlen--;\n}\n\nif (len > 0 && *str >= '0' && *str <= '9') {\nret = strtoul(str, &end, 10);\nif (end == str)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nret = strtoul(str + 2, &end, 16);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'b') {\nret = strtoul(str + 2, &end, 2);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'o') {\nret = strtoul(str + 2, &end, 8);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'c') {\nret = strtoul(str + 2, &end, 12);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'd') {\nret = strtoul(str + 2, &end, 10);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nret = strtoul(str + 2, &end, 16);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'b') {\nret = strtoul(str + 2, &end, 2);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'o') {\nret = strtoul(str + 2, &end, 8);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'c') {\nret = strtoul(str + 2, &end, 12);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'd') {\nret = strtoul(str + 2, &end, 10);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nret = strtoul(str + 2, &end, 16);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'b') {\nret = strtoul(str + 2, &end, 2);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'o') {\nret = strtoul(str + 2, &end, 8);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'c') {\nret = strtoul(str + 2, &end, 12);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'd') {\nret = strtoul(str + 2, &end, 10);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nret = strtoul(str + 2, &end, 16);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'b') {\nret = strtoul(str + 2, &end, 2);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'o') {\nret = strtoul(str + 2, &end, 8);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'c') {\nret = strtoul(str + 2, &end, 12);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'd') {\nret = strtoul(str + 2, &end, 10);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nret = strtoul(str + 2, &end, 16);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'b') {\nret = strtoul(str + 2, &end, 2);\nif (end == str + 2)\nreturn -1;\nif (val)\n*val = ret;\n} else if (len > 0 && *str == '0' && len > 1 && str[1] == 'o') {\nret = strtoul(str + 2, &end,"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_reserve_job_delayed",
    "input":"\n0000000000000000 <cttest_reserve_job_delayed>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_reserve_job_delayed+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_reserve_job_delayed+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_reserve_job_delayed+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_reserve_job_delayed+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_reserve_job_delayed+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_reserve_job_delayed+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_reserve_job_delayed+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_reserve_job_delayed+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_reserve_job_delayed+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_reserve_job_delayed+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_reserve_job_delayed+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_reserve_job_delayed+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_reserve_job_delayed+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_reserve_job_delayed+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_reserve_job_delayed+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tcallq\t0xb9 <cttest_reserve_job_delayed+0xb9>\nb9: \tmovl\t$0, %esi\nbe: \tmovl\t%ebx, %edi\nc0: \tcallq\t0xc5 <cttest_reserve_job_delayed+0xc5>\nc5: \tmovl\t$0, %esi\nca: \tmovl\t%ebx, %edi\ncc: \tcallq\t0xd1 <cttest_reserve_job_delayed+0xd1>\nd1: \tmovl\t$0, %esi\nd6: \tmovl\t%ebx, %edi\nd8: \tpopq\t%rbx\nd9: \tjmp\t0xde <cttest_reserve_job_delayed+0xde>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_reserve_job_delayed()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\n\nmustsend(fd, \"put 0 100 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"put 0 100 1 1\\r\\n\");\nmustsend(fd, \"B\\r\\n\");\nckresp(fd, \"INSERTED 2\\r\\n\");\nmustsend(fd, \"put 0 100 1 1\\r\\n\");\nmustsend(fd, \"C\\r\\n\");\nckresp(fd, \"INSERTED 3\\r\\n\");\n\nmustsend(fd, \"reserve-job 2\\r\\n\");\nckresp(fd, \"RESERVED 2 1\\r\\n\");\nckresp(fd, \"B\\r\\n\");\n\nmustsend(fd, \"release 2 1 0\\r\\n\");\nckresp(fd, \"RELEASED\\r\\n\");\n\n// verify that job was released in ready state.\nmustsend(fd, \"stats-job 2\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\nstate: ready\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_get_module (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_module_reserve_job_delayed (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay (int /*<<< orphan*/ ,char*,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority (int /*<<< orphan*/ ,char*,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority (int /*<<< orphan*/ ,char*,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay (int /*<<< orphan*/ ,char*,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_module_reserve_job_immediate_with_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_delay_and_priority_and_"
},
{
    "file:":"./beanstalkd/extr_walg.c_reserve",
    "input":"\n0000000000000000 <reserve>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tcmpl\t$0, 24(%rdi)\n8: \tje\t0x4f <reserve+0x4f>\na: \tmovl\t%esi, %ebx\nc: \tmovq\t%rdi, %r14\nf: \tmovq\t16(%rdi), %rax\n13: \tmovl\t(%rax), %ecx\n15: \tsubl\t%esi, %ecx\n17: \tjge\t0x56 <reserve+0x56>\n19: \tmovq\t%r14, %rdi\n1c: \tmovl\t%ebx, %esi\n1e: \tcallq\t0x23 <reserve+0x23>\n23: \tcmpl\t%ebx, %eax\n25: \tjne\t0x60 <reserve+0x60>\n27: \tmovq\t8(%r14), %rax\n2b: \tsubl\t%ebx, (%rax)\n2d: \taddl\t%ebx, 4(%rax)\n30: \taddl\t%ebx, (%r14)\n33: \tmovq\t%r14, %rdi\n36: \tmovl\t%ebx, %esi\n38: \tcallq\t0x3d <reserve+0x3d>\n3d: \ttestl\t%eax, %eax\n3f: \tjne\t0x6c <reserve+0x6c>\n41: \tsubl\t%ebx, (%r14)\n44: \tmovq\t8(%r14), %rax\n48: \tsubl\t%ebx, 4(%rax)\n4b: \taddl\t%ebx, (%rax)\n4d: \tjmp\t0x6a <reserve+0x6a>\n4f: \tmovl\t$1, %ebx\n54: \tjmp\t0x6c <reserve+0x6c>\n56: \tmovl\t%ecx, (%rax)\n58: \taddl\t%ebx, 4(%rax)\n5b: \taddl\t%ebx, (%r14)\n5e: \tjmp\t0x6c <reserve+0x6c>\n60: \tmovl\t$0, %edi\n65: \tcallq\t0x6a <reserve+0x6a>\n6a: \txorl\t%ebx, %ebx\n6c: \tmovl\t%ebx, %eax\n6e: \taddq\t$8, %rsp\n72: \tpopq\t%rbx\n73: \tpopq\t%r14\n75: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int resv; TYPE_2__* tail; TYPE_1__* cur; int /*<<< orphan*/  use; } ;\ntypedef  TYPE_3__ Wal ;\nstruct TYPE_8__ {int free; int resv; } ;\nstruct TYPE_7__ {int free; int resv; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  balance (TYPE_3__*,int) ;\nint needfree (TYPE_3__*,int) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\n__attribute__((used)) static int\nreserve(Wal *w, int n)\n{\nint r;\n\n// return value must be nonzero but is otherwise ignored\nif (!w->use) return 1;\n\nif (w->cur->free >= n) {\nw->cur->free -= n;\nw->cur->resv += n;\nw->resv += n;\nreturn n;\n}\n\nr = needfree(w, n);\nif (r != n) {\ntwarnx(\"needfree\");\nreturn 0;\n}\n\nw->tail->free -= n;\nw->tail->resv += n;\nw->resv += n;\nif (!balance(w, n)) {\n// error; undo the reservation\nw->resv -= n;\nw->tail->resv -= n;\nw->tail->free += n;\nreturn 0;\n}\n\nreturn n;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  size; TYPE_1__* free; int /*<<< orphan*/  free_size; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  size; } ;\ntypedef  TYPE_2__ GLogBuffer ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  log_buffer_add_free (TYPE_2__*,int) ;\nint /*<<< orphan*/  log_buffer_add_used (TYPE_2__*,int) ;\nint /*<<< orphan*/  log_buffer_remove_free (TYPE_2__*,int) ;\n\n__attribute__((used)) static int reserve (GLogBuffer *buffer, int size) {\nif (!buffer->free_size) {\nreturn 1;\n}\n\nif (buffer->free->size < size) {\nlog_buffer_remove_free (buffer, size);\nif (log_buffer_add_free (buffer, size)) {\nreturn 0;\n}\n}\n\nlog_buffer_add_used (buffer, size);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_contains",
    "input":"\n0000000000000000 <ms_contains>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0x1f <ms_contains+0x1f>\n8: \tmovq\t8(%rdi), %rcx\nc: \txorl\t%edx, %edx\ne: \tnop\n10: \tcmpq\t%rsi, (%rcx,%rdx,8)\n14: \tje\t0x22 <ms_contains+0x22>\n16: \taddq\t$1, %rdx\n1a: \tcmpq\t%rax, %rdx\n1d: \tjb\t0x10 <ms_contains+0x10>\n1f: \txorl\t%eax, %eax\n21: \tretq\n22: \tmovl\t$1, %eax\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t len; void** items; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\n\nint\nms_contains(Ms *a, void *item)\n{\nsize_t i;\n\nfor (i = 0; i < a->len; i++) {\nif (a->items[i] == item)\nreturn 1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t n; int /*<<< orphan*/ * items; } ;\ntypedef  TYPE_1__* MultiSet ;\ntypedef  int /*<<< orphan*/  Item ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int ms_contains (MultiSet ms, Item item) {\nsize_t i;\nfor (i = 0; i < ms->n; i++) {\nif (ms->items[i] == item) {\nreturn 1;\n}\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_sd-daemon.c_sd_is_fifo",
    "input":"\n0000000000000000 <sd_is_fifo>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tsubq\t$56, %rsp\na: \ttestl\t%edi, %edi\nc: \tjs\t0x96 <sd_is_fifo+0x96>\n12: \tmovq\t%rsi, %r14\n15: \tmovl\t%edi, %ebp\n17: \tleaq\t8(%rsp), %r15\n1c: \txorl\t%ebx, %ebx\n1e: \tmovq\t%r15, %rdi\n21: \txorl\t%esi, %esi\n23: \tmovl\t$24, %edx\n28: \tcallq\t0x2d <sd_is_fifo+0x2d>\n2d: \tmovl\t%ebp, %edi\n2f: \tmovq\t%r15, %rsi\n32: \tcallq\t0x37 <sd_is_fifo+0x37>\n37: \ttestq\t%rax, %rax\n3a: \tjs\t0xa0 <sd_is_fifo+0xa0>\n3c: \tmovl\t24(%rsp), %edi\n40: \tcallq\t0x45 <sd_is_fifo+0x45>\n45: \ttestl\t%eax, %eax\n47: \tje\t0xcd <sd_is_fifo+0xcd>\n4d: \ttestq\t%r14, %r14\n50: \tje\t0xaa <sd_is_fifo+0xaa>\n52: \tleaq\t32(%rsp), %rbx\n57: \txorl\t%ebp, %ebp\n59: \tmovq\t%rbx, %rdi\n5c: \txorl\t%esi, %esi\n5e: \tmovl\t$24, %edx\n63: \tcallq\t0x68 <sd_is_fifo+0x68>\n68: \tmovq\t%r14, %rdi\n6b: \tmovq\t%rbx, %rsi\n6e: \tcallq\t0x73 <sd_is_fifo+0x73>\n73: \ttestq\t%rax, %rax\n76: \tjs\t0xb1 <sd_is_fifo+0xb1>\n78: \tmovq\t32(%rsp), %rax\n7d: \tmovq\t40(%rsp), %rcx\n82: \txorq\t8(%rsp), %rax\n87: \txorq\t16(%rsp), %rcx\n8c: \txorl\t%ebx, %ebx\n8e: \torq\t%rax, %rcx\n91: \tsete\t%bl\n94: \tjmp\t0xcd <sd_is_fifo+0xcd>\n96: \txorl\t%ebx, %ebx\n98: \tsubl\t(%rip), %ebx  # 0x9e <sd_is_fifo+0x9e>\n9e: \tjmp\t0xcd <sd_is_fifo+0xcd>\na0: \txorl\t%ebx, %ebx\na2: \tsubl\t(%rip), %ebx  # 0xa8 <sd_is_fifo+0xa8>\na8: \tjmp\t0xcd <sd_is_fifo+0xcd>\naa: \tmovl\t$1, %ebx\naf: \tjmp\t0xcd <sd_is_fifo+0xcd>\nb1: \tmovl\t(%rip), %eax  # 0xb7 <sd_is_fifo+0xb7>\nb7: \tmovl\t%eax, %ebx\nb9: \tnegl\t%ebx\nbb: \tcmpl\t(%rip), %eax  # 0xc1 <sd_is_fifo+0xc1>\nc1: \tcmovel\t%ebp, %ebx\nc4: \tcmpl\t(%rip), %eax  # 0xca <sd_is_fifo+0xca>\nca: \tcmovel\t%ebp, %ebx\ncd: \tmovl\t%ebx, %eax\ncf: \taddq\t$56, %rsp\nd3: \tpopq\t%rbx\nd4: \tpopq\t%r14\nd6: \tpopq\t%r15\nd8: \tpopq\t%rbp\nd9: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {scalar_t__ st_dev; scalar_t__ st_ino; int /*<<< orphan*/  st_mode; } ;\ntypedef  int /*<<< orphan*/  st_path ;\ntypedef  int /*<<< orphan*/  st_fd ;\n\n/* Variables and functions */\nint EINVAL ;\nint ENOENT ;\nint ENOTDIR ;\nint /*<<< orphan*/  S_ISFIFO (int /*<<< orphan*/ ) ;\nint errno ;\nscalar_t__ fstat (int,struct stat*) ;\nint /*<<< orphan*/  memset (struct stat*,int /*<<< orphan*/ ,int) ;\nscalar_t__ stat (char const*,struct stat*) ;\n\nint sd_is_fifo(int fd, const char *path) {\nstruct stat st_fd;\n\nif (fd < 0)\nreturn -EINVAL;\n\nmemset(&st_fd, 0, sizeof(st_fd));\nif (fstat(fd, &st_fd) < 0)\nreturn -errno;\n\nif (!S_ISFIFO(st_fd.st_mode))\nreturn 0;\n\nif (path) {\nstruct stat st_path;\n\nmemset(&st_path, 0, sizeof(st_path));\nif (stat(path, &st_path) < 0) {\n\nif (errno == ENOENT || errno == ENOTDIR)\nreturn 0;\n\nreturn -errno;\n}\n\nreturn\nst_path.st_dev == st_fd.st_dev &&\nst_path.st_ino == st_fd.st_ino;\n}\n\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {scalar_t__ st_mode; } ;\n\n/* Variables and functions */\nint EINVAL ;\nint ENAMETOOLONG ;\nint ENOENT ;\nint ENOTDIR ;\nint /*<<< orphan*/  memset (struct stat*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  stat (char const*,struct stat*) ;\nscalar_t__ strcmp (char const*,char const*) ;\nscalar_t__ strlen (char const*) ;\n\nint sd_is_fifo(int fd, const char *path) {\nstruct stat st;\nint r;\n\nif (fd < 0) {\nreturn -ENOENT;\n}\n\nmemset(&st, 0, sizeof(st));\nr = stat(path, &st);\nif (r < 0) {\nreturn -ENOENT;\n}\n\nif (!S_ISFIFO(st.st_mode)) {\nreturn 0;\n}\n\nif (path && strlen(path) == 0) {\nreturn 1;\n}\n\nif (strcmp(path, \"/dev/fd/0\") == 0) {\nreturn 1;\n}\n\nreturn -ENOTDIR;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_filedecref",
    "input":"\n0000000000000000 <filedecref>:\n0: \ttestq\t%rdi, %rdi\n3: \tje\t0x19 <filedecref+0x19>\n5: \tmovl\t(%rdi), %eax\n7: \tleal\t-1(%rax), %ecx\na: \tmovl\t%ecx, (%rdi)\nc: \tcmpl\t$1, %eax\nf: \tjg\t0x19 <filedecref+0x19>\n11: \tmovl\t4(%rdi), %edi\n14: \tjmp\t0x19 <filedecref+0x19>\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int refs; int /*<<< orphan*/  w; } ;\ntypedef  TYPE_1__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  walgc (int /*<<< orphan*/ ) ;\n\nvoid\nfiledecref(File *f)\n{\nif (!f) return;\nf->refs--;\nif (f->refs < 1) {\nwalgc(f->w);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int ref; int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ file ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void filedecref(file *f) {\nif (f == NULL) {\nreturn;\n}\nf->ref--;\nif (f->ref == 0) {\nclose(f->fd);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_fileadd",
    "input":"\n0000000000000000 <fileadd>:\n0: \tmovq\t%rsi, %rax\n3: \tmovq\t16(%rsi), %rcx\n7: \ttestq\t%rcx, %rcx\na: \tje\t0xf <fileadd+0xf>\nc: \tmovq\t%rdi, (%rcx)\nf: \tmovq\t%rdi, 16(%rax)\n13: \tcmpq\t$0, 8(%rax)\n18: \tje\t0x1e <fileadd+0x1e>\n1a: \taddl\t$1, (%rax)\n1d: \tretq\n1e: \tmovq\t%rdi, 8(%rax)\n22: \taddl\t$1, (%rax)\n25: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  nfile; TYPE_2__* head; TYPE_2__* tail; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_7__ {struct TYPE_7__* next; } ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\n\nWal*\nfileadd(File *f, Wal *w)\n{\nif (w->tail) {\nw->tail->next = f;\n}\nw->tail = f;\nif (!w->head) {\nw->head = f;\n}\nw->nfile++;\nreturn w;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; int /*<<< orphan*/ * prev; struct TYPE_3__* prev_file; int /*<<< orphan*/ * next_file; } ;\ntypedef  TYPE_1__ file_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void fileadd(file_t *f, file_t *f2)\n{\nif (f2->prev_file)\nf2->prev_file->next_file = f;\nf->prev_file = f2->prev_file;\nf->next_file = f2;\nif (f2->prev)\nf2->prev->next = f;\nf2->prev = f;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_cmp_ids",
    "input":"\n0000000000000000 <cttest_job_cmp_ids>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %ebx  # 0x7 <cttest_job_cmp_ids+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <cttest_job_cmp_ids+0x11>\n11: \tmovl\t%ebx, %edi\n13: \tmovl\t%eax, %esi\n15: \tcallq\t0x1a <cttest_job_cmp_ids+0x1a>\n1a: \tmovl\t(%rip), %r8d  # 0x21 <cttest_job_cmp_ids+0x21>\n21: \tmovl\t$1, %edi\n26: \txorl\t%esi, %esi\n28: \tmovl\t$1, %edx\n2d: \txorl\t%ecx, %ecx\n2f: \tcallq\t0x34 <cttest_job_cmp_ids+0x34>\n34: \tmovq\t%rax, %rbx\n37: \tmovl\t(%rip), %r8d  # 0x3e <cttest_job_cmp_ids+0x3e>\n3e: \tmovl\t$1, %edi\n43: \txorl\t%esi, %esi\n45: \tmovl\t$1, %edx\n4a: \txorl\t%ecx, %ecx\n4c: \tcallq\t0x51 <cttest_job_cmp_ids+0x51>\n51: \tmovq\t%rbx, %rdi\n54: \tmovq\t%rax, %rsi\n57: \tcallq\t0x5c <cttest_job_cmp_ids+0x5c>\n5c: \tmovl\t$0, %esi\n61: \tmovl\t%eax, %edi\n63: \tpopq\t%rbx\n64: \tjmp\t0x69 <cttest_job_cmp_ids+0x69>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int id; } ;\nstruct TYPE_7__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  job_pri_less (TYPE_2__*,TYPE_2__*) ;\nTYPE_2__* make_job (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_cmp_ids()\n{\nJob *a, *b;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\na = make_job(1, 0, 1, 0, default_tube);\nb = make_job(1, 0, 1, 0, default_tube);\n\nb->r.id <<= 49;\nassertf(job_pri_less(a, b), \"should be less\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CMP_ID ;\nint /*<<< orphan*/  TEST_int_eq (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_str_eq (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_cmp_id (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_job_id (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_job_id_str ;\nint /*<<< orphan*/  ct_test_job_id_str2 ;\n\n__attribute__((used)) static void cttest_job_cmp_ids(void)\n{\nct_test_job_t *job1, *job2;\n\njob1 = TEST_ptr(ct_test_job_id(&ct_test_job_id_str));\njob2 = TEST_ptr(ct_test_job_id(&ct_test_job_id_str2));\n\nTEST_int_eq(1, ct_test_job_cmp_id(job1, job2));\nTEST_int_eq(1, ct_test_job_cmp_id(job2, job1));\nTEST_str_eq(\"1\", ct_test_job_id(job1));\nTEST_str_eq(\"2\", ct_test_job_id(job2));\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_connsetworker",
    "input":"\n0000000000000000 <connsetworker>:\n0: \tmovl\t(%rdi), %eax\n2: \tmovl\t(%rip), %ecx  # 0x8 <connsetworker+0x8>\n8: \ttestl\t%eax, %ecx\na: \tje\t0xd <connsetworker+0xd>\nc: \tretq\nd: \torl\t%eax, %ecx\nf: \tmovl\t%ecx, (%rdi)\n11: \taddl\t$1, (%rip)    # 0x18 <connsetworker+0x18>\n18: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int type; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint CONN_TYPE_WORKER ;\nint /*<<< orphan*/  cur_worker_ct ;\n\nvoid\nconnsetworker(Conn *c)\n{\nif (c->type & CONN_TYPE_WORKER) return;\nc->type |= CONN_TYPE_WORKER;\ncur_worker_ct++; /* stats */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; } ;\ntypedef  TYPE_1__ connection ;\n\n/* Variables and functions */\nint C_WORKER ;\nint /*<<< orphan*/  nworkers ;\n\nvoid connsetworker(connection *c) {\nif (c->flags & C_WORKER) {\nreturn;\n}\nc->flags |= C_WORKER;\nnworkers++;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_1024_no_fsync",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_1024_no_fsync>:\n0: \tmovl\t$1024, %esi   # imm = 0x400\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \txorl\t%ecx, %ecx\nc: \txorl\t%r8d, %r8d\nf: \tjmp\t0x14 <ctbench_put_delete_wal_1024_no_fsync+0x14>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_wal_1024_no_fsync(int n)\n{\nbench_put_delete_size(n, 1024, 512000, 0, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal (int,int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nint ctbench_put_delete_wal_1024_no_fsync (int fd) {\nreturn ctbench_put_delete_wal (fd, 1024, 512000, 0, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_next_awaited_job",
    "input":"\n0000000000000000 <next_awaited_job>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tcmpq\t$0, (%rip)    # 0x10 <next_awaited_job+0x10>\n10: \tje\t0x7b <next_awaited_job+0x7b>\n12: \tmovq\t%rdi, %r14\n15: \txorl\t%ebx, %ebx\n17: \txorl\t%r15d, %r15d\n1a: \tjmp\t0x30 <next_awaited_job+0x30>\n1c: \tnopl\t(%rax)\n20: \tmovq\t%r12, %r15\n23: \taddq\t$1, %rbx\n27: \tcmpq\t(%rip), %rbx  # 0x2e <next_awaited_job+0x2e>\n2e: \tjae\t0x7e <next_awaited_job+0x7e>\n30: \tmovq\t(%rip), %rax  # 0x37 <next_awaited_job+0x37>\n37: \tmovq\t(%rax,%rbx,8), %rax\n3b: \tcmpq\t$0, 32(%rax)\n40: \tje\t0x4f <next_awaited_job+0x4f>\n42: \tcmpq\t%r14, (%rax)\n45: \tjg\t0x23 <next_awaited_job+0x23>\n47: \tmovq\t$0, 32(%rax)\n4f: \tcmpq\t$0, 24(%rax)\n54: \tje\t0x23 <next_awaited_job+0x23>\n56: \tcmpq\t$0, 16(%rax)\n5b: \tje\t0x23 <next_awaited_job+0x23>\n5d: \tmovq\t8(%rax), %rax\n61: \tmovq\t(%rax), %r12\n64: \ttestq\t%r15, %r15\n67: \tje\t0x20 <next_awaited_job+0x20>\n69: \tmovq\t%r12, %rdi\n6c: \tmovq\t%r15, %rsi\n6f: \tcallq\t0x74 <next_awaited_job+0x74>\n74: \ttestq\t%rax, %rax\n77: \tjne\t0x20 <next_awaited_job+0x20>\n79: \tjmp\t0x23 <next_awaited_job+0x23>\n7b: \txorl\t%r15d, %r15d\n7e: \tmovq\t%r15, %rax\n81: \taddq\t$8, %rsp\n85: \tpopq\t%rbx\n86: \tpopq\t%r12\n88: \tpopq\t%r14\n8a: \tpopq\t%r15\n8c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_4__ ;\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ int64 ;\nstruct TYPE_6__ {int /*<<< orphan*/ ** data; scalar_t__ len; } ;\nstruct TYPE_5__ {scalar_t__ len; } ;\nstruct TYPE_7__ {scalar_t__ unpause_at; TYPE_2__ ready; TYPE_1__ waiting_conns; scalar_t__ pause; } ;\ntypedef  TYPE_3__ Tube ;\nstruct TYPE_8__ {size_t len; TYPE_3__** items; } ;\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nscalar_t__ job_pri_less (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nTYPE_4__ tubes ;\n\n__attribute__((used)) static Job *\nnext_awaited_job(int64 now)\n{\nsize_t i;\nJob *j = NULL;\n\nfor (i = 0; i < tubes.len; i++) {\nTube *t = tubes.items[i];\nif (t->pause) {\nif (t->unpause_at > now)\ncontinue;\nt->pause = 0;\n}\nif (t->waiting_conns.len && t->ready.len) {\nJob *candidate = t->ready.data[0];\nif (!j || job_pri_less(candidate, j)) {\nj = candidate;\n}\n}\n}\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {scalar_t__ job_id; } ;\nstruct TYPE_9__ {scalar_t__ job_id; } ;\nstruct TYPE_8__ {scalar_t__ job_id; } ;\ntypedef  TYPE_1__ GLogJob ;\ntypedef  TYPE_2__ GLogJobAwaited ;\ntypedef  TYPE_3__ GLogJobAwaitedList ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_free (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_insert_sorted (TYPE_3__*,TYPE_3__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_queue_peek_head (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_remove (TYPE_3__*,TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_sort (TYPE_3__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nTYPE_3__* g_queue_new () ;\nint /*<<< orphan*/  g_queue_push_tail (TYPE_3__*,TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_ref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_sort_func ;\nint /*<<< orphan*/  g_queue_take_head (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE_3__*) ;\nint /*<<< orphan*/  g_queue_unref (TYPE"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_release_bad_format",
    "input":"\n0000000000000000 <cttest_release_bad_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_release_bad_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_release_bad_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_release_bad_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_release_bad_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_release_bad_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_release_bad_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_release_bad_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_release_bad_format+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_release_bad_format+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_release_bad_format+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_release_bad_format+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_release_bad_format+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_release_bad_format+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tpopq\t%rbx\n9d: \tjmp\t0xa2 <cttest_release_bad_format+0xa2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_release_bad_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\n\n// bad id\nmustsend(fd, \"release 18446744073709551616 1 1\\r\\n\"); // UINT64_MAX+1\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"release 184467440737095516160000000000000000000000000000 1 1\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"release foo111\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"release 111foo\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n\n// bad priority\nmustsend(fd, \"release 18446744073709551615 abc 1\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n\n// bad duration\nmustsend(fd, \"release 18446744073709551615 1 abc\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HCRYPTMSG ;\ntypedef  int /*<<< orphan*/  HCERTSTORE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CryptMsgClose (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CryptMsgOpenToDecode (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< or"
},
{
    "file:":"./beanstalkd/extr_prot.c_kick_jobs",
    "input":"\n0000000000000000 <kick_jobs>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%edx, %r14d\n7: \tmovq\t%rsi, %rbx\na: \tmovq\t%rdi, %rbp\nd: \tmovq\t%rsi, %rdi\n10: \tcallq\t0x15 <kick_jobs+0x15>\n15: \tmovq\t%rbp, %rdi\n18: \tmovq\t%rbx, %rsi\n1b: \tmovl\t%r14d, %edx\n1e: \ttestq\t%rax, %rax\n21: \tje\t0x2c <kick_jobs+0x2c>\n23: \tpopq\t%rbx\n24: \tpopq\t%r14\n26: \tpopq\t%rbp\n27: \tjmp\t0x2c <kick_jobs+0x2c>\n2c: \tpopq\t%rbx\n2d: \tpopq\t%r14\n2f: \tpopq\t%rbp\n30: \tjmp\t0x35 <kick_jobs+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint ;\ntypedef  int /*<<< orphan*/  Tube ;\ntypedef  int /*<<< orphan*/  Server ;\n\n/* Variables and functions */\nscalar_t__ buried_job_p (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  kick_buried_jobs (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_delayed_jobs (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static uint\nkick_jobs(Server *s, Tube *t, uint n)\n{\nif (buried_job_p(t))\nreturn kick_buried_jobs(s, t, n);\nreturn kick_delayed_jobs(s, t, n);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  job_t ;\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  kick_job (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  kick_jobs_all (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nscalar_t__ job_is_active (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void kick_jobs(fz_context *ctx, job_t *job, int force)\n{\nif (job_is_active(ctx, job))\nkick_job(ctx, job, force);\nelse\nkick_jobs_all(ctx, job);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_ctbench_job_free",
    "input":"\n0000000000000000 <ctbench_job_free>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edi, %r14d\na: \tmovl\t$8, %esi\nf: \tcallq\t0x14 <ctbench_job_free+0x14>\n14: \tmovq\t%rax, %r15\n17: \tmovl\t(%rip), %ebp  # 0x1d <ctbench_job_free+0x1d>\n1d: \tmovl\t$0, %edi\n22: \tcallq\t0x27 <ctbench_job_free+0x27>\n27: \tmovl\t%ebp, %edi\n29: \tmovl\t%eax, %esi\n2b: \tcallq\t0x30 <ctbench_job_free+0x30>\n30: \ttestl\t%r14d, %r14d\n33: \tjle\t0x94 <ctbench_job_free+0x94>\n35: \tmovl\t%r14d, %ebp\n38: \txorl\t%ebx, %ebx\n3a: \tnopw\t(%rax,%rax)\n40: \tmovl\t(%rip), %r8d  # 0x47 <ctbench_job_free+0x47>\n47: \txorl\t%edi, %edi\n49: \txorl\t%esi, %esi\n4b: \tmovl\t$1, %edx\n50: \txorl\t%ecx, %ecx\n52: \tcallq\t0x57 <ctbench_job_free+0x57>\n57: \tmovq\t%rax, (%r15,%rbx,8)\n5b: \taddq\t$1, %rbx\n5f: \tcmpq\t%rbx, %rbp\n62: \tjne\t0x40 <ctbench_job_free+0x40>\n64: \txorl\t%eax, %eax\n66: \tcallq\t0x6b <ctbench_job_free+0x6b>\n6b: \ttestl\t%r14d, %r14d\n6e: \tjle\t0x9b <ctbench_job_free+0x9b>\n70: \txorl\t%ebx, %ebx\n72: \tnopw\t%cs:(%rax,%rax)\n7c: \tnopl\t(%rax)\n80: \tmovq\t(%r15,%rbx,8), %rdi\n84: \tcallq\t0x89 <ctbench_job_free+0x89>\n89: \taddq\t$1, %rbx\n8d: \tcmpq\t%rbx, %rbp\n90: \tjne\t0x80 <ctbench_job_free+0x80>\n92: \tjmp\t0x9b <ctbench_job_free+0x9b>\n94: \txorl\t%eax, %eax\n96: \tcallq\t0x9b <ctbench_job_free+0x9b>\n9b: \txorl\t%eax, %eax\n9d: \tcallq\t0xa2 <ctbench_job_free+0xa2>\na2: \tmovq\t%r15, %rdi\na5: \taddq\t$8, %rsp\na9: \tpopq\t%rbx\naa: \tpopq\t%r14\nac: \tpopq\t%r15\nae: \tpopq\t%rbp\naf: \tjmp\t0xb4 <ctbench_job_free+0xb4>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ ** calloc (int,int) ;\nint /*<<< orphan*/  ctresettimer () ;\nint /*<<< orphan*/  ctstoptimer () ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ **) ;\nint /*<<< orphan*/  job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_job (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\nctbench_job_free(int n)\n{\nint i;\nJob **j = calloc(n, sizeof *j);\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\nfor (i = 0; i < n; i++) {\nj[i] = make_job(0, 0, 1, 0, default_tube);\n}\n\nctresettimer();\nfor (i = 0; i < n; i++) {\njob_free(j[i]);\n}\nctstoptimer();\n\nfree(j);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ctbench_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CRYPTO_THREAD_lock_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  CRYPTO_THREAD_lock_new () ;\nint /*<<< orphan*/  CRYPTO_THREAD_lock_num_locks () ;\nint /*<<< orphan*/  CRYPTO_THREAD_lock_type_default () ;\nint /*<<< orphan*/  OPENSSL_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * OPENSSL_zalloc (int) ;\nint /*<<< orphan*/  ctbench_job_free_cb ;\nint /*<<< orphan*/  ctbench_job_free_cb_arg ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free ;\nint /*<<< orphan*/  ctbench_job_free_cb_lock_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free_arg_free"
},
{
    "file:":"./beanstalkd/extr_file.c_filermjob",
    "input":"\n0000000000000000 <filermjob>:\n0: \ttestq\t%rdi, %rdi\n3: \tje\t0xb <filermjob+0xb>\n5: \tcmpq\t%rdi, 8(%rsi)\n9: \tje\t0xc <filermjob+0xc>\nb: \tretq\nc: \tleaq\t8(%rsi), %rax\n10: \tmovq\t16(%rsi), %rcx\n14: \tmovq\t24(%rsi), %rdx\n18: \tmovq\t%rcx, (%rdx)\n1b: \tmovq\t%rdx, (%rcx)\n1e: \txorps\t%xmm0, %xmm0\n21: \tmovups\t%xmm0, (%rax)\n24: \tmovq\t$0, 16(%rax)\n2c: \tmovl\t(%rsi), %eax\n2e: \tmovq\t(%rdi), %rcx\n31: \tsubl\t%eax, (%rcx)\n33: \tmovq\t$0, (%rsi)\n3a: \tjmp\t0x3f <filermjob+0x3f>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_5__ ;\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_13__ {TYPE_1__* w; } ;\nstruct TYPE_12__ {scalar_t__ walused; TYPE_5__* file; TYPE_2__* fprev; TYPE_3__* fnext; } ;\nstruct TYPE_11__ {TYPE_2__* fprev; } ;\nstruct TYPE_10__ {TYPE_3__* fnext; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  alive; } ;\ntypedef  TYPE_4__ Job ;\ntypedef  TYPE_5__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  filedecref (TYPE_5__*) ;\n\nvoid\nfilermjob(File *f, Job *j)\n{\nif (!f) return;\nif (f != j->file) return;\nj->fnext->fprev = j->fprev;\nj->fprev->fnext = j->fnext;\nj->fnext = 0;\nj->fprev = 0;\nj->file = NULL;\nf->w->alive -= j->walused;\nj->walused = 0;\nfiledecref(f);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * job; int /*<<< orphan*/ * next; int /*<<< orphan*/ * prev; } ;\ntypedef  TYPE_1__ fz_job ;\ntypedef  int /*<<< orphan*/  fz_context ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_drop_job (int /*<<< orphan*/ *,TYPE_1__*) ;\n\n__attribute__((used)) static void filermjob(fz_context *ctx, fz_job *job)\n{\nif (job)\n{\nfz_job *next = job->next;\nfz_job *prev = job->prev;\nfz_job **head = job->job;\n\nprev->next = next;\nnext->prev = prev;\n*head = NULL;\n\nfz_drop_job(ctx, job);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_main.c_main",
    "input":"\n0000000000000000 <main>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rsi, %rbx\n4: \tcallq\t0x9 <main+0x9>\n9: \tmovq\t(%rbx), %rax\nc: \tmovq\t%rax, (%rip)  # 0x13 <main+0x13>\n13: \tmovl\t(%rip), %edi  # 0x19 <main+0x19>\n19: \tcallq\t0x1e <main+0x1e>\n1e: \taddq\t$8, %rbx\n22: \tmovl\t$0, %edi\n27: \tmovq\t%rbx, %rsi\n2a: \tcallq\t0x2f <main+0x2f>\n2f: \tcmpq\t$0, (%rip)    # 0x37 <main+0x37>\n37: \tje\t0x4c <main+0x4c>\n39: \txorl\t%eax, %eax\n3b: \tcallq\t0x40 <main+0x40>\n40: \tmovl\t$0, %edi\n45: \tmovl\t%eax, %esi\n47: \tcallq\t0x4c <main+0x4c>\n4c: \tmovl\t(%rip), %edi  # 0x52 <main+0x52>\n52: \tmovl\t(%rip), %esi  # 0x58 <main+0x58>\n58: \tcallq\t0x5d <main+0x5d>\n5d: \tcmpl\t$-1, %eax\n60: \tjne\t0x76 <main+0x76>\n62: \tmovl\t$0, %edi\n67: \tcallq\t0x6c <main+0x6c>\n6c: \tmovl\t$111, %edi\n71: \tcallq\t0x76 <main+0x76>\n76: \tmovl\t%eax, (%rip)  # 0x7c <main+0x7c>\n7c: \txorl\t%eax, %eax\n7e: \tcallq\t0x83 <main+0x83>\n83: \tmovq\t(%rip), %rdi  # 0x8a <main+0x8a>\n8a: \ttestq\t%rdi, %rdi\n8d: \tje\t0x94 <main+0x94>\n8f: \tcallq\t0x94 <main+0x94>\n94: \txorl\t%eax, %eax\n96: \tcallq\t0x9b <main+0x9b>\n9b: \tmovl\t$0, %edi\na0: \tcallq\t0xa5 <main+0xa5>\na5: \tmovl\t$0, %edi\naa: \tcallq\t0xaf <main+0xaf>\naf: \txorl\t%edi, %edi\nb1: \tcallq\t0xb6 <main+0xb6>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int fd; } ;\nstruct TYPE_7__ {scalar_t__ user; TYPE_1__ sock; int /*<<< orphan*/  port; int /*<<< orphan*/  addr; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  UNUSED_PARAMETER (int) ;\nint /*<<< orphan*/  exit (int) ;\nint getpid () ;\nint make_server_socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nint /*<<< orphan*/  printf (char*,int) ;\nchar* progname ;\nint /*<<< orphan*/  prot_init () ;\nint /*<<< orphan*/  set_sig_handlers () ;\nint /*<<< orphan*/  setlinebuf (int /*<<< orphan*/ ) ;\nTYPE_2__ srv ;\nint /*<<< orphan*/  srv_acquire_wal (TYPE_2__*) ;\nint /*<<< orphan*/  srvserve (TYPE_2__*) ;\nint /*<<< orphan*/  stdout ;\nint /*<<< orphan*/  su (scalar_t__) ;\nint /*<<< orphan*/  twarnx (char*) ;\nscalar_t__ verbose ;\n\nint\nmain(int argc, char **argv)\n{\nUNUSED_PARAMETER(argc);\n\nprogname = argv[0];\nsetlinebuf(stdout);\noptparse(&srv, argv+1);\n\nif (verbose) {\nprintf(\"pid %d\\n\", getpid());\n}\n\nint r = make_server_socket(srv.addr, srv.port);\nif (r == -1) {\ntwarnx(\"make_server_socket()\");\nexit(111);\n}\n\nsrv.sock.fd = r;\n\nprot_init();\n\nif (srv.user)\nsu(srv.user);\nset_sig_handlers();\n\nsrv_acquire_wal(&srv);\nsrvserve(&srv);\nexit(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  EXIT_FAILURE ;\nint /*<<< orphan*/  EXIT_SUCCESS ;\nint /*<<< orphan*/  SIGINT ;\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  SIGUSR1 ;\nint /*<<< orphan*/  SIGUSR2 ;\nint /*<<< orphan*/  SIGUSR3 ;\nint /*<<< orphan*/  SIGUSR4 ;\nint /*<<< orphan*/  SIGUSR5 ;\nint /*<<< orphan*/  SIGUSR6 ;\nint /*<<< orphan*/  SIGUSR7 ;\nint /*<<< orphan*/  SIGUSR8 ;\nint /*<<< orphan*/  SIGUSR9 ;\nint /*<<< orphan*/  SIGUSR10 ;\nint /*<<< orphan*/  SIGUSR11 ;\nint /*<<< orphan*/  SIGUSR12 ;\nint /*<<< orphan*/  SIGUSR13 ;\nint /*<<< orphan*/  SIGUSR14 ;\nint /*<<< orphan*/  SIGUSR15 ;\nint /*<<< orphan*/  SIGUSR16 ;\nint /*<<< orphan*/  SIGUSR17 ;\nint /*<<< orphan*/  SIGUSR18 ;\nint /*<<< orphan*/  SIGUSR19 ;\nint /*<<< orphan*/  SIGUSR20 ;\nint /*<<< orphan*/  SIGUSR21 ;\nint /*<<< orphan*/  SIGUSR22 ;\nint /*<<< orphan*/  SIGUSR23 ;\nint /*<<< orphan*/  SIGUSR24 ;\nint /*<<< orphan*/  SIGUSR25 ;\nint /*<<< orphan*/  SIGUSR26 ;\nint /*<<< orphan*/  SIGUSR27 ;\nint /*<<< orphan*/  SIGUSR28 ;\nint /*<<< orphan*/  SIGUSR29 ;\nint /*<<< orphan*/  SIGUSR30 ;\nint /*<<< orphan*/  SIGUSR31 ;\nint /*<<< orphan*/  SIGUSR32 ;\nint /*<<< orphan*/  SIGUSR33 ;\nint /*<<< orphan*/  SIGUSR34 ;\nint /*<<< orphan*/  SIGUSR35 ;\nint /*<<< orphan*/  SIGUSR36 ;\nint /*<<< orphan*/  SIGUSR37 ;\nint /*<<< orphan*/  SIGUSR38 ;\nint /*<<< orphan*/  SIGUSR39 ;\nint /*<<< orphan*/  SIGUSR40 ;\nint /*<<< orphan*/  SIGUSR41 ;\nint /*<<< orphan*/  SIGUSR42 ;\nint /*<<< orphan*/  SIGUSR43 ;\nint /*<<< orphan*/  SIGUSR44 ;\nint /*<<< orphan*/  SIGUSR45 ;\nint /*<<< orphan*/  SIGUSR46 ;\nint /*<<< orphan*/  SIGUSR47 ;\nint /*<<< orphan*/  SIGUSR48 ;\nint /*<<< orphan*/  SIGUSR49 ;\nint /*<<< orphan*/  SIGUSR50 ;\nint /*<<< orphan*/  SIGUSR51 ;\nint /*<<< orphan*/  SIGUSR52 ;\nint /*<<< orphan*/  SIGUSR53 ;\nint /*<<< orphan*/  SIGUSR54 ;\nint /*<<< orphan*/  SIGUSR55 ;\nint /*<<< orphan*/  SIGUSR56 ;\nint /*<<< orphan*/  SIGUSR57 ;\nint /*<<< orphan*/  SIGUSR58 ;\nint /*<<< orphan*/  SIGUSR59 ;\nint /*<<< orphan*/  SIGUSR60 ;\nint /*<<< orphan*/  SIGUSR61 ;\nint /*<<< orphan*/  SIGUSR62 ;\nint /*<<< orphan*/  SIGUSR63 ;\nint /*<<< orphan*/  SIGUSR64 ;\nint /*<<< orphan*/  SIGUSR65 ;\nint /*<<< orphan*/  SIGUSR66 ;\nint /*<<< orphan*/  SIGUSR67 ;\nint /*<<< orphan*/  SIGUSR68 ;\nint /*<<< orphan*/  SIGUSR69 ;\nint /*<<< orphan*/  SIGUSR70 ;\nint /*<<< orphan*/  SIGUSR71 ;\nint /*<<< orphan*/  SIGUSR72 ;\nint /*<<< orphan*/  SIGUSR73 ;\nint /*<<< orphan*/  SIGUSR74 ;\nint /*<<< orphan*/  SIGUSR75 ;\nint /*<<< orphan*/  SIGUSR76 ;\nint /*<<< orphan*/  SIGUSR77 ;\nint /*<<< orphan*/  SIGUSR78 ;\nint /*<<< orphan*/  SIGUSR79 ;\nint /*<<< orphan*/  SIGUSR80 ;\nint /*<<< orphan*/  SIGUSR81 ;\nint /*<<< orphan*/  SIGUSR82 ;\nint /*<<< orphan*/  SIGUSR83 ;\nint /*<<< orphan*/  SIGUSR84 ;\nint /*<<< orphan*/  SIGUSR85 ;\nint /*<<< orphan*/  SIGUSR86 ;\nint /*<<< orphan*/  SIGUSR87 ;\nint /*<<< orphan*/  SIGUSR88 ;\nint /*<<< orphan*/  SIGUSR89 ;\nint /*<<< orphan*/  SIGUSR90 ;\nint /*<<< orphan*/  SIGUSR91 ;\nint /*<<< orphan*/  SIGUSR92 ;\nint /*<<< orphan*/  SIGUSR93 ;\nint /*<<< orphan*/  SIGUSR94 ;\nint /*<<< orphan*/  SIGUSR95 ;\nint /*<<< orphan*/  SIGUSR96 ;\nint /*<<< orphan*/  SIGUSR97 ;\nint /*<<< orphan*/  SIGUSR98 ;\nint /*<<< orphan*/  SIGUSR99 ;\nint /*<<< orphan*/  SIGUSR100 ;\nint /*<<< orphan*/  SIGUSR101 ;\nint /*<<< orphan*/  SIGUSR102 ;\nint /*<<< orphan*/  SIGUSR103 ;\nint /*<<< orphan*/  SIGUSR104 ;\nint /*<<< orphan*/  SIGUSR105 ;\nint /*<<< orphan*/  SIGUSR106 ;\nint /*<<< orphan*/  SIGUSR107 ;\nint /*<<< orphan*/  SIGUSR108 ;\nint /*<<< orphan*/  SIGUSR109 ;\nint /*<<< orphan*/  SIGUSR110 ;\nint /*<<< orphan*/  SIGUSR111 ;\nint /*<<< orphan*/  SIGUSR112 ;\nint /*<<< orphan*/  SIGUSR113 ;\nint /*<<< orphan*/  SIGUSR114 ;\nint /*<<< orphan*/  SIGUSR115 ;\nint /*<<< orphan*/  SIGUSR116 ;\nint /*<<< orphan*/  SIG"
},
{
    "file:":"./beanstalkd/extr_prot.c_epollq_add",
    "input":"\n0000000000000000 <epollq_add>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovb\t%sil, (%rdi)\n7: \tcallq\t0xc <epollq_add+0xc>\nc: \tmovq\t(%rip), %rax  # 0x13 <epollq_add+0x13>\n13: \tmovq\t%rax, 8(%rbx)\n17: \tmovq\t%rbx, (%rip)  # 0x1e <epollq_add+0x1e>\n1e: \tpopq\t%rbx\n1f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {char rw; struct TYPE_5__* next; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  connsched (TYPE_1__*) ;\nTYPE_1__* epollq ;\n\n__attribute__((used)) static void\nepollq_add(Conn *c, char rw) {\nc->rw = rw;\nconnsched(c);\nc->next = epollq;\nepollq = c;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  data; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ epollq_t ;\n\n/* Variables and functions */\nTYPE_1__* epollq_tail ;\nint /*<<< orphan*/  epollq_tail_add (TYPE_1__*) ;\n\nvoid epollq_add (epollq_t *E, int fd, void *data) {\nE->data = data;\nE->next = epollq_tail;\nepollq_tail = E;\nepollq_tail_add (E);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_remove_this_reserved_job",
    "input":"\n0000000000000000 <remove_this_reserved_job>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t%rsi, %rdi\n7: \tcallq\t0xc <remove_this_reserved_job+0xc>\nc: \ttestq\t%rax, %rax\nf: \tje\t0x26 <remove_this_reserved_job+0x26>\n11: \taddl\t$-1, (%rip)   # 0x18 <remove_this_reserved_job+0x18>\n18: \tmovq\t8(%rax), %rcx\n1c: \taddl\t$-1, (%rcx)\n1f: \tmovq\t$0, (%rax)\n26: \tmovq\t$0, (%rbx)\n2d: \tpopq\t%rbx\n2e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_15__   TYPE_4__ ;\ntypedef  struct TYPE_14__   TYPE_3__ ;\ntypedef  struct TYPE_13__   TYPE_2__ ;\ntypedef  struct TYPE_12__   TYPE_1__ ;\ntypedef  struct TYPE_11__   TYPE_10__ ;\n\n/* Type definitions */\nstruct TYPE_15__ {int /*<<< orphan*/ * soonest_job; } ;\nstruct TYPE_14__ {int /*<<< orphan*/ * reserver; TYPE_2__* tube; } ;\nstruct TYPE_12__ {int /*<<< orphan*/  reserved_ct; } ;\nstruct TYPE_13__ {TYPE_1__ stat; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  reserved_ct; } ;\ntypedef  TYPE_3__ Job ;\ntypedef  TYPE_4__ Conn ;\n\n/* Variables and functions */\nTYPE_10__ global_stat ;\nTYPE_3__* job_list_remove (TYPE_3__*) ;\n\n__attribute__((used)) static Job *\nremove_this_reserved_job(Conn *c, Job *j)\n{\nj = job_list_remove(j);\nif (j) {\nglobal_stat.reserved_ct--;\nj->tube->stat.reserved_ct--;\nj->reserver = NULL;\n}\nc->soonest_job = NULL;\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * job; int /*<<< orphan*/ * reserved_jobs; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nTYPE_1__* get_job_by_id (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  reserved_jobs_count ;\n\n__attribute__((used)) static void remove_this_reserved_job (job_t **J, int job_id) {\njob_t *J_ = get_job_by_id (J, job_id);\nif (J_) {\nreserved_jobs_count--;\nJ_->reserved_jobs[0]--;\nJ_->job = NULL;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_on_ignore",
    "input":"\n0000000000000000 <on_ignore>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdx, %r14\n7: \tmovq\t%rsi, %rbx\na: \tcallq\t0xf <on_ignore+0xf>\nf: \tmovq\t%r14, %rdi\n12: \tcallq\t0x17 <on_ignore+0x17>\n17: \taddl\t$-1, (%rbx)\n1a: \tmovq\t%rbx, %rdi\n1d: \taddq\t$8, %rsp\n21: \tpopq\t%rbx\n22: \tpopq\t%r14\n24: \tjmp\t0x29 <on_ignore+0x29>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  watching_ct; } ;\ntypedef  TYPE_1__ Tube ;\ntypedef  int /*<<< orphan*/  Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  UNUSED_PARAMETER (size_t) ;\nint /*<<< orphan*/  tube_dref (TYPE_1__*) ;\n\n__attribute__((used)) static void\non_ignore(Ms *a, Tube *t, size_t i)\n{\nUNUSED_PARAMETER(a);\nUNUSED_PARAMETER(i);\nt->watching_ct--;\ntube_dref(t);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  ignore_count; } ;\ntypedef  TYPE_1__ signal_user_data_t ;\ntypedef  int /*<<< orphan*/  GDBusConnection ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_dbus_connection_unref (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_free (char*) ;\nint /*<<< orphan*/  signal_user_data_free (TYPE_1__*) ;\n\n__attribute__((used)) static void\non_ignore (GDBusConnection *connection, const char *name, void *user_data)\n{\nsignal_user_data_t *data = user_data;\n\ng_dbus_connection_unref (connection);\ng_free ((char *) name);\n\ndata->ignore_count--;\nsignal_user_data_free (data);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_omit_time_left",
    "input":"\n0000000000000000 <cttest_omit_time_left>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_omit_time_left+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_omit_time_left+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_omit_time_left+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_omit_time_left+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_omit_time_left+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_omit_time_left+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_omit_time_left+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_omit_time_left+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_omit_time_left()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 5 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"stats-job 1\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ntime-left: 0\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  get_time_left () ;\n\n__attribute__((used)) static void cttest_omit_time_left(void)\n{\nFILE *f = fopen(\"cttest_omit_time_left.txt\", \"w\");\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d\\n\", get_time_left());\nfprintf(f, \"%d"
},
{
    "file:":"./beanstalkd/extr_testserv.c_muststart",
    "input":"\n0000000000000000 <muststart>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tsubq\t$16, %rsp\nd: \tmovq\t%r8, %r14\n10: \tmovq\t%rcx, %r15\n13: \tmovq\t%rdx, %r12\n16: \tmovq\t%rsi, %r13\n19: \tmovq\t%rdi, %rbx\n1c: \txorl\t%eax, %eax\n1e: \tcallq\t0x23 <muststart+0x23>\n23: \tmovl\t%eax, (%rip)  # 0x29 <muststart+0x29>\n29: \ttestl\t%eax, %eax\n2b: \tjs\t0xa0 <muststart+0xa0>\n2d: \tje\t0x73 <muststart+0x73>\n2f: \tmovl\t$0, %edi\n34: \tmovq\t%rbx, %rsi\n37: \tmovq\t%r13, %rdx\n3a: \tmovq\t%r12, %rcx\n3d: \tmovq\t%r15, %r8\n40: \tmovq\t%r14, %r9\n43: \txorl\t%eax, %eax\n45: \tcallq\t0x4a <muststart+0x4a>\n4a: \tmovl\t(%rip), %esi  # 0x50 <muststart+0x50>\n50: \tmovl\t$0, %edi\n55: \txorl\t%eax, %eax\n57: \tcallq\t0x5c <muststart+0x5c>\n5c: \tmovl\t$100000, %edi # imm = 0x186A0\n61: \taddq\t$16, %rsp\n65: \tpopq\t%rbx\n66: \tpopq\t%r12\n68: \tpopq\t%r13\n6a: \tpopq\t%r14\n6c: \tpopq\t%r15\n6e: \tjmp\t0x73 <muststart+0x73>\n73: \tmovq\t$0, (%rsp)\n7b: \tmovq\t%rbx, %rdi\n7e: \tmovq\t%rbx, %rsi\n81: \tmovq\t%r13, %rdx\n84: \tmovq\t%r12, %rcx\n87: \tmovq\t%r15, %r8\n8a: \tmovq\t%r14, %r9\n8d: \tcallq\t0x92 <muststart+0x92>\n92: \taddq\t$16, %rsp\n96: \tpopq\t%rbx\n97: \tpopq\t%r12\n99: \tpopq\t%r13\n9b: \tpopq\t%r14\n9d: \tpopq\t%r15\n9f: \tretq\na0: \tmovl\t$0, %edi\na5: \tcallq\t0xaa <muststart+0xaa>\naa: \tmovl\t$1, %edi\naf: \tcallq\t0xb4 <muststart+0xb4>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  execlp (char*,char*,char*,char*,char*,char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  exit (int) ;\nint fork () ;\nint /*<<< orphan*/  printf (char*,...) ;\nint srvpid ;\nint /*<<< orphan*/  twarn (char*) ;\nint /*<<< orphan*/  usleep (int) ;\n\n__attribute__((used)) static void\nmuststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n{\nsrvpid = fork();\nif (srvpid < 0) {\ntwarn(\"fork\");\nexit(1);\n}\n\nif (srvpid > 0) {\nprintf(\"%s %s %s %s %s\\n\", a0, a1, a2, a3, a4);\nprintf(\"start server pid=%d\\n\", srvpid);\nusleep(100000); // .1s; time for the child to bind to its port\nreturn;\n}\n\n/* now in child */\n\nexeclp(a0, a0, a1, a2, a3, a4, NULL);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  PGconn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PQERRORS_TERSE ;\nint /*<<< orphan*/  PQfinish (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PQsetErrorVerbosity (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  PQsetNoticeReceiver (int /*<<< orphan*/ *,int /*<<< orphan*/ *,void*) ;\nint /*<<< orphan*/  PQsetNoticeProcessor (int /*<<< orphan*/ *,int /*<<< orphan*/ *,void*) ;\nint /*<<< orphan*/  PQsetSingleRowMode (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PQstatus (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char const*,char const*,char const*,char const*,char const*) ;\nint /*<<< orphan*/  pg_log_error (char*) ;\nint /*<<< orphan*/  pg_log_info (char*,...) ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static void\nmuststart(PGconn *conn, const char *dbname, const char *username,\nconst char *host, const char *port)\n{\nint\t\t\tstatus;\n\nstatus = PQstatus(conn);\nif (status == CONNECTION_BAD)\n{\nPQfinish(conn);\npg_log_error(\"connection to database \\\"%s\\\" failed: %s\",\ndbname, PQerrorMessage(conn));\n}\nelse if (status != CONNECTION_OK)\n{\nPQsetNoticeProcessor(conn, notice_processor, NULL);\nPQsetNoticeReceiver(conn, notice_receiver, NULL);\nPQsetSingleRowMode(conn);\nPQsetErrorVerbosity(conn, PQERRORS_TERSE);\n\nfprintf(stderr,\n\"could not connect to database \\\"%s\\\" as user \\\"%s\\\" on host \\\"%s\\\" at port \\\"%s\\\": %s\\n\",\ndbname, username, host, port, PQerrorMessage(conn));\nPQfinish(conn);\npg_log_info(\"exiting because connection to database failed\");\nexit(1);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_pri_less",
    "input":"\n0000000000000000 <job_pri_less>:\n0: \tmovq\t(%rdi), %rcx\n3: \tmovq\t(%rsi), %rdx\n6: \tmovl\t$1, %eax\nb: \tcmpq\t%rdx, %rcx\ne: \tjl\t0x24 <job_pri_less+0x24>\n10: \txorl\t%eax, %eax\n12: \tcmpq\t%rdx, %rcx\n15: \tjg\t0x24 <job_pri_less+0x24>\n17: \tmovq\t8(%rdi), %rcx\n1b: \txorl\t%eax, %eax\n1d: \tcmpq\t8(%rsi), %rcx\n21: \tsetl\t%al\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ pri; scalar_t__ id; } ;\nstruct TYPE_4__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\n\nint\njob_pri_less(void *ja, void *jb)\n{\nJob *a = (Job *)ja;\nJob *b = (Job *)jb;\nif (a->r.pri < b->r.pri) return 1;\nif (a->r.pri > b->r.pri) return 0;\nreturn a->r.id < b->r.id;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ pri; scalar_t__ id; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static inline int\njob_pri_less(const job_t *a, const job_t *b)\n{\nif (a->pri < b->pri)\nreturn 1;\nif (a->pri > b->pri)\nreturn 0;\nreturn a->id < b->id;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_quit_releases_job",
    "input":"\n0000000000000000 <cttest_quit_releases_job>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <cttest_quit_releases_job+0xa>\na: \tmovl\t%eax, %ebx\nc: \tmovl\t%eax, %edi\ne: \tcallq\t0x13 <cttest_quit_releases_job+0x13>\n13: \tmovl\t%eax, %ebp\n15: \tmovl\t%ebx, %edi\n17: \tcallq\t0x1c <cttest_quit_releases_job+0x1c>\n1c: \tmovl\t%eax, %ebx\n1e: \tmovl\t$0, %esi\n23: \tmovl\t%ebp, %edi\n25: \tcallq\t0x2a <cttest_quit_releases_job+0x2a>\n2a: \tmovl\t$0, %esi\n2f: \tmovl\t%ebx, %edi\n31: \tcallq\t0x36 <cttest_quit_releases_job+0x36>\n36: \tmovl\t$0, %esi\n3b: \tmovl\t%ebx, %edi\n3d: \tcallq\t0x42 <cttest_quit_releases_job+0x42>\n42: \tmovl\t$0, %esi\n47: \tmovl\t%ebx, %edi\n49: \tcallq\t0x4e <cttest_quit_releases_job+0x4e>\n4e: \tmovl\t$0, %esi\n53: \tmovl\t%ebp, %edi\n55: \tcallq\t0x5a <cttest_quit_releases_job+0x5a>\n5a: \tmovl\t$0, %esi\n5f: \tmovl\t%ebp, %edi\n61: \tcallq\t0x66 <cttest_quit_releases_job+0x66>\n66: \tmovl\t$0, %esi\n6b: \tmovl\t%ebx, %edi\n6d: \tcallq\t0x72 <cttest_quit_releases_job+0x72>\n72: \tmovl\t$0, %esi\n77: \tmovl\t%ebx, %edi\n79: \tcallq\t0x7e <cttest_quit_releases_job+0x7e>\n7e: \tmovl\t$0, %esi\n83: \tmovl\t%ebx, %edi\n85: \tcallq\t0x8a <cttest_quit_releases_job+0x8a>\n8a: \tmovl\t$0, %esi\n8f: \tmovl\t%ebp, %edi\n91: \tcallq\t0x96 <cttest_quit_releases_job+0x96>\n96: \tmovl\t$0, %esi\n9b: \tmovl\t%ebx, %edi\n9d: \tcallq\t0xa2 <cttest_quit_releases_job+0xa2>\na2: \tmovl\t$0, %esi\na7: \tmovl\t%ebx, %edi\na9: \tcallq\t0xae <cttest_quit_releases_job+0xae>\nae: \tmovl\t$0, %esi\nb3: \tmovl\t%ebx, %edi\nb5: \taddq\t$8, %rsp\nb9: \tpopq\t%rbx\nba: \tpopq\t%rbp\nbb: \tjmp\t0xc0 <cttest_quit_releases_job+0xc0>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_quit_releases_job()\n{\n// This test is similar to the close_releases_job test, except that\n// connection is not closed, but command quit is sent.\nint port = SERVER();\nint cons = mustdiallocal(port);\nint prod = mustdiallocal(port);\nmustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n\nmustsend(prod, \"put 0 0 100 1\\r\\n\");\nmustsend(prod, \"a\\r\\n\");\nckresp(prod, \"INSERTED 1\\r\\n\");\n\nckresp(cons, \"RESERVED 1 1\\r\\n\");\nckresp(cons, \"a\\r\\n\");\n\nmustsend(prod, \"stats-job 1\\r\\n\");\nckrespsub(prod, \"OK \");\nckrespsub(prod, \"\\nstate: reserved\\n\");\n\n// Quitting consumer should make the job ready sooner than ttr=100.\nmustsend(cons, \"quit\\r\\n\");\n\n// Job should be released in less than 1s. It is not instantly;\n// we do not make guarantees about how soon jobs should be released.\nmustsend(prod, \"reserve-with-timeout 1\\r\\n\");\nckresp(prod, \"RESERVED 1 1\\r\\n\");\nckresp(prod, \"a\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_module_close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_name () ;\nint /*<<< orphan*/  g_test_add_data_func (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_init (int*,char***) ;\nint /*<<< orphan*/  g_test_quit () ;\nint /*<<< orphan*/  g_test_subprocess () ;\nint /*<<< orphan*/  g_test_trap_assert_failed () ;\nint /*<<< orphan*/  g_test_trap_assert_stderr (char*) ;\nint /*<<< orphan*/  g_test_trap_assert_stderr_unmatched (char*) ;\nint /*<<< orphan*/  g_test_trap_assert_stdout (char*) ;\nint /*<<< orphan*/  g_test_trap_assert_stdout_unmatched (char*) ;\nint /*<<< orphan*/  g_test_trap_assert_unmatched (char*) ;\nint /*<<< orphan*/  g_test_trap_fork (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_reached_state (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_subprocess (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\ncttest_quit_releases_job (void)\n{\nGModule *module;\n\ng_test_init (&module, NULL);\n\ng_test_trap_fork (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_subprocess (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_fork (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_subprocess (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_fork (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_subprocess (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_fork (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_stderr (\"*Hello, world!*\");\ng_test_trap_assert_stderr_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_unmatched (\"*Hello, world!*\");\ng_test_trap_assert_unmatched (\"*Goodbye, world!*\");\ng_test_trap_assert_reached_state (g_test_trap_assert_failed, 0);\n\ng_test_trap_subprocess (g_test_subprocess (), 0, 0);\ng_test_trap_assert_passed ();\ng_test_trap_assert_stdout (\"*Hello, world!*\");\ng_test_trap_assert_stdout_unmatched (\"*Goodbye, world!"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_unknown_command",
    "input":"\n0000000000000000 <cttest_unknown_command>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_unknown_command+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_unknown_command+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_unknown_command+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tpopq\t%rbx\n25: \tjmp\t0x2a <cttest_unknown_command+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_unknown_command()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"nont10knowncommand\\r\\n\");\nckresp(fd, \"UNKNOWN_COMMAND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  BIO_s_file () ;\nint /*<<< orphan*/  BIO_stderr () ;\n\n__attribute__((used)) static void cttest_unknown_command(void)\n{\nBIO *bio = BIO_new(BIO_s_file());\n\nBIO_printf(bio, \"Unknown command\\n\");\nBIO_printf(BIO_stderr(), \"Unknown command\\n\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_8192_fsync_050ms",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_8192_fsync_050ms>:\n0: \tmovl\t$8192, %esi   # imm = 0x2000\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \tmovl\t$1, %ecx\nf: \tmovl\t$100, %r8d\n15: \tjmp\t0x1a <ctbench_put_delete_wal_8192_fsync_050ms+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int,int) ;\n\nvoid\nctbench_put_delete_wal_8192_fsync_050ms(int n)\n{\nbench_put_delete_size(n, 8192, 512000, 1, 100);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal (int,int,int,int,int) ;\n\nint ctbench_put_delete_wal_8192_fsync_050ms (int fd) {\nreturn ctbench_put_delete_wal (fd, 8192, 512000, 1, 100);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_1024_fsync_200ms",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_1024_fsync_200ms>:\n0: \tmovl\t$1024, %esi   # imm = 0x400\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \tmovl\t$1, %ecx\nf: \tmovl\t$500, %r8d    # imm = 0x1F4\n15: \tjmp\t0x1a <ctbench_put_delete_wal_1024_fsync_200ms+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int,int) ;\n\nvoid\nctbench_put_delete_wal_1024_fsync_200ms(int n)\n{\nbench_put_delete_size(n, 1024, 512000, 1, 500);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal (int,int,int,int,int) ;\n\nint ctbench_put_delete_wal_1024_fsync_200ms (int fd) {\nreturn ctbench_put_delete_wal (fd, 1024, 512000, 1, 500);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_close_releases_job",
    "input":"\n0000000000000000 <cttest_close_releases_job>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <cttest_close_releases_job+0xa>\na: \tmovl\t%eax, %ebx\nc: \tmovl\t%eax, %edi\ne: \tcallq\t0x13 <cttest_close_releases_job+0x13>\n13: \tmovl\t%eax, %ebp\n15: \tmovl\t%ebx, %edi\n17: \tcallq\t0x1c <cttest_close_releases_job+0x1c>\n1c: \tmovl\t%eax, %ebx\n1e: \tmovl\t$0, %esi\n23: \tmovl\t%ebp, %edi\n25: \tcallq\t0x2a <cttest_close_releases_job+0x2a>\n2a: \tmovl\t$0, %esi\n2f: \tmovl\t%ebx, %edi\n31: \tcallq\t0x36 <cttest_close_releases_job+0x36>\n36: \tmovl\t$0, %esi\n3b: \tmovl\t%ebx, %edi\n3d: \tcallq\t0x42 <cttest_close_releases_job+0x42>\n42: \tmovl\t$0, %esi\n47: \tmovl\t%ebx, %edi\n49: \tcallq\t0x4e <cttest_close_releases_job+0x4e>\n4e: \tmovl\t$0, %esi\n53: \tmovl\t%ebp, %edi\n55: \tcallq\t0x5a <cttest_close_releases_job+0x5a>\n5a: \tmovl\t$0, %esi\n5f: \tmovl\t%ebp, %edi\n61: \tcallq\t0x66 <cttest_close_releases_job+0x66>\n66: \tmovl\t$0, %esi\n6b: \tmovl\t%ebx, %edi\n6d: \tcallq\t0x72 <cttest_close_releases_job+0x72>\n72: \tmovl\t$0, %esi\n77: \tmovl\t%ebx, %edi\n79: \tcallq\t0x7e <cttest_close_releases_job+0x7e>\n7e: \tmovl\t$0, %esi\n83: \tmovl\t%ebx, %edi\n85: \tcallq\t0x8a <cttest_close_releases_job+0x8a>\n8a: \tmovl\t%ebp, %edi\n8c: \tcallq\t0x91 <cttest_close_releases_job+0x91>\n91: \tmovl\t$0, %esi\n96: \tmovl\t%ebx, %edi\n98: \tcallq\t0x9d <cttest_close_releases_job+0x9d>\n9d: \tmovl\t$0, %esi\na2: \tmovl\t%ebx, %edi\na4: \tcallq\t0xa9 <cttest_close_releases_job+0xa9>\na9: \tmovl\t$0, %esi\nae: \tmovl\t%ebx, %edi\nb0: \taddq\t$8, %rsp\nb4: \tpopq\t%rbx\nb5: \tpopq\t%rbp\nb6: \tjmp\t0xbb <cttest_close_releases_job+0xbb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint /*<<< orphan*/  close (int) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_close_releases_job()\n{\nint port = SERVER();\nint cons = mustdiallocal(port);\nint prod = mustdiallocal(port);\nmustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n\nmustsend(prod, \"put 0 0 100 1\\r\\n\");\nmustsend(prod, \"a\\r\\n\");\nckresp(prod, \"INSERTED 1\\r\\n\");\n\nckresp(cons, \"RESERVED 1 1\\r\\n\");\nckresp(cons, \"a\\r\\n\");\n\nmustsend(prod, \"stats-job 1\\r\\n\");\nckrespsub(prod, \"OK \");\nckrespsub(prod, \"\\nstate: reserved\\n\");\n\n// Closed consumer connection should make the job ready sooner than ttr=100.\nclose(cons);\n\n// Job should be released in less than 1s. It is not instantly;\n// we do not make guarantees about how soon jobs should be released.\nmustsend(prod, \"reserve-with-timeout 1\\r\\n\");\nckresp(prod, \"RESERVED 1 1\\r\\n\");\nckresp(prod, \"a\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_test_close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_job (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_name (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_jobs (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_failed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_skipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_total (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_xfailed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_xpassed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_xskipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_xtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_xxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_xxxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_skipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_xfailed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_xpassed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_xtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_skipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_xfailed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_xpassed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_xtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_skipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_xfailed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_xpassed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_xtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_skipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_xfailed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_xpassed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_xtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_skipped (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_xfailed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_xpassed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_xtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_yxtotal_passed (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_num_tests_yxtotal_yxtotal_yxtotal_yxt"
},
{
    "file:":"./beanstalkd/extr_prot.c_kick_buried_job",
    "input":"\n0000000000000000 <kick_buried_job>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tcallq\t0xf <kick_buried_job+0xf>\nf: \ttestl\t%eax, %eax\n11: \tje\t0x4a <kick_buried_job+0x4a>\n13: \taddl\t%eax, (%rbx)\n15: \tmovq\t%rbx, %rdi\n18: \tcallq\t0x1d <kick_buried_job+0x1d>\n1d: \taddl\t$1, 4(%rbx)\n21: \tmovl\t$1, %ebp\n26: \tmovq\t%r14, %rdi\n29: \tmovq\t%rbx, %rsi\n2c: \txorl\t%edx, %edx\n2e: \tmovl\t$1, %ecx\n33: \tcallq\t0x38 <kick_buried_job+0x38>\n38: \tcmpl\t$1, %eax\n3b: \tje\t0x4c <kick_buried_job+0x4c>\n3d: \tmovq\t%r14, %rdi\n40: \tmovq\t%rbx, %rsi\n43: \txorl\t%edx, %edx\n45: \tcallq\t0x4a <kick_buried_job+0x4a>\n4a: \txorl\t%ebp, %ebp\n4c: \tmovl\t%ebp, %eax\n4e: \tpopq\t%rbx\n4f: \tpopq\t%r14\n51: \tpopq\t%rbp\n52: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {int /*<<< orphan*/  kick_ct; } ;\nstruct TYPE_13__ {int walresv; TYPE_1__ r; } ;\nstruct TYPE_12__ {int /*<<< orphan*/  wal; } ;\ntypedef  TYPE_2__ Server ;\ntypedef  TYPE_3__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  bury_job (TYPE_2__*,TYPE_3__*,int /*<<< orphan*/ ) ;\nint enqueue_job (TYPE_2__*,TYPE_3__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  remove_buried_job (TYPE_3__*) ;\nint walresvupdate (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int\nkick_buried_job(Server *s, Job *j)\n{\nint r;\nint z;\n\nz = walresvupdate(&s->wal);\nif (!z)\nreturn 0;\nj->walresv += z;\n\nremove_buried_job(j);\n\nj->r.kick_ct++;\nr = enqueue_job(s, j, 0, 1);\nif (r == 1)\nreturn 1;\n\n/* ready queue is full, so bury it */\nbury_job(s, j, 0);\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  pri; int /*<<< orphan*/  state; } ;\ntypedef  TYPE_1__ job_t ;\ntypedef  int /*<<< orphan*/  connection ;\n\n/* Variables and functions */\nint /*<<< orphan*/  kick_job (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_queue (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state_pri_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state_state (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state_state_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_queue_state_state_state_state_state_state_state_pri_pri (int /*<<< orphan*/ *,TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  kick_job_from_state_"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_hash_free_next",
    "input":"\n0000000000000000 <cttest_job_hash_free_next>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %ebx  # 0xa <cttest_job_hash_free_next+0xa>\na: \tmovl\t$0, %edi\nf: \tcallq\t0x14 <cttest_job_hash_free_next+0x14>\n14: \tmovl\t%ebx, %edi\n16: \tmovl\t%eax, %esi\n18: \tcallq\t0x1d <cttest_job_hash_free_next+0x1d>\n1d: \tmovl\t(%rip), %r8d  # 0x24 <cttest_job_hash_free_next+0x24>\n24: \txorl\t%edi, %edi\n26: \txorl\t%esi, %esi\n28: \tmovl\t$1, %edx\n2d: \txorl\t%ecx, %ecx\n2f: \tmovl\t$12386, %r9d  # imm = 0x3062\n35: \tcallq\t0x3a <cttest_job_hash_free_next+0x3a>\n3a: \tmovq\t%rax, %r14\n3d: \tmovl\t(%rip), %r8d  # 0x44 <cttest_job_hash_free_next+0x44>\n44: \txorl\t%edi, %edi\n46: \txorl\t%esi, %esi\n48: \tmovl\t$1, %edx\n4d: \txorl\t%ecx, %ecx\n4f: \tmovl\t$97, %r9d\n55: \tcallq\t0x5a <cttest_job_hash_free_next+0x5a>\n5a: \tmovq\t%rax, %rbx\n5d: \txorl\t%edi, %edi\n5f: \tcmpq\t%r14, (%rax)\n62: \tsete\t%dil\n66: \tmovl\t$0, %esi\n6b: \tcallq\t0x70 <cttest_job_hash_free_next+0x70>\n70: \tmovq\t%r14, %rdi\n73: \tcallq\t0x78 <cttest_job_hash_free_next+0x78>\n78: \txorl\t%edi, %edi\n7a: \tcmpq\t$0, (%rbx)\n7e: \tsete\t%dil\n82: \tmovl\t$0, %esi\n87: \taddq\t$8, %rsp\n8b: \tpopq\t%rbx\n8c: \tpopq\t%r14\n8e: \tjmp\t0x93 <cttest_job_hash_free_next+0x93>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int uint64 ;\nstruct TYPE_4__ {struct TYPE_4__* ht_next; } ;\ntypedef  TYPE_1__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  job_free (TYPE_1__*) ;\nTYPE_1__* make_job_with_id (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_hash_free_next()\n{\nJob *a, *b;\nuint64 aid = 97, bid = 12386;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\nb = make_job_with_id(0, 0, 1, 0, default_tube, bid);\na = make_job_with_id(0, 0, 1, 0, default_tube, aid);\n\nassertf(a->ht_next == b, \"b should be chained to a\");\n\njob_free(b);\n\nassertf(a->ht_next == NULL, \"job should be missing\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ next; } ;\ntypedef  TYPE_1__ cttest_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CTT_JOB_HASH_SIZE ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  cttest_job_hash_free (TYPE_1__*) ;\nint /*<<< orphan*/  cttest_job_hash_init (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  cttest_job_hash_lookup (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_hash_lookup_next_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cttest_job_"
},
{
    "file:":"./beanstalkd/extr_prot.c_uptime",
    "input":"\n0000000000000000 <uptime>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <uptime+0x8>\n8: \tsubl\t(%rip), %eax  # 0xe <uptime+0xe>\ne: \tcltq\n10: \timulq\t$1152921505, %rax, %rax # imm = 0x44B82FA1\n17: \tmovq\t%rax, %rcx\n1a: \tshrq\t$63, %rcx\n1e: \tsarq\t$60, %rax\n22: \taddl\t%ecx, %eax\n24: \tpopq\t%rcx\n25: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint ;\n\n/* Variables and functions */\nint nanoseconds () ;\nint started_at ;\n\n__attribute__((used)) static uint\nuptime()\n{\nreturn (nanoseconds() - started_at) / 1000000000;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  time (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  uptime_sec ;\n\nlong long uptime(void) {\nlong long uptime_sec = time(NULL) - uptime_sec;\nreturn uptime_sec * 1000000;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_writefull",
    "input":"\n0000000000000000 <writefull>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \ttestl\t%edx, %edx\n6: \tje\t0x2c <writefull+0x2c>\n8: \tmovl\t%edx, %ebp\na: \tmovq\t%rsi, %rbx\nd: \tmovl\t%edi, %r14d\n10: \tmovl\t%r14d, %edi\n13: \tmovq\t%rbx, %rsi\n16: \tmovl\t%ebp, %edx\n18: \tcallq\t0x1d <writefull+0x1d>\n1d: \tcmpl\t$-1, %eax\n20: \tje\t0x31 <writefull+0x31>\n22: \tmovslq\t%eax, %rcx\n25: \taddq\t%rcx, %rbx\n28: \tsubl\t%eax, %ebp\n2a: \tjne\t0x10 <writefull+0x10>\n2c: \tpopq\t%rbx\n2d: \tpopq\t%r14\n2f: \tpopq\t%rbp\n30: \tretq\n31: \tmovl\t$0, %edi\n36: \tcallq\t0x3b <writefull+0x3b>\n3b: \tmovl\t$1, %edi\n40: \tcallq\t0x45 <writefull+0x45>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  perror (char*) ;\nint write (int,char*,int) ;\n\n__attribute__((used)) static void\nwritefull(int fd, char *s, int n)\n{\nint c;\nfor (; n; n -= c) {\nc = write(fd, s, n);\nif (c == -1) {\nperror(\"write\");\nexit(1);\n}\ns += c;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  perror (char*) ;\nint write (int,char const*,int) ;\n\nvoid writefull(int fd, const char *buf, int len)\n{\nint w;\nwhile (len) {\nw = write(fd, buf, len);\nif (w == -1) {\nperror(\"write\");\nexit(1);\n}\nbuf += w;\nlen -= w;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_1024",
    "input":"\n0000000000000000 <ctbench_put_delete_1024>:\n0: \tmovl\t$1024, %esi   # imm = 0x400\n5: \txorl\t%edx, %edx\n7: \txorl\t%ecx, %ecx\n9: \txorl\t%r8d, %r8d\nc: \tjmp\t0x11 <ctbench_put_delete_1024+0x11>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_1024(int n)\n{\nbench_put_delete_size(n, 1024, 0, 0, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_bench_t ;\n\n/* Variables and functions */\nint ctbench_put_delete (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int ctbench_put_delete_1024 (ct_bench_t *b) {\nreturn ctbench_put_delete (b, 1024, 0, 0, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_filesize",
    "input":"\n0000000000000000 <filesize>:\n0: \tpushq\t%rax\n1: \tmovq\t%rsp, %rsi\n4: \tcallq\t0x9 <filesize+0x9>\n9: \tcmpl\t$-1, %eax\nc: \tje\t0x13 <filesize+0x13>\ne: \tmovl\t(%rsp), %eax\n11: \tpopq\t%rcx\n12: \tretq\n13: \tmovl\t$0, %edi\n18: \tcallq\t0x1d <filesize+0x1d>\n1d: \tmovl\t$1, %edi\n22: \tcallq\t0x27 <filesize+0x27>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {int st_size; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint stat (char*,struct stat*) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static int\nfilesize(char *path)\n{\nstruct stat s;\n\nint r = stat(path, &s);\nif (r == -1) {\ntwarn(\"stat\");\nexit(1);\n}\nreturn s.st_size;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  off_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  perror (char*) ;\nint stat (char*,int /*<<< orphan*/ *) ;\n\noff_t filesize(char *filename)\n{\nstruct stat st;\n\nif (stat(filename, &st) == -1) {\nperror(\"stat\");\nexit(1);\n}\nreturn st.st_size;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_1024_fsync_050ms",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_1024_fsync_050ms>:\n0: \tmovl\t$1024, %esi   # imm = 0x400\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \tmovl\t$1, %ecx\nf: \tmovl\t$100, %r8d\n15: \tjmp\t0x1a <ctbench_put_delete_wal_1024_fsync_050ms+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int,int) ;\n\nvoid\nctbench_put_delete_wal_1024_fsync_050ms(int n)\n{\nbench_put_delete_size(n, 1024, 512000, 1, 100);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal (int,int,int,int,int) ;\n\nint ctbench_put_delete_wal_1024_fsync_050ms (int fd) {\nreturn ctbench_put_delete_wal (fd, 1024, 512000, 1, 100);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_connsched",
    "input":"\n0000000000000000 <connsched>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcmpl\t$0, (%rdi)\n7: \tje\t0x1b <connsched+0x1b>\n9: \tmovq\t8(%rbx), %rdi\nd: \tmovl\t24(%rbx), %esi\n10: \tcallq\t0x15 <connsched+0x15>\n15: \tmovl\t$0, (%rbx)\n1b: \tmovq\t%rbx, %rdi\n1e: \tcallq\t0x23 <connsched+0x23>\n23: \tmovq\t%rax, 16(%rbx)\n27: \ttestq\t%rax, %rax\n2a: \tje\t0x3e <connsched+0x3e>\n2c: \tmovq\t8(%rbx), %rdi\n30: \tmovq\t%rbx, %rsi\n33: \tcallq\t0x38 <connsched+0x38>\n38: \tmovl\t$1, (%rbx)\n3e: \tpopq\t%rbx\n3f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int in_conns; TYPE_1__* srv; scalar_t__ tickat; int /*<<< orphan*/  tickpos; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  conns; } ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nscalar_t__ conntickat (TYPE_2__*) ;\nint /*<<< orphan*/  heapinsert (int /*<<< orphan*/ *,TYPE_2__*) ;\nint /*<<< orphan*/  heapremove (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\nvoid\nconnsched(Conn *c)\n{\nif (c->in_conns) {\nheapremove(&c->srv->conns, c->tickpos);\nc->in_conns = 0;\n}\nc->tickat = conntickat(c);\nif (c->tickat) {\nheapinsert(&c->srv->conns, c);\nc->in_conns = 1;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  conn_scheduled; int /*<<< orphan*/ * conn; int /*<<< orphan*/  conn_id; int /*<<< orphan*/  conn_type; } ;\ntypedef  TYPE_1__ GLogConn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  conn_sched_add (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  conn_sched_del (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/ * get_conn (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void connsched (GLogConn *c) {\nif (c->conn_scheduled) {\nconn_sched_del (c->conn, c);\n}\nc->conn = get_conn (c->conn_type, c->conn_id);\nif (c->conn) {\nconn_sched_add (c->conn, c);\nc->conn_scheduled = 1;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optb",
    "input":"\n0000000000000000 <cttest_optb>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optb+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optb+0x1c>\n1c: \tmovl\t(%rip), %edi  # 0x22 <cttest_optb+0x22>\n22: \tmovl\t$0, %esi\n27: \tcallq\t0x2c <cttest_optb+0x2c>\n2c: \txorl\t%edi, %edi\n2e: \ttestq\t%rax, %rax\n31: \tsete\t%dil\n35: \tcallq\t0x3a <cttest_optb+0x3a>\n3a: \txorl\t%edi, %edi\n3c: \tcmpl\t$1, (%rip)    # 0x43 <cttest_optb+0x43>\n43: \tsete\t%dil\n47: \tcallq\t0x4c <cttest_optb+0x4c>\n4c: \taddq\t$24, %rsp\n50: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int use; int /*<<< orphan*/  dir; } ;\nstruct TYPE_5__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nTYPE_2__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,char*) ;\n\nvoid\ncttest_optb()\n{\nchar *args[] = {\n\"-bfoo\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(strcmp(srv.wal.dir, \"foo\") == 0);\nassert(srv.wal.use == 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_str_eq (char*,char*) ;\nint /*<<< orphan*/  TEST_str_ne (char*,char*) ;\nint /*<<< orphan*/  ct_test_opt_b ;\nint /*<<< orphan*/  ct_test_opt_b_default ;\nint /*<<< orphan*/  ct_test_opt_b_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_default_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_default_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set ;\nint /*<<< orphan*/  ct_test_opt_b_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_default ;\nint /*<<"
},
{
    "file:":"./beanstalkd/extr_main.c_set_sig_handlers",
    "input":"\n0000000000000000 <set_sig_handlers>:\n0: \tsubq\t$24, %rsp\n4: \tmovl\t(%rip), %eax  # 0xa <set_sig_handlers+0xa>\na: \tmovl\t%eax, 8(%rsp)\ne: \tmovq\t$0, 16(%rsp)\n17: \tleaq\t12(%rsp), %rdi\n1c: \tcallq\t0x21 <set_sig_handlers+0x21>\n21: \tcmpl\t$-1, %eax\n24: \tje\t0x90 <set_sig_handlers+0x90>\n26: \tmovl\t(%rip), %edi  # 0x2c <set_sig_handlers+0x2c>\n2c: \tleaq\t8(%rsp), %rsi\n31: \txorl\t%edx, %edx\n33: \tcallq\t0x38 <set_sig_handlers+0x38>\n38: \tcmpl\t$-1, %eax\n3b: \tje\t0x97 <set_sig_handlers+0x97>\n3d: \tmovl\t(%rip), %eax  # 0x43 <set_sig_handlers+0x43>\n43: \tmovl\t%eax, 8(%rsp)\n47: \tmovl\t(%rip), %edi  # 0x4d <set_sig_handlers+0x4d>\n4d: \tleaq\t8(%rsp), %rsi\n52: \txorl\t%edx, %edx\n54: \tcallq\t0x59 <set_sig_handlers+0x59>\n59: \tcmpl\t$-1, %eax\n5c: \tje\t0x9e <set_sig_handlers+0x9e>\n5e: \txorl\t%eax, %eax\n60: \tcallq\t0x65 <set_sig_handlers+0x65>\n65: \tcmpl\t$1, %eax\n68: \tjne\t0x8b <set_sig_handlers+0x8b>\n6a: \tmovl\t(%rip), %eax  # 0x70 <set_sig_handlers+0x70>\n70: \tmovl\t%eax, 8(%rsp)\n74: \tmovl\t(%rip), %edi  # 0x7a <set_sig_handlers+0x7a>\n7a: \tleaq\t8(%rsp), %rsi\n7f: \txorl\t%edx, %edx\n81: \tcallq\t0x86 <set_sig_handlers+0x86>\n86: \tcmpl\t$-1, %eax\n89: \tje\t0xa5 <set_sig_handlers+0xa5>\n8b: \taddq\t$24, %rsp\n8f: \tretq\n90: \tmovl\t$0, %edi\n95: \tjmp\t0xaa <set_sig_handlers+0xaa>\n97: \tmovl\t$0, %edi\n9c: \tjmp\t0xaa <set_sig_handlers+0xaa>\n9e: \tmovl\t$0, %edi\na3: \tjmp\t0xaa <set_sig_handlers+0xaa>\na5: \tmovl\t$0, %edi\naa: \tcallq\t0xaf <set_sig_handlers+0xaf>\naf: \tmovl\t$111, %edi\nb4: \tcallq\t0xb9 <set_sig_handlers+0xb9>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sigaction {int /*<<< orphan*/  sa_handler; int /*<<< orphan*/  sa_mask; scalar_t__ sa_flags; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGPIPE ;\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  SIGUSR1 ;\nint /*<<< orphan*/  SIG_IGN ;\nint /*<<< orphan*/  enter_drain_mode ;\nint /*<<< orphan*/  exit (int) ;\nint getpid () ;\nint /*<<< orphan*/  handle_sigterm_pid1 ;\nint sigaction (int /*<<< orphan*/ ,struct sigaction*,int /*<<< orphan*/ ) ;\nint sigemptyset (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static void\nset_sig_handlers()\n{\nstruct sigaction sa;\n\nsa.sa_handler = SIG_IGN;\nsa.sa_flags = 0;\nint r = sigemptyset(&sa.sa_mask);\nif (r == -1) {\ntwarn(\"sigemptyset()\");\nexit(111);\n}\n\nr = sigaction(SIGPIPE, &sa, 0);\nif (r == -1) {\ntwarn(\"sigaction(SIGPIPE)\");\nexit(111);\n}\n\nsa.sa_handler = enter_drain_mode;\nr = sigaction(SIGUSR1, &sa, 0);\nif (r == -1) {\ntwarn(\"sigaction(SIGUSR1)\");\nexit(111);\n}\n\n// Workaround for running the server with pid=1 in Docker.\n// Handle SIGTERM so the server is killed immediately and\n// not after 10 seconds timeout. See issue #527.\nif (getpid() == 1) {\nsa.sa_handler = handle_sigterm_pid1;\nr = sigaction(SIGTERM, &sa, 0);\nif (r == -1) {\ntwarn(\"sigaction(SIGTERM)\");\nexit(111);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sigset_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGABRT ;\nint /*<<< orphan*/  SIGALRM ;\nint /*<<< orphan*/  SIGINT ;\nint /*<<< orphan*/  SIGPIPE ;\nint /*<<< orphan*/  SIGQUIT ;\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  SIGUSR1 ;\nint /*<<< orphan*/  SIGUSR2 ;\nint /*<<< orphan*/  SIGUSR3 ;\nint /*<<< orphan*/  SIGUSR4 ;\nint /*<<< orphan*/  SIGUSR5 ;\nint /*<<< orphan*/  SIGUSR6 ;\nint /*<<< orphan*/  SIGUSR7 ;\nint /*<<< orphan*/  SIGUSR8 ;\nint /*<<< orphan*/  SIGUSR9 ;\nint /*<<< orphan*/  SIGUSR10 ;\nint /*<<< orphan*/  SIGUSR11 ;\nint /*<<< orphan*/  SIGUSR12 ;\nint /*<<< orphan*/  SIGUSR13 ;\nint /*<<< orphan*/  SIGUSR14 ;\nint /*<<< orphan*/  SIGUSR15 ;\nint /*<<< orphan*/  SIGUSR16 ;\nint /*<<< orphan*/  SIGUSR17 ;\nint /*<<< orphan*/  SIGUSR18 ;\nint /*<<< orphan*/  SIGUSR19 ;\nint /*<<< orphan*/  SIGUSR20 ;\nint /*<<< orphan*/  SIGUSR21 ;\nint /*<<< orphan*/  SIGUSR22 ;\nint /*<<< orphan*/  SIGUSR23 ;\nint /*<<< orphan*/  SIGUSR24 ;\nint /*<<< orphan*/  SIGUSR25 ;\nint /*<<< orphan*/  SIGUSR26 ;\nint /*<<< orphan*/  SIGUSR27 ;\nint /*<<< orphan*/  SIGUSR28 ;\nint /*<<< orphan*/  SIGUSR29 ;\nint /*<<< orphan*/  SIGUSR30 ;\nint /*<<< orphan*/  SIGUSR31 ;\nint /*<<< orphan*/  SIGUSR32 ;\nint /*<<< orphan*/  SIGUSR33 ;\nint /*<<< orphan*/  SIGUSR34 ;\nint /*<<< orphan*/  SIGUSR35 ;\nint /*<<< orphan*/  SIGUSR36 ;\nint /*<<< orphan*/  SIGUSR37 ;\nint /*<<< orphan*/  SIGUSR38 ;\nint /*<<< orphan*/  SIGUSR39 ;\nint /*<<< orphan*/  SIGUSR40 ;\nint /*<<< orphan*/  SIGUSR41 ;\nint /*<<< orphan*/  SIGUSR42 ;\nint /*<<< orphan*/  SIGUSR43 ;\nint /*<<< orphan*/  SIGUSR44 ;\nint /*<<< orphan*/  SIGUSR45 ;\nint /*<<< orphan*/  SIGUSR46 ;\nint /*<<< orphan*/  SIGUSR47 ;\nint /*<<< orphan*/  SIGUSR48 ;\nint /*<<< orphan*/  SIGUSR49 ;\nint /*<<< orphan*/  SIGUSR50 ;\nint /*<<< orphan*/  SIGUSR51 ;\nint /*<<< orphan*/  SIGUSR52 ;\nint /*<<< orphan*/  SIGUSR53 ;\nint /*<<< orphan*/  SIGUSR54 ;\nint /*<<< orphan*/  SIGUSR55 ;\nint /*<<< orphan*/  SIGUSR56 ;\nint /*<<< orphan*/  SIGUSR57 ;\nint /*<<< orphan*/  SIGUSR58 ;\nint /*<<< orphan*/  SIGUSR59 ;\nint /*<<< orphan*/  SIGUSR60 ;\nint /*<<< orphan*/  SIGUSR61 ;\nint /*<<< orphan*/  SIGUSR62 ;\nint /*<<< orphan*/  SIGUSR63 ;\nint /*<<< orphan*/  SIGUSR64 ;\nint /*<<< orphan*/  SIGUSR65 ;\nint /*<<< orphan*/  SIGUSR66 ;\nint /*<<< orphan*/  SIGUSR67 ;\nint /*<<< orphan*/  SIGUSR68 ;\nint /*<<< orphan*/  SIGUSR69 ;\nint /*<<< orphan*/  SIGUSR70 ;\nint /*<<< orphan*/  SIGUSR71 ;\nint /*<<< orphan*/  SIGUSR72 ;\nint /*<<< orphan*/  SIGUSR73 ;\nint /*<<< orphan*/  SIGUSR74 ;\nint /*<<< orphan*/  SIGUSR75 ;\nint /*<<< orphan*/  SIGUSR76 ;\nint /*<<< orphan*/  SIGUSR77 ;\nint /*<<< orphan*/  SIGUSR78 ;\nint /*<<< orphan*/  SIGUSR79 ;\nint /*<<< orphan*/  SIGUSR80 ;\nint /*<<< orphan*/  SIGUSR81 ;\nint /*<<< orphan*/  SIGUSR82 ;\nint /*<<< orphan*/  SIGUSR83 ;\nint /*<<< orphan*/  SIGUSR84 ;\nint /*<<< orphan*/  SIGUSR85 ;\nint /*<<< orphan*/  SIGUSR86 ;\nint /*<<< orphan*/  SIGUSR87 ;\nint /*<<< orphan*/  SIGUSR88 ;\nint /*<<< orphan*/  SIGUSR89 ;\nint /*<<< orphan*/  SIGUSR90 ;\nint /*<<< orphan*/  SIGUSR91 ;\nint /*<<< orphan*/  SIGUSR92 ;\nint /*<<< orphan*/  SIGUSR93 ;\nint /*<<< orphan*/  SIGUSR94 ;\nint /*<<< orphan*/  SIGUSR95 ;\nint /*<<< orphan*/  SIGUSR96 ;\nint /*<<< orphan*/  SIGUSR97 ;\nint /*<<< orphan*/  SIGUSR98 ;\nint /*<<< orphan*/  SIGUSR99 ;\nint /*<<< orphan*/  SIGUSR100 ;\nint /*<<< orphan*/  SIGUSR101 ;\nint /*<<< orphan*/  SIGUSR102 ;\nint /*<<< orphan*/  SIGUSR103 ;\nint /*<<< orphan*/  SIGUSR104 ;\nint /*<<< orphan*/  SIGUSR105 ;\nint /*<<< orphan*/  SIGUSR106 ;\nint /*<<< orphan*/  SIGUSR107 ;\nint /*<<< orphan*/  SIGUSR108 ;\nint /*<<< orphan*/  SIGUSR109 ;\nint /*<<< orphan*/  SIGUSR110 ;\nint /*<<< orphan*/  SIGUSR111 ;\nint /*<<< orphan*/  SIGUSR112 ;\nint /*<<< orphan*/  SIGUSR113 ;\nint /*<<< orphan*/  SIGUSR114 ;"
},
{
    "file:":"./beanstalkd/extr_heap.c_heapremove",
    "input":"\n0000000000000000 <heapremove>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t(%rdi), %rax\n8: \tcmpq\t%rsi, %rax\nb: \tjbe\t0x44 <heapremove+0x44>\nd: \tmovq\t%rsi, %r15\n10: \tmovq\t%rdi, %rbx\n13: \tmovq\t8(%rdi), %rcx\n17: \tmovq\t(%rcx,%rsi,8), %r14\n1b: \tleaq\t-1(%rax), %rdx\n1f: \tmovq\t%rdx, (%rdi)\n22: \tmovq\t-8(%rcx,%rax,8), %rdx\n27: \tcallq\t0x2c <heapremove+0x2c>\n2c: \tmovq\t%rbx, %rdi\n2f: \tmovq\t%r15, %rsi\n32: \tcallq\t0x37 <heapremove+0x37>\n37: \tmovq\t%rbx, %rdi\n3a: \tmovq\t%r15, %rsi\n3d: \tcallq\t0x42 <heapremove+0x42>\n42: \tjmp\t0x47 <heapremove+0x47>\n44: \txorl\t%r14d, %r14d\n47: \tmovq\t%r14, %rax\n4a: \tpopq\t%rbx\n4b: \tpopq\t%r14\n4d: \tpopq\t%r15\n4f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {size_t len; void** data; } ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nint /*<<< orphan*/  set (TYPE_1__*,size_t,void*) ;\nint /*<<< orphan*/  siftdown (TYPE_1__*,size_t) ;\nint /*<<< orphan*/  siftup (TYPE_1__*,size_t) ;\n\nvoid *\nheapremove(Heap *h, size_t k)\n{\nif (k >= h->len) {\nreturn 0;\n}\n\nvoid *x = h->data[k];\nh->len--;\nset(h, k, h->data[h->len]);\nsiftdown(h, k);\nsiftup(h, k);\nreturn x;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t n; int /*<<< orphan*/ * heap; } ;\ntypedef  TYPE_1__ heap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  heapdown (TYPE_1__*,size_t) ;\nint /*<<< orphan*/  heapup (TYPE_1__*,size_t) ;\n\n__attribute__((used)) static inline void *\nheapremove(heap_t *heap, size_t i)\n{\nvoid\t   *ret;\n\nif (i >= heap->n)\nreturn NULL;\n\nret = heap->heap[i];\nheap->heap[i] = heap->heap[--heap->n];\nheapdown(heap, i);\nheapup(heap, i);\nreturn ret;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_reserve_job_ready",
    "input":"\n0000000000000000 <cttest_reserve_job_ready>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_reserve_job_ready+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_reserve_job_ready+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_reserve_job_ready+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_reserve_job_ready+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_reserve_job_ready+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_reserve_job_ready+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_reserve_job_ready+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_reserve_job_ready+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_reserve_job_ready+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_reserve_job_ready+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_reserve_job_ready+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_reserve_job_ready+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_reserve_job_ready+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_reserve_job_ready+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_reserve_job_ready+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tcallq\t0xb9 <cttest_reserve_job_ready+0xb9>\nb9: \tmovl\t$0, %esi\nbe: \tmovl\t%ebx, %edi\nc0: \tpopq\t%rbx\nc1: \tjmp\t0xc6 <cttest_reserve_job_ready+0xc6>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_reserve_job_ready()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\n\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"B\\r\\n\");\nckresp(fd, \"INSERTED 2\\r\\n\");\n\nmustsend(fd, \"reserve-job 2\\r\\n\");\nckresp(fd, \"RESERVED 2 1\\r\\n\");\nckresp(fd, \"B\\r\\n\");\n\n// Non-existing job.\nmustsend(fd, \"reserve-job 3\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n\n// id=1 was not reserved.\nmustsend(fd, \"release 1 1 0\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n\nmustsend(fd, \"release 2 1 0\\r\\n\");\nckresp(fd, \"RELEASED\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_reserve_job_ready (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_symbol (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  g_module_symbol_error () ;\nint /*<<< orphan*/  g_module_symbol_name (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_symbol_unref (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_unref (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_add_data_func (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_init (int*,char***) ;\n\nvoid cttest_reserve_job_ready(void) {\nGModule *module;\n\ng_test_init(&g_test_count, NULL);\n\nmodule = g_module_open(\"ct-reserve-job-ready\", 0);\ng_test_add_data_func(\"/ct-reserve-job-ready/reserve-job-ready\", module, ct_reserve_job_ready);\n\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_name(module);\ng_module_symbol_error();\ng_module_symbol(module, \"ct_reserve_job_ready\");\ng_module_symbol_"
},
{
    "file:":"./beanstalkd/extr_darwin.c_sockwant",
    "input":"\n0000000000000000 <sockwant>:\n0: \tsubq\t$104, %rsp\n4: \txorps\t%xmm0, %xmm0\n7: \tmovaps\t%xmm0, 80(%rsp)\nc: \tmovaps\t%xmm0, 64(%rsp)\n11: \tmovaps\t%xmm0, 48(%rsp)\n16: \tmovaps\t%xmm0, 32(%rsp)\n1b: \tmovaps\t%xmm0, 16(%rsp)\n20: \tmovq\t$0, 8(%rsp)\n29: \tmovq\t(%rdi), %rax\n2c: \ttestq\t%rax, %rax\n2f: \tje\t0x57 <sockwant+0x57>\n31: \tmovl\t8(%rdi), %ecx\n34: \tmovl\t%ecx, 44(%rsp)\n38: \tmovq\t%rax, 16(%rsp)\n3d: \tmovl\t(%rip), %eax  # 0x43 <sockwant+0x43>\n43: \tmovl\t%eax, 32(%rsp)\n47: \tmovl\t$1, %edx\n4c: \tleaq\t56(%rsp), %rax\n51: \ttestl\t%esi, %esi\n53: \tjne\t0x62 <sockwant+0x62>\n55: \tjmp\t0xb9 <sockwant+0xb9>\n57: \tleaq\t16(%rsp), %rax\n5c: \txorl\t%edx, %edx\n5e: \ttestl\t%esi, %esi\n60: \tje\t0xb9 <sockwant+0xb9>\n62: \tmovl\t8(%rdi), %ecx\n65: \tmovl\t%ecx, 28(%rax)\n68: \tcmpl\t$119, %esi\n6b: \tje\t0x7e <sockwant+0x7e>\n6d: \tcmpl\t$114, %esi\n70: \tjne\t0x8a <sockwant+0x8a>\n72: \tmovq\t(%rip), %rcx  # 0x79 <sockwant+0x79>\n79: \tmovq\t%rcx, (%rax)\n7c: \tjmp\t0xa6 <sockwant+0xa6>\n7e: \tmovq\t(%rip), %rcx  # 0x85 <sockwant+0x85>\n85: \tmovq\t%rcx, (%rax)\n88: \tjmp\t0xa6 <sockwant+0xa6>\n8a: \tmovq\t(%rip), %rcx  # 0x91 <sockwant+0x91>\n91: \tmovq\t%rcx, (%rax)\n94: \tmovl\t(%rip), %esi  # 0x9a <sockwant+0x9a>\n9a: \tmovl\t%esi, 24(%rax)\n9d: \tmovl\t(%rip), %esi  # 0xa3 <sockwant+0xa3>\na3: \tmovl\t%esi, 20(%rax)\na6: \tmovl\t(%rip), %esi  # 0xac <sockwant+0xac>\nac: \tmovl\t%esi, 16(%rax)\naf: \tmovq\t%rdi, 8(%rax)\nb3: \tmovq\t%rcx, (%rdi)\nb6: \taddl\t$1, %edx\nb9: \tmovl\t(%rip), %edi  # 0xbf <sockwant+0xbf>\nbf: \tleaq\t16(%rsp), %rsi\nc4: \tleaq\t8(%rsp), %r9\nc9: \txorl\t%ecx, %ecx\ncb: \txorl\t%r8d, %r8d\nce: \tcallq\t0xd3 <sockwant+0xd3>\nd3: \taddq\t$104, %rsp\nd7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct timespec {int /*<<< orphan*/  tv_nsec; int /*<<< orphan*/  tv_sec; } ;\nstruct kevent {void* filter; TYPE_1__* udata; int /*<<< orphan*/  flags; int /*<<< orphan*/  data; int /*<<< orphan*/  fflags; int /*<<< orphan*/  ident; int /*<<< orphan*/  member_0; } ;\nstruct TYPE_3__ {void* added; int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ Socket ;\n\n/* Variables and functions */\nvoid* EVFILT_READ ;\nvoid* EVFILT_WRITE ;\nint /*<<< orphan*/  EV_ADD ;\nint /*<<< orphan*/  EV_DELETE ;\nint /*<<< orphan*/  Infinity ;\nint /*<<< orphan*/  NOTE_LOWAT ;\nint kevent (int /*<<< orphan*/ ,struct kevent*,int,int /*<<< orphan*/ *,int /*<<< orphan*/ ,struct timespec*) ;\nint /*<<< orphan*/  kq ;\n\nint\nsockwant(Socket *s, int rw)\n{\nint n = 0;\nstruct kevent evs[2] = {{0}};\nstruct kevent *ev = evs;\nstruct timespec ts = {.tv_sec = 0, .tv_nsec = 0};\n\nif (s->added) {\nev->ident = s->fd;\nev->filter = s->added;\nev->flags = EV_DELETE;\nev++;\nn++;\n}\n\nif (rw) {\nev->ident = s->fd;\nswitch (rw) {\ncase 'r':\nev->filter = EVFILT_READ;\nbreak;\ncase 'w':\nev->filter = EVFILT_WRITE;\nbreak;\ndefault:\n// check only for hangup\nev->filter = EVFILT_READ;\nev->fflags = NOTE_LOWAT;\nev->data = Infinity;\n}\nev->flags = EV_ADD;\nev->udata = s;\ns->added = ev->filter;\nev++;\nn++;\n}\n\nreturn kevent(kq, evs, n, NULL, 0, &ts);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * sock; int /*<<< orphan*/  socktype; } ;\ntypedef  TYPE_1__ PGconn ;\ntypedef  int /*<<< orphan*/  fd_set ;\n\n/* Variables and functions */\nint /*<<< orphan*/  FD_SET (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  FD_ZERO (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PG_SOCK_READABLE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_CONNECT ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_SSL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_STARTUP ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_TELL_WRITE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_WRITE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_WRITE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_WRITE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_WRITE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_WRITE_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_XLOG ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_XLOG_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_XLOG_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_XLOG_WRITE ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_XLOG_WRITE_KERNEL ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_XLOG_XLOG_XLOG_WRITE_USER ;\nint /*<<< orphan*/  PG_SOCK_WRITEABLE_XLOG_SWITCH_XLOG_XLOG_X"
},
{
    "file:":"./beanstalkd/extr_conn.c_conndeadlinesoon",
    "input":"\n0000000000000000 <conndeadlinesoon>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r15\n8: \txorl\t%ebx, %ebx\na: \txorl\t%eax, %eax\nc: \tcallq\t0x11 <conndeadlinesoon+0x11>\n11: \tmovq\t%rax, %r14\n14: \tmovq\t%r15, %rdi\n17: \tcallq\t0x1c <conndeadlinesoon+0x1c>\n1c: \ttestq\t%rax, %rax\n1f: \tje\t0x33 <conndeadlinesoon+0x33>\n21: \tmovq\t(%rax), %rax\n24: \tsubq\t(%rip), %rax  # 0x2b <conndeadlinesoon+0x2b>\n2b: \txorl\t%ebx, %ebx\n2d: \tcmpq\t%rax, %r14\n30: \tsetge\t%bl\n33: \tmovl\t%ebx, %eax\n35: \tpopq\t%rbx\n36: \tpopq\t%r14\n38: \tpopq\t%r15\n3a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ int64 ;\nstruct TYPE_4__ {scalar_t__ deadline_at; } ;\nstruct TYPE_5__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\ntypedef  int /*<<< orphan*/  Conn ;\n\n/* Variables and functions */\nscalar_t__ SAFETY_MARGIN ;\nTYPE_2__* connsoonestjob (int /*<<< orphan*/ *) ;\nscalar_t__ nanoseconds () ;\n\nint\nconndeadlinesoon(Conn *c)\n{\nint64 t = nanoseconds();\nJob *j = connsoonestjob(c);\n\nreturn j && t >= j->r.deadline_at - SAFETY_MARGIN;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ deadline; } ;\ntypedef  TYPE_1__ connection ;\n\n/* Variables and functions */\nscalar_t__ now ;\nTYPE_1__* server_pool_conn (TYPE_1__*) ;\n\n__attribute__((used)) static int\nconndeadlinesoon(connection *c)\n{\nreturn server_pool_conn(c) && server_pool_conn(c)->deadline - now >= 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_hash_free",
    "input":"\n0000000000000000 <cttest_job_hash_free>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %ebx  # 0x7 <cttest_job_hash_free+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <cttest_job_hash_free+0x11>\n11: \tmovl\t%ebx, %edi\n13: \tmovl\t%eax, %esi\n15: \tcallq\t0x1a <cttest_job_hash_free+0x1a>\n1a: \tmovl\t(%rip), %r8d  # 0x21 <cttest_job_hash_free+0x21>\n21: \txorl\t%edi, %edi\n23: \txorl\t%esi, %esi\n25: \tmovl\t$1, %edx\n2a: \txorl\t%ecx, %ecx\n2c: \tmovl\t$83, %r9d\n32: \tcallq\t0x37 <cttest_job_hash_free+0x37>\n37: \tmovq\t%rax, %rdi\n3a: \tcallq\t0x3f <cttest_job_hash_free+0x3f>\n3f: \tmovl\t$83, %edi\n44: \tcallq\t0x49 <cttest_job_hash_free+0x49>\n49: \txorl\t%edi, %edi\n4b: \ttestl\t%eax, %eax\n4d: \tsete\t%dil\n51: \tmovl\t$0, %esi\n56: \tpopq\t%rbx\n57: \tjmp\t0x5c <cttest_job_hash_free+0x5c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint64 ;\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  job_find (int) ;\nint /*<<< orphan*/  job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_job_with_id (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_hash_free()\n{\nJob *j;\nuint64 jid = 83;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\nj = make_job_with_id(0, 0, 1, 0, default_tube, jid);\njob_free(j);\n\nassertf(!job_find(jid), \"job should be missing\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CALLOC_RETURN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_hash ;\nint /*<<< orphan*/  g_hash_table_destroy (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_hash_table_new (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  g_hash_table_size (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_hash_table_unref (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_module_name ;\nint /*<<< orphan*/  g_strdup (char*) ;\nint /*<<< orphan*/  g_test_add_data_func (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_init (int*,char***) ;\nint /*<<< orphan*/  g_test_log_set_fatal_handler (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_test_log_set_output_handler (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  g_test_log_set_printer (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  g_test_log_type_name (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_skip (char*) ;\nint /*<<< orphan*/  test_job_hash_free ;\n\nvoid\ncttest_job_hash_free (void)\n{\nGModule *module;\n\ng_test_init (&g_test_log_set_fatal_handler, &g_test_log_set_output_handler, NULL);\ng_test_log_set_printer (g_test_log_type_name, g_test_log_set_fatal_handler, g_test_log_set_output_handler, NULL, 0);\n\nmodule = CALLOC_RETURN (g_module_name, g_module_name);\ng_hash_table_unref (ct_test_job_hash);\nct_test_job_hash = g_hash_table_new (NULL, NULL, 1, NULL, 83);\n\nif (g_hash_table_size (ct_test_job_hash) != 0)\ng_test_skip (\"cttest_job_hash_free: hash table not empty\");\n\ng_test_add_data_func (g_module_name, &ct_test_job_hash, test_job_hash_free);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_state",
    "input":"\n0000000000000000 <job_state>:\n0: \tmovq\t(%rdi), %rcx\n3: \tmovl\t$0, %eax\n8: \tcmpq\t(%rip), %rcx  # 0xf <job_state+0xf>\nf: \tje\t0x42 <job_state+0x42>\n11: \tmovl\t$0, %eax\n16: \tcmpq\t(%rip), %rcx  # 0x1d <job_state+0x1d>\n1d: \tje\t0x42 <job_state+0x42>\n1f: \tmovl\t$0, %eax\n24: \tcmpq\t(%rip), %rcx  # 0x2b <job_state+0x2b>\n2b: \tje\t0x42 <job_state+0x42>\n2d: \tcmpq\t(%rip), %rcx  # 0x34 <job_state+0x34>\n34: \tmovl\t$0, %ecx\n39: \tmovl\t$0, %eax\n3e: \tcmoveq\t%rcx, %rax\n42: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ state; } ;\nstruct TYPE_5__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nscalar_t__ Buried ;\nscalar_t__ Delayed ;\nscalar_t__ Ready ;\nscalar_t__ Reserved ;\n\nconst char *\njob_state(Job *j)\n{\nif (j->r.state == Ready) return \"ready\";\nif (j->r.state == Reserved) return \"reserved\";\nif (j->r.state == Buried) return \"buried\";\nif (j->r.state == Delayed) return \"delayed\";\nreturn \"invalid\";\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ state; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nscalar_t__ JOB_STATE_DONE ;\nscalar_t__ JOB_STATE_ERROR ;\nscalar_t__ JOB_STATE_RUNNING ;\nscalar_t__ JOB_STATE_WAITING ;\n\n__attribute__((used)) static const char *\njob_state(job_t *job)\n{\nswitch (job->state)\n{\ncase JOB_STATE_WAITING:\nreturn \"waiting\";\ncase JOB_STATE_RUNNING:\nreturn \"running\";\ncase JOB_STATE_DONE:\nreturn \"done\";\ncase JOB_STATE_ERROR:\nreturn \"error\";\ndefault:\nreturn \"unknown\";\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_binlog_empty_exit",
    "input":"\n0000000000000000 <cttest_binlog_empty_exit>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_binlog_empty_exit+0x8>\n8: \tmovl\t%eax, (%rip)  # 0xe <cttest_binlog_empty_exit+0xe>\ne: \tmovl\t$1, (%rip)    # 0x18 <cttest_binlog_empty_exit+0x18>\n18: \tmovl\t$10, (%rip)   # 0x22 <cttest_binlog_empty_exit+0x22>\n22: \txorl\t%eax, %eax\n24: \tcallq\t0x29 <cttest_binlog_empty_exit+0x29>\n29: \txorl\t%eax, %eax\n2b: \tcallq\t0x30 <cttest_binlog_empty_exit+0x30>\n30: \txorl\t%eax, %eax\n32: \tcallq\t0x37 <cttest_binlog_empty_exit+0x37>\n37: \tmovl\t%eax, %edi\n39: \tcallq\t0x3e <cttest_binlog_empty_exit+0x3e>\n3e: \tmovl\t%eax, %ebx\n40: \tmovl\t$0, %esi\n45: \tmovl\t%eax, %edi\n47: \tcallq\t0x4c <cttest_binlog_empty_exit+0x4c>\n4c: \tmovl\t$0, %esi\n51: \tmovl\t%ebx, %edi\n53: \tcallq\t0x58 <cttest_binlog_empty_exit+0x58>\n58: \tmovl\t$0, %esi\n5d: \tmovl\t%ebx, %edi\n5f: \tpopq\t%rbx\n60: \tjmp\t0x65 <cttest_binlog_empty_exit+0x65>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int use; int /*<<< orphan*/  dir; } ;\nstruct TYPE_4__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ctdir () ;\nint job_data_size_limit ;\nint /*<<< orphan*/  kill_srvpid () ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nTYPE_2__ srv ;\n\nvoid\ncttest_binlog_empty_exit()\n{\nsrv.wal.dir = ctdir();\nsrv.wal.use = 1;\njob_data_size_limit = 10;\n\nint port = SERVER();\nkill_srvpid();\n\nport = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fwrite (char*,int,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  test_binlog_empty_exit ;\nint /*<<< orphan*/  test_binlog_empty_exit_len ;\nint /*<<< orphan*/  test_binlog_empty_exit_str ;\n\n__attribute__((used)) static void cttest_binlog_empty_exit(void)\n{\nFILE *fp;\n\ntest_binlog_empty_exit = 0;\ntest_binlog_empty_exit_len = 1;\ntest_binlog_empty_exit_str[0] = '\\n';\n\nfp = fopen(\"test_binlog_empty_exit.binlog\", \"wb\");\nfwrite(test_binlog_empty_exit_str, test_binlog_empty_exit_len, 1, fp);\nfclose(fp);\n\nfprintf(stderr, \"test_binlog_empty_exit.binlog: \");\nfprintf(stderr, \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_1024_fsync_000ms",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_1024_fsync_000ms>:\n0: \tmovl\t$1024, %esi   # imm = 0x400\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \tmovl\t$1, %ecx\nf: \txorl\t%r8d, %r8d\n12: \tjmp\t0x17 <ctbench_put_delete_wal_1024_fsync_000ms+0x17>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_wal_1024_fsync_000ms(int n)\n{\nbench_put_delete_size(n, 1024, 512000, 1, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal (int,int,int,int,int /*<<< orphan*/ ) ;\n\nint ctbench_put_delete_wal_1024_fsync_000ms (int fd) {\nreturn ctbench_put_delete_wal (fd, 1024, 512000, 1, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_init",
    "input":"\n0000000000000000 <ms_init>:\n0: \txorps\t%xmm0, %xmm0\n3: \tmovups\t%xmm0, 32(%rdi)\n7: \tmovups\t%xmm0, 16(%rdi)\nb: \tmovq\t%rsi, 8(%rdi)\nf: \tmovq\t%rdx, (%rdi)\n12: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  void* ms_event_fn ;\nstruct TYPE_3__ {void* onremove; void* oninsert; int /*<<< orphan*/ * items; scalar_t__ last; scalar_t__ cap; scalar_t__ len; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\n\nvoid\nms_init(Ms *a, ms_event_fn oninsert, ms_event_fn onremove)\n{\na->len = a->cap = a->last = 0;\na->items = NULL;\na->oninsert = oninsert;\na->onremove = onremove;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ size; scalar_t__ pos; scalar_t__ buf; scalar_t__ buf_end; } ;\ntypedef  TYPE_1__ ms_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void\nms_init(ms_t *ms, char *buf, size_t size)\n{\nms->buf = buf;\nms->buf_end = buf + size;\nms->pos = buf;\nms->size = size;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_kill_srvpid",
    "input":"\n0000000000000000 <kill_srvpid>:\n0: \tpushq\t%rax\n1: \tmovq\t(%rip), %rdi  # 0x8 <kill_srvpid+0x8>\n8: \ttestq\t%rdi, %rdi\nb: \tje\t0x33 <kill_srvpid+0x33>\nd: \tmovl\t(%rip), %esi  # 0x13 <kill_srvpid+0x13>\n13: \tcallq\t0x18 <kill_srvpid+0x18>\n18: \tmovq\t(%rip), %rdi  # 0x1f <kill_srvpid+0x1f>\n1f: \txorl\t%esi, %esi\n21: \txorl\t%edx, %edx\n23: \tcallq\t0x28 <kill_srvpid+0x28>\n28: \tmovq\t$0, (%rip)    # 0x33 <kill_srvpid+0x33>\n33: \tpopq\t%rax\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  kill (scalar_t__,int /*<<< orphan*/ ) ;\nscalar_t__ srvpid ;\nint /*<<< orphan*/  waitpid (scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nkill_srvpid(void)\n{\nif (!srvpid)\nreturn;\nkill(srvpid, SIGTERM);\nwaitpid(srvpid, 0, 0);\nsrvpid = 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  kill (scalar_t__,int /*<<< orphan*/ ) ;\nscalar_t__ srvpid ;\n\nvoid kill_srvpid (void) {\nif (srvpid) {\nkill (srvpid, SIGTERM);\nsrvpid = 0;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optV",
    "input":"\n0000000000000000 <cttest_optV>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optV+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optV+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$1, (%rip)    # 0x25 <cttest_optV+0x25>\n25: \tsete\t%dil\n29: \tcallq\t0x2e <cttest_optV+0x2e>\n2e: \taddq\t$24, %rsp\n32: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (int /*<<< orphan*/ *,char**) ;\nint /*<<< orphan*/  srv ;\nint verbose ;\n\nvoid\ncttest_optV()\n{\nchar *args[] = {\n\"-V\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(verbose == 1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_str_eq (char*,char*) ;\nint /*<<< orphan*/  ct_test_optV (char*,char**) ;\nint /*<<< orphan*/  ct_test_optV_expected ;\n\n__attribute__((used)) static void cttest_optV(void)\n{\nchar *argv[] = { \"test\", \"-V\" };\n\nTEST_str_eq(ct_test_optV_expected, ct_test_optV(argv[0], argv));\nTEST_true(argv[1] == NULL);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_fileinit",
    "input":"\n0000000000000000 <fileinit>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovq\t%rsi, 8(%rdi)\n8: \tmovl\t%edx, (%rdi)\na: \tmovl\t(%rsi), %esi\nc: \tmovl\t$0, %edi\n11: \tcallq\t0x16 <fileinit+0x16>\n16: \tmovl\t%eax, 4(%rbx)\n19: \txorl\t%ecx, %ecx\n1b: \ttestl\t%eax, %eax\n1d: \tsetne\t%cl\n20: \tmovl\t%ecx, %eax\n22: \tpopq\t%rbx\n23: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  dir; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_6__ {int seq; int /*<<< orphan*/  path; TYPE_1__* w; } ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fmtalloc (char*,int /*<<< orphan*/ ,int) ;\n\nint\nfileinit(File *f, Wal *w, int n)\n{\nf->w = w;\nf->seq = n;\nf->path = fmtalloc(\"%s/binlog.%d\", w->dir, n);\nreturn !!f->path;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  name; int /*<<< orphan*/  f; } ;\ntypedef  TYPE_1__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fopen (char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int fileinit(File *f, const char *name, int mode)\n{\nf->name = name;\nf->f = fopen(name, mode);\nreturn f->f != NULL;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_put_in_drain",
    "input":"\n0000000000000000 <cttest_put_in_drain>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %edi  # 0x7 <cttest_put_in_drain+0x7>\n7: \tcallq\t0xc <cttest_put_in_drain+0xc>\nc: \txorl\t%eax, %eax\ne: \tcallq\t0x13 <cttest_put_in_drain+0x13>\n13: \tmovl\t%eax, %edi\n15: \tcallq\t0x1a <cttest_put_in_drain+0x1a>\n1a: \tmovl\t%eax, %ebx\n1c: \tmovl\t$0, %esi\n21: \tmovl\t%eax, %edi\n23: \tcallq\t0x28 <cttest_put_in_drain+0x28>\n28: \tmovl\t$0, %esi\n2d: \tmovl\t%ebx, %edi\n2f: \tcallq\t0x34 <cttest_put_in_drain+0x34>\n34: \tmovl\t$0, %esi\n39: \tmovl\t%ebx, %edi\n3b: \tpopq\t%rbx\n3c: \tjmp\t0x41 <cttest_put_in_drain+0x41>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  SIGUSR1 ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  enter_drain_mode (int /*<<< orphan*/ ) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_put_in_drain()\n{\nenter_drain_mode(SIGUSR1);\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"x\\r\\n\");\nckresp(fd, \"DRAINING\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CT_TEST_FILE ;\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fflush (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fopen (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fputs (char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void cttest_put_in_drain(void)\n{\nFILE *fp;\n\nfp = fopen(CT_TEST_FILE, \"w\");\nfflush(fp);\nfputs(\"hello\", fp);\nfclose(fp);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_negative_delay",
    "input":"\n0000000000000000 <cttest_negative_delay>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_negative_delay+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_negative_delay+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_negative_delay+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tpopq\t%rbx\n25: \tjmp\t0x2a <cttest_negative_delay+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_negative_delay()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 512 -1 100 0\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_null () ;\nint /*<<< orphan*/  BIO_write (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  TEST_error (char*,char*) ;\n\n__attribute__((used)) static void cttest_negative_delay(void)\n{\nBIO *bio = BIO_new(BIO_s_null());\n\nif (!TEST_error(\"BIO_write(NULL, NULL, 0)\",\nBIO_write(NULL, NULL, 0)))\nTEST_error(\"BIO_write(NULL, NULL, 0)\",\nBIO_write(bio, NULL, 0));\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_reserve_job_already_reserved",
    "input":"\n0000000000000000 <cttest_reserve_job_already_reserved>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_reserve_job_already_reserved+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_reserve_job_already_reserved+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_reserve_job_already_reserved+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_reserve_job_already_reserved+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_reserve_job_already_reserved+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_reserve_job_already_reserved+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_reserve_job_already_reserved+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_reserve_job_already_reserved+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_reserve_job_already_reserved+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tpopq\t%rbx\n6d: \tjmp\t0x72 <cttest_reserve_job_already_reserved+0x72>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_reserve_job_already_reserved()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\n\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nmustsend(fd, \"reserve-job 1\\r\\n\");\nckresp(fd, \"RESERVED 1 1\\r\\n\");\nckresp(fd, \"A\\r\\n\");\n\n// Job should not be reserved twice.\nmustsend(fd, \"reserve-job 1\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GPtrArray ;\ntypedef  int /*<<< orphan*/  GtkWidget ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_reserve_job (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_assert_cmpint (int /*<<< orphan*/ ,==,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_assert_cmpstr (char*,char*) ;\nint /*<<< orphan*/  g_"
},
{
    "file:":"./beanstalkd/extr_prot.c_read_tube_name",
    "input":"\n0000000000000000 <read_tube_name>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %r14\n8: \tmovq\t%rsi, %rbx\nb: \tmovq\t%rdi, %r15\ne: \taddq\t$-1, %rbx\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \tcmpb\t$32, 1(%rbx)\n24: \tleaq\t1(%rbx), %rbx\n28: \tje\t0x20 <read_tube_name+0x20>\n2a: \tmovl\t(%rip), %esi  # 0x30 <read_tube_name+0x30>\n30: \tmovq\t%rbx, %rdi\n33: \tcallq\t0x38 <read_tube_name+0x38>\n38: \ttestq\t%rax, %rax\n3b: \tje\t0x57 <read_tube_name+0x57>\n3d: \tmovq\t%rax, %rcx\n40: \ttestq\t%r15, %r15\n43: \tje\t0x48 <read_tube_name+0x48>\n45: \tmovq\t%rbx, (%r15)\n48: \txorl\t%eax, %eax\n4a: \ttestq\t%r14, %r14\n4d: \tje\t0x5c <read_tube_name+0x5c>\n4f: \taddq\t%rcx, %rbx\n52: \tmovq\t%rbx, (%r14)\n55: \tjmp\t0x5c <read_tube_name+0x5c>\n57: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n5c: \tpopq\t%rbx\n5d: \tpopq\t%r14\n5f: \tpopq\t%r15\n61: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  NAME_CHARS ;\nsize_t strspn (char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nread_tube_name(char **tubename, char *buf, char **end)\n{\nsize_t len;\n\nwhile (buf[0] == ' ')\nbuf++;\nlen = strspn(buf, NAME_CHARS);\nif (len == 0)\nreturn -1;\nif (tubename)\n*tubename = buf;\nif (end)\n*end = buf + len;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  isspace (char) ;\nchar* strchr (char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int read_tube_name(char **p, char **q, char **r) {\nchar *s = *p;\nchar *t = s;\n\nwhile (*s && !isspace(*s)) {\ns++;\n}\nif (p) {\n*p = s;\n}\nif (q) {\n*q = t;\n}\nif (r) {\n*r = s;\n}\nif (*s) {\nreturn 0;\n}\nreturn -1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_cmp_pris",
    "input":"\n0000000000000000 <cttest_job_cmp_pris>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %ebx  # 0x7 <cttest_job_cmp_pris+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <cttest_job_cmp_pris+0x11>\n11: \tmovl\t%ebx, %edi\n13: \tmovl\t%eax, %esi\n15: \tcallq\t0x1a <cttest_job_cmp_pris+0x1a>\n1a: \tmovl\t(%rip), %r8d  # 0x21 <cttest_job_cmp_pris+0x21>\n21: \tmovl\t$1, %edi\n26: \txorl\t%esi, %esi\n28: \tmovl\t$1, %edx\n2d: \txorl\t%ecx, %ecx\n2f: \tcallq\t0x34 <cttest_job_cmp_pris+0x34>\n34: \tmovq\t%rax, %rbx\n37: \tmovl\t(%rip), %r8d  # 0x3e <cttest_job_cmp_pris+0x3e>\n3e: \tmovl\t$134217728, %edi   # imm = 0x8000000\n43: \txorl\t%esi, %esi\n45: \tmovl\t$1, %edx\n4a: \txorl\t%ecx, %ecx\n4c: \tcallq\t0x51 <cttest_job_cmp_pris+0x51>\n51: \tmovq\t%rbx, %rdi\n54: \tmovq\t%rax, %rsi\n57: \tcallq\t0x5c <cttest_job_cmp_pris+0x5c>\n5c: \tmovl\t$0, %esi\n61: \tmovl\t%eax, %edi\n63: \tpopq\t%rbx\n64: \tjmp\t0x69 <cttest_job_cmp_pris+0x69>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  job_pri_less (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_job (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_cmp_pris()\n{\nJob *a, *b;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\na = make_job(1, 0, 1, 0, default_tube);\nb = make_job(1 << 27, 0, 1, 0, default_tube);\n\nassertf(job_pri_less(a, b), \"should be less\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CMP_EQ ;\nint /*<<< orphan*/  CMP_GT ;\nint /*<<< orphan*/  CMP_LT ;\nint /*<<< orphan*/  ct_test_job_cmp (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_job_new (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq_lt (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq_neq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq_neq_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_set_pris_cmp_neq_neq_neq_neq_neq_neq_neq_neq_gt (int /*<<< orphan*/ *,int /*<<< or"
},
{
    "file:":"./beanstalkd/extr_job.c_job_delay_less",
    "input":"\n0000000000000000 <job_delay_less>:\n0: \tmovq\t(%rdi), %rcx\n3: \tmovq\t(%rsi), %rdx\n6: \tmovl\t$1, %eax\nb: \tcmpq\t%rdx, %rcx\ne: \tjl\t0x24 <job_delay_less+0x24>\n10: \txorl\t%eax, %eax\n12: \tcmpq\t%rdx, %rcx\n15: \tjg\t0x24 <job_delay_less+0x24>\n17: \tmovq\t8(%rdi), %rcx\n1b: \txorl\t%eax, %eax\n1d: \tcmpq\t8(%rsi), %rcx\n21: \tsetl\t%al\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ deadline_at; scalar_t__ id; } ;\nstruct TYPE_4__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\n\nint\njob_delay_less(void *ja, void *jb)\n{\nJob *a = ja;\nJob *b = jb;\nif (a->r.deadline_at < b->r.deadline_at) return 1;\nif (a->r.deadline_at > b->r.deadline_at) return 0;\nreturn a->r.id < b->r.id;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ delay; scalar_t__ priority; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\n\n__attribute__((used)) static inline int\njob_delay_less(const job_t *a, const job_t *b)\n{\nif (a->delay < b->delay)\nreturn 1;\nif (a->delay > b->delay)\nreturn 0;\nreturn a->priority < b->priority;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_remove_reserved_job",
    "input":"\n0000000000000000 <remove_reserved_job>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <remove_reserved_job+0xf>\nf: \ttestl\t%eax, %eax\n11: \tje\t0x25 <remove_reserved_job+0x25>\n13: \tmovq\t%rbx, %rdi\n16: \tmovq\t%r14, %rsi\n19: \taddq\t$8, %rsp\n1d: \tpopq\t%rbx\n1e: \tpopq\t%r14\n20: \tjmp\t0x25 <remove_reserved_job+0x25>\n25: \txorl\t%eax, %eax\n27: \taddq\t$8, %rsp\n2b: \tpopq\t%rbx\n2c: \tpopq\t%r14\n2e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Job ;\ntypedef  int /*<<< orphan*/  Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  is_job_reserved_by_conn (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * remove_this_reserved_job (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static Job *\nremove_reserved_job(Conn *c, Job *j)\n{\nif (!is_job_reserved_by_conn(c, j))\nreturn NULL;\nreturn remove_this_reserved_job(c, j);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  is_reserved_job (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  remove_job (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int remove_reserved_job (job_t *job, job_t *reserved_job) {\nif (!is_reserved_job (reserved_job)) {\nreturn 0;\n}\n\nreturn remove_job (job, reserved_job);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_fileincref",
    "input":"\n0000000000000000 <fileincref>:\n0: \ttestq\t%rdi, %rdi\n3: \tje\t0x8 <fileincref+0x8>\n5: \taddl\t$1, (%rdi)\n8: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  refs; } ;\ntypedef  TYPE_1__ File ;\n\n/* Variables and functions */\n\nvoid\nfileincref(File *f)\n{\nif (!f) return;\nf->refs++;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  ref; } ;\ntypedef  TYPE_1__ file ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void fileincref(file *f)\n{\nif (f)\nf->ref++;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_prothandle",
    "input":"\n0000000000000000 <prothandle>:\n0: \tmovq\t%rdi, %rdx\n3: \tmovl\t(%rdi), %edi\n5: \tjmp\t0xa <prothandle+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  fd; } ;\nstruct TYPE_6__ {TYPE_1__ sock; } ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h_conn (int /*<<< orphan*/ ,int,TYPE_2__*) ;\n\n__attribute__((used)) static void\nprothandle(Conn *c, int ev)\n{\nh_conn(c->sock.fd, ev, c);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  handle; } ;\ntypedef  TYPE_1__ PROTOCOL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  handle_proto (int /*<<< orphan*/ ,int,TYPE_1__*) ;\n\n__attribute__((used)) static void\nprothandle(PROTOCOL *prot)\n{\nhandle_proto(prot->handle, 0, prot);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_allocate_job",
    "input":"\n0000000000000000 <allocate_job>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t%edi, %r14d\n7: \tleal\t16(%r14), %edi\nb: \tcallq\t0x10 <allocate_job+0x10>\n10: \tmovq\t%rax, %rbx\n13: \ttestq\t%rax, %rax\n16: \tje\t0x49 <allocate_job+0x49>\n18: \tmovq\t%rbx, %rdi\n1b: \txorl\t%esi, %esi\n1d: \tmovl\t$16, %edx\n22: \tcallq\t0x27 <allocate_job+0x27>\n27: \txorl\t%eax, %eax\n29: \tcallq\t0x2e <allocate_job+0x2e>\n2e: \tmovl\t%eax, 12(%rbx)\n31: \tmovl\t%r14d, 8(%rbx)\n35: \tmovq\t%rbx, %rax\n38: \taddq\t$16, %rax\n3c: \tmovq\t%rax, (%rbx)\n3f: \tmovq\t%rbx, %rdi\n42: \tcallq\t0x47 <allocate_job+0x47>\n47: \tjmp\t0x53 <allocate_job+0x53>\n49: \tmovl\t$0, %edi\n4e: \tcallq\t0x53 <allocate_job+0x53>\n53: \tmovq\t%rbx, %rax\n56: \taddq\t$8, %rsp\n5a: \tpopq\t%rbx\n5b: \tpopq\t%r14\n5d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {int body_size; int /*<<< orphan*/  created_at; } ;\nstruct TYPE_8__ {char* body; TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  job_list_reset (TYPE_2__*) ;\nTYPE_2__* malloc (int) ;\nint /*<<< orphan*/  memset (TYPE_2__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  nanoseconds () ;\nint /*<<< orphan*/  twarnx (char*) ;\n\nJob *\nallocate_job(int body_size)\n{\nJob *j;\n\nj = malloc(sizeof(Job) + body_size);\nif (!j) {\ntwarnx(\"OOM\");\nreturn (Job *) 0;\n}\n\nmemset(j, 0, sizeof(Job));\nj->r.created_at = nanoseconds();\nj->r.body_size = body_size;\nj->body = (char *)j + sizeof(Job);\njob_list_reset(j);\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * next; int /*<<< orphan*/  job_id; int /*<<< orphan*/  job_type; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (TYPE_1__*) ;\nint /*<<< orphan*/  get_time () ;\nint /*<<< orphan*/  malloc (int) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  printf (char*) ;\n\njob_t *allocate_job (int job_type) {\njob_t *job = (job_t *) malloc (sizeof (job_t) + 16);\nif (job == NULL) {\nprintf (\"Out of memory\\n\");\nreturn NULL;\n}\nmemset (job, 0, sizeof (job_t) + 16);\njob->job_type = job_type;\njob->job_id = get_time ();\njob->next = job + 1;\nassert (job);\nreturn job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_h_conn",
    "input":"\n0000000000000000 <h_conn>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdx, %rbx\n6: \tcmpl\t%edi, 28(%rdx)\n9: \tjne\t0x51 <h_conn+0x51>\nb: \tcmpw\t$104, %si\nf: \tjne\t0x17 <h_conn+0x17>\n11: \tmovl\t$1, (%rbx)\n17: \tmovq\t%rbx, %rdi\n1a: \tcallq\t0x1f <h_conn+0x1f>\n1f: \tnop\n20: \tmovq\t%rbx, %rdi\n23: \tcallq\t0x28 <h_conn+0x28>\n28: \ttestq\t%rax, %rax\n2b: \tje\t0x66 <h_conn+0x66>\n2d: \tmovl\t16(%rbx), %esi\n30: \tmovl\t20(%rbx), %edi\n33: \tcallq\t0x38 <h_conn+0x38>\n38: \tmovl\t%eax, 24(%rbx)\n3b: \ttestl\t%eax, %eax\n3d: \tje\t0x66 <h_conn+0x66>\n3f: \tmovq\t%rbx, %rdi\n42: \tcallq\t0x47 <h_conn+0x47>\n47: \tmovq\t%rbx, %rdi\n4a: \tcallq\t0x4f <h_conn+0x4f>\n4f: \tjmp\t0x20 <h_conn+0x20>\n51: \tmovl\t%edi, %ebp\n53: \tmovl\t$0, %edi\n58: \tcallq\t0x5d <h_conn+0x5d>\n5d: \tmovl\t%ebp, %edi\n5f: \tcallq\t0x64 <h_conn+0x64>\n64: \tjmp\t0x7b <h_conn+0x7b>\n66: \tmovq\t8(%rbx), %rax\n6a: \tcmpq\t(%rip), %rax  # 0x71 <h_conn+0x71>\n71: \tjne\t0x83 <h_conn+0x83>\n73: \tmovq\t%rbx, %rdi\n76: \tcallq\t0x7b <h_conn+0x7b>\n7b: \tmovq\t%rbx, %rdi\n7e: \tcallq\t0x83 <h_conn+0x83>\n83: \txorl\t%eax, %eax\n85: \taddq\t$8, %rsp\n89: \tpopq\t%rbx\n8a: \tpopq\t%rbp\n8b: \tjmp\t0x90 <h_conn+0x90>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int const fd; } ;\nstruct TYPE_11__ {int halfclosed; scalar_t__ state; int /*<<< orphan*/  cmd_read; int /*<<< orphan*/  cmd; int /*<<< orphan*/  cmd_len; TYPE_1__ sock; } ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nscalar_t__ STATE_CLOSE ;\nint /*<<< orphan*/  close (int const) ;\nscalar_t__ cmd_data_ready (TYPE_2__*) ;\nint /*<<< orphan*/  conn_process_io (TYPE_2__*) ;\nint /*<<< orphan*/  connclose (TYPE_2__*) ;\nint /*<<< orphan*/  dispatch_cmd (TYPE_2__*) ;\nint /*<<< orphan*/  epollq_apply () ;\nint /*<<< orphan*/  epollq_rmconn (TYPE_2__*) ;\nint /*<<< orphan*/  fill_extra_data (TYPE_2__*) ;\nint /*<<< orphan*/  scan_line_end (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\n__attribute__((used)) static void\nh_conn(const int fd, const short which, Conn *c)\n{\nif (fd != c->sock.fd) {\ntwarnx(\"Argh! event fd doesn't match conn fd.\");\nclose(fd);\nconnclose(c);\nepollq_apply();\nreturn;\n}\n\nif (which == 'h') {\nc->halfclosed = 1;\n}\n\nconn_process_io(c);\nwhile (cmd_data_ready(c) && (c->cmd_len = scan_line_end(c->cmd, c->cmd_read))) {\ndispatch_cmd(c);\nfill_extra_data(c);\n}\nif (c->state == STATE_CLOSE) {\nepollq_rmconn(c);\nconnclose(c);\n}\nepollq_apply();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  h_conn_state; int /*<<< orphan*/  h_conn_fd; int /*<<< orphan*/  h_conn_port; int /*<<< orphan*/  h_conn_host; int /*<<< orphan*/  h_conn_proto; scalar_t__ h_conn_type; } ;\ntypedef  TYPE_1__ h_conn_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nscalar_t__ h_conn_type_tcp ;\nint /*<<< orphan*/  h_conn_update_state (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_tcp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_udp_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_udp_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp_udp (TYPE_1__*) ;\nint /*<<< orphan*/  h_conn_write_state_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_unix_udp ("
},
{
    "file:":"./beanstalkd/extr_prot.c_touch_job",
    "input":"\n0000000000000000 <touch_job>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tcallq\t0xf <touch_job+0xf>\nf: \ttestq\t%rax, %rax\n12: \tje\t0x30 <touch_job+0x30>\n14: \txorl\t%eax, %eax\n16: \tcallq\t0x1b <touch_job+0x1b>\n1b: \taddq\t(%rbx), %rax\n1e: \tmovq\t%rax, 8(%rbx)\n22: \tmovq\t$0, (%r14)\n29: \tmovl\t$1, %eax\n2e: \tjmp\t0x32 <touch_job+0x32>\n30: \txorl\t%eax, %eax\n32: \taddq\t$8, %rsp\n36: \tpopq\t%rbx\n37: \tpopq\t%r14\n39: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/ * soonest_job; } ;\nstruct TYPE_8__ {scalar_t__ ttr; scalar_t__ deadline_at; } ;\nstruct TYPE_9__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\ntypedef  TYPE_3__ Conn ;\n\n/* Variables and functions */\nscalar_t__ is_job_reserved_by_conn (TYPE_3__*,TYPE_2__*) ;\nscalar_t__ nanoseconds () ;\n\n__attribute__((used)) static bool\ntouch_job(Conn *c, Job *j)\n{\nif (is_job_reserved_by_conn(c, j)) {\nj->r.deadline_at = nanoseconds() + j->r.ttr;\nc->soonest_job = NULL;\nreturn true;\n}\nreturn false;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ size; scalar_t__ offset; } ;\ntypedef  TYPE_1__ GLogFile ;\ntypedef  int /*<<< orphan*/  GLog ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_log_file_close (TYPE_1__*) ;\nscalar_t__ g_log_file_open (TYPE_1__*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int\ntouch_job (GLog * log, void *data)\n{\nGLogFile *file = (GLogFile *) data;\n\nif (g_log_file_open (file, log)) {\ng_log_file_close (file);\nfile->offset = file->size;\nreturn 1;\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_underscore",
    "input":"\n0000000000000000 <cttest_underscore>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_underscore+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_underscore+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_underscore+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tpopq\t%rbx\n25: \tjmp\t0x2a <cttest_underscore+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_underscore()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"use x_y\\r\\n\");\nckresp(fd, \"USING x_y\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  BIO_write (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  TEST_int_eq (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void cttest_underscore(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\n\nTEST_int_eq(BIO_write(bio, \"_\", 1), 1);\nTEST_int_eq(BIO_write(bio, \"_\", 1), 1);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_on_watch",
    "input":"\n0000000000000000 <on_watch>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdx, %r14\n7: \tmovq\t%rsi, %rbx\na: \tcallq\t0xf <on_watch+0xf>\nf: \tmovq\t%r14, %rdi\n12: \tcallq\t0x17 <on_watch+0x17>\n17: \tmovq\t%rbx, %rdi\n1a: \tcallq\t0x1f <on_watch+0x1f>\n1f: \taddl\t$1, (%rbx)\n22: \taddq\t$8, %rsp\n26: \tpopq\t%rbx\n27: \tpopq\t%r14\n29: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  watching_ct; } ;\ntypedef  TYPE_1__ Tube ;\ntypedef  int /*<<< orphan*/  Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  UNUSED_PARAMETER (size_t) ;\nint /*<<< orphan*/  tube_iref (TYPE_1__*) ;\n\n__attribute__((used)) static void\non_watch(Ms *a, Tube *t, size_t i)\n{\nUNUSED_PARAMETER(a);\nUNUSED_PARAMETER(i);\ntube_iref(t);\nt->watching_ct++;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  watch_count; } ;\ntypedef  TYPE_1__ GLog ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_log_free (TYPE_1__*) ;\nint /*<<< orphan*/  g_log_ref (TYPE_1__*) ;\n\n__attribute__((used)) static void\non_watch (void *data, GLog *log, gpointer user_data)\n{\ng_log_ref (log);\ng_log_free (log);\n\nlog->watch_count++;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walcompact",
    "input":"\n0000000000000000 <walcompact>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdi, %rbx\n6: \tcallq\t0xb <walcompact+0xb>\nb: \tcmpl\t$2, %eax\ne: \tjl\t0x30 <walcompact+0x30>\n10: \tmovl\t%eax, %ebp\n12: \taddl\t$1, %ebp\n15: \tnopw\t%cs:(%rax,%rax)\n1f: \tnop\n20: \tmovq\t%rbx, %rdi\n23: \tcallq\t0x28 <walcompact+0x28>\n28: \taddl\t$-1, %ebp\n2b: \tcmpl\t$2, %ebp\n2e: \tjg\t0x20 <walcompact+0x20>\n30: \taddq\t$8, %rsp\n34: \tpopq\t%rbx\n35: \tpopq\t%rbp\n36: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Wal ;\n\n/* Variables and functions */\nint /*<<< orphan*/  moveone (int /*<<< orphan*/ *) ;\nint ratio (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\nwalcompact(Wal *w)\n{\nint r;\n\nfor (r=ratio(w); r>=2; r--) {\nmoveone(w);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sqlite3_file ;\n\n/* Variables and functions */\nint sqlite3WalFrames (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  walFrame (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void walcompact(sqlite3_file *pWal){\nint i;\nfor(i=2; i<sqlite3WalFrames(pWal); i++){\nwalFrame(pWal);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_connsetproducer",
    "input":"\n0000000000000000 <connsetproducer>:\n0: \tmovl\t(%rdi), %eax\n2: \tmovl\t(%rip), %ecx  # 0x8 <connsetproducer+0x8>\n8: \ttestl\t%eax, %ecx\na: \tje\t0xd <connsetproducer+0xd>\nc: \tretq\nd: \torl\t%eax, %ecx\nf: \tmovl\t%ecx, (%rdi)\n11: \taddl\t$1, (%rip)    # 0x18 <connsetproducer+0x18>\n18: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int type; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint CONN_TYPE_PRODUCER ;\nint /*<<< orphan*/  cur_producer_ct ;\n\nvoid\nconnsetproducer(Conn *c)\n{\nif (c->type & CONN_TYPE_PRODUCER) return;\nc->type |= CONN_TYPE_PRODUCER;\ncur_producer_ct++; /* stats */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; } ;\ntypedef  TYPE_1__ connection ;\n\n/* Variables and functions */\nint C_PRODUCER ;\nint /*<<< orphan*/  producers ;\n\nvoid connsetproducer(connection *c) {\nif (c->flags & C_PRODUCER) {\nreturn;\n}\nc->flags |= C_PRODUCER;\nproducers++;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walmaint",
    "input":"\n0000000000000000 <walmaint>:\n0: \tpushq\t%rbx\n1: \tcmpq\t$0, (%rdi)\n5: \tje\t0x18 <walmaint+0x18>\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <walmaint+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tpopq\t%rbx\n13: \tjmp\t0x18 <walmaint+0x18>\n18: \tpopq\t%rbx\n19: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ use; } ;\ntypedef  TYPE_1__ Wal ;\n\n/* Variables and functions */\nint /*<<< orphan*/  walcompact (TYPE_1__*) ;\nint /*<<< orphan*/  walsync (TYPE_1__*) ;\n\nvoid\nwalmaint(Wal *w)\n{\nif (w->use) {\nwalcompact(w);\nwalsync(w);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ wal_enabled; } ;\ntypedef  TYPE_1__ WalSnd ;\n\n/* Variables and functions */\nint /*<<< orphan*/  wal_catchup (TYPE_1__*) ;\nint /*<<< orphan*/  wal_send (TYPE_1__*) ;\n\nvoid\nwalmaint(WalSnd *walsnd)\n{\n/*\n* If we're not streaming, there is nothing to do here.\n*/\nif (!walsnd->wal_enabled)\nreturn;\n\n/*\n* Update shared memory status\n*/\nwal_send(walsnd);\n\n/*\n* If we're not streaming, there is nothing more to do.\n*/\nif (!walsnd->wal_enabled)\nreturn;\n\n/*\n* If we're streaming, catch up to the current point of the master.\n*/\nwal_catchup(walsnd);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_buried_job_p",
    "input":"\n0000000000000000 <buried_job_p>:\n0: \tpushq\t%rax\n1: \tcallq\t0x6 <buried_job_p+0x6>\n6: \txorl\t%ecx, %ecx\n8: \ttestl\t%eax, %eax\na: \tsete\t%cl\nd: \tmovl\t%ecx, %eax\nf: \tpopq\t%rcx\n10: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  buried; } ;\ntypedef  TYPE_1__ Tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/  job_list_is_empty (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int\nburied_job_p(Tube *t)\n{\n// this function does not do much. inline?\nreturn !job_list_is_empty(&t->buried);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  job_state_p (int /*<<< orphan*/  const*,int) ;\n\n__attribute__((used)) static inline bool\nburied_job_p (const job_t *job)\n{\nreturn job_state_p (job, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_remove_buried_job",
    "input":"\n0000000000000000 <remove_buried_job>:\n0: \tpushq\t%rax\n1: \ttestq\t%rdi, %rdi\n4: \tje\t0x2c <remove_buried_job+0x2c>\n6: \tmovq\t8(%rdi), %rax\na: \tcmpq\t(%rip), %rax  # 0x11 <remove_buried_job+0x11>\n11: \tjne\t0x2c <remove_buried_job+0x2c>\n13: \tcallq\t0x18 <remove_buried_job+0x18>\n18: \ttestq\t%rax, %rax\n1b: \tje\t0x2c <remove_buried_job+0x2c>\n1d: \taddl\t$-1, (%rip)   # 0x24 <remove_buried_job+0x24>\n24: \tmovq\t(%rax), %rcx\n27: \taddl\t$-1, (%rcx)\n2a: \tpopq\t%rcx\n2b: \tretq\n2c: \txorl\t%eax, %eax\n2e: \tpopq\t%rcx\n2f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_14__   TYPE_9__ ;\ntypedef  struct TYPE_13__   TYPE_4__ ;\ntypedef  struct TYPE_12__   TYPE_3__ ;\ntypedef  struct TYPE_11__   TYPE_2__ ;\ntypedef  struct TYPE_10__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_14__ {int /*<<< orphan*/  buried_ct; } ;\nstruct TYPE_10__ {scalar_t__ state; } ;\nstruct TYPE_13__ {TYPE_3__* tube; TYPE_1__ r; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  buried_ct; } ;\nstruct TYPE_12__ {TYPE_2__ stat; } ;\ntypedef  TYPE_4__ Job ;\n\n/* Variables and functions */\nscalar_t__ Buried ;\nTYPE_9__ global_stat ;\nTYPE_4__* job_list_remove (TYPE_4__*) ;\n\n__attribute__((used)) static Job *\nremove_buried_job(Job *j)\n{\nif (!j || j->r.state != Buried)\nreturn NULL;\nj = job_list_remove(j);\nif (j) {\nglobal_stat.buried_ct--;\nj->tube->stat.buried_ct--;\n}\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  buried_jobs; int /*<<< orphan*/ * queue; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  buried_jobs ;\nTYPE_1__* get_job (TYPE_1__*) ;\n\n__attribute__((used)) static job_t *remove_buried_job (job_t *job) {\nif (!job || job->queue != &buried_jobs) {\nreturn NULL;\n}\n\njob = get_job (job);\nif (!job) {\nreturn NULL;\n}\n\nburied_jobs--;\njob->buried_jobs--;\n\nreturn job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_clear",
    "input":"\n0000000000000000 <ms_clear>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tnopw\t%cs:(%rax,%rax)\ne: \tnop\n10: \tmovq\t%rbx, %rdi\n13: \txorl\t%esi, %esi\n15: \tcallq\t0x1a <ms_clear+0x1a>\n1a: \ttestq\t%rax, %rax\n1d: \tjne\t0x10 <ms_clear+0x10>\n1f: \tmovl\t8(%rbx), %edi\n22: \tcallq\t0x27 <ms_clear+0x27>\n27: \tmovl\t(%rbx), %edx\n29: \tmovl\t4(%rbx), %esi\n2c: \tmovq\t%rbx, %rdi\n2f: \tpopq\t%rbx\n30: \tjmp\t0x35 <ms_clear+0x35>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  onremove; int /*<<< orphan*/  oninsert; int /*<<< orphan*/  items; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\nscalar_t__ ms_delete (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ms_init (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nms_clear(Ms *a)\n{\nwhile (ms_delete(a, 0));\nfree(a->items);\nms_init(a, a->oninsert, a->onremove);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  len; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__ MSStmt ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\nscalar_t__ ms_is_null (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nms_clear(MSStmt *stmt)\n{\nwhile (ms_is_null(stmt, 0))\n{\nmemset(stmt, 0, sizeof(*stmt));\n}\nfree(stmt->data);\nstmt->len = 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testheap.c_cttest_heap_insert_and_remove_one",
    "input":"\n0000000000000000 <cttest_heap_insert_and_remove_one>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tsubq\t$24, %rsp\n7: \tmovq\t$0, (%rsp)\nf: \tmovl\t$0, 8(%rsp)\n17: \tmovl\t(%rip), %eax  # 0x1d <cttest_heap_insert_and_remove_one+0x1d>\n1d: \tmovl\t%eax, 12(%rsp)\n21: \tmovl\t(%rip), %eax  # 0x27 <cttest_heap_insert_and_remove_one+0x27>\n27: \tmovl\t%eax, 16(%rsp)\n2b: \tmovl\t$1, %edi\n30: \txorl\t%esi, %esi\n32: \tmovl\t$1, %edx\n37: \txorl\t%ecx, %ecx\n39: \txorl\t%r8d, %r8d\n3c: \tcallq\t0x41 <cttest_heap_insert_and_remove_one+0x41>\n41: \tmovq\t%rax, %rbx\n44: \tmovl\t$0, %esi\n49: \tmovl\t%ebx, %edi\n4b: \tcallq\t0x50 <cttest_heap_insert_and_remove_one+0x50>\n50: \tmovq\t%rsp, %r14\n53: \tmovq\t%r14, %rdi\n56: \tmovq\t%rbx, %rsi\n59: \tcallq\t0x5e <cttest_heap_insert_and_remove_one+0x5e>\n5e: \tmovl\t$0, %esi\n63: \tmovl\t%eax, %edi\n65: \tcallq\t0x6a <cttest_heap_insert_and_remove_one+0x6a>\n6a: \tmovq\t%r14, %rdi\n6d: \txorl\t%esi, %esi\n6f: \tcallq\t0x74 <cttest_heap_insert_and_remove_one+0x74>\n74: \txorl\t%edi, %edi\n76: \tcmpq\t%rbx, %rax\n79: \tsete\t%dil\n7d: \tmovl\t$0, %esi\n82: \tcallq\t0x87 <cttest_heap_insert_and_remove_one+0x87>\n87: \txorl\t%edi, %edi\n89: \tcmpq\t$0, (%rsp)\n8e: \tsete\t%dil\n92: \tmovl\t$0, %esi\n97: \tcallq\t0x9c <cttest_heap_insert_and_remove_one+0x9c>\n9c: \tmovl\t8(%rsp), %edi\na0: \tcallq\t0xa5 <cttest_heap_insert_and_remove_one+0xa5>\na5: \tmovq\t%rbx, %rdi\na8: \tcallq\t0xad <cttest_heap_insert_and_remove_one+0xad>\nad: \taddq\t$24, %rsp\nb1: \tpopq\t%rbx\nb2: \tpopq\t%r14\nb4: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ len; int /*<<< orphan*/  data; int /*<<< orphan*/  setpos; int /*<<< orphan*/  less; } ;\ntypedef  int /*<<< orphan*/  Job ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\nint heapinsert (TYPE_1__*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * heapremove (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  job_pri_less ;\nint /*<<< orphan*/  job_setpos ;\nint /*<<< orphan*/ * make_job (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\ncttest_heap_insert_and_remove_one()\n{\nHeap h = {\n.less = job_pri_less,\n.setpos = job_setpos,\n};\n\nJob *j1 = make_job(1, 0, 1, 0, 0);\nassertf(j1, \"allocate job\");\n\nint r = heapinsert(&h, j1);\nassertf(r, \"insert should succeed\");\n\nJob *got = heapremove(&h, 0);\nassertf(got == j1, \"j1 should come back out\");\nassertf(h.len == 0, \"h should be empty.\");\n\nfree(h.data);\njob_free(j1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_heap_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CMP_INT ;\nint /*<<< orphan*/  ct_heap_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_insert (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_remove (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_size (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_verify (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_verify_cmp (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_empty (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_verify_one (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_size (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  ct_heap_verify_zero (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_verify_zero_size (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_verify_zero_size_empty (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_heap_verify_zero_size_one (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_zero_size_two (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_one (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_one (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_one_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_one_two (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_one_two_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_one_two_one (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_heap_verify_two_size_two_one_two_one_two_one_two_one_empty (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,"
},
{
    "file:":"./beanstalkd/extr_prot.c_remove_waiting_conn",
    "input":"\n0000000000000000 <remove_waiting_conn>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tcallq\t0xc <remove_waiting_conn+0xc>\nc: \ttestl\t%eax, %eax\ne: \tje\t0x4d <remove_waiting_conn+0x4d>\n10: \tmovl\t(%rip), %eax  # 0x16 <remove_waiting_conn+0x16>\n16: \tnotl\t%eax\n18: \tandl\t%eax, 16(%r14)\n1c: \taddl\t$-1, (%rip)   # 0x23 <remove_waiting_conn+0x23>\n23: \tcmpq\t$0, (%r14)\n27: \tje\t0x4d <remove_waiting_conn+0x4d>\n29: \txorl\t%ebx, %ebx\n2b: \tnopl\t(%rax,%rax)\n30: \tmovq\t8(%r14), %rax\n34: \tmovq\t(%rax,%rbx,8), %rdi\n38: \taddl\t$-1, 4(%rdi)\n3c: \tmovq\t%r14, %rsi\n3f: \tcallq\t0x44 <remove_waiting_conn+0x44>\n44: \taddq\t$1, %rbx\n48: \tcmpq\t(%r14), %rbx\n4b: \tjb\t0x30 <remove_waiting_conn+0x30>\n4d: \taddq\t$8, %rsp\n51: \tpopq\t%rbx\n52: \tpopq\t%r14\n54: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_7__ ;\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  waiting_ct; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  waiting_conns; TYPE_2__ stat; } ;\ntypedef  TYPE_3__ Tube ;\nstruct TYPE_13__ {int /*<<< orphan*/  waiting_ct; } ;\nstruct TYPE_9__ {size_t len; TYPE_3__** items; } ;\nstruct TYPE_12__ {TYPE_1__ watch; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_4__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CONN_TYPE_WAITING ;\nint /*<<< orphan*/  conn_waiting (TYPE_4__*) ;\nTYPE_7__ global_stat ;\nint /*<<< orphan*/  ms_remove (int /*<<< orphan*/ *,TYPE_4__*) ;\n\nvoid\nremove_waiting_conn(Conn *c)\n{\nif (!conn_waiting(c))\nreturn;\n\nc->type &= ~CONN_TYPE_WAITING;\nglobal_stat.waiting_ct--;\nsize_t i;\nfor (i = 0; i < c->watch.len; i++) {\nTube *t = c->watch.items[i];\nt->stat.waiting_ct--;\nms_remove(&t->waiting_conns, c);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ n_waiting_conns; TYPE_1__* waiting_conns; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  n_waiting_conns; int /*<<< orphan*/  flags; } ;\ntypedef  TYPE_1__ waiting_conn_t ;\ntypedef  TYPE_2__ connection_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  WAITING_CONN_FLAG_REMOVED ;\nint /*<<< orphan*/  assert (TYPE_2__*) ;\nint /*<<< orphan*/  waiting_conn_remove (TYPE_1__*,TYPE_2__*) ;\n\n__attribute__((used)) static void remove_waiting_conn (connection_t *c) {\nassert (c);\n\nc->flags &= ~WAITING_CONN_FLAG_REMOVED;\n\nif (c->n_waiting_conns) {\nint i;\nfor (i = 0; i < c->n_waiting_conns; i++) {\nwaiting_conn_t *wc = c->waiting_conns[i];\nwc->n_waiting_conns--;\nwaiting_conn_remove (wc, c);\n}\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_heap.c_siftup",
    "input":"\n0000000000000000 <siftup>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r13\n6: \tpushq\t%r12\n8: \tpushq\t%rbx\n9: \tmovq\t%rsi, %rbx\nc: \tmovq\t%rdi, %r14\nf: \tmovq\t%rsi, %r15\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \tleaq\t(%rbx,%rbx), %r13\n24: \taddq\t$1, %r13\n28: \tleaq\t(%rbx,%rbx), %r12\n2c: \taddq\t$2, %r12\n30: \tmovq\t(%r14), %rax\n33: \tcmpq\t%rax, %r13\n36: \tjae\t0x54 <siftup+0x54>\n38: \tmovq\t%r14, %rdi\n3b: \tmovq\t%r13, %rsi\n3e: \tmovq\t%rbx, %rdx\n41: \tcallq\t0x46 <siftup+0x46>\n46: \tmovq\t%rbx, %r15\n49: \ttestq\t%rax, %rax\n4c: \tje\t0x51 <siftup+0x51>\n4e: \tmovq\t%r13, %r15\n51: \tmovq\t(%r14), %rax\n54: \tcmpq\t%rax, %r12\n57: \tjae\t0x6f <siftup+0x6f>\n59: \tmovq\t%r14, %rdi\n5c: \tmovq\t%r12, %rsi\n5f: \tmovq\t%r15, %rdx\n62: \tcallq\t0x67 <siftup+0x67>\n67: \ttestq\t%rax, %rax\n6a: \tje\t0x6f <siftup+0x6f>\n6c: \tmovq\t%r12, %r15\n6f: \tcmpq\t%rbx, %r15\n72: \tje\t0x87 <siftup+0x87>\n74: \tmovq\t%r14, %rdi\n77: \tmovq\t%rbx, %rsi\n7a: \tmovq\t%r15, %rdx\n7d: \tcallq\t0x82 <siftup+0x82>\n82: \tmovq\t%r15, %rbx\n85: \tjmp\t0x20 <siftup+0x20>\n87: \tpopq\t%rbx\n88: \tpopq\t%r12\n8a: \tpopq\t%r13\n8c: \tpopq\t%r14\n8e: \tpopq\t%r15\n90: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {size_t len; } ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nscalar_t__ less (TYPE_1__*,size_t,size_t) ;\nint /*<<< orphan*/  swap (TYPE_1__*,size_t,size_t) ;\n\n__attribute__((used)) static void\nsiftup(Heap *h, size_t k)\n{\nfor (;;) {\nsize_t l = k*2 + 1; /* left child */\nsize_t r = k*2 + 2; /* right child */\n\n/* find the smallest of the three */\nsize_t s = k;\nif (l < h->len && less(h, l, s)) s = l;\nif (r < h->len && less(h, r, s)) s = r;\n\nif (s == k) {\nreturn; /* satisfies the heap property */\n}\n\nswap(h, k, s);\nk = s;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ int64 ;\n\n/* Variables and functions */\nscalar_t__ compare (void const*,size_t,size_t) ;\nint /*<<< orphan*/  swap (void const*,size_t,size_t) ;\n\n__attribute__((used)) static void\nsiftup(const void *a, size_t i)\n{\nsize_t\t\tj;\n\nfor (; i > 0; i = j)\n{\nj = (i - 1) >> 1;\nif (compare(a, j, i) <= 0)\nbreak;\nswap(a, i, j);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_conn_ready",
    "input":"\n0000000000000000 <conn_ready>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0x23 <conn_ready+0x23>\n8: \tmovq\t8(%rdi), %rcx\nc: \txorl\t%edx, %edx\ne: \tnop\n10: \tmovq\t(%rcx,%rdx,8), %rsi\n14: \tcmpq\t$0, (%rsi)\n18: \tjne\t0x26 <conn_ready+0x26>\n1a: \taddq\t$1, %rdx\n1e: \tcmpq\t%rax, %rdx\n21: \tjb\t0x10 <conn_ready+0x10>\n23: \txorl\t%eax, %eax\n25: \tretq\n26: \tmovl\t$1, %eax\n2b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ len; } ;\nstruct TYPE_8__ {TYPE_1__ ready; } ;\ntypedef  TYPE_3__ Tube ;\nstruct TYPE_7__ {size_t len; scalar_t__* items; } ;\nstruct TYPE_9__ {TYPE_2__ watch; } ;\ntypedef  TYPE_4__ Conn ;\n\n/* Variables and functions */\n\nint\nconn_ready(Conn *c)\n{\nsize_t i;\n\nfor (i = 0; i < c->watch.len; i++) {\nif (((Tube *) c->watch.items[i])->ready.len)\nreturn 1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t nconns; int /*<<< orphan*/ ** conns; } ;\ntypedef  TYPE_1__ GLog ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int\nconn_ready (GLog * log)\n{\nsize_t i;\n\nfor (i = 0; i < log->nconns; i++)\nif (log->conns[i]->fd == 0)\nreturn 0;\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_job_size_max_plus_1",
    "input":"\n0000000000000000 <cttest_job_size_max_plus_1>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$1048592, %rsp# imm = 0x100010\nb: \tmovl\t(%rip), %eax  # 0x11 <cttest_job_size_max_plus_1+0x11>\n11: \tmovl\t%eax, (%rip)  # 0x17 <cttest_job_size_max_plus_1+0x17>\n17: \txorl\t%ebp, %ebp\n19: \txorl\t%eax, %eax\n1b: \tcallq\t0x20 <cttest_job_size_max_plus_1+0x20>\n20: \tmovl\t%eax, %edi\n22: \tcallq\t0x27 <cttest_job_size_max_plus_1+0x27>\n27: \tmovl\t%eax, %ebx\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%eax, %edi\n30: \tcallq\t0x35 <cttest_job_size_max_plus_1+0x35>\n35: \tmovq\t%rsp, %rdi\n38: \tmovl\t$97, %esi\n3d: \tmovl\t$1048576, %edx# imm = 0x100000\n42: \tcallq\t0x47 <cttest_job_size_max_plus_1+0x47>\n47: \tmovb\t$0, 1048576(%rsp)\n4f: \tcmpl\t$0, (%rip)    # 0x56 <cttest_job_size_max_plus_1+0x56>\n56: \tjle\t0x78 <cttest_job_size_max_plus_1+0x78>\n58: \tmovq\t%rsp, %r14\n5b: \tnopl\t(%rax,%rax)\n60: \tmovl\t%ebx, %edi\n62: \tmovq\t%r14, %rsi\n65: \tcallq\t0x6a <cttest_job_size_max_plus_1+0x6a>\n6a: \taddl\t$1048576, %ebp# imm = 0x100000\n70: \tcmpl\t(%rip), %ebp  # 0x76 <cttest_job_size_max_plus_1+0x76>\n76: \tjl\t0x60 <cttest_job_size_max_plus_1+0x60>\n78: \tmovl\t$0, %esi\n7d: \tmovl\t%ebx, %edi\n7f: \tcallq\t0x84 <cttest_job_size_max_plus_1+0x84>\n84: \tmovl\t$0, %esi\n89: \tmovl\t%ebx, %edi\n8b: \tcallq\t0x90 <cttest_job_size_max_plus_1+0x90>\n90: \tmovl\t$0, %esi\n95: \tmovl\t%ebx, %edi\n97: \tcallq\t0x9c <cttest_job_size_max_plus_1+0x9c>\n9c: \taddq\t$1048592, %rsp# imm = 0x100010\na3: \tpopq\t%rbx\na4: \tpopq\t%r14\na6: \tpopq\t%rbp\na7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint JOB_DATA_SIZE_LIMIT_MAX ;\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint job_data_size_limit ;\nint /*<<< orphan*/  memset (char*,char,int const) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_job_size_max_plus_1()\n{\n/* verify that server reject the job larger than maximum allowed. */\njob_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 1073741825\\r\\n\");\n\nconst int len = 1024*1024;\nchar body[len+1];\nmemset(body, 'a', len);\nbody[len] = 0;\n\nint i;\nfor (i=0; i<JOB_DATA_SIZE_LIMIT_MAX; i+=len) {\nmustsend(fd, body);\n}\nmustsend(fd, \"x\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"JOB_TOO_BIG\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_test_end (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_start (char*) ;\nint /*<<< orphan*/  ct_test_subtest (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_end (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_subtest_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_end_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_end_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_start_end (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_test_subtest_"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_ctbench_job_make",
    "input":"\n0000000000000000 <ctbench_job_make>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edi, %r14d\na: \tmovl\t$8, %esi\nf: \tcallq\t0x14 <ctbench_job_make+0x14>\n14: \tmovq\t%rax, %r15\n17: \tmovl\t(%rip), %ebp  # 0x1d <ctbench_job_make+0x1d>\n1d: \tmovl\t$0, %edi\n22: \tcallq\t0x27 <ctbench_job_make+0x27>\n27: \tmovl\t%ebp, %edi\n29: \tmovl\t%eax, %esi\n2b: \tcallq\t0x30 <ctbench_job_make+0x30>\n30: \txorl\t%eax, %eax\n32: \tcallq\t0x37 <ctbench_job_make+0x37>\n37: \ttestl\t%r14d, %r14d\n3a: \tjle\t0xa4 <ctbench_job_make+0xa4>\n3c: \tmovl\t%r14d, %ebp\n3f: \txorl\t%ebx, %ebx\n41: \tnopw\t%cs:(%rax,%rax)\n4b: \tnopl\t(%rax,%rax)\n50: \tmovl\t(%rip), %r8d  # 0x57 <ctbench_job_make+0x57>\n57: \txorl\t%edi, %edi\n59: \txorl\t%esi, %esi\n5b: \tmovl\t$1, %edx\n60: \txorl\t%ecx, %ecx\n62: \tcallq\t0x67 <ctbench_job_make+0x67>\n67: \tmovq\t%rax, (%r15,%rbx,8)\n6b: \taddq\t$1, %rbx\n6f: \tcmpq\t%rbx, %rbp\n72: \tjne\t0x50 <ctbench_job_make+0x50>\n74: \txorl\t%eax, %eax\n76: \tcallq\t0x7b <ctbench_job_make+0x7b>\n7b: \ttestl\t%r14d, %r14d\n7e: \tjle\t0xab <ctbench_job_make+0xab>\n80: \txorl\t%ebx, %ebx\n82: \tnopw\t%cs:(%rax,%rax)\n8c: \tnopl\t(%rax)\n90: \tmovq\t(%r15,%rbx,8), %rdi\n94: \tcallq\t0x99 <ctbench_job_make+0x99>\n99: \taddq\t$1, %rbx\n9d: \tcmpq\t%rbx, %rbp\na0: \tjne\t0x90 <ctbench_job_make+0x90>\na2: \tjmp\t0xab <ctbench_job_make+0xab>\na4: \txorl\t%eax, %eax\na6: \tcallq\t0xab <ctbench_job_make+0xab>\nab: \tmovq\t%r15, %rdi\nae: \taddq\t$8, %rsp\nb2: \tpopq\t%rbx\nb3: \tpopq\t%r14\nb5: \tpopq\t%r15\nb7: \tpopq\t%rbp\nb8: \tjmp\t0xbd <ctbench_job_make+0xbd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ ** calloc (int,int) ;\nint /*<<< orphan*/  ctresettimer () ;\nint /*<<< orphan*/  ctstoptimer () ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ **) ;\nint /*<<< orphan*/  job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_job (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\nctbench_job_make(int n)\n{\nint i;\nJob **j = calloc(n, sizeof *j);\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\n\nctresettimer();\nfor (i = 0; i < n; i++) {\nj[i] = make_job(0, 0, 1, 0, default_tube);\n}\nctstoptimer();\n\nfor (i = 0; i < n; i++) {\njob_free(j[i]);\n}\nfree(j);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ctbench_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_INIT ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_UNSET ;\nint /*<<< orphan*/  ctbench_job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ctbench_job_init (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ctbench_job_set_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len_key (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ctbench_job_set_key_type_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len_key_len (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<"
},
{
    "file:":"./beanstalkd/extr_job.c_job_list_is_empty",
    "input":"\n0000000000000000 <job_list_is_empty>:\n0: \txorl\t%eax, %eax\n2: \tcmpq\t%rdi, 8(%rdi)\n6: \tje\t0x9 <job_list_is_empty+0x9>\n8: \tretq\n9: \txorl\t%eax, %eax\nb: \tcmpq\t%rdi, (%rdi)\ne: \tsete\t%al\n11: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* prev; struct TYPE_3__* next; } ;\ntypedef  TYPE_1__ Job ;\n\n/* Variables and functions */\n\nint\njob_list_is_empty(Job *head)\n{\nreturn head->next == head && head->prev == head;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct job_list {struct job_list* tail; struct job_list* head; } ;\n\n/* Variables and functions */\n\n__attribute__((used)) static inline bool\njob_list_is_empty(struct job_list *list)\n{\nreturn list->head == list->tail;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_touch_not_found",
    "input":"\n0000000000000000 <cttest_touch_not_found>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_touch_not_found+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_touch_not_found+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_touch_not_found+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_touch_not_found+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_touch_not_found+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tpopq\t%rbx\n3d: \tjmp\t0x42 <cttest_touch_not_found+0x42>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_touch_not_found()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"touch 1\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\nmustsend(fd, \"touch 100000000000000\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GFile ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_file_new_for_path (char*) ;\nint /*<<< orphan*/  g_file_touch (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  g_file_trash (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_file_unref (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_add_data_func (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  test_touch_not_found ;\n\nvoid cttest_touch_not_found(void)\n{\nGFile *file;\n\nfile = g_file_new_for_path(\"/tmp/not-found\");\ng_file_touch(file, \"w\");\ng_file_unref(file);\n\ng_test_add_data_func(\"/file/touch/not-found\", &test_touch_not_found,\ng_file_trash);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_rawfalloc",
    "input":"\n0000000000000000 <rawfalloc>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%edi, %r14d\n7: \ttestl\t%esi, %esi\n9: \tjle\t0x2d <rawfalloc+0x2d>\nb: \tmovl\t%esi, %ebp\nd: \txorl\t%ebx, %ebx\nf: \tnop\n10: \tmovl\t$0, %esi\n15: \tmovl\t%r14d, %edi\n18: \tmovl\t$4096, %edx   # imm = 0x1000\n1d: \tcallq\t0x22 <rawfalloc+0x22>\n22: \tcmpl\t$-1, %eax\n25: \tje\t0x3d <rawfalloc+0x3d>\n27: \taddl\t%eax, %ebx\n29: \tcmpl\t%ebp, %ebx\n2b: \tjl\t0x10 <rawfalloc+0x10>\n2d: \txorl\t%ebp, %ebp\n2f: \tmovl\t%r14d, %edi\n32: \txorl\t%esi, %esi\n34: \txorl\t%edx, %edx\n36: \tcallq\t0x3b <rawfalloc+0x3b>\n3b: \tjmp\t0x43 <rawfalloc+0x43>\n3d: \tmovl\t(%rip), %ebp  # 0x43 <rawfalloc+0x43>\n43: \tmovl\t%ebp, %eax\n45: \tpopq\t%rbx\n46: \tpopq\t%r14\n48: \tpopq\t%rbp\n49: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint errno ;\nint /*<<< orphan*/  lseek (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint write (int,char*,int) ;\n\nint\nrawfalloc(int fd, int len)\n{\n// We do not use ftruncate() because it might extend the file\n// with a sequence of null bytes or a hole.\n// posix_fallocate() is not portable enough, might fail for NFS.\nstatic char buf[4096] = {0};\nint i, w;\n\nfor (i = 0; i < len; i += w) {\nw = write(fd, buf, sizeof buf);\nif (w == -1)\nreturn errno;\n}\nlseek(fd, 0, 0);            // do not care if this fails\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ENOMEM ;\nint /*<<< orphan*/  ftruncate (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lseek (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (int,int /*<<< orphan*/ ,int) ;\nint posix_fallocate (int,int /*<<< orphan*/ ,int) ;\n\nint rawfalloc(int fd, int size) {\nint i;\nfor (i = 0; i < size; i += 4096) {\nif (posix_fallocate(fd, i, 4096) == -1) {\nreturn ENOMEM;\n}\n}\nlseek(fd, 0, 0);\nmemset(fd, 0, 0);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_epollq_apply",
    "input":"\n0000000000000000 <epollq_apply>:\n0: \tpushq\t%rbx\n1: \tnopw\t%cs:(%rax,%rax)\nb: \tnopl\t(%rax,%rax)\n10: \tmovq\t(%rip), %rbx  # 0x17 <epollq_apply+0x17>\n17: \ttestq\t%rbx, %rbx\n1a: \tje\t0x53 <epollq_apply+0x53>\n1c: \tmovq\t8(%rbx), %rax\n20: \tmovq\t%rax, (%rip)  # 0x27 <epollq_apply+0x27>\n27: \tmovq\t$0, 8(%rbx)\n2f: \tleaq\t4(%rbx), %rdi\n33: \tmovl\t(%rbx), %esi\n35: \tcallq\t0x3a <epollq_apply+0x3a>\n3a: \tcmpl\t$-1, %eax\n3d: \tjne\t0x10 <epollq_apply+0x10>\n3f: \tmovl\t$0, %edi\n44: \tcallq\t0x49 <epollq_apply+0x49>\n49: \tmovq\t%rbx, %rdi\n4c: \tcallq\t0x51 <epollq_apply+0x51>\n51: \tjmp\t0x10 <epollq_apply+0x10>\n53: \tpopq\t%rbx\n54: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  rw; int /*<<< orphan*/  sock; struct TYPE_4__* next; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  connclose (TYPE_1__*) ;\nTYPE_1__* epollq ;\nint sockwant (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static void\nepollq_apply()\n{\nConn *c;\n\nwhile (epollq) {\nc = epollq;\nepollq = epollq->next;\nc->next = NULL;\nint r = sockwant(&c->sock, c->rw);\nif (r == -1) {\ntwarn(\"sockwant\");\nconnclose(c);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; int /*<<< orphan*/ * next; } ;\ntypedef  TYPE_1__ epollq_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  epoll_ctl (int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free (TYPE_1__*) ;\nint /*<<< orphan*/  perror (char*) ;\nTYPE_1__* q ;\n\nvoid epollq_apply (void) {\nepollq_t *e;\nwhile (q) {\ne = q;\nq = e->next;\ne->next = NULL;\nif (epoll_ctl (0, e->fd, NULL) == -1) {\nperror (\"epoll_ctl\");\nclose (e->fd);\nfree (e);\n}\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_kick_delayed_jobs",
    "input":"\n0000000000000000 <kick_delayed_jobs>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \ttestq\t%rdx, %rdx\nb: \tjle\t0x43 <kick_delayed_jobs+0x43>\nd: \tmovq\t%rdx, %r14\n10: \tmovq\t%rsi, %r15\n13: \tmovq\t%rdi, %r12\n16: \txorl\t%ebx, %ebx\n18: \tnopl\t(%rax,%rax)\n20: \tcmpq\t$0, (%r15)\n24: \tjle\t0x45 <kick_delayed_jobs+0x45>\n26: \tmovq\t8(%r15), %rax\n2a: \tmovq\t(%rax), %rsi\n2d: \tmovq\t%r12, %rdi\n30: \tcallq\t0x35 <kick_delayed_jobs+0x35>\n35: \taddq\t$1, %rbx\n39: \tcmpq\t%rbx, %r14\n3c: \tjne\t0x20 <kick_delayed_jobs+0x20>\n3e: \tmovq\t%r14, %rbx\n41: \tjmp\t0x45 <kick_delayed_jobs+0x45>\n43: \txorl\t%ebx, %ebx\n45: \tmovq\t%rbx, %rax\n48: \taddq\t$8, %rsp\n4c: \tpopq\t%rbx\n4d: \tpopq\t%r12\n4f: \tpopq\t%r14\n51: \tpopq\t%r15\n53: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint ;\nstruct TYPE_4__ {scalar_t__ len; scalar_t__* data; } ;\nstruct TYPE_5__ {TYPE_1__ delay; } ;\ntypedef  TYPE_2__ Tube ;\ntypedef  int /*<<< orphan*/  Server ;\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  kick_delayed_job (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static uint\nkick_delayed_jobs(Server *s, Tube *t, uint n)\n{\nuint i;\nfor (i = 0; (i < n) && (t->delay.len > 0); ++i) {\nkick_delayed_job(s, (Job *)t->delay.data[0]);\n}\nreturn i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  job; } ;\nstruct TYPE_9__ {TYPE_1__* jobs; } ;\nstruct TYPE_8__ {scalar_t__ len; TYPE_3__* items; } ;\ntypedef  TYPE_2__ delayed_jobs_t ;\ntypedef  TYPE_3__ delayed_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  kick_job (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int kick_delayed_jobs (int *job_ids, delayed_jobs_t *delayed_jobs, int n) {\nint i, k = 0;\nfor (i = 0; i < n; i++) {\ndelayed_job_t *job = &delayed_jobs->items[delayed_jobs->len - 1];\nif (job_ids[i] == 0) {\nkick_job (job, job->job);\n}\n}\nreturn k;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_heap.c_siftdown",
    "input":"\n0000000000000000 <siftdown>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \ttestq\t%rsi, %rsi\n8: \tje\t0x40 <siftdown+0x40>\na: \tmovq\t%rsi, %r15\nd: \tmovq\t%rdi, %r14\n10: \tleaq\t-1(%r15), %rbx\n14: \tshrq\t%rbx\n17: \tmovq\t%r14, %rdi\n1a: \tmovq\t%rbx, %rsi\n1d: \tmovq\t%r15, %rdx\n20: \tcallq\t0x25 <siftdown+0x25>\n25: \ttestq\t%rax, %rax\n28: \tjne\t0x40 <siftdown+0x40>\n2a: \tmovq\t%r14, %rdi\n2d: \tmovq\t%r15, %rsi\n30: \tmovq\t%rbx, %rdx\n33: \tcallq\t0x38 <siftdown+0x38>\n38: \tmovq\t%rbx, %r15\n3b: \ttestq\t%rbx, %rbx\n3e: \tjne\t0x10 <siftdown+0x10>\n40: \tpopq\t%rbx\n41: \tpopq\t%r14\n43: \tpopq\t%r15\n45: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Heap ;\n\n/* Variables and functions */\nscalar_t__ less (int /*<<< orphan*/ *,size_t,size_t) ;\nint /*<<< orphan*/  swap (int /*<<< orphan*/ *,size_t,size_t) ;\n\n__attribute__((used)) static void\nsiftdown(Heap *h, size_t k)\n{\nfor (;;) {\nsize_t p = (k-1) / 2; /* parent */\n\nif (k == 0 || less(h, p, k)) {\nreturn;\n}\n\nswap(h, k, p);\nk = p;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ compare (void const*,size_t,size_t) ;\n\n__attribute__((used)) static void\nsiftdown(const void *a, size_t n, size_t i)\n{\nwhile (i > 0)\n{\nsize_t\t\tp = (i - 1) >> 1;\n\nif (compare(a, p, i) >= 0)\nbreak;\nswap(a, i, p);\ni = p;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optminus",
    "input":"\n0000000000000000 <cttest_optminus>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optminus+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovl\t(%rip), %edi  # 0x15 <cttest_optminus+0x15>\n15: \tcallq\t0x1a <cttest_optminus+0x1a>\n1a: \tmovq\t%rsp, %rsi\n1d: \tmovl\t$0, %edi\n22: \tcallq\t0x27 <cttest_optminus+0x27>\n27: \tmovl\t$0, %esi\n2c: \txorl\t%edi, %edi\n2e: \tcallq\t0x33 <cttest_optminus+0x33>\n33: \taddq\t$24, %rsp\n37: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assertf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  atexit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  optparse (int /*<<< orphan*/ *,char**) ;\nint /*<<< orphan*/  srv ;\nint /*<<< orphan*/  success ;\n\nvoid\ncttest_optminus()\n{\nchar *args[] = {\n\"-\",\nNULL,\n};\n\natexit(success);\noptparse(&srv, args);\nassertf(0, \"optparse failed to call exit\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  cmsInt32Number ;\ntypedef  int /*<<< orphan*/  cmsContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  cmsContext (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  cmsSetLogErrorHandler (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER1 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER2 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER3 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER4 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER5 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER6 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER7 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER8 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER9 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER10 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER11 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER12 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER13 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER14 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER15 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER16 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER17 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER18 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER19 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER20 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER21 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER22 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER23 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER24 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER25 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER26 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER27 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER28 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER29 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER30 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER31 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER32 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER33 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER34 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER35 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER36 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER37 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER38 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER39 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER40 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER41 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER42 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER43 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER44 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER45 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER46 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER47 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER48 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER49 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER50 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER51 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER52 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER53 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER54 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER55 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER56 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER57 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER58 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER59 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER60 (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  cmsUNUSED_PARAMETER61 (int"
},
{
    "file:":"./beanstalkd/extr_walg.c_balancerest",
    "input":"\n0000000000000000 <balancerest>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t$1, %r14d\nd: \ttestq\t%rsi, %rsi\n10: \tje\t0x78 <balancerest+0x78>\n12: \tmovq\t%rsi, %rbx\n15: \tmovq\t%rdi, %r15\n18: \tjmp\t0x2d <balancerest+0x2d>\n1a: \tmovq\t%rbx, %rdi\n1d: \tcallq\t0x22 <balancerest+0x22>\n22: \tmovq\t8(%rbx), %rbx\n26: \txorl\t%edx, %edx\n28: \ttestq\t%rbx, %rbx\n2b: \tje\t0x78 <balancerest+0x78>\n2d: \tmovl\t(%rbx), %ebp\n2f: \tsubl\t%edx, %ebp\n31: \tleal\t7(%rbp), %eax\n34: \ttestl\t%ebp, %ebp\n36: \tcmovnsl\t%ebp, %eax\n39: \tandl\t$-8, %eax\n3c: \tsubl\t%eax, %ebp\n3e: \tje\t0x22 <balancerest+0x22>\n40: \tmovl\t$8, %edx\n45: \tsubl\t%ebp, %edx\n47: \tmovq\t(%r15), %rsi\n4a: \tcmpl\t%edx, (%rsi)\n4c: \tjl\t0x53 <balancerest+0x53>\n4e: \tcmpl\t%edx, 4(%rbx)\n51: \tjge\t0x1a <balancerest+0x1a>\n53: \tmovq\t%r15, %rdi\n56: \tmovl\t%ebp, %esi\n58: \tcallq\t0x5d <balancerest+0x5d>\n5d: \tcmpl\t%ebp, %eax\n5f: \tjne\t0x6b <balancerest+0x6b>\n61: \tmovq\t(%r15), %rdi\n64: \tmovq\t%rbx, %rsi\n67: \tmovl\t%ebp, %edx\n69: \tjmp\t0x1d <balancerest+0x1d>\n6b: \tmovl\t$0, %edi\n70: \tcallq\t0x75 <balancerest+0x75>\n75: \txorl\t%r14d, %r14d\n78: \tmovl\t%r14d, %eax\n7b: \taddq\t$8, %rsp\n7f: \tpopq\t%rbx\n80: \tpopq\t%r14\n82: \tpopq\t%r15\n84: \tpopq\t%rbp\n85: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {TYPE_2__* tail; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_9__ {int resv; int free; struct TYPE_9__* next; } ;\ntypedef  int /*<<< orphan*/  Jobrec ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  moveresv (TYPE_2__*,TYPE_2__*,int) ;\nint needfree (TYPE_1__*,int) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\n__attribute__((used)) static int\nbalancerest(Wal *w, File *b, int n)\n{\nint rest, c, r;\nstatic const int z = sizeof(int) + sizeof(Jobrec);\n\nif (!b) return 1;\n\nrest = b->resv - n;\nr = rest % z;\nif (r == 0) return balancerest(w, b->next, 0);\n\nc = z - r;\nif (w->tail->resv >= c && b->free >= c) {\nmoveresv(b, w->tail, c);\nreturn balancerest(w, b->next, 0);\n}\n\nif (needfree(w, r) != r) {\ntwarnx(\"needfree\");\nreturn 0;\n}\nmoveresv(w->tail, b, r);\nreturn balancerest(w, b->next, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int n; int* a; } ;\ntypedef  TYPE_1__* Huffman ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint huffmanbalance (TYPE_1__*,TYPE_1__*,int) ;\nint huffmanbalance2 (TYPE_1__*,TYPE_1__*,int) ;\n\n__attribute__((used)) static int balancerest(Huffman *h, Huffman *h2)\n{\nint i, n;\n\nwhile (h2) {\nn = h2->n;\nfor (i = 0; i < n; i++)\nif (h->n < 8)\nbreak;\nif (i == n) {\nif (huffmanbalance(h, h2, n) != n) {\nfprintf(stderr, \"huffmanbalance failed\\n\");\nreturn 0;\n}\n} else {\nif (huffmanbalance2(h, h2, i) != i) {\nfprintf(stderr, \"huffmanbalance2 failed\\n\");\nreturn 0;\n}\n}\nh2 = h2->a[0];\n}\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_large_pris",
    "input":"\n0000000000000000 <cttest_job_large_pris>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %ebx  # 0x7 <cttest_job_large_pris+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <cttest_job_large_pris+0x11>\n11: \tmovl\t%ebx, %edi\n13: \tmovl\t%eax, %esi\n15: \tcallq\t0x1a <cttest_job_large_pris+0x1a>\n1a: \tmovl\t(%rip), %r8d  # 0x21 <cttest_job_large_pris+0x21>\n21: \tmovl\t$1, %edi\n26: \txorl\t%esi, %esi\n28: \tmovl\t$1, %edx\n2d: \txorl\t%ecx, %ecx\n2f: \tcallq\t0x34 <cttest_job_large_pris+0x34>\n34: \tmovq\t%rax, %rbx\n37: \tmovl\t(%rip), %r8d  # 0x3e <cttest_job_large_pris+0x3e>\n3e: \tmovl\t$4294967291, %edi  # imm = 0xFFFFFFFB\n43: \txorl\t%esi, %esi\n45: \tmovl\t$1, %edx\n4a: \txorl\t%ecx, %ecx\n4c: \tcallq\t0x51 <cttest_job_large_pris+0x51>\n51: \tmovq\t%rbx, %rdi\n54: \tmovq\t%rax, %rsi\n57: \tcallq\t0x5c <cttest_job_large_pris+0x5c>\n5c: \tmovl\t$0, %esi\n61: \tmovl\t%eax, %edi\n63: \tcallq\t0x68 <cttest_job_large_pris+0x68>\n68: \tmovl\t(%rip), %r8d  # 0x6f <cttest_job_large_pris+0x6f>\n6f: \tmovl\t$4294967291, %edi  # imm = 0xFFFFFFFB\n74: \txorl\t%esi, %esi\n76: \tmovl\t$1, %edx\n7b: \txorl\t%ecx, %ecx\n7d: \tcallq\t0x82 <cttest_job_large_pris+0x82>\n82: \tmovq\t%rax, %rbx\n85: \tmovl\t(%rip), %r8d  # 0x8c <cttest_job_large_pris+0x8c>\n8c: \tmovl\t$1, %edi\n91: \txorl\t%esi, %esi\n93: \tmovl\t$1, %edx\n98: \txorl\t%ecx, %ecx\n9a: \tcallq\t0x9f <cttest_job_large_pris+0x9f>\n9f: \tmovq\t%rbx, %rdi\na2: \tmovq\t%rax, %rsi\na5: \tcallq\t0xaa <cttest_job_large_pris+0xaa>\naa: \txorl\t%edi, %edi\nac: \ttestl\t%eax, %eax\nae: \tsete\t%dil\nb2: \tmovl\t$0, %esi\nb7: \tpopq\t%rbx\nb8: \tjmp\t0xbd <cttest_job_large_pris+0xbd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  default_tube ;\nint job_pri_less (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_job (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_large_pris()\n{\nJob *a, *b;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\na = make_job(1, 0, 1, 0, default_tube);\nb = make_job(-5, 0, 1, 0, default_tube);\n\nassertf(job_pri_less(a, b), \"should be less\");\n\na = make_job(-5, 0, 1, 0, default_tube);\nb = make_job(1, 0, 1, 0, default_tube);\n\nassertf(!job_pri_less(a, b), \"should not be less\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\ntypedef  int /*<<< orphan*/  ct_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CT_TEST_JOB_LARGE_PRIS ;\nint /*<<< orphan*/  TEST_ASSERT (int,char*) ;\nint /*<<< orphan*/  ct_job_add_test (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_job_new (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_new (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_run (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_set_name (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  ct_test_set_pris (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  pris_large ;\n\n__attribute__((used)) static void cttest_job_large_pris(void) {\nct_job_t *job = ct_job_new(1, 0, 1, 0);\nct_test_t *test = ct_test_new(CT_TEST_JOB_LARGE_PRIS, 0, 1, 0);\nct_test_set_name(test, \"large_pris\");\nct_test_set_pris(test, &pris_large);\nct_job_add_test(job, test, 1, 1, CT_TEST_JOB_LARGE_PRIS);\nct_test_run(job);\nTEST_ASSERT(0 == ct_test_run(job), \"large_pris\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_negative_priority",
    "input":"\n0000000000000000 <cttest_negative_priority>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_negative_priority+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_negative_priority+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_negative_priority+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_negative_priority+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_negative_priority+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_negative_priority()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put -1 0 100 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_cipher_list (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  SSL_CTX_set_max_proto_version (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_min_proto_version (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_priority_string (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TLS1_2_VERSION ;\nint /*<<< orphan*/  TLS1_3_VERSION ;\n\n__attribute__((used)) static void cttest_negative_priority(void)\n{\nSSL_CTX *ctx = SSL_CTX_new(TLS_method());\n\nSSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\nSSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION);\n\nSSL_CTX_set_priority_string(ctx, \"ALL:!aNULL:!eNULL:!LOW:!EXP:!MD5:@STRENGTH\");\nSSL_CTX_set_cipher_list(ctx, \"ALL:!aNULL:!eNULL:!LOW:!EXP:!MD5:@STRENGTH\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_allocf",
    "input":"\n0000000000000000 <cttest_allocf>:\n0: \tpushq\t%rbx\n1: \tmovl\t$0, %edi\n6: \tmovl\t$0, %esi\nb: \tmovl\t$5, %edx\n10: \tcallq\t0x15 <cttest_allocf+0x15>\n15: \tmovq\t%rax, %rbx\n18: \tmovl\t$0, %edi\n1d: \tmovq\t%rax, %rsi\n20: \tcallq\t0x25 <cttest_allocf+0x25>\n25: \txorl\t%edi, %edi\n27: \ttestq\t%rax, %rax\n2a: \tsete\t%dil\n2e: \tmovl\t$0, %esi\n33: \tmovq\t%rbx, %rdx\n36: \tcallq\t0x3b <cttest_allocf+0x3b>\n3b: \tmovq\t%rbx, %rdi\n3e: \tpopq\t%rbx\n3f: \tjmp\t0x44 <cttest_allocf+0x44>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assertf (int,char*,char*) ;\nchar* fmtalloc (char*,char*,int) ;\nint /*<<< orphan*/  free (char*) ;\nscalar_t__ strcmp (char*,char*) ;\n\nvoid\ncttest_allocf()\n{\nchar *got;\n\ngot = fmtalloc(\"hello, %s %d\", \"world\", 5);\nassertf(strcmp(\"hello, world 5\", got) == 0, \"got \\\"%s\\\"\", got);\nfree(got);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * TEST_ptr_null (char*,char*,int) ;\nint /*<<< orphan*/  TEST_str_eq (char*,char*,char*) ;\n\n__attribute__((used)) static ct_test_t *cttest_allocf(void)\n{\nchar *test_name = \"cttest_allocf\";\nchar *test_desc = \"allocf()\";\n\nct_test_t *test = TEST_ptr_null(test_name, test_desc, 5);\n\nTEST_ptr(test);\nTEST_str_eq(test_name, test_desc, test_name);\n\nreturn test;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_heap.c_less",
    "input":"\n0000000000000000 <less>:\n0: \tmovq\t(%rdi), %rax\n3: \tmovq\t8(%rdi), %rcx\n7: \tmovl\t(%rcx,%rsi,4), %edi\na: \tmovl\t(%rcx,%rdx,4), %esi\nd: \tjmpq\t*%rax",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int (* less ) (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nint stub1 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nless(Heap *h, size_t a, size_t b)\n{\nreturn h->less(h->data[a], h->data[b]);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int (* compare ) (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;} ;\ntypedef  TYPE_1__ GCompareFunc ;\ntypedef  int /*<<< orphan*/  gpointer ;\n\n/* Variables and functions */\nint stub1 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nless (gconstpointer a, gconstpointer b, gpointer user_data)\n{\nGCompareFunc *compare = (GCompareFunc *) user_data;\nreturn compare[0] (compare[1] (a, b), compare[2] (a, b));\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_exit_process",
    "input":"\n0000000000000000 <exit_process>:\n0: \tpushq\t%rax\n1: \tcallq\t0x6 <exit_process+0x6>\n6: \txorl\t%edi, %edi\n8: \tcallq\t0xd <exit_process+0xd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  UNUSED_PARAMETER (int) ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nexit_process(int signum)\n{\nUNUSED_PARAMETER(signum);\nexit(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ExitProcess (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  flush_buffers () ;\n\nvoid exit_process(void)\n{\nflush_buffers();\nExitProcess(0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_get_delayed_job_ct",
    "input":"\n0000000000000000 <get_delayed_job_ct>:\n0: \tmovq\t(%rip), %r9   # 0x7 <get_delayed_job_ct+0x7>\n7: \ttestq\t%r9, %r9\na: \tje\t0x2a <get_delayed_job_ct+0x2a>\nc: \tmovq\t(%rip), %rdx  # 0x13 <get_delayed_job_ct+0x13>\n13: \tleaq\t-1(%r9), %rax\n17: \tmovl\t%r9d, %r8d\n1a: \tandl\t$3, %r8d\n1e: \tcmpq\t$3, %rax\n22: \tjae\t0x2d <get_delayed_job_ct+0x2d>\n24: \txorl\t%edi, %edi\n26: \txorl\t%eax, %eax\n28: \tjmp\t0x64 <get_delayed_job_ct+0x64>\n2a: \txorl\t%eax, %eax\n2c: \tretq\n2d: \tsubq\t%r8, %r9\n30: \txorl\t%edi, %edi\n32: \txorl\t%eax, %eax\n34: \tnopw\t%cs:(%rax,%rax)\n3e: \tnop\n40: \tmovq\t(%rdx,%rdi,8), %rcx\n44: \tmovq\t8(%rdx,%rdi,8), %rsi\n49: \taddl\t(%rcx), %eax\n4b: \taddl\t(%rsi), %eax\n4d: \tmovq\t16(%rdx,%rdi,8), %rcx\n52: \taddl\t(%rcx), %eax\n54: \tmovq\t24(%rdx,%rdi,8), %rcx\n59: \taddl\t(%rcx), %eax\n5b: \taddq\t$4, %rdi\n5f: \tcmpq\t%rdi, %r9\n62: \tjne\t0x40 <get_delayed_job_ct+0x40>\n64: \ttestq\t%r8, %r8\n67: \tje\t0x7f <get_delayed_job_ct+0x7f>\n69: \tleaq\t(%rdx,%rdi,8), %rdx\n6d: \txorl\t%esi, %esi\n6f: \tnop\n70: \tmovq\t(%rdx,%rsi,8), %rcx\n74: \taddl\t(%rcx), %eax\n76: \taddq\t$1, %rsi\n7a: \tcmpq\t%rsi, %r8\n7d: \tjne\t0x70 <get_delayed_job_ct+0x70>\n7f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_3__ ;\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint ;\nstruct TYPE_4__ {scalar_t__ len; } ;\nstruct TYPE_5__ {TYPE_1__ delay; } ;\ntypedef  TYPE_2__ Tube ;\nstruct TYPE_6__ {size_t len; TYPE_2__** items; } ;\n\n/* Variables and functions */\nTYPE_3__ tubes ;\n\n__attribute__((used)) static uint\nget_delayed_job_ct()\n{\nsize_t i;\nuint count = 0;\n\nfor (i = 0; i < tubes.len; i++) {\nTube *t = tubes.items[i];\ncount += t->delay.len;\n}\nreturn count;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  ct; } ;\n\n/* Variables and functions */\nTYPE_1__* delayed_jobs ;\nsize_t delayed_jobs_ct ;\n\nint get_delayed_job_ct (void) {\nsize_t i;\nint ct = 0;\n\nif (!delayed_jobs_ct) {\nreturn 0;\n}\n\nfor (i = 0; i < delayed_jobs_ct - 1; i++) {\nct += delayed_jobs[i].ct;\nct += delayed_jobs[i + 1].ct;\nct += delayed_jobs[i + 2].ct;\nct += delayed_jobs[i + 3].ct;\n}\n\nfor (i = 0; i < delayed_jobs_ct % 4; i++) {\nct += delayed_jobs[delayed_jobs_ct - 1 - i].ct;\n}\n\nreturn ct;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_delete_ready",
    "input":"\n0000000000000000 <cttest_delete_ready>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_delete_ready+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_delete_ready+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_delete_ready+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_delete_ready+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_delete_ready+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_delete_ready+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tpopq\t%rbx\n49: \tjmp\t0x4e <cttest_delete_ready+0x4e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_delete_ready()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"delete 1\\r\\n\");\nckresp(fd, \"DELETED\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HANDLE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CloseHandle (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CreateEvent (int /*<<< orphan*/ *,int,int,char*) ;\nint /*<<< orphan*/  DeleteFile (char*) ;\nint /*<<< orphan*/  GetCurrentProcess () ;\nint /*<<< orphan*/  SetEvent (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  WaitForSingleObject (int /*<<< orphan*/ ,int) ;\n\n__attribute__((used)) static void cttest_delete_ready(void)\n{\nHANDLE event;\n\nevent = CreateEvent(NULL, 0, 0, \"test_delete_ready\");\nSetEvent(event);\nWaitForSingleObject(event, 1000);\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDeleteFile(\"test_delete_ready\");\nDelete"
},
{
    "file:":"./beanstalkd/extr_testserv.c_mustdiallocal",
    "input":"\n0000000000000000 <mustdiallocal>:\n0: \tpushq\t%rbx\n1: \tsubq\t$32, %rsp\n5: \tmovl\t$0, 16(%rsp)\nd: \tcallq\t0x12 <mustdiallocal+0x12>\n12: \tmovl\t%eax, 20(%rsp)\n16: \tmovl\t(%rip), %eax  # 0x1c <mustdiallocal+0x1c>\n1c: \tmovl\t%eax, 24(%rsp)\n20: \tleaq\t16(%rsp), %rsi\n25: \tmovl\t$0, %edi\n2a: \tcallq\t0x2f <mustdiallocal+0x2f>\n2f: \ttestl\t%eax, %eax\n31: \tje\t0x96 <mustdiallocal+0x96>\n33: \tmovl\t(%rip), %edi  # 0x39 <mustdiallocal+0x39>\n39: \tmovl\t(%rip), %esi  # 0x3f <mustdiallocal+0x3f>\n3f: \txorl\t%edx, %edx\n41: \tcallq\t0x46 <mustdiallocal+0x46>\n46: \tcmpl\t$-1, %eax\n49: \tje\t0xa9 <mustdiallocal+0xa9>\n4b: \tmovl\t%eax, %ebx\n4d: \tmovl\t$1, 12(%rsp)\n55: \tmovl\t(%rip), %esi  # 0x5b <mustdiallocal+0x5b>\n5b: \tmovl\t(%rip), %edx  # 0x61 <mustdiallocal+0x61>\n61: \tleaq\t12(%rsp), %rcx\n66: \tmovl\t%eax, %edi\n68: \tmovl\t$4, %r8d\n6e: \tcallq\t0x73 <mustdiallocal+0x73>\n73: \ttestq\t%rax, %rax\n76: \tjne\t0xb0 <mustdiallocal+0xb0>\n78: \tleaq\t16(%rsp), %rsi\n7d: \tmovl\t%ebx, %edi\n7f: \tmovl\t$12, %edx\n84: \tcallq\t0x89 <mustdiallocal+0x89>\n89: \tcmpl\t$-1, %eax\n8c: \tje\t0xc8 <mustdiallocal+0xc8>\n8e: \tmovl\t%ebx, %eax\n90: \taddq\t$32, %rsp\n94: \tpopq\t%rbx\n95: \tretq\n96: \tmovl\t(%rip), %eax  # 0x9c <mustdiallocal+0x9c>\n9c: \tmovl\t%eax, (%rip)  # 0xa2 <mustdiallocal+0xa2>\na2: \tmovl\t$0, %edi\na7: \tjmp\t0xcd <mustdiallocal+0xcd>\na9: \tmovl\t$0, %edi\nae: \tjmp\t0xcd <mustdiallocal+0xcd>\nb0: \tmovl\t$0, %edi\nb5: \tmovl\t%ebx, %esi\nb7: \txorl\t%eax, %eax\nb9: \tcallq\t0xbe <mustdiallocal+0xbe>\nbe: \tmovl\t$1, %edi\nc3: \tcallq\t0xc8 <mustdiallocal+0xc8>\nc8: \tmovl\t$0, %edi\ncd: \txorl\t%eax, %eax\ncf: \tcallq\t0xd4 <mustdiallocal+0xd4>\nd4: \tmovl\t$1, %edi\nd9: \tcallq\t0xde <mustdiallocal+0xde>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_in {int /*<<< orphan*/  sin_addr; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; } ;\nstruct sockaddr {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint /*<<< orphan*/  EINVAL ;\nint /*<<< orphan*/  IPPROTO_TCP ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint /*<<< orphan*/  TCP_NODELAY ;\nint connect (int,struct sockaddr*,int) ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  htons (int) ;\nint inet_aton (char*,int /*<<< orphan*/ *) ;\nscalar_t__ setsockopt (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*,int) ;\nint socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  twarn (char*,...) ;\n\n__attribute__((used)) static int\nmustdiallocal(int port)\n{\nstruct sockaddr_in addr = {\n.sin_family = AF_INET,\n.sin_port = htons(port),\n};\n\nint r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\nif (!r) {\nerrno = EINVAL;\ntwarn(\"inet_aton\");\nexit(1);\n}\n\nint fd = socket(AF_INET, SOCK_STREAM, 0);\nif (fd == -1) {\ntwarn(\"socket\");\nexit(1);\n}\n\n// Fix of the benchmarking issue on Linux. See issue #430.\nint flags = 1;\nif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof(int))) {\ntwarn(\"setting TCP_NODELAY on fd %d\", fd);\nexit(1);\n}\n\nr = connect(fd, (struct sockaddr *)&addr, sizeof addr);\nif (r == -1) {\ntwarn(\"connect\");\nexit(1);\n}\n\nreturn fd;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_un {int dummy; } ;\nstruct sockaddr {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_ll {int dummy; } ;\nstruct sockaddr_at {int dummy; } ;\nstruct sockaddr_ax25 {int dummy; } ;\nstruct sockaddr_ipx {int dummy; } ;\nstruct sockaddr_netlink {int dummy; } ;\nstruct sockaddr_tipc {int dummy; } ;\nstruct sockaddr_x25 {int dummy; } ;\nstruct sockaddr_llc {int dummy; } ;\nstruct sockaddr_ppp {int dummy; } ;\nstruct sockaddr_pkt {int dummy; } ;\nstruct sockaddr_hci {int dummy; } ;\nstruct sockaddr_l2 {int dummy; } ;\nstruct sockaddr_ec {int dummy; } ;\nstruct sockaddr_rose {int dummy; } ;\nstruct sockaddr_arc {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_dl {int dummy; } ;\nstruct sockaddr_"
},
{
    "file:":"./beanstalkd/extr_prot.c_enqueue_waiting_conn",
    "input":"\n0000000000000000 <enqueue_waiting_conn>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %eax  # 0xa <enqueue_waiting_conn+0xa>\na: \torl\t%eax, 16(%rdi)\nd: \taddl\t$1, (%rip)    # 0x14 <enqueue_waiting_conn+0x14>\n14: \tcmpq\t$0, (%rdi)\n18: \tje\t0x3d <enqueue_waiting_conn+0x3d>\n1a: \tmovq\t%rdi, %r14\n1d: \txorl\t%ebx, %ebx\n1f: \tnop\n20: \tmovq\t8(%r14), %rax\n24: \tmovq\t(%rax,%rbx,8), %rdi\n28: \taddl\t$1, 4(%rdi)\n2c: \tmovq\t%r14, %rsi\n2f: \tcallq\t0x34 <enqueue_waiting_conn+0x34>\n34: \taddq\t$1, %rbx\n38: \tcmpq\t(%r14), %rbx\n3b: \tjb\t0x20 <enqueue_waiting_conn+0x20>\n3d: \taddq\t$8, %rsp\n41: \tpopq\t%rbx\n42: \tpopq\t%r14\n44: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_6__ ;\ntypedef  struct TYPE_11__   TYPE_4__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  waiting_ct; } ;\nstruct TYPE_10__ {int /*<<< orphan*/  waiting_conns; TYPE_2__ stat; } ;\ntypedef  TYPE_3__ Tube ;\nstruct TYPE_12__ {int /*<<< orphan*/  waiting_ct; } ;\nstruct TYPE_8__ {size_t len; TYPE_3__** items; } ;\nstruct TYPE_11__ {TYPE_1__ watch; int /*<<< orphan*/  type; } ;\ntypedef  TYPE_4__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CONN_TYPE_WAITING ;\nTYPE_6__ global_stat ;\nint /*<<< orphan*/  ms_append (int /*<<< orphan*/ *,TYPE_4__*) ;\n\n__attribute__((used)) static void\nenqueue_waiting_conn(Conn *c)\n{\nc->type |= CONN_TYPE_WAITING;\nglobal_stat.waiting_ct++;\nsize_t i;\nfor (i = 0; i < c->watch.len; i++) {\nTube *t = c->watch.items[i];\nt->stat.waiting_ct++;\nms_append(&t->waiting_conns, c);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  waiting_conn_count; int /*<<< orphan*/  waiting_conn_count_lock; } ;\nstruct TYPE_4__ {int /*<<< orphan*/  waiting_conn_count; } ;\ntypedef  TYPE_1__ PGconn ;\ntypedef  TYPE_2__ PGconnShared ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PG_WAITING ;\nint /*<<< orphan*/  pq_enqueue_waiting_conn (TYPE_1__*,TYPE_2__*) ;\nTYPE_2__* shared_connections ;\n\n__attribute__((used)) static void\nenqueue_waiting_conn(PGconn *conn)\n{\nPGconnShared *conns = shared_connections;\nint\t\t\ti;\n\n/*\n* We don't need to hold the lock here, because we're only modifying the\n* PGconn's state.\n*/\nconn->statusFlags |= PG_WAITING;\n\n/*\n* Increment the count of waiting connections for each shared connection.\n* We don't need to hold the lock here, because we're only modifying the\n* PGconnShared's state.\n*/\nfor (i = 0; i < conns->num_connections; i++)\n{\nconns->connections[i]->waiting_conn_count++;\n}\n\n/*\n* Enqueue the connection.\n*/\npq_enqueue_waiting_conn(conn, conns);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_moveresv",
    "input":"\n0000000000000000 <moveresv>:\n0: \tsubl\t%edx, (%rsi)\n2: \taddl\t%edx, 4(%rsi)\n5: \taddl\t%edx, (%rdi)\n7: \tsubl\t%edx, 4(%rdi)\na: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int resv; int free; } ;\ntypedef  TYPE_1__ File ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void\nmoveresv(File *to, File *from, int n)\n{\nfrom->resv -= n;\nfrom->free += n;\nto->resv += n;\nto->free -= n;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  rsv; int /*<<< orphan*/  rsv_size; } ;\ntypedef  TYPE_1__ GLog ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void moveresv(GLog *a, GLog *b, int n)\n{\na->rsv_size -= n;\nb->rsv_size += n;\nb->rsv += n;\na->rsv_size += n;\na->rsv -= n;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_read_u64",
    "input":"\n0000000000000000 <read_u64>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdx, %r15\na: \tmovq\t%rsi, %rbx\nd: \tmovq\t%rdi, %r14\n10: \tmovq\t$0, (%rip)    # 0x1b <read_u64+0x1b>\n1b: \taddq\t$-1, %rbx\n1f: \tnop\n20: \tmovzbl\t1(%rbx), %eax\n24: \taddq\t$1, %rbx\n28: \tcmpb\t$32, %al\n2a: \tje\t0x20 <read_u64+0x20>\n2c: \taddb\t$-48, %al\n2e: \tmovl\t$4294967295, %ebp  # imm = 0xFFFFFFFF\n33: \tcmpb\t$9, %al\n35: \tjbe\t0x44 <read_u64+0x44>\n37: \tmovl\t%ebp, %eax\n39: \taddq\t$8, %rsp\n3d: \tpopq\t%rbx\n3e: \tpopq\t%r14\n40: \tpopq\t%r15\n42: \tpopq\t%rbp\n43: \tretq\n44: \tmovq\t%rsp, %rsi\n47: \tmovq\t%rbx, %rdi\n4a: \tmovl\t$10, %edx\n4f: \tcallq\t0x54 <read_u64+0x54>\n54: \tmovq\t(%rsp), %rcx\n58: \tcmpq\t%rbx, %rcx\n5b: \tje\t0x37 <read_u64+0x37>\n5d: \tcmpq\t$0, (%rip)    # 0x65 <read_u64+0x65>\n65: \tjne\t0x37 <read_u64+0x37>\n67: \ttestq\t%r15, %r15\n6a: \tje\t0x89 <read_u64+0x89>\n6c: \tcmpq\t(%rip), %rax  # 0x73 <read_u64+0x73>\n73: \tjg\t0x37 <read_u64+0x37>\n75: \ttestq\t%r14, %r14\n78: \tje\t0x7d <read_u64+0x7d>\n7a: \tmovq\t%rax, (%r14)\n7d: \txorl\t%ebp, %ebp\n7f: \ttestq\t%r15, %r15\n82: \tje\t0x37 <read_u64+0x37>\n84: \tmovq\t%rcx, (%r15)\n87: \tjmp\t0x37 <read_u64+0x37>\n89: \tcmpb\t$0, (%rcx)\n8c: \tjne\t0x37 <read_u64+0x37>\n8e: \tjmp\t0x6c <read_u64+0x6c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uintmax_t ;\ntypedef  scalar_t__ uint64 ;\n\n/* Variables and functions */\nscalar_t__ UINT64_MAX ;\nscalar_t__ errno ;\nscalar_t__ strtoumax (char const*,char**,int) ;\n\n__attribute__((used)) static int\nread_u64(uint64 *num, const char *buf, char **end)\n{\nuintmax_t tnum;\nchar *tend;\n\nerrno = 0;\nwhile (buf[0] == ' ')\nbuf++;\nif (buf[0] < '0' || '9' < buf[0])\nreturn -1;\ntnum = strtoumax(buf, &tend, 10);\nif (tend == buf)\nreturn -1;\nif (errno)\nreturn -1;\nif (!end && tend[0] != '\\0')\nreturn -1;\nif (tnum > UINT64_MAX)\nreturn -1;\n\nif (num) *num = (uint64)tnum;\nif (end) *end = tend;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\ntypedef  scalar_t__ uint32_t ;\n\n/* Variables and functions */\nscalar_t__ UINT64_MAX ;\nint /*<<< orphan*/  sscanf (char const*,char*,scalar_t__*) ;\n\n__attribute__((used)) static int read_u64(const char *str, size_t len, uint64_t *val)\n{\nuint64_t ret = 0;\nchar *end;\n\nwhile (len > 0 && *str == ' ') {\nstr++;\nlen--;\n}\nif (len == 0 || *str == '\\0')\nreturn -1;\nif (*str == '-')\nreturn -1;\nif (*str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 10 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 + *str - '0';\nif (ret > UINT64_MAX)\nreturn -1;\nstr++;\nlen--;\n}\nif (len > 0 && *str == 'x') {\nstr++;\nlen--;\n}\nif (len > 0 && *str == '0' && len > 1 && str[1] == 'x') {\nstr += 2;\nlen -= 2;\n}\nwhile (len > 0 && *str >= '0' && *str <= '9') {\nret = ret * 16 +"
},
{
    "file:":"./beanstalkd/extr_serv.c_srv_acquire_wal",
    "input":"\n0000000000000000 <srv_acquire_wal>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tsubq\t$24, %rsp\n7: \tcmpq\t$0, 8(%rdi)\nc: \tje\t0x43 <srv_acquire_wal+0x43>\ne: \tmovq\t%rdi, %rbx\n11: \tcallq\t0x16 <srv_acquire_wal+0x16>\n16: \ttestl\t%eax, %eax\n18: \tje\t0x4b <srv_acquire_wal+0x4b>\n1a: \tleaq\t8(%rsp), %r14\n1f: \tmovq\t%r14, 8(%rsp)\n24: \tmovq\t%r14, 16(%rsp)\n29: \tmovq\t%rbx, %rdi\n2c: \tmovq\t%r14, %rsi\n2f: \tcallq\t0x34 <srv_acquire_wal+0x34>\n34: \tmovq\t%rbx, %rdi\n37: \tmovq\t%r14, %rsi\n3a: \tcallq\t0x3f <srv_acquire_wal+0x3f>\n3f: \ttestl\t%eax, %eax\n41: \tje\t0x63 <srv_acquire_wal+0x63>\n43: \taddq\t$24, %rsp\n47: \tpopq\t%rbx\n48: \tpopq\t%r14\n4a: \tretq\n4b: \tmovl\t(%rbx), %esi\n4d: \tmovl\t$0, %edi\n52: \txorl\t%eax, %eax\n54: \tcallq\t0x59 <srv_acquire_wal+0x59>\n59: \tmovl\t$10, %edi\n5e: \tcallq\t0x63 <srv_acquire_wal+0x63>\n63: \tmovl\t$0, %edi\n68: \txorl\t%eax, %eax\n6a: \tcallq\t0x6f <srv_acquire_wal+0x6f>\n6f: \tmovl\t$1, %edi\n74: \tcallq\t0x79 <srv_acquire_wal+0x79>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {int /*<<< orphan*/  dir; scalar_t__ use; } ;\nstruct TYPE_10__ {struct TYPE_10__* next; struct TYPE_10__* prev; } ;\nstruct TYPE_9__ {TYPE_3__ wal; } ;\ntypedef  TYPE_1__ Server ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint prot_replay (TYPE_1__*,TYPE_2__*) ;\nint /*<<< orphan*/  twarnx (char*,...) ;\nint /*<<< orphan*/  waldirlock (TYPE_3__*) ;\nint /*<<< orphan*/  walinit (TYPE_3__*,TYPE_2__*) ;\n\nvoid srv_acquire_wal(Server *s) {\nif (s->wal.use) {\n// We want to make sure that only one beanstalkd tries\n// to use the wal directory at a time. So acquire a lock\n// now and never release it.\nif (!waldirlock(&s->wal)) {\ntwarnx(\"failed to lock wal dir %s\", s->wal.dir);\nexit(10);\n}\n\nJob list = {.prev=NULL, .next=NULL};\nlist.prev = list.next = &list;\nwalinit(&s->wal, &list);\nint ok = prot_replay(s, &list);\nif (!ok) {\ntwarnx(\"failed to replay log\");\nexit(1);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  id; scalar_t__ wal_enabled; } ;\ntypedef  TYPE_1__ srv_t ;\ntypedef  int /*<<< orphan*/  lua_State ;\ntypedef  int /*<<< orphan*/  lua_Integer ;\ntypedef  int /*<<< orphan*/  lua_Number ;\n\n/* Variables and functions */\nint /*<<< orphan*/  luaL_error (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  lua_pushinteger (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_pushnil (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  lua_pushnumber (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_pushstring (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  lua_settable (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_tointeger (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_tonumber (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_touserdata (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_type (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  lua_yield (int /*<<< orphan*/ *,int) ;\nint /*<<< orphan*/  srv_wal_get_info (TYPE_1__*,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  srv_wal_get_status (TYPE_1__*,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\nsrv_acquire_wal (srv_t *srv) {\nlua_State *L = srv->L;\n\nif (!srv->wal_enabled) {\nluaL_error(L, \"wal is not enabled\");\n}\n\nlua_pushinteger(L, srv->id);\n\nif (lua_type(L, -1) != LUA_TNUMBER) {\nluaL_error(L, \"invalid server id\");\n}\n\nlua_pushstring(L, \"status\");\nlua_pushnil(L);\nlua_settable(L, -3);\n\nlua_pushstring(L, \"info\");\nlua_pushnil(L);\nlua_settable(L, -3);\n\nlua_settop(L, 1);\n\nif (!srv_wal_get_status(srv, L, 1) || !srv_wal_get_info(srv, L, 1)) {\nluaL_error(L, \"failed to acquire wal\");\n}\n\nlua_yield(L, 1);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_tube.c_tube_find_or_make",
    "input":"\n0000000000000000 <tube_find_or_make>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <tube_find_or_make+0x9>\n9: \ttestq\t%rax, %rax\nc: \tje\t0x10 <tube_find_or_make+0x10>\ne: \tpopq\t%rbx\nf: \tretq\n10: \tmovq\t%rbx, %rdi\n13: \tpopq\t%rbx\n14: \tjmp\t0x19 <tube_find_or_make+0x19>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * make_and_insert_tube (char const*) ;\nint /*<<< orphan*/ * tube_find (char const*) ;\n\nTube *\ntube_find_or_make(const char *name)\n{\nTube *t = tube_find(name);\nif (t)\nreturn t;\nreturn make_and_insert_tube(name);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct tube {int dummy; } ;\n\n/* Variables and functions */\nstruct tube* tube_find (char const*) ;\nstruct tube* tube_make (char const*) ;\n\nstruct tube *tube_find_or_make(const char *name) {\nstruct tube *tube = tube_find(name);\nif (tube) {\nreturn tube;\n}\nreturn tube_make(name);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_tube.c_make_and_insert_tube",
    "input":"\n0000000000000000 <make_and_insert_tube>:\n0: \tpushq\t%rbx\n1: \tcallq\t0x6 <make_and_insert_tube+0x6>\n6: \ttestq\t%rax, %rax\n9: \tje\t0x27 <make_and_insert_tube+0x27>\nb: \tmovq\t%rax, %rbx\ne: \tmovl\t$0, %edi\n13: \tmovq\t%rax, %rsi\n16: \tcallq\t0x1b <make_and_insert_tube+0x1b>\n1b: \ttestl\t%eax, %eax\n1d: \tjne\t0x29 <make_and_insert_tube+0x29>\n1f: \tmovq\t%rbx, %rdi\n22: \tcallq\t0x27 <make_and_insert_tube+0x27>\n27: \txorl\t%ebx, %ebx\n29: \tmovq\t%rbx, %rax\n2c: \tpopq\t%rbx\n2d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/ * make_tube (char const*) ;\nint ms_append (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * tube_dref (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  tubes ;\n\n__attribute__((used)) static Tube *\nmake_and_insert_tube(const char *name)\n{\nint r;\nTube *t = NULL;\n\nt = make_tube(name);\nif (!t)\nreturn NULL;\n\n/* We want this global tube list to behave like \"weak\" refs, so don't\n* increment the ref count. */\nr = ms_append(&tubes, t);\nif (!r)\nreturn tube_dref(t), (Tube *) 0;\n\nreturn t;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free_tube (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_tube (char const*) ;\nint /*<<< orphan*/  strcmp (char const*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static tube *make_and_insert_tube(const char *name) {\ntube *t = make_tube(name);\nif (t && strcmp(name, t)) {\nfree_tube(t);\nt = NULL;\n}\nreturn t;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_take",
    "input":"\n0000000000000000 <ms_take>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rdi), %ecx\n6: \ttestl\t%ecx, %ecx\n8: \tje\t0x2c <ms_take+0x2c>\na: \tmovq\t%rdi, %rbx\nd: \tmovl\t4(%rdi), %eax\n10: \tcltd\n11: \tidivl\t%ecx\n13: \tmovl\t%edx, 4(%rdi)\n16: \tmovq\t8(%rdi), %rax\n1a: \tmovslq\t%edx, %rsi\n1d: \tmovq\t(%rax,%rsi,8), %r14\n21: \tcallq\t0x26 <ms_take+0x26>\n26: \taddl\t$1, 4(%rbx)\n2a: \tjmp\t0x2f <ms_take+0x2f>\n2c: \txorl\t%r14d, %r14d\n2f: \tmovq\t%r14, %rax\n32: \taddq\t$8, %rsp\n36: \tpopq\t%rbx\n37: \tpopq\t%r14\n39: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int len; int last; void** items; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ms_delete (TYPE_1__*,size_t) ;\n\nvoid *\nms_take(Ms *a)\n{\nvoid *item;\n\nif (!a->len)\nreturn NULL;\n\n// The result of last behaviour is that ms_take returns the oldest elements\n// first, exception is a row of multiple take calls without inserts on ms\n// of even number of elements. See the test.\na->last = a->last % a->len;\nitem = a->items[a->last];\nms_delete(a, a->last);\n++a->last;\nreturn item;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int size; int count; int /*<<< orphan*/ ** items; } ;\ntypedef  TYPE_1__ ms_t ;\ntypedef  int /*<<< orphan*/  ms_item_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static ms_item_t *ms_take(ms_t *ms) {\nif (ms->size == 0) {\nreturn NULL;\n}\n\nms_item_t *item = ms->items[ms->count];\nfree(item);\nms->count++;\n\nreturn item;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_find",
    "input":"\n0000000000000000 <job_find>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tcallq\t0x9 <job_find+0x9>\n9: \tmovq\t(%rip), %rcx  # 0x10 <job_find+0x10>\n10: \tcltq\n12: \tmovq\t(%rcx,%rax,8), %rax\n16: \ttestq\t%rax, %rax\n19: \tje\t0x2e <job_find+0x2e>\n1b: \tnopl\t(%rax,%rax)\n20: \tcmpq\t%rbx, 8(%rax)\n24: \tje\t0x30 <job_find+0x30>\n26: \tmovq\t(%rax), %rax\n29: \ttestq\t%rax, %rax\n2c: \tjne\t0x20 <job_find+0x20>\n2e: \txorl\t%eax, %eax\n30: \tpopq\t%rbx\n31: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64 ;\nstruct TYPE_5__ {scalar_t__ id; } ;\nstruct TYPE_6__ {struct TYPE_6__* ht_next; TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint _get_job_hash_index (scalar_t__) ;\nTYPE_2__** all_jobs ;\n\nJob *\njob_find(uint64 job_id)\n{\nint index = _get_job_hash_index(job_id);\nJob *jh = all_jobs[index];\n\nwhile (jh && jh->r.id != job_id)\njh = jh->ht_next;\n\nreturn jh;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; scalar_t__ job; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nTYPE_1__** jobs ;\nsize_t job_hash (scalar_t__) ;\n\n__attribute__((used)) static job_t *\njob_find(scalar_t__ job)\n{\nsize_t\t\t\thash = job_hash(job);\njob_t\t\t   *job_ptr;\n\nfor (job_ptr = jobs[hash]; job_ptr != NULL; job_ptr = job_ptr->next)\n{\nif (job_ptr->job == job)\nreturn job_ptr;\n}\n\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_bury_job",
    "input":"\n0000000000000000 <bury_job>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovl\t%edx, %ebp\n9: \tmovq\t%rsi, %rbx\nc: \tmovq\t%rdi, %r14\nf: \ttestb\t%bpl, %bpl\n12: \tje\t0x22 <bury_job+0x22>\n14: \tmovq\t%r14, %rdi\n17: \tcallq\t0x1c <bury_job+0x1c>\n1c: \ttestl\t%eax, %eax\n1e: \tje\t0x79 <bury_job+0x79>\n20: \taddl\t%eax, (%rbx)\n22: \tmovq\t24(%rbx), %rdi\n26: \taddq\t$4, %rdi\n2a: \tmovq\t%rbx, %rsi\n2d: \tcallq\t0x32 <bury_job+0x32>\n32: \taddl\t$1, (%rip)    # 0x39 <bury_job+0x39>\n39: \tmovq\t24(%rbx), %rax\n3d: \taddl\t$1, (%rax)\n40: \tmovl\t(%rip), %eax  # 0x46 <bury_job+0x46>\n46: \taddl\t$1, 4(%rbx)\n4a: \tmovl\t%eax, 8(%rbx)\n4d: \tmovq\t$0, 16(%rbx)\n55: \tmovl\t$1, %r15d\n5b: \ttestb\t%bpl, %bpl\n5e: \tje\t0x7c <bury_job+0x7c>\n60: \tmovq\t%r14, %rdi\n63: \tmovq\t%rbx, %rsi\n66: \tcallq\t0x6b <bury_job+0x6b>\n6b: \ttestl\t%eax, %eax\n6d: \tje\t0x79 <bury_job+0x79>\n6f: \tmovq\t%r14, %rdi\n72: \tcallq\t0x77 <bury_job+0x77>\n77: \tjmp\t0x7c <bury_job+0x7c>\n79: \txorl\t%r15d, %r15d\n7c: \tmovl\t%r15d, %eax\n7f: \taddq\t$8, %rsp\n83: \tpopq\t%rbx\n84: \tpopq\t%r14\n86: \tpopq\t%r15\n88: \tpopq\t%rbp\n89: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_16__   TYPE_8__ ;\ntypedef  struct TYPE_15__   TYPE_5__ ;\ntypedef  struct TYPE_14__   TYPE_4__ ;\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_16__ {int /*<<< orphan*/  buried_ct; } ;\nstruct TYPE_13__ {int /*<<< orphan*/  bury_ct; int /*<<< orphan*/  state; } ;\nstruct TYPE_15__ {int walresv; TYPE_3__ r; int /*<<< orphan*/ * reserver; TYPE_2__* tube; } ;\nstruct TYPE_14__ {int /*<<< orphan*/  wal; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  buried_ct; } ;\nstruct TYPE_12__ {TYPE_1__ stat; int /*<<< orphan*/  buried; } ;\ntypedef  TYPE_4__ Server ;\ntypedef  TYPE_5__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Buried ;\nTYPE_8__ global_stat ;\nint /*<<< orphan*/  job_list_insert (int /*<<< orphan*/ *,TYPE_5__*) ;\nint /*<<< orphan*/  walmaint (int /*<<< orphan*/ *) ;\nint walresvupdate (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  walwrite (int /*<<< orphan*/ *,TYPE_5__*) ;\n\n__attribute__((used)) static int\nbury_job(Server *s, Job *j, char update_store)\n{\nif (update_store) {\nint z = walresvupdate(&s->wal);\nif (!z)\nreturn 0;\nj->walresv += z;\n}\n\njob_list_insert(&j->tube->buried, j);\nglobal_stat.buried_ct++;\nj->tube->stat.buried_ct++;\nj->r.state = Buried;\nj->reserver = NULL;\nj->r.bury_ct++;\n\nif (update_store) {\nif (!walwrite(&s->wal, j)) {\nreturn 0;\n}\nwalmaint(&s->wal);\n}\n\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  pri; int /*<<< orphan*/  state; int /*<<< orphan*/  tube; int /*<<< orphan*/  delay; int /*<<< orphan*/  pri_count; int /*<<< orphan*/  pri_dequeue; } ;\ntypedef  TYPE_1__* job_t ;\ntypedef  int /*<<< orphan*/  server_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  JOB_STATE_BURIED ;\nint /*<<< orphan*/  JOB_STATE_READY ;\nint /*<<< orphan*/  incr_pri_count (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  incr_pri_dequeue (int /*<<< orphan*/ *,TYPE_1__*) ;\nint /*<<< orphan*/  incr_ready_count (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  incr_tube_ready_count (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  job_is_ready (int /*<<< orphan*/ *,TYPE_1__*) ;\n\n__attribute__((used)) static int bury_job(server_t *server, job_t job, int bury) {\nif (bury) {\nif (!job_is_ready(server, job)) {\nreturn 0;\n}\nincr_ready_count(server);\nincr_pri_dequeue(server, job);\nincr_pri_count(server, job);\n}\njob->state = JOB_STATE_BURIED;\njob->tube = 0;\njob->delay = 0;\njob->pri = 0;\njob->pri_count = 0;\nincr_tube_ready_count(server, job->tube);\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_epollq_rmconn",
    "input":"\n0000000000000000 <epollq_rmconn>:\n0: \tmovq\t(%rip), %rcx  # 0x7 <epollq_rmconn+0x7>\n7: \txorl\t%eax, %eax\n9: \ttestq\t%rcx, %rcx\nc: \tje\t0x39 <epollq_rmconn+0x39>\ne: \tnop\n10: \tmovq\t(%rcx), %rdx\n13: \tcmpq\t%rdi, %rcx\n16: \tmovl\t$0, %esi\n1b: \tcmovneq\t%rax, %rsi\n1f: \tcmovneq\t%rcx, %rax\n23: \tmovq\t%rdx, (%rip)  # 0x2a <epollq_rmconn+0x2a>\n2a: \tmovq\t%rsi, (%rcx)\n2d: \tmovq\t(%rip), %rcx  # 0x34 <epollq_rmconn+0x34>\n34: \ttestq\t%rcx, %rcx\n37: \tjne\t0x10 <epollq_rmconn+0x10>\n39: \tmovq\t%rax, (%rip)  # 0x40 <epollq_rmconn+0x40>\n40: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {struct TYPE_4__* next; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nTYPE_1__* epollq ;\n\n__attribute__((used)) static void\nepollq_rmconn(Conn *c)\n{\nConn *x, *newhead = NULL;\n\nwhile (epollq) {\n// x as next element from epollq.\nx = epollq;\nepollq = epollq->next;\nx->next = NULL;\n\n// put x back into newhead list.\nif (x != c) {\nx->next = newhead;\nnewhead = x;\n}\n}\nepollq = newhead;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct epollq {struct epollq* next; } ;\n\n/* Variables and functions */\nstruct epollq* epollq_head ;\nstruct epollq* epollq_tail ;\n\nvoid epollq_rmconn (struct epollq *E) {\nstruct epollq *E2;\n\nwhile (epollq_head) {\nE2 = epollq_head;\nif (E == epollq_head) {\nepollq_head = epollq_head->next;\nif (epollq_head) {\nepollq_head->next = NULL;\n} else {\nepollq_tail = NULL;\n}\n} else {\nepollq_head = epollq_head->next;\n}\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_heap.c_heapinsert",
    "input":"\n0000000000000000 <heapinsert>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \tmovq\t%rsi, %r14\nb: \tmovq\t%rdi, %r15\ne: \tmovq\t(%rdi), %rbx\n11: \tcmpq\t8(%rdi), %rbx\n15: \tjne\t0x5a <heapinsert+0x5a>\n17: \tleaq\t(%rbx,%rbx), %r12\n1b: \taddq\t$2, %r12\n1f: \tleal\t(,%r12,8), %edi\n27: \tcallq\t0x2c <heapinsert+0x2c>\n2c: \ttestq\t%rax, %rax\n2f: \tje\t0x81 <heapinsert+0x81>\n31: \tmovq\t%rax, %rbx\n34: \tmovq\t16(%r15), %rsi\n38: \tmovl\t(%r15), %edx\n3b: \tshll\t$3, %edx\n3e: \tmovq\t%rax, %rdi\n41: \tcallq\t0x46 <heapinsert+0x46>\n46: \tmovq\t16(%r15), %rdi\n4a: \tcallq\t0x4f <heapinsert+0x4f>\n4f: \tmovq\t%rbx, 16(%r15)\n53: \tmovq\t%r12, 8(%r15)\n57: \tmovq\t(%r15), %rbx\n5a: \tleaq\t1(%rbx), %rax\n5e: \tmovq\t%rax, (%r15)\n61: \tmovq\t%r15, %rdi\n64: \tmovq\t%rbx, %rsi\n67: \tmovq\t%r14, %rdx\n6a: \tcallq\t0x6f <heapinsert+0x6f>\n6f: \tmovq\t%r15, %rdi\n72: \tmovq\t%rbx, %rsi\n75: \tcallq\t0x7a <heapinsert+0x7a>\n7a: \tmovl\t$1, %eax\n7f: \tjmp\t0x83 <heapinsert+0x83>\n81: \txorl\t%eax, %eax\n83: \taddq\t$8, %rsp\n87: \tpopq\t%rbx\n88: \tpopq\t%r12\n8a: \tpopq\t%r14\n8c: \tpopq\t%r15\n8e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {size_t len; size_t cap; void** data; } ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (void**) ;\nvoid** malloc (int) ;\nint /*<<< orphan*/  memcpy (void**,void**,int) ;\nint /*<<< orphan*/  set (TYPE_1__*,size_t,void*) ;\nint /*<<< orphan*/  siftdown (TYPE_1__*,size_t) ;\n\nint\nheapinsert(Heap *h, void *x)\n{\nif (h->len == h->cap) {\nvoid **ndata;\nsize_t ncap = (h->len+1) * 2; /* allocate twice what we need */\n\nndata = malloc(sizeof(void*) * ncap);\nif (!ndata) {\nreturn 0;\n}\n\nmemcpy(ndata, h->data, sizeof(void*) * h->len);\nfree(h->data);\nh->data = ndata;\nh->cap = ncap;\n}\n\nsize_t k = h->len;\nh->len++;\nset(h, k, x);\nsiftdown(h, k);\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t nheap; size_t nheapmax; int /*<<< orphan*/ * heap; } ;\ntypedef  TYPE_1__ HeapContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  heap_insert (TYPE_1__*,size_t,void*) ;\nint /*<<< orphan*/  heap_swap (TYPE_1__*,size_t,size_t) ;\nint /*<<< orphan*/  heap_up (TYPE_1__*,size_t) ;\nint /*<<< orphan*/  heap_up_max (TYPE_1__*,size_t) ;\nvoid* palloc (int) ;\nint /*<<< orphan*/  pfree (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int\nheapinsert(HeapContext *hc, void *item)\n{\nsize_t\t\ti;\n\nif (hc->nheap == hc->nheapmax)\n{\nsize_t\t\tnheapmax = hc->nheapmax * 2 + 2;\n\nhc->heap = (void **) palloc(nheapmax * sizeof(void *));\nhc->nheapmax = nheapmax;\n\n/*\n* Copy the old heap to the new one, and free the old heap.  We don't\n* need to copy the first entry, since it's always NULL.\n*/\nfor (i = 1; i <= hc->nheap; i++)\nhc->heap[i] = hc->heap[i + 1];\npfree(hc->heap);\n}\n\ni = ++hc->nheap;\n\n/*\n* Sift up the new entry to its correct position.\n*/\nheap_insert(hc, i, item);\nheap_up(hc, i);\n\n/*\n* Sift up the last entry to its correct position.\n*/\nheap_up_max(hc, hc->nheap);\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_sunos.c_sockinit",
    "input":"\n0000000000000000 <sockinit>:\n0: \tpushq\t%rbx\n1: \txorl\t%ebx, %ebx\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <sockinit+0xa>\na: \tmovl\t%eax, (%rip)  # 0x10 <sockinit+0x10>\n10: \tcmpl\t$-1, %eax\n13: \tjne\t0x24 <sockinit+0x24>\n15: \tmovl\t$0, %edi\n1a: \tcallq\t0x1f <sockinit+0x1f>\n1f: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\n24: \tmovl\t%ebx, %eax\n26: \tpopq\t%rbx\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint port_create () ;\nint portfd ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nsockinit(void)\n{\nportfd = port_create();\nif (portfd == -1) {\ntwarn(\"port_create\");\nreturn -1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  perror (char*) ;\nint socket (int,int,int) ;\nint /*<<< orphan*/  sockfd ;\n\nint sockinit(int domain, int type, int protocol)\n{\nint fd;\n\nfd = socket(domain, type, protocol);\nif (fd == -1) {\nperror(\"socket\");\nreturn -1;\n}\nsockfd = fd;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_conn_less",
    "input":"\n0000000000000000 <conn_less>:\n0: \tmovq\t(%rdi), %rcx\n3: \txorl\t%eax, %eax\n5: \tcmpq\t(%rsi), %rcx\n8: \tsetl\t%al\nb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {scalar_t__ tickat; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\n\nint\nconn_less(void *ca, void *cb)\n{\nConn *a = (Conn *)ca;\nConn *b = (Conn *)cb;\nreturn a->tickat < b->tickat;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct connection {scalar_t__ id; } ;\n\n/* Variables and functions */\n\nint conn_less (struct connection *a, struct connection *b) {\nreturn a->id < b->id;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_kickjob_bad_format",
    "input":"\n0000000000000000 <cttest_kickjob_bad_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_kickjob_bad_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_kickjob_bad_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_kickjob_bad_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_kickjob_bad_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_kickjob_bad_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_kickjob_bad_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_kickjob_bad_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_kickjob_bad_format+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_kickjob_bad_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"kick-job a111\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"kick-job 111a\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"kick-job !@#!@#\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  kickjob_test (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\ncttest_kickjob_bad_format(void *notused)\n{\nFILE *fp;\n\nfp = fopen(\"kickjob_bad_format.txt\", \"w\");\nfprintf(fp, \"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_ttr_small",
    "input":"\n0000000000000000 <cttest_ttr_small>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_ttr_small+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_ttr_small+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_ttr_small+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_ttr_small+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_ttr_small+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_ttr_small+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_ttr_small+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_ttr_small+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_ttr_small()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"stats-job 1\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\nttr: 1\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  BIO_write (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  TEST_mem_eq (char*,char*,int) ;\n\n__attribute__((used)) static void cttest_ttr_small(void)\n{\nBIO *b = BIO_new(BIO_s_mem());\n\nBIO_write(b, \"1234567890\", 10);\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234567890\");\nBIO_printf(b, \"1234"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_release_not_found",
    "input":"\n0000000000000000 <cttest_release_not_found>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_release_not_found+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_release_not_found+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_release_not_found+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tpopq\t%rbx\n25: \tjmp\t0x2a <cttest_release_not_found+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_release_not_found()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"release 1 1 1\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HANDLE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CloseHandle (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CreateFile (char*,int,int,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  GetLastError () ;\nint /*<<< orphan*/  GetModuleHandleA (char*) ;\nint /*<<< orphan*/  ok (int /*<<< orphan*/ ,char*) ;\n\n__attribute__((used)) static void cttest_release_not_found(void)\n{\nHANDLE h;\n\nh = CreateFile(\"\\\\\\\\.\\\\HarddiskVolume1\\\\nonexistent\", 0, 0, NULL,\nOPEN_EXISTING, 0, NULL);\nok(h == INVALID_HANDLE_VALUE, \"CreateFile succeeded\\n\");\nok(GetLastError() == 3, \"wrong error %d\\n\", GetLastError());\n\nh = CreateFile(\"\\\\\\\\.\\\\HarddiskVolume1\\\\nonexistent\", 0, 0, NULL,\nOPEN_EXISTING, 0, GetModuleHandleA(\"ntdll\"));\nok(h == INVALID_HANDLE_VALUE, \"CreateFile succeeded\\n\");\nok(GetLastError() == 3, \"wrong error %d\\n\", GetLastError());\n\nCloseHandle(h);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_delete_bad_format",
    "input":"\n0000000000000000 <cttest_delete_bad_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_delete_bad_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_delete_bad_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_delete_bad_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_delete_bad_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_delete_bad_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_delete_bad_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_delete_bad_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_delete_bad_format+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_delete_bad_format+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tpopq\t%rbx\n6d: \tjmp\t0x72 <cttest_delete_bad_format+0x72>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_delete_bad_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"delete 18446744073709551616\\r\\n\"); // UINT64_MAX+1\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"delete 184467440737095516160000000000000000000000000000\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"delete foo111\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"delete 111foo\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HCRYPTMSG ;\ntypedef  int /*<<< orphan*/  HCERTSTORE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CryptMsgClose (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CryptMsgOpenToDecode (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< or"
},
{
    "file:":"./beanstalkd/extr_prot.c_check_err",
    "input":"\n0000000000000000 <check_err>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rip), %rax  # 0x8 <check_err+0x8>\n8: \tcmpq\t(%rip), %rax  # 0xf <check_err+0xf>\nf: \tje\t0x38 <check_err+0x38>\n11: \tcmpq\t(%rip), %rax  # 0x18 <check_err+0x18>\n18: \tje\t0x38 <check_err+0x38>\n1a: \tcmpq\t(%rip), %rax  # 0x21 <check_err+0x21>\n21: \tje\t0x38 <check_err+0x38>\n23: \tmovq\t%rdi, %rbx\n26: \tmovl\t$0, %edi\n2b: \tcallq\t0x30 <check_err+0x30>\n30: \tmovl\t(%rip), %eax  # 0x36 <check_err+0x36>\n36: \tmovl\t%eax, (%rbx)\n38: \tpopq\t%rbx\n39: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  state; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nscalar_t__ EAGAIN ;\nscalar_t__ EINTR ;\nscalar_t__ EWOULDBLOCK ;\nint /*<<< orphan*/  STATE_CLOSE ;\nscalar_t__ errno ;\nint /*<<< orphan*/  twarn (char*,char const*) ;\n\n__attribute__((used)) static void\ncheck_err(Conn *c, const char *s)\n{\nif (errno == EAGAIN)\nreturn;\nif (errno == EINTR)\nreturn;\nif (errno == EWOULDBLOCK)\nreturn;\n\ntwarn(\"%s\", s);\nc->state = STATE_CLOSE;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HRESULT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  E_FAIL ;\nscalar_t__ E_INVALIDARG ;\nscalar_t__ E_NOTIMPL ;\nscalar_t__ E_OUTOFMEMORY ;\nint /*<<< orphan*/  FIXME (char*,scalar_t__) ;\n\n__attribute__((used)) static void check_err(HRESULT *hr)\n{\nif (*hr == E_INVALIDARG || *hr == E_NOTIMPL || *hr == E_OUTOFMEMORY)\n{\nFIXME(\"Unexpected error %08x\\n\", *hr);\n*hr = E_FAIL;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_success",
    "input":"\n0000000000000000 <success>:\n0: \tpushq\t%rax\n1: \txorl\t%edi, %edi\n3: \tcallq\t0x8 <success+0x8>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  _exit (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nsuccess(void)\n{\n_exit(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void success(void) {\nassert(0 == 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c__skip",
    "input":"\n0000000000000000 <_skip>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%ecx, %r14d\n7: \tmovq\t%rdx, %rbp\na: \tmovq\t%rdi, %rbx\nd: \tmovq\t$0, 32(%rdi)\n15: \tmovq\t%rsi, (%rdi)\n18: \tcallq\t0x1d <_skip+0x1d>\n1d: \tcmpq\t$0, (%rbx)\n21: \tje\t0x41 <_skip+0x41>\n23: \tmovq\t%rbp, 8(%rbx)\n27: \tmovl\t%r14d, 16(%rbx)\n2b: \tmovq\t$0, 24(%rbx)\n33: \tmovl\t(%rip), %eax  # 0x39 <_skip+0x39>\n39: \tmovl\t%eax, 20(%rbx)\n3c: \tpopq\t%rbx\n3d: \tpopq\t%r14\n3f: \tpopq\t%rbp\n40: \tretq\n41: \tmovl\t(%rip), %ecx  # 0x47 <_skip+0x47>\n47: \tmovq\t%rbx, %rdi\n4a: \tmovq\t%rbp, %rsi\n4d: \tmovl\t%r14d, %edx\n50: \tpopq\t%rbx\n51: \tpopq\t%r14\n53: \tpopq\t%rbp\n54: \tjmp\t0x59 <_skip+0x59>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ int64 ;\nstruct TYPE_5__ {scalar_t__ in_job_read; char* reply; int reply_len; int /*<<< orphan*/  state; scalar_t__ reply_sent; scalar_t__ in_job; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  STATE_BITBUCKET ;\nint /*<<< orphan*/  STATE_SEND_WORD ;\nint /*<<< orphan*/  fill_extra_data (TYPE_1__*) ;\nint /*<<< orphan*/  reply (TYPE_1__*,char*,int,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\n_skip(Conn *c, int64 n, char *msg, int msglen)\n{\n/* Invert the meaning of in_job_read while throwing away data -- it\n* counts the bytes that remain to be thrown away. */\nc->in_job = 0;\nc->in_job_read = n;\nfill_extra_data(c);\n\nif (c->in_job_read == 0) {\nreply(c, msg, msglen, STATE_SEND_WORD);\nreturn;\n}\n\nc->reply = msg;\nc->reply_len = msglen;\nc->reply_sent = 0;\nc->state = STATE_BITBUCKET;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ error; scalar_t__ eof; int /*<<< orphan*/  last_op; scalar_t__ last_token; int /*<<< orphan*/  last_line; } ;\ntypedef  TYPE_1__ js_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  JS_TOK_EOF ;\nint /*<<< orphan*/  js_next (TYPE_1__*) ;\nint /*<<< orphan*/  js_skip_comment (TYPE_1__*,char const*,int) ;\n\n__attribute__((used)) static void _skip(js_State *J, const char *p, int l, int c)\n{\nJ->last_line = 0;\nJ->last_op = 0;\nJ->last_token = 0;\nJ->eof = 0;\nif (!js_next(J)) {\njs_skip_comment(J, p, l);\n} else {\nJ->last_line = c;\nJ->last_op = JS_TOK_EOF;\nJ->last_token = 0;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_bury_bad_format",
    "input":"\n0000000000000000 <cttest_bury_bad_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_bury_bad_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_bury_bad_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_bury_bad_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_bury_bad_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_bury_bad_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_bury_bad_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_bury_bad_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_bury_bad_format+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_bury_bad_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"bury 111abc 2\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"bury 111\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"bury 111 222abc\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static void cttest_bury_bad_format(void) {\nFILE *f = fopen(\"test.txt\", \"w\");\nfprintf(f, \"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"
},
{
    "file:":"./beanstalkd/extr_sunos.c_sockwant",
    "input":"\n0000000000000000 <sockwant>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%esi, %ebx\n6: \tmovq\t%rdi, %r14\n9: \txorl\t%eax, %eax\nb: \tmovl\t$0, %ebp\n10: \ttestl\t%esi, %esi\n12: \tje\t0x31 <sockwant+0x31>\n14: \tcmpl\t$119, %ebx\n17: \tje\t0x2b <sockwant+0x2b>\n19: \tmovl\t$0, %ebp\n1e: \tcmpl\t$114, %ebx\n21: \tjne\t0x31 <sockwant+0x31>\n23: \tmovl\t(%rip), %ebp  # 0x29 <sockwant+0x29>\n29: \tjmp\t0x31 <sockwant+0x31>\n2b: \tmovl\t(%rip), %ebp  # 0x31 <sockwant+0x31>\n31: \tmovl\t(%r14), %ecx\n34: \tmovl\t%ecx, %edx\n36: \torl\t%ebx, %edx\n38: \tje\t0x88 <sockwant+0x88>\n3a: \torl\t(%rip), %ebp  # 0x40 <sockwant+0x40>\n40: \ttestl\t%ebx, %ebx\n42: \tje\t0x51 <sockwant+0x51>\n44: \ttestl\t%ecx, %ecx\n46: \tjne\t0x51 <sockwant+0x51>\n48: \tmovl\t$1, (%r14)\n4f: \tjmp\t0x6a <sockwant+0x6a>\n51: \tmovl\t(%rip), %edi  # 0x57 <sockwant+0x57>\n57: \tmovl\t(%rip), %esi  # 0x5d <sockwant+0x5d>\n5d: \tmovl\t4(%r14), %edx\n61: \tcallq\t0x66 <sockwant+0x66>\n66: \ttestl\t%ebx, %ebx\n68: \tje\t0x88 <sockwant+0x88>\n6a: \tmovl\t(%rip), %edi  # 0x70 <sockwant+0x70>\n70: \tmovl\t(%rip), %esi  # 0x76 <sockwant+0x76>\n76: \tmovl\t4(%r14), %edx\n7a: \tmovl\t%ebp, %ecx\n7c: \tmovq\t%r14, %r8\n7f: \tpopq\t%rbx\n80: \tpopq\t%r14\n82: \tpopq\t%rbp\n83: \tjmp\t0x88 <sockwant+0x88>\n88: \tpopq\t%rbx\n89: \tpopq\t%r14\n8b: \tpopq\t%rbp\n8c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int added; int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ Socket ;\n\n/* Variables and functions */\nint POLLIN ;\nint POLLOUT ;\nint POLLPRI ;\nint /*<<< orphan*/  PORT_SOURCE_FD ;\nint port_associate (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,void*) ;\nint port_dissociate (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  portfd ;\n\nint\nsockwant(Socket *s, int rw)\n{\nint events = 0;\n\nif (rw) {\nswitch (rw) {\ncase 'r':\nevents |= POLLIN;\nbreak;\ncase 'w':\nevents |= POLLOUT;\nbreak;\n}\n}\n\nevents |= POLLPRI;\n\nif (!s->added && !rw) {\nreturn 0;\n} else if (!s->added && rw) {\ns->added = 1;\nreturn port_associate(portfd, PORT_SOURCE_FD, s->fd, events, (void *)s);\n} else if (!rw) {\nreturn port_dissociate(portfd, PORT_SOURCE_FD, s->fd);\n} else {\nport_dissociate(portfd, PORT_SOURCE_FD, s->fd);\nreturn port_associate(portfd, PORT_SOURCE_FD, s->fd, events, (void *)s);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int flags; int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ PGconn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EV_READ ;\nint /*<<< orphan*/  EV_WRITE ;\nint /*<<< orphan*/  PGRES_POLLING_FAILED ;\nint /*<<< orphan*/  PGRES_POLLING_OK ;\nint /*<<< orphan*/  PGRES_POLLING_READING ;\nint /*<<< orphan*/  PGRES_POLLING_WRITING ;\nint /*<<< orphan*/  WSAEWOULDBLOCK ;\nint /*<<< orphan*/  WSAGetLastError () ;\nint /*<<< orphan*/  WSASetLastError (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  add_event_socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  errno_is (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static PGconn *\nsockwant(PGconn *conn, int want)\n{\nif (want)\n{\nif (want == 119)\n{\nif (conn->flags & 1)\nreturn &conn->conn;\nconn->flags |= 1;\n}\nelse if (want == 114)\n{\nif (conn->flags & 2)\nreturn &conn->conn;\nconn->flags |= 2;\n}\nelse\n{\n/* error */\nreturn NULL;\n}\n}\nelse\n{\nif (conn->flags & 1)\n{\nif (errno_is(WSAEWOULDBLOCK))\n{\n/*\n* We're in nonblocking mode, and the last I/O attempt failed with\n* WSAEWOULDBLOCK.  We have to clear the flag bit and return\n* PGRES_POLLING_READING to request another poll.\n*/\nconn->flags &= ~1;\nreturn &conn->conn;\n}\nelse\n{\n/* error */\nreturn NULL;\n}\n}\nelse if (conn->flags & 2)\n{\nif (errno_is(WSAEWOULDBLOCK))\n{\n/*\n* We're in nonblocking mode, and the last I/O attempt failed with\n* WSAEWOULDBLOCK.  We have to clear the flag bit and return\n* PGRES_POLLING_WRITING to request another poll.\n*/\nconn->flags &= ~2;\nreturn &conn->conn;\n}\nelse\n{\n/* error */\nreturn NULL;\n}\n}\nelse\n{\n/* error */\nreturn NULL;\n}\n}\n\n/*\n* We're not in nonblocking mode, so we don't have to worry about\n* clearing the flag bit.\n*/\nif (want)\n{\nif (want == 119)\n{\nadd_event_socket(conn->fd, EV_READ, conn->fd, EV_READ, conn);\nreturn &conn->conn;\n}\nelse if (want == 114)\n{\nadd_event_socket(conn->fd, EV_WRITE, conn->fd, EV_WRITE, conn);\nreturn &conn->conn;\n}\nelse\n{\n/* error */\nreturn NULL;\n}\n}\nelse\n{\nif (errno_is(WSAEWOULDBLOCK))\n{\n/*\n* We're in blocking mode, and the last I/O attempt failed with\n* WSAEWOULDBLOCK.  We have to return PGRES_POLLING_READING or\n* PGRES_POLLING_WRITING to request another poll.\n*/\nif (conn->flags & 1)\nreturn &conn->conn;\nelse if (conn->flags & 2)\nreturn &conn->conn;\nelse\n{\n/* error */\nreturn NULL;\n}\n}\nelse\n{\n/* error */\nreturn NULL;\n}\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_util.c_flagusage",
    "input":"\n0000000000000000 <flagusage>:\n0: \tpushq\t%rax\n1: \tmovq\t%rdi, %rsi\n4: \tmovl\t$0, %edi\n9: \tcallq\t0xe <flagusage+0xe>\ne: \tmovl\t$5, %edi\n13: \tpopq\t%rax\n14: \tjmp\t0x19 <flagusage+0x19>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  usage (int) ;\nint /*<<< orphan*/  warnx (char*,char*) ;\n\n__attribute__((used)) static char *\nflagusage(char *flag)\n{\nwarnx(\"flag requires an argument: %s\", flag);\nusage(5);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  printf (char*,char*) ;\n\nvoid flagusage(char *name)\n{\nprintf(\"Usage: %s [-h] [-v] [-f] [-d] [-s] [-t] [-p] [-b] [-a] [-c] [-e] [-i] [-o] [-u] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l] [-m] [-n] [-o] [-p] [-q] [-r] [-s] [-t] [-u] [-v] [-w] [-x] [-y] [-z] [-A] [-B] [-C] [-D] [-E] [-F] [-G] [-H] [-I] [-J] [-K] [-L] [-M] [-N] [-O] [-P] [-Q] [-R] [-S] [-T] [-U] [-V] [-W] [-X] [-Y] [-Z] [-a] [-b] [-c] [-d] [-e] [-f] [-g] [-h] [-i] [-j] [-k] [-l]"
},
{
    "file:":"./beanstalkd/extr_testserv.c_mustsend",
    "input":"\n0000000000000000 <mustsend>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rsi, %rbx\n6: \tmovl\t%edi, %ebp\n8: \tmovq\t%rsi, %rdi\nb: \tcallq\t0x10 <mustsend+0x10>\n10: \tmovl\t%ebp, %edi\n12: \tmovq\t%rbx, %rsi\n15: \tmovl\t%eax, %edx\n17: \tcallq\t0x1c <mustsend+0x1c>\n1c: \tmovl\t$0, %edi\n21: \tmovl\t%ebp, %esi\n23: \tmovq\t%rbx, %rdx\n26: \tcallq\t0x2b <mustsend+0x2b>\n2b: \tmovl\t(%rip), %edi  # 0x31 <mustsend+0x31>\n31: \taddq\t$8, %rsp\n35: \tpopq\t%rbx\n36: \tpopq\t%rbp\n37: \tjmp\t0x3c <mustsend+0x3c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  fflush (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  printf (char*,int,char*) ;\nint /*<<< orphan*/  stdout ;\nint /*<<< orphan*/  strlen (char*) ;\nint /*<<< orphan*/  writefull (int,char*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nmustsend(int fd, char *s)\n{\nwritefull(fd, s, strlen(s));\nprintf(\">%d %s\", fd, s);\nfflush(stdout);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  u_char ;\ntypedef  int /*<<< orphan*/  u_short ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  log_file ;\nint /*<<< orphan*/  log_printf (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  strlen (char*) ;\n\nvoid\nmustsend(u_short port, u_char *buf)\n{\nfprintf(log_file, \"mustsend: port %d, buf %s\\n\", port, buf);\nlog_printf(log_file, \"mustsend: port %d, buf %s\\n\", port, buf);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_kick_buried_jobs",
    "input":"\n0000000000000000 <kick_buried_jobs>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%r12\n6: \tpushq\t%rbx\n7: \tpushq\t%rax\n8: \ttestq\t%rdx, %rdx\nb: \tjle\t0x46 <kick_buried_jobs+0x46>\nd: \tmovq\t%rdx, %r14\n10: \tmovq\t%rsi, %r15\n13: \tmovq\t%rdi, %r12\n16: \txorl\t%ebx, %ebx\n18: \tnopl\t(%rax,%rax)\n20: \tmovq\t%r15, %rdi\n23: \tcallq\t0x28 <kick_buried_jobs+0x28>\n28: \ttestq\t%rax, %rax\n2b: \tje\t0x48 <kick_buried_jobs+0x48>\n2d: \tmovl\t(%r15), %esi\n30: \tmovq\t%r12, %rdi\n33: \tcallq\t0x38 <kick_buried_jobs+0x38>\n38: \taddq\t$1, %rbx\n3c: \tcmpq\t%rbx, %r14\n3f: \tjne\t0x20 <kick_buried_jobs+0x20>\n41: \tmovq\t%r14, %rbx\n44: \tjmp\t0x48 <kick_buried_jobs+0x48>\n46: \txorl\t%ebx, %ebx\n48: \tmovq\t%rbx, %rax\n4b: \taddq\t$8, %rsp\n4f: \tpopq\t%rbx\n50: \tpopq\t%r12\n52: \tpopq\t%r14\n54: \tpopq\t%r15\n56: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint ;\nstruct TYPE_5__ {int /*<<< orphan*/  next; } ;\nstruct TYPE_6__ {TYPE_1__ buried; } ;\ntypedef  TYPE_2__ Tube ;\ntypedef  int /*<<< orphan*/  Server ;\n\n/* Variables and functions */\nscalar_t__ buried_job_p (TYPE_2__*) ;\nint /*<<< orphan*/  kick_buried_job (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static uint\nkick_buried_jobs(Server *s, Tube *t, uint n)\n{\nuint i;\nfor (i = 0; (i < n) && buried_job_p(t); ++i) {\nkick_buried_job(s, t->buried.next);\n}\nreturn i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  id; } ;\ntypedef  TYPE_1__ job_t ;\ntypedef  int /*<<< orphan*/  server ;\n\n/* Variables and functions */\nscalar_t__ job_is_buried (TYPE_1__*) ;\nint /*<<< orphan*/  kick_job (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int kick_buried_jobs(server *srv, job_t *jobs, int n) {\nint i;\nfor (i = 0; i < n; i++) {\nif (job_is_buried(&jobs[i])) {\nkick_job(srv, jobs[i].id);\n}\n}\nreturn i;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_exist",
    "input":"\n0000000000000000 <exist>:\n0: \tpushq\t%rax\n1: \tmovq\t%rsp, %rsi\n4: \tcallq\t0x9 <exist+0x9>\n9: \txorl\t%ecx, %ecx\nb: \tcmpl\t$-1, %eax\ne: \tsetne\t%cl\n11: \tmovl\t%ecx, %eax\n13: \tpopq\t%rcx\n14: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {int dummy; } ;\n\n/* Variables and functions */\nint stat (char*,struct stat*) ;\n\n__attribute__((used)) static int\nexist(char *path)\n{\nstruct stat s;\n\nint r = stat(path, &s);\nreturn r != -1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  access (char const*,int /*<<< orphan*/ ) ;\n\nint exist(const char *path)\n{\nreturn access(path, 0) != -1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_count_tot_conns",
    "input":"\n0000000000000000 <count_tot_conns>:\n0: \tmovl\t(%rip), %eax  # 0x6 <count_tot_conns+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  uint ;\n\n/* Variables and functions */\nint /*<<< orphan*/  tot_conn_ct ;\n\nuint\ncount_tot_conns()\n{\nreturn tot_conn_ct;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint tot_conns ;\n\nint count_tot_conns (void) {\nreturn tot_conns;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_pause",
    "input":"\n0000000000000000 <cttest_pause>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <cttest_pause+0xa>\na: \tmovl\t%eax, %edi\nc: \tcallq\t0x11 <cttest_pause+0x11>\n11: \tmovl\t%eax, %ebx\n13: \tmovl\t$0, %esi\n18: \tmovl\t%eax, %edi\n1a: \tcallq\t0x1f <cttest_pause+0x1f>\n1f: \tmovl\t$0, %esi\n24: \tmovl\t%ebx, %edi\n26: \tcallq\t0x2b <cttest_pause+0x2b>\n2b: \tmovl\t$0, %esi\n30: \tmovl\t%ebx, %edi\n32: \tcallq\t0x37 <cttest_pause+0x37>\n37: \txorl\t%eax, %eax\n39: \tcallq\t0x3e <cttest_pause+0x3e>\n3e: \tmovl\t%eax, %ebp\n40: \tmovl\t$0, %esi\n45: \tmovl\t%ebx, %edi\n47: \tcallq\t0x4c <cttest_pause+0x4c>\n4c: \tmovl\t$0, %esi\n51: \tmovl\t%ebx, %edi\n53: \tcallq\t0x58 <cttest_pause+0x58>\n58: \tmovl\t$0, %esi\n5d: \tmovl\t%ebx, %edi\n5f: \tcallq\t0x64 <cttest_pause+0x64>\n64: \tmovl\t$0, %esi\n69: \tmovl\t%ebx, %edi\n6b: \tcallq\t0x70 <cttest_pause+0x70>\n70: \tmovl\t$0, %esi\n75: \tmovl\t%ebx, %edi\n77: \tcallq\t0x7c <cttest_pause+0x7c>\n7c: \txorl\t%eax, %eax\n7e: \tcallq\t0x83 <cttest_pause+0x83>\n83: \tsubl\t%ebp, %eax\n85: \txorl\t%edi, %edi\n87: \tcmpl\t$999999999, %eax   # imm = 0x3B9AC9FF\n8c: \tsetg\t%dil\n90: \taddq\t$8, %rsp\n94: \tpopq\t%rbx\n95: \tpopq\t%rbp\n96: \tjmp\t0x9b <cttest_pause+0x9b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int int64 ;\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nint nanoseconds () ;\n\nvoid\ncttest_pause()\n{\nint64 s;\n\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 1\\r\\n\");\nmustsend(fd, \"x\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\ns = nanoseconds();\nmustsend(fd, \"pause-tube default 1\\r\\n\");\nckresp(fd, \"PAUSED\\r\\n\");\nmustsend(fd, \"reserve\\r\\n\");\nckresp(fd, \"RESERVED 1 1\\r\\n\");\nckresp(fd, \"x\\r\\n\");\nassert(nanoseconds() - s >= 1000000000); // 1s\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  getpid () ;\nint /*<<< orphan*/  printf (char*,...) ;\nint /*<<< orphan*/  sleep (int) ;\nint time (int /*<<< orphan*/ *) ;\n\nvoid cttest_pause(int t) {\nint i, start, end;\n\nstart = time(NULL);\nprintf(\"PID %d: starting pause for %d seconds\\n\", getpid(), t);\nfor (i = 0; i < t; i++) {\nprintf(\"PID %d: %d\\n\", getpid(), i);\nsleep(1);\n}\nend = time(NULL);\nprintf(\"PID %d: ending pause\\n\", getpid());\nassert(end - start >= t);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_store_job",
    "input":"\n0000000000000000 <store_job>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t8(%rdi), %edi\n7: \tcallq\t0xc <store_job+0xc>\nc: \tmovq\t(%rip), %rcx  # 0x13 <store_job+0x13>\n13: \tcltq\n15: \tmovq\t(%rcx,%rax,8), %rcx\n19: \tmovq\t%rcx, (%rbx)\n1c: \tmovq\t(%rip), %rcx  # 0x23 <store_job+0x23>\n23: \tmovq\t%rbx, (%rcx,%rax,8)\n27: \tmovl\t(%rip), %eax  # 0x2d <store_job+0x2d>\n2d: \tleal\t1(%rax), %ecx\n30: \tmovl\t%ecx, (%rip)  # 0x36 <store_job+0x36>\n36: \tmovl\t(%rip), %ecx  # 0x3c <store_job+0x3c>\n3c: \tshll\t$2, %ecx\n3f: \tcmpl\t%ecx, %eax\n41: \tjge\t0x45 <store_job+0x45>\n43: \tpopq\t%rbx\n44: \tretq\n45: \tmovl\t$1, %edi\n4a: \tpopq\t%rbx\n4b: \tjmp\t0x50 <store_job+0x50>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  id; } ;\nstruct TYPE_6__ {struct TYPE_6__* ht_next; TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint _get_job_hash_index (int /*<<< orphan*/ ) ;\nTYPE_2__** all_jobs ;\nint all_jobs_cap ;\nint all_jobs_used ;\nint /*<<< orphan*/  rehash (int) ;\n\n__attribute__((used)) static void\nstore_job(Job *j)\n{\nint index = 0;\n\nindex = _get_job_hash_index(j->r.id);\n\nj->ht_next = all_jobs[index];\nall_jobs[index] = j;\nall_jobs_used++;\n\n/* accept a load factor of 4 */\nif (all_jobs_used > (all_jobs_cap << 2)) rehash(1);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  job; int /*<<< orphan*/  id; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  free (int /*<<< orphan*/ ) ;\nsize_t hash (int /*<<< orphan*/ ) ;\nTYPE_1__** jobs ;\nint /*<<< orphan*/ * jobs_free ;\nint /*<<< orphan*/  jobs_free_len ;\n\n__attribute__((used)) static void store_job (job_t *job) {\nfree (job->id);\njob->id = jobs[hash (job->job)].id;\njobs[hash (job->job)] = job;\njobs_free_len++;\nif (jobs_free_len == (1 << 2)) {\nassert (1);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walwrite",
    "input":"\n0000000000000000 <walwrite>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tcmpq\t$0, 8(%rdi)\n9: \tje\t0x2f <walwrite+0x2f>\nb: \tmovq\t%rsi, %r14\ne: \tmovq\t%rdi, %rbx\n11: \tmovq\t16(%rdi), %rdi\n15: \tcmpq\t$0, (%rdi)\n19: \tjle\t0x36 <walwrite+0x36>\n1b: \tcmpq\t$0, (%r14)\n1f: \tje\t0x4d <walwrite+0x4d>\n21: \tmovq\t%r14, %rsi\n24: \tcallq\t0x29 <walwrite+0x29>\n29: \ttestl\t%eax, %eax\n2b: \tjne\t0x6c <walwrite+0x6c>\n2d: \tjmp\t0x59 <walwrite+0x59>\n2f: \tmovl\t$1, %eax\n34: \tjmp\t0x6f <walwrite+0x6f>\n36: \tmovq\t%rbx, %rdi\n39: \tcallq\t0x3e <walwrite+0x3e>\n3e: \ttestq\t%rax, %rax\n41: \tje\t0x59 <walwrite+0x59>\n43: \tmovq\t16(%rbx), %rdi\n47: \tcmpq\t$0, (%r14)\n4b: \tjne\t0x21 <walwrite+0x21>\n4d: \tmovq\t%r14, %rsi\n50: \tcallq\t0x55 <walwrite+0x55>\n55: \ttestl\t%eax, %eax\n57: \tjne\t0x6c <walwrite+0x6c>\n59: \tmovq\t16(%rbx), %rdi\n5d: \tcallq\t0x62 <walwrite+0x62>\n62: \tmovq\t$0, 8(%rbx)\n6a: \txorl\t%eax, %eax\n6c: \taddl\t$1, (%rbx)\n6f: \taddq\t$8, %rsp\n73: \tpopq\t%rbx\n74: \tpopq\t%r14\n76: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_6__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_11__ {int /*<<< orphan*/  nrec; scalar_t__ use; TYPE_6__* cur; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_13__ {scalar_t__ resv; } ;\nstruct TYPE_12__ {scalar_t__ file; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  filewclose (TYPE_6__*) ;\nint filewrjobfull (TYPE_6__*,TYPE_2__*) ;\nint filewrjobshort (TYPE_6__*,TYPE_2__*) ;\nscalar_t__ usenext (TYPE_1__*) ;\n\nint\nwalwrite(Wal *w, Job *j)\n{\nint r = 0;\n\nif (!w->use) return 1;\nif (w->cur->resv > 0 || usenext(w)) {\nif (j->file) {\nr = filewrjobshort(w->cur, j);\n} else {\nr = filewrjobfull(w->cur, j);\n}\n}\nif (!r) {\nfilewclose(w->cur);\nw->use = 0;\n}\nw->nrec++;\nreturn r;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  n_wal; TYPE_1__* wal; } ;\nstruct TYPE_4__ {scalar_t__ n_entries; int /*<<< orphan*/ * entries; } ;\ntypedef  TYPE_1__ WAL ;\ntypedef  TYPE_2__ WAL_Manager ;\n\n/* Variables and functions */\nint /*<<< orphan*/  wal_add_entry (TYPE_1__*,TYPE_2__*) ;\nscalar_t__ wal_empty (TYPE_1__*) ;\nint /*<<< orphan*/  wal_flush (TYPE_1__*) ;\n\n__attribute__((used)) static int walwrite (WAL_Manager *manager, WAL *wal) {\nif (manager->wal == NULL) {\nreturn 1;\n}\nif (manager->wal->n_entries > 0 && wal->entries != NULL) {\nif (!wal_add_entry (manager->wal, wal)) {\nreturn 0;\n}\n}\nif (manager->wal->n_entries > 0 && wal->entries == NULL) {\nif (!wal_flush (manager->wal)) {\nreturn 0;\n}\n}\nmanager->wal->n_entries = 0;\nmanager->n_wal++;\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_util.c_warn_systemd_ignored_option",
    "input":"\n0000000000000000 <warn_systemd_ignored_option>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \txorl\t%edi, %edi\nc: \tcallq\t0x11 <warn_systemd_ignored_option+0x11>\n11: \ttestq\t%rax, %rax\n14: \tjle\t0x2d <warn_systemd_ignored_option+0x2d>\n16: \tmovl\t$0, %edi\n1b: \tmovq\t%rbx, %rsi\n1e: \tmovq\t%r14, %rdx\n21: \taddq\t$8, %rsp\n25: \tpopq\t%rbx\n26: \tpopq\t%r14\n28: \tjmp\t0x2d <warn_systemd_ignored_option+0x2d>\n2d: \taddq\t$8, %rsp\n31: \tpopq\t%rbx\n32: \tpopq\t%r14\n34: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ sd_listen_fds (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  warnx (char*,char*,char*) ;\n\n__attribute__((used)) static void\nwarn_systemd_ignored_option(char *opt, char *arg)\n{\nif (sd_listen_fds(0) > 0) {\nwarnx(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ getenv (char*) ;\nint /*<<< orphan*/  warn (char*,char const*,char const*) ;\n\n__attribute__((used)) static void\nwarn_systemd_ignored_option(const char *option, const char *value)\n{\nif (getenv(\"NOTIFY_SOCKET\"))\nwarn(\"ignoring option \\\"%s\\\" because systemd supervision is in use\",\noption);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_conn_reserve_job",
    "input":"\n0000000000000000 <conn_reserve_job>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t40(%rsi), %rax\nb: \taddl\t$1, (%rax)\ne: \tmovq\t%rdi, %r14\n11: \taddl\t$1, 32(%rsi)\n15: \txorl\t%eax, %eax\n17: \tcallq\t0x1c <conn_reserve_job+0x1c>\n1c: \taddq\t16(%rbx), %rax\n20: \tmovq\t%rax, 24(%rbx)\n24: \tmovl\t(%rip), %eax  # 0x2a <conn_reserve_job+0x2a>\n2a: \tmovl\t%eax, 8(%rbx)\n2d: \tleaq\t4(%r14), %rdi\n31: \tmovq\t%rbx, %rsi\n34: \tcallq\t0x39 <conn_reserve_job+0x39>\n39: \tmovq\t%r14, (%rbx)\n3c: \tmovl\t$4294967295, (%r14)# imm = 0xFFFFFFFF\n43: \tmovq\t%r14, %rdi\n46: \tmovq\t%rbx, %rsi\n49: \taddq\t$8, %rsp\n4d: \tpopq\t%rbx\n4e: \tpopq\t%r14\n50: \tjmp\t0x55 <conn_reserve_job+0x55>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_15__   TYPE_5__ ;\ntypedef  struct TYPE_14__   TYPE_4__ ;\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_15__ {int pending_timeout; int /*<<< orphan*/  reserved_jobs; } ;\nstruct TYPE_13__ {int /*<<< orphan*/  state; scalar_t__ ttr; scalar_t__ deadline_at; int /*<<< orphan*/  reserve_ct; } ;\nstruct TYPE_14__ {TYPE_5__* reserver; TYPE_3__ r; TYPE_2__* tube; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  reserved_ct; } ;\nstruct TYPE_12__ {TYPE_1__ stat; } ;\ntypedef  TYPE_4__ Job ;\ntypedef  TYPE_5__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Reserved ;\nint /*<<< orphan*/  conn_set_soonestjob (TYPE_5__*,TYPE_4__*) ;\nint /*<<< orphan*/  job_list_insert (int /*<<< orphan*/ *,TYPE_4__*) ;\nscalar_t__ nanoseconds () ;\n\nvoid\nconn_reserve_job(Conn *c, Job *j) {\nj->tube->stat.reserved_ct++;\nj->r.reserve_ct++;\n\nj->r.deadline_at = nanoseconds() + j->r.ttr;\nj->r.state = Reserved;\njob_list_insert(&c->reserved_jobs, j);\nj->reserver = c;\nc->pending_timeout = -1;\nconn_set_soonestjob(c, j);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  job_id; int /*<<< orphan*/  state; int /*<<< orphan*/  job_id_counter; int /*<<< orphan*/  job_id_counter_lock; int /*<<< orphan*/  job_id_counter_lock_lock; int /*<<< orphan*/  job_id_counter_lock_cond; } ;\nstruct TYPE_9__ {int /*<<< orphan*/ * conn; int /*<<< orphan*/  job_id; int /*<<< orphan*/  job_id_counter; int /*<<< orphan*/  job_id_counter_lock; int /*<<< orphan*/  job_id_counter_lock_lock; int /*<<< orphan*/  job_id_counter_lock_cond; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  job_id; int /*<<< orphan*/  state; int /*<<< orphan*/ * conn; } ;\ntypedef  TYPE_1__ job_t ;\ntypedef  TYPE_2__ conn_t ;\ntypedef  TYPE_3__ server_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_COND_SIGNAL (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_COND_WAIT (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_UNLOCK (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  PTHREAD_MUTEX_LOCK (int"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ckrespsub",
    "input":"\n0000000000000000 <ckrespsub>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tcallq\t0xc <ckrespsub+0xc>\nc: \tmovq\t%rax, %rbx\nf: \tmovq\t%rax, %rdi\n12: \tmovq\t%r14, %rsi\n15: \tcallq\t0x1a <ckrespsub+0x1a>\n1a: \tmovl\t$0, %esi\n1f: \tmovl\t%eax, %edi\n21: \tmovq\t%r14, %rdx\n24: \tmovq\t%rbx, %rcx\n27: \taddq\t$8, %rsp\n2b: \tpopq\t%rbx\n2c: \tpopq\t%r14\n2e: \tjmp\t0x33 <ckrespsub+0x33>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assertf (int /*<<< orphan*/ ,char*,char*,char*) ;\nchar* readline (int) ;\nint /*<<< orphan*/  strstr (char*,char*) ;\n\n__attribute__((used)) static void\nckrespsub(int fd, char *sub)\n{\nchar *line = readline(fd);\nassertf(strstr(line, sub), \"\\\"%s\\\" not in \\\"%s\\\"\", sub, line);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  u_char ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ckrespsub2 (int /*<<< orphan*/ *,char*,char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ckrespsub3 (int /*<<< orphan*/ *,char*,char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * ckrespsub4 (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  ckrespsub5 (int /*<<< orphan*/ *,char*,char*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void\nckrespsub(u_char *p, char *sub)\n{\nu_char *q;\n\nq = ckrespsub4(p, sub);\nckrespsub2(q, sub, \"2\", p);\nckrespsub3(q, sub, \"3\", p);\nckrespsub5(q, sub, \"5\", p);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_enter_drain_mode",
    "input":"\n0000000000000000 <enter_drain_mode>:\n0: \tpushq\t%rax\n1: \tcallq\t0x6 <enter_drain_mode+0x6>\n6: \tmovl\t$1, (%rip)    # 0x10 <enter_drain_mode+0x10>\n10: \tpopq\t%rax\n11: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  UNUSED_PARAMETER (int) ;\nint drain_mode ;\n\nvoid\nenter_drain_mode(int sig)\n{\nUNUSED_PARAMETER(sig);\ndrain_mode = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  flush_output () ;\nint /*<<< orphan*/  in_drain_mode ;\n\nvoid enter_drain_mode (void) {\nflush_output ();\nin_drain_mode = 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optp",
    "input":"\n0000000000000000 <cttest_optp>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optp+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optp+0x1c>\n1c: \tmovl\t(%rip), %edi  # 0x22 <cttest_optp+0x22>\n22: \tmovl\t$0, %esi\n27: \tcallq\t0x2c <cttest_optp+0x2c>\n2c: \txorl\t%edi, %edi\n2e: \ttestq\t%rax, %rax\n31: \tsete\t%dil\n35: \tcallq\t0x3a <cttest_optp+0x3a>\n3a: \taddq\t$24, %rsp\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  port; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_1__*,char**) ;\nTYPE_1__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,char*) ;\n\nvoid\ncttest_optp()\n{\nchar *args[] = {\n\"-p1234\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(strcmp(srv.port, \"1234\") == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  ct_test_opt_parse (char*,char**) ;\nint /*<<< orphan*/  ct_test_opt_usage ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static void cttest_optp(void)\n{\nchar *argv[] = { \"cttest\", \"-h\" };\n\nTEST_ptr(ct_test_opt_parse(\"cttest\", argv));\nTEST_true(ct_test_opt_usage == stderr);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optz_more_than_max",
    "input":"\n0000000000000000 <cttest_optz_more_than_max>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optz_more_than_max+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optz_more_than_max+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$1073741824, (%rip)# imm = 0x40000000\n# 0x28 <cttest_optz_more_than_max+0x28>\n28: \tsete\t%dil\n2c: \tcallq\t0x31 <cttest_optz_more_than_max+0x31>\n31: \taddq\t$24, %rsp\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint job_data_size_limit ;\nint /*<<< orphan*/  optparse (int /*<<< orphan*/ *,char**) ;\nint /*<<< orphan*/  srv ;\n\nvoid\ncttest_optz_more_than_max()\n{\nchar *args[] = {\n\"-z1073741825\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(job_data_size_limit == 1073741824);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_size_t_eq (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_optz_more_than_max ;\n\n__attribute__((used)) static int cttest_optz_more_than_max(void)\n{\nct_test_t *test;\n\nTEST_ptr(test = ct_test_optz_more_than_max);\nTEST_size_t_eq(1073741824, test->max);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_small_delay",
    "input":"\n0000000000000000 <cttest_small_delay>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_small_delay+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_small_delay+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_small_delay+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_small_delay+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_small_delay+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_small_delay()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 1 1 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fputs (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  stdout ;\n\n__attribute__((used)) static void cttest_small_delay(void)\n{\nFILE *fp;\n\nfp = fopen(\"/dev/null\", \"w\");\nfprintf(fp, \"small delay\\n\");\nfputs(\"small delay\\n\", fp);\nfclose(fp);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_util.c_vwarnx",
    "input":"\n0000000000000000 <vwarnx>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%edx, %r14d\n7: \tmovq\t%rsi, %rbp\na: \tmovq\t%rdi, %rbx\nd: \tmovl\t(%rip), %edi  # 0x13 <vwarnx+0x13>\n13: \tmovq\t(%rip), %rdx  # 0x1a <vwarnx+0x1a>\n1a: \tmovl\t$0, %esi\n1f: \tcallq\t0x24 <vwarnx+0x24>\n24: \ttestq\t%rbp, %rbp\n27: \tje\t0x52 <vwarnx+0x52>\n29: \tmovl\t(%rip), %edi  # 0x2f <vwarnx+0x2f>\n2f: \tmovq\t%rbp, %rsi\n32: \tmovl\t%r14d, %edx\n35: \tcallq\t0x3a <vwarnx+0x3a>\n3a: \ttestq\t%rbx, %rbx\n3d: \tje\t0x52 <vwarnx+0x52>\n3f: \tmovl\t(%rip), %edi  # 0x45 <vwarnx+0x45>\n45: \tmovl\t$0, %esi\n4a: \tmovq\t%rbx, %rdx\n4d: \tcallq\t0x52 <vwarnx+0x52>\n52: \tmovl\t(%rip), %esi  # 0x58 <vwarnx+0x58>\n58: \tmovl\t$10, %edi\n5d: \tpopq\t%rbx\n5e: \tpopq\t%r14\n60: \tpopq\t%rbp\n61: \tjmp\t0x66 <vwarnx+0x66>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  va_list ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char const*) ;\nint /*<<< orphan*/  fputc (char,int /*<<< orphan*/ ) ;\nchar* progname ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  vfprintf (int /*<<< orphan*/ ,char const*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nvwarnx(const char *err, const char *fmt, va_list args)\n{\nfprintf(stderr, \"%s: \", progname);\nif (fmt) {\nvfprintf(stderr, fmt, args);\nif (err) fprintf(stderr, \": %s\", err);\n}\nfputc('\\n', stderr);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,...) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  vfprintf (int /*<<< orphan*/ ,char const*,int) ;\nint /*<<< orphan*/  vprintf (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  vsnprintf (char*,int,char const*,int) ;\nint /*<<< orphan*/  warn ;\nint /*<<< orphan*/  warn_file ;\nint /*<<< orphan*/  warn_line ;\n\nvoid\nvwarnx(const char *fmt, const char *file, int line)\n{\nfprintf(stderr, \"warning: \");\nif (file != NULL)\nvfprintf(stderr, file, line);\nif (fmt != NULL)\nvprintf(fmt, warn);\nfprintf(stderr, \"\\n\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_count_cur_producers",
    "input":"\n0000000000000000 <count_cur_producers>:\n0: \tmovl\t(%rip), %eax  # 0x6 <count_cur_producers+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint cur_producer_ct ;\n\nint\ncount_cur_producers()\n{\nreturn cur_producer_ct;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint cur_producers ;\n\nint count_cur_producers (void) {\nreturn cur_producers;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_100_000_jobs",
    "input":"\n0000000000000000 <cttest_job_100_000_jobs>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %ebx  # 0x7 <cttest_job_100_000_jobs+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <cttest_job_100_000_jobs+0x11>\n11: \tmovl\t%ebx, %edi\n13: \tmovl\t%eax, %esi\n15: \tcallq\t0x1a <cttest_job_100_000_jobs+0x1a>\n1a: \tmovl\t$100000, %ebx # imm = 0x186A0\n1f: \tnop\n20: \tmovl\t(%rip), %r8d  # 0x27 <cttest_job_100_000_jobs+0x27>\n27: \txorl\t%edi, %edi\n29: \txorl\t%esi, %esi\n2b: \tmovl\t$1, %edx\n30: \txorl\t%ecx, %ecx\n32: \tcallq\t0x37 <cttest_job_100_000_jobs+0x37>\n37: \taddl\t$-1, %ebx\n3a: \tjne\t0x20 <cttest_job_100_000_jobs+0x20>\n3c: \txorl\t%eax, %eax\n3e: \tcallq\t0x43 <cttest_job_100_000_jobs+0x43>\n43: \txorl\t%edi, %edi\n45: \tcmpl\t$100000, %eax # imm = 0x186A0\n4a: \tsete\t%dil\n4e: \tmovl\t$0, %esi\n53: \tcallq\t0x58 <cttest_job_100_000_jobs+0x58>\n58: \tmovl\t$1, %ebx\n5d: \tnopl\t(%rax)\n60: \tmovl\t%ebx, %edi\n62: \tcallq\t0x67 <cttest_job_100_000_jobs+0x67>\n67: \tmovl\t%eax, %edi\n69: \tcallq\t0x6e <cttest_job_100_000_jobs+0x6e>\n6e: \taddl\t$1, %ebx\n71: \tcmpl\t$100001, %ebx # imm = 0x186A1\n77: \tjne\t0x60 <cttest_job_100_000_jobs+0x60>\n79: \tmovl\t(%rip), %ebx  # 0x7f <cttest_job_100_000_jobs+0x7f>\n7f: \txorl\t%eax, %eax\n81: \tcallq\t0x86 <cttest_job_100_000_jobs+0x86>\n86: \tmovl\t$0, %esi\n8b: \tmovl\t%ebx, %edi\n8d: \tmovl\t%eax, %edx\n8f: \tcallq\t0x94 <cttest_job_100_000_jobs+0x94>\n94: \txorl\t%eax, %eax\n96: \tcallq\t0x9b <cttest_job_100_000_jobs+0x9b>\n9b: \txorl\t%edi, %edi\n9d: \ttestl\t%eax, %eax\n9f: \tsete\t%dil\na3: \tmovl\t$0, %esi\na8: \tpopq\t%rbx\na9: \tjmp\t0xae <cttest_job_100_000_jobs+0xae>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  default_tube ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int) ;\nint get_all_jobs_used () ;\nint /*<<< orphan*/  job_find (int) ;\nint /*<<< orphan*/  job_free (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_job (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\nint /*<<< orphan*/  stderr ;\n\nvoid\ncttest_job_100_000_jobs()\n{\nint i;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\nfor (i = 0; i < 100000; i++) {\nmake_job(0, 0, 1, 0, default_tube);\n}\nassertf(get_all_jobs_used() == 100000, \"should match\");\n\nfor (i = 1; i <= 100000; i++) {\njob_free(job_find(i));\n}\nfprintf(stderr, \"get_all_jobs_used() => %zu\\n\", get_all_jobs_used());\nassertf(get_all_jobs_used() == 0, \"should match\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  C_ASSERT (int) ;\nint /*<<< orphan*/  CT_ASSERT (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CT_ASSERT_EQ (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CT_ASSERT_TRUE (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_job_new (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_job_queue_add (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_job_queue_get_size () ;\nint /*<<< orphan*/  ct_job_queue_init () ;\nint /*<<< orphan*/  ct_job_queue_run () ;\nint /*<<< orphan*/  ct_job_queue_wait () ;\nint /*<<< orphan*/  ct_job_queue_wait_all () ;\nint /*<<< orphan*/  ct_job_queue_wait_all_timeout (int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout (int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all (int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout (int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all (int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout (int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all (int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout (int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int) ;\nint /*<<< orphan*/  ct_job_queue_wait_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all_timeout_all (int,int,int,int,int,int,int,"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optVFVu",
    "input":"\n0000000000000000 <cttest_optVFVu>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optVFVu+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optVFVu+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$2, (%rip)    # 0x25 <cttest_optVFVu+0x25>\n25: \tsete\t%dil\n29: \tcallq\t0x2e <cttest_optVFVu+0x2e>\n2e: \txorl\t%edi, %edi\n30: \tcmpq\t$0, (%rip)    # 0x38 <cttest_optVFVu+0x38>\n38: \tsete\t%dil\n3c: \tcallq\t0x41 <cttest_optVFVu+0x41>\n41: \tmovl\t(%rip), %edi  # 0x47 <cttest_optVFVu+0x47>\n47: \tmovl\t$0, %esi\n4c: \tcallq\t0x51 <cttest_optVFVu+0x51>\n51: \txorl\t%edi, %edi\n53: \ttestq\t%rax, %rax\n56: \tsete\t%dil\n5a: \tcallq\t0x5f <cttest_optVFVu+0x5f>\n5f: \taddq\t$24, %rsp\n63: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ wantsync; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  user; TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nTYPE_2__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,char*) ;\nint verbose ;\n\nvoid\ncttest_optVFVu()\n{\nchar *args[] = {\n\"-VFVukr\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(verbose == 2);\nassert(srv.wal.wantsync == 0);\nassert(strcmp(srv.user, \"kr\") == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_uint_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ulong_eq (size_t,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_optVFVu ;\nint /*<<< orphan*/  ct_test_optVFVu_arg ;\nsize_t ct_test_optVFVu_arg_len ;\nint ct_test_optVFVu_arg_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_len ;\nint /*<<< orphan*/  ct_test_optVFVu_arg_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str_num_str ;\nint"
},
{
    "file:":"./beanstalkd/extr_conn.c_conntickat",
    "input":"\n0000000000000000 <conntickat>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdi, %rbx\na: \tmovl\t(%rip), %r15d # 0x11 <conntickat+0x11>\n11: \tcallq\t0x16 <conntickat+0x16>\n16: \tmovq\t%rax, %r14\n19: \tmovl\t(%rip), %ebp  # 0x1f <conntickat+0x1f>\n1f: \tmovq\t%rbx, %rdi\n22: \tcallq\t0x27 <conntickat+0x27>\n27: \ttestq\t%rax, %rax\n2a: \tje\t0x53 <conntickat+0x53>\n2c: \tmovq\t%rbx, %rdi\n2f: \tcallq\t0x34 <conntickat+0x34>\n34: \tnegl\t%ebp\n36: \txorl\t%ecx, %ecx\n38: \ttestq\t%r14, %r14\n3b: \tcmovel\t%ecx, %ebp\n3e: \taddl\t(%rax), %ebp\n40: \txorl\t%eax, %eax\n42: \tcallq\t0x47 <conntickat+0x47>\n47: \tsubl\t%eax, %ebp\n49: \tmovl\t$1, %eax\n4e: \tmovl\t%ebp, %r15d\n51: \tjmp\t0x55 <conntickat+0x55>\n53: \txorl\t%eax, %eax\n55: \tmovq\t(%rbx), %rcx\n58: \ttestq\t%rcx, %rcx\n5b: \tjs\t0x70 <conntickat+0x70>\n5d: \timull\t$1000000000, %ecx, %esi # imm = 0x3B9ACA00\n63: \tmovl\t%r15d, %edi\n66: \tcallq\t0x6b <conntickat+0x6b>\n6b: \tmovl\t%eax, %r15d\n6e: \tjmp\t0x74 <conntickat+0x74>\n70: \ttestl\t%eax, %eax\n72: \tje\t0x89 <conntickat+0x89>\n74: \txorl\t%eax, %eax\n76: \tcallq\t0x7b <conntickat+0x7b>\n7b: \taddl\t%r15d, %eax\n7e: \taddq\t$8, %rsp\n82: \tpopq\t%rbx\n83: \tpopq\t%r14\n85: \tpopq\t%r15\n87: \tpopq\t%rbp\n88: \tretq\n89: \txorl\t%eax, %eax\n8b: \tjmp\t0x7e <conntickat+0x7e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_5__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int int64 ;\nstruct TYPE_8__ {int deadline_at; } ;\nstruct TYPE_10__ {TYPE_1__ r; } ;\nstruct TYPE_9__ {scalar_t__ pending_timeout; } ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nint INT64_MAX ;\nint SAFETY_MARGIN ;\nscalar_t__ conn_waiting (TYPE_2__*) ;\nTYPE_5__* connsoonestjob (TYPE_2__*) ;\nscalar_t__ has_reserved_job (TYPE_2__*) ;\nint min (int,int) ;\nint nanoseconds () ;\n\n__attribute__((used)) static int64\nconntickat(Conn *c)\n{\nint margin = 0, should_timeout = 0;\nint64 t = INT64_MAX;\n\nif (conn_waiting(c)) {\nmargin = SAFETY_MARGIN;\n}\n\nif (has_reserved_job(c)) {\nt = connsoonestjob(c)->r.deadline_at - nanoseconds() - margin;\nshould_timeout = 1;\n}\nif (c->pending_timeout >= 0) {\nt = min(t, ((int64)c->pending_timeout) * 1000000000);\nshould_timeout = 1;\n}\n\nif (should_timeout) {\nreturn nanoseconds() + t;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ timeout; } ;\ntypedef  TYPE_1__ connection ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CLOCK_MONOTONIC ;\nint /*<<< orphan*/  CLOCK_REALTIME ;\nint /*<<< orphan*/  TIMEOUT_CONNECT ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_OK_FAIL ;\nint /*<<< orphan*/  TIMEOUT_CONNECT_RETRY_OK_OK_OK_OK_OK_"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_opts",
    "input":"\n0000000000000000 <cttest_opts>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_opts+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_opts+0x1c>\n1c: \txorl\t%edi, %edi\n1e: \tcmpl\t$1234, (%rip) # imm = 0x4D2\n# 0x28 <cttest_opts+0x28>\n28: \tsete\t%dil\n2c: \tcallq\t0x31 <cttest_opts+0x31>\n31: \taddq\t$24, %rsp\n35: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int filesize; } ;\nstruct TYPE_5__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nTYPE_2__ srv ;\n\nvoid\ncttest_opts()\n{\nchar *args[] = {\n\"-s1234\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(srv.wal.filesize == 1234);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_int_eq (int,int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_opts ;\nint /*<<< orphan*/  opt_ct_test_opts ;\n\n__attribute__((used)) static void cttest_opts(void)\n{\nint ret;\n\nret = opt_ct_test_opts(\"-ct_test_opts=0x1234\", &ct_test_opts);\nTEST_ptr(ret);\nTEST_int_eq(ct_test_opts, 0x1234);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_needfree",
    "input":"\n0000000000000000 <needfree>:\n0: \tpushq\t%rbx\n1: \tmovl\t%esi, %ebx\n3: \tmovq\t(%rdi), %rax\n6: \tcmpl\t%esi, (%rax)\n8: \tjge\t0x17 <needfree+0x17>\na: \tcallq\t0xf <needfree+0xf>\nf: \txorl\t%ecx, %ecx\n11: \ttestq\t%rax, %rax\n14: \tcmovel\t%ecx, %ebx\n17: \tmovl\t%ebx, %eax\n19: \tpopq\t%rbx\n1a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {TYPE_1__* tail; } ;\ntypedef  TYPE_2__ Wal ;\nstruct TYPE_5__ {int free; } ;\n\n/* Variables and functions */\nscalar_t__ makenextfile (TYPE_2__*) ;\n\n__attribute__((used)) static int\nneedfree(Wal *w, int n)\n{\nif (w->tail->free >= n) return n;\nif (makenextfile(w)) return n;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * free; } ;\ntypedef  TYPE_1__ lua_State ;\n\n/* Variables and functions */\nscalar_t__ lua_gettop (TYPE_1__*) ;\n\n__attribute__((used)) static int needfree (lua_State *L, int n) {\nreturn (n < 0 || n >= lua_gettop(L)) ? 0 : 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_ratio",
    "input":"\n0000000000000000 <ratio>:\n0: \tmovl\t4(%rdi), %ecx\n3: \taddl\t(%rdi), %ecx\n5: \tje\t0x14 <ratio+0x14>\n7: \tmovl\t8(%rdi), %eax\na: \timull\t16(%rdi), %eax\ne: \tsubl\t%ecx, %eax\n10: \tcltd\n11: \tidivl\t%ecx\n13: \tretq\n14: \txorl\t%eax, %eax\n16: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int int64 ;\nstruct TYPE_3__ {int alive; int resv; scalar_t__ filesize; scalar_t__ nfile; } ;\ntypedef  TYPE_1__ Wal ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int\nratio(Wal *w)\n{\nint64 n, d;\n\nd = w->alive + w->resv;\nn = (int64)w->nfile * (int64)w->filesize - d;\nif (!d) return 0;\nreturn n / d;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int nb_samples; int nb_frames; int nb_samples_max; int nb_frames_max; } ;\ntypedef  TYPE_1__ AVRational ;\n\n/* Variables and functions */\n\n__attribute__((used)) static int ratio(AVRational r)\n{\nif (r.nb_frames)\nreturn (r.nb_samples * r.nb_frames_max) / r.nb_frames;\nelse\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optlseparate",
    "input":"\n0000000000000000 <cttest_optlseparate>:\n0: \tsubq\t$24, %rsp\n4: \tmovq\t(%rip), %rax  # 0xb <cttest_optlseparate+0xb>\nb: \tmovq\t%rax, 16(%rsp)\n10: \tmovaps\t(%rip), %xmm0 # 0x17 <cttest_optlseparate+0x17>\n17: \tmovaps\t%xmm0, (%rsp)\n1b: \tmovq\t%rsp, %rsi\n1e: \tmovl\t$0, %edi\n23: \tcallq\t0x28 <cttest_optlseparate+0x28>\n28: \tmovl\t(%rip), %edi  # 0x2e <cttest_optlseparate+0x2e>\n2e: \tmovl\t$0, %esi\n33: \tcallq\t0x38 <cttest_optlseparate+0x38>\n38: \txorl\t%edi, %edi\n3a: \ttestq\t%rax, %rax\n3d: \tsete\t%dil\n41: \tcallq\t0x46 <cttest_optlseparate+0x46>\n46: \taddq\t$24, %rsp\n4a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  addr; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_1__*,char**) ;\nTYPE_1__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,char*) ;\n\nvoid\ncttest_optlseparate()\n{\nchar *args[] = {\n\"-l\",\n\"localhost\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(strcmp(srv.addr, \"localhost\") == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct option {char* name; int /*<<< orphan*/ * has_arg; int /*<<< orphan*/ * flag; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EXPECT_EQ (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  OPTION_ARG_NONE ;\nint /*<<< orphan*/  OPTION_ARG_REQ ;\nint /*<<< orphan*/  OPTION_FLAG_NONE ;\nint /*<<< orphan*/  ct_test (char*,struct option*) ;\nint /*<<< orphan*/  ct_test_fail (char*) ;\n\n__attribute__((used)) static void cttest_optlseparate(void)\n{\nstruct option opt = { \"opt\", &OPTION_ARG_REQ, &OPTION_FLAG_NONE };\n\nct_test(\"optlseparate\", &opt);\nEXPECT_EQ(0, ct_test_fail(\"optlseparate\"));\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_garbage_priority",
    "input":"\n0000000000000000 <cttest_garbage_priority>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_garbage_priority+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_garbage_priority+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_garbage_priority+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_garbage_priority+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_garbage_priority+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_garbage_priority()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put -1kkdj9djjkd9 0 100 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  BIO_s_mem () ;\n\n__attribute__((used)) static void cttest_garbage_priority(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\n\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"garbage\");\nBIO_printf(bio, \"gar"
},
{
    "file:":"./beanstalkd/extr_tube.c_tube_free",
    "input":"\n0000000000000000 <tube_free>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t$0, %edi\n9: \tmovq\t%rbx, %rsi\nc: \tcallq\t0x11 <tube_free+0x11>\n11: \tmovq\t16(%rbx), %rdi\n15: \tcallq\t0x1a <tube_free+0x1a>\n1a: \tmovq\t8(%rbx), %rdi\n1e: \tcallq\t0x23 <tube_free+0x23>\n23: \tmovq\t%rbx, %rdi\n26: \tcallq\t0x2b <tube_free+0x2b>\n2b: \tmovq\t%rbx, %rdi\n2e: \tpopq\t%rbx\n2f: \tjmp\t0x34 <tube_free+0x34>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {TYPE_3__* data; } ;\nstruct TYPE_7__ {TYPE_3__* data; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  waiting_conns; TYPE_2__ delay; TYPE_1__ ready; } ;\ntypedef  TYPE_3__ Tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_3__*) ;\nint /*<<< orphan*/  ms_clear (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ms_remove (int /*<<< orphan*/ *,TYPE_3__*) ;\nint /*<<< orphan*/  tubes ;\n\n__attribute__((used)) static void\ntube_free(Tube *t)\n{\nms_remove(&tubes, t);\nfree(t->ready.data);\nfree(t->delay.data);\nms_clear(&t->waiting_conns);\nfree(t);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  list; int /*<<< orphan*/  tube_list; int /*<<< orphan*/  tube_hash; } ;\ntypedef  TYPE_1__ tube_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_1__*) ;\nint /*<<< orphan*/  list_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  tube_hash_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  tube_list_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  zfree (TYPE_1__*,int) ;\n\nvoid\ntube_free(tube_t *tube)\n{\nzfree(tube, sizeof(tube_t));\ntube_hash_free(&tube->tube_hash);\ntube_list_free(&tube->tube_list);\nlist_free(&tube->list);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_darwin.c_sockinit",
    "input":"\n0000000000000000 <sockinit>:\n0: \tpushq\t%rbx\n1: \txorl\t%ebx, %ebx\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <sockinit+0xa>\na: \tmovl\t%eax, (%rip)  # 0x10 <sockinit+0x10>\n10: \tcmpl\t$-1, %eax\n13: \tjne\t0x24 <sockinit+0x24>\n15: \tmovl\t$0, %edi\n1a: \tcallq\t0x1f <sockinit+0x1f>\n1f: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\n24: \tmovl\t%ebx, %eax\n26: \tpopq\t%rbx\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint kq ;\nint kqueue () ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nsockinit(void)\n{\nkq = kqueue();\nif (kq == -1) {\ntwarn(\"kqueue\");\nreturn -1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  perror (char*) ;\nint socket (int,int,int) ;\nint /*<<< orphan*/  sockfd ;\n\nint sockinit(int domain, int type, int protocol)\n{\nint fd;\n\nfd = socket(domain, type, protocol);\nif (fd == -1) {\nperror(\"socket\");\nreturn -1;\n}\nsockfd = fd;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_remove_ready_job",
    "input":"\n0000000000000000 <remove_ready_job>:\n0: \tpushq\t%rbx\n1: \ttestq\t%rdi, %rdi\n4: \tje\t0x48 <remove_ready_job+0x48>\n6: \tmovq\t%rdi, %rbx\n9: \tmovq\t8(%rdi), %rax\nd: \tcmpq\t(%rip), %rax  # 0x14 <remove_ready_job+0x14>\n14: \tjne\t0x48 <remove_ready_job+0x48>\n16: \tmovq\t(%rbx), %rdi\n19: \taddq\t$4, %rdi\n1d: \tmovl\t24(%rbx), %esi\n20: \tcallq\t0x25 <remove_ready_job+0x25>\n25: \taddl\t$-1, (%rip)   # 0x2c <remove_ready_job+0x2c>\n2c: \tmovq\t16(%rbx), %rax\n30: \tcmpq\t(%rip), %rax  # 0x37 <remove_ready_job+0x37>\n37: \tjge\t0x4a <remove_ready_job+0x4a>\n39: \taddl\t$-1, (%rip)   # 0x40 <remove_ready_job+0x40>\n40: \tmovq\t(%rbx), %rax\n43: \taddl\t$-1, (%rax)\n46: \tjmp\t0x4a <remove_ready_job+0x4a>\n48: \txorl\t%ebx, %ebx\n4a: \tmovq\t%rbx, %rax\n4d: \tpopq\t%rbx\n4e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_12__   TYPE_7__ ;\ntypedef  struct TYPE_11__   TYPE_4__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_12__ {int /*<<< orphan*/  urgent_ct; } ;\nstruct TYPE_8__ {scalar_t__ state; scalar_t__ pri; } ;\nstruct TYPE_11__ {TYPE_2__* tube; TYPE_1__ r; int /*<<< orphan*/  heap_index; } ;\nstruct TYPE_10__ {int /*<<< orphan*/  urgent_ct; } ;\nstruct TYPE_9__ {TYPE_3__ stat; int /*<<< orphan*/  ready; } ;\ntypedef  TYPE_4__ Job ;\n\n/* Variables and functions */\nscalar_t__ Ready ;\nscalar_t__ URGENT_THRESHOLD ;\nTYPE_7__ global_stat ;\nint /*<<< orphan*/  heapremove (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ready_ct ;\n\n__attribute__((used)) static Job *\nremove_ready_job(Job *j)\n{\nif (!j || j->r.state != Ready)\nreturn NULL;\nheapremove(&j->tube->ready, j->heap_index);\nready_ct--;\nif (j->r.pri < URGENT_THRESHOLD) {\nglobal_stat.urgent_ct--;\nj->tube->stat.urgent_ct--;\n}\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * ready_jobs; int /*<<< orphan*/  ready_jobs_len; int /*<<< orphan*/  ready_jobs_cap; int /*<<< orphan*/ * ready_jobs_pos; int /*<<< orphan*/  ready_jobs_count; } ;\ntypedef  TYPE_1__ fz_context ;\ntypedef  int /*<<< orphan*/  fz_job_ready_cb ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fz_free (TYPE_1__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fz_free_job_ready_cb (int /*<<< orphan*/ ) ;\nscalar_t__ fz_job_ready_cb_free ;\nint /*<<< orphan*/  fz_job_ready_cb_list ;\nint /*<<< orphan*/  fz_job_ready_cb_list_len ;\nint /*<<< orphan*/  fz_job_ready_cb_list_pos ;\n\n__attribute__((used)) static fz_job_ready_cb *remove_ready_job(fz_context *ctx)\n{\nfz_job_ready_cb *job;\n\nif (!ctx)\nreturn NULL;\n\nif (ctx->ready_jobs_count == 0)\nreturn NULL;\n\njob = ctx->ready_jobs + ctx->ready_jobs_pos;\nfz_free(ctx, ctx->ready_jobs[ctx->ready_jobs_pos]);\nctx->ready_jobs_count--;\nif (ctx->ready_jobs_count == 0)\n{\nfz_free(ctx, ctx->ready_jobs);\nctx->ready_jobs = NULL;\nctx->ready_jobs_len = 0;\nctx->ready_jobs_cap = 0;\nctx->ready_jobs_pos = 0;\n}\nelse\n{\nctx->ready_jobs_pos++;\nif (ctx->ready_jobs_pos == ctx->ready_jobs_len)\n{\nfz_free(ctx, ctx->ready_jobs);\nctx->ready_jobs = NULL;\nctx->ready_jobs_len = 0;\nctx->ready_jobs_cap = 0;\nctx->ready_jobs_pos = 0;\n}\n}\n\nfz_job_ready_cb_list_len--;\nif (fz_job_ready_cb_list_len == 0)\n{\nfz_free(ctx, fz_job_ready_cb_list);\nfz_job_ready_cb_list = NULL;\nfz_job_ready_cb_list_pos = 0;\n}\nelse\n{\nfz_job_ready_cb_list_pos++;\nif (fz_job_ready_cb_list_pos == fz_job_ready_cb_list_len)\n{\nfz_free(ctx, fz_job_ready_cb_list);\nfz_job_ready_cb_list = NULL;\nfz_job_ready_cb_list_pos = 0;\nfz_job_ready_cb_list_len = 0;\n}\n}\n\nfz_job_ready_cb_list_count--;\nif (fz_job_ready_cb_list_count == 0)\n{\nfz_free_job_ready_cb(fz_job_ready_cb_list);\nfz_job_ready_cb_list = NULL;\nfz_job_ready_cb_list_pos = 0;\nfz_job_ready_cb_list_len = 0;\n}\n\nreturn job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_all_jobs_used",
    "input":"\n0000000000000000 <cttest_job_all_jobs_used>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovl\t(%rip), %ebx  # 0xa <cttest_job_all_jobs_used+0xa>\na: \tmovl\t$0, %edi\nf: \tcallq\t0x14 <cttest_job_all_jobs_used+0x14>\n14: \tmovl\t%ebx, %edi\n16: \tmovl\t%eax, %esi\n18: \tcallq\t0x1d <cttest_job_all_jobs_used+0x1d>\n1d: \tmovl\t(%rip), %r8d  # 0x24 <cttest_job_all_jobs_used+0x24>\n24: \txorl\t%edi, %edi\n26: \txorl\t%esi, %esi\n28: \tmovl\t$1, %edx\n2d: \txorl\t%ecx, %ecx\n2f: \tcallq\t0x34 <cttest_job_all_jobs_used+0x34>\n34: \tmovq\t%rax, %r14\n37: \txorl\t%eax, %eax\n39: \tcallq\t0x3e <cttest_job_all_jobs_used+0x3e>\n3e: \txorl\t%edi, %edi\n40: \tcmpl\t$1, %eax\n43: \tsete\t%dil\n47: \tmovl\t$0, %esi\n4c: \tcallq\t0x51 <cttest_job_all_jobs_used+0x51>\n51: \tmovl\t$10, %edi\n56: \tcallq\t0x5b <cttest_job_all_jobs_used+0x5b>\n5b: \tmovq\t%rax, %rbx\n5e: \txorl\t%eax, %eax\n60: \tcallq\t0x65 <cttest_job_all_jobs_used+0x65>\n65: \txorl\t%edi, %edi\n67: \tcmpl\t$1, %eax\n6a: \tsete\t%dil\n6e: \tmovl\t$0, %esi\n73: \tcallq\t0x78 <cttest_job_all_jobs_used+0x78>\n78: \tmovq\t%rbx, %rdi\n7b: \tcallq\t0x80 <cttest_job_all_jobs_used+0x80>\n80: \txorl\t%eax, %eax\n82: \tcallq\t0x87 <cttest_job_all_jobs_used+0x87>\n87: \txorl\t%edi, %edi\n89: \tcmpl\t$1, %eax\n8c: \tsete\t%dil\n90: \tmovl\t$0, %esi\n95: \tcallq\t0x9a <cttest_job_all_jobs_used+0x9a>\n9a: \tmovq\t%r14, %rdi\n9d: \tcallq\t0xa2 <cttest_job_all_jobs_used+0xa2>\na2: \txorl\t%eax, %eax\na4: \tcallq\t0xa9 <cttest_job_all_jobs_used+0xa9>\na9: \txorl\t%edi, %edi\nab: \ttestl\t%eax, %eax\nad: \tsete\t%dil\nb1: \tmovl\t$0, %esi\nb6: \taddq\t$8, %rsp\nba: \tpopq\t%rbx\nbb: \tpopq\t%r14\nbd: \tjmp\t0xc2 <cttest_job_all_jobs_used+0xc2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * allocate_job (int) ;\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  default_tube ;\nint get_all_jobs_used () ;\nint /*<<< orphan*/  job_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * make_job (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_all_jobs_used()\n{\nJob *j, *x;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\nj = make_job(0, 0, 1, 0, default_tube);\nassertf(get_all_jobs_used() == 1, \"should match\");\n\nx = allocate_job(10);\nassertf(get_all_jobs_used() == 1, \"should match\");\n\njob_free(x);\nassertf(get_all_jobs_used() == 1, \"should match\");\n\njob_free(j);\nassertf(get_all_jobs_used() == 0, \"should match\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  C_TRUE ;\nint /*<<< orphan*/  TEST_ASSERT (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ASSERT_EQUAL (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ASSERT_NOT_NULL (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_ASSERT_NULL (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_get_job_count (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_job_id (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_get_job_status (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_init (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_job_id ;\nint /*<<< orphan*/  ct_test_job_status ;\nint /*<<< orphan*/  ct_test_job_status_all_jobs_used ;\nint /*<<< orphan*/  ct_test_job_status_none_used ;\nint /*<<< orphan*/  ct_test_job_status_some_used ;\nint /*<<< orphan*/  ct_test_job_status_unused ;\nint /*<<< orphan*/  ct_test_name ;\nint /*<<< orphan*/  ct_test_run_job (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_set_job_status (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_uninit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_unused_job_id ;\nint /*<<< orphan*/  ct_test_used_job_id ;\nint /*<<< orphan*/  ct_test_used_job_id_2 ;\nint /*<<< orphan*/  ct_test_used_job_id_3 ;\nint /*<<< orphan*/  ct_test_used_job_id_4 ;\nint /*<<< orphan*/  ct_test_used_job_id_5 ;\nint /*<<< orphan*/  ct_test_used_job_id_6 ;\nint /*<<< orphan*/  ct_test_used_job_id_7 ;\nint /*<<< orphan*/  ct_test_used_job_id_8 ;\nint /*<<< orphan*/  ct_test_used_job_id_9 ;\nint /*<<< orphan*/  ct_test_used_job_id_10 ;\nint /*<<< orphan*/  ct_test_used_job_id_11 ;\nint /*<<< orphan*/  ct_test_used_job_id_12 ;\nint /*<<< orphan*/  ct_test_used_job_id_13 ;\nint /*<<< orphan*/  ct_test_used_job_id_14 ;\nint /*<<< orphan*/  ct_test_used_job_id_15 ;\nint /*<<< orphan*/  ct_test_used_job_id_16 ;\nint /*<<< orphan*/  ct_test_used_job_id_17 ;\nint /*<<< orphan*/  ct_test_used_job_id_18 ;\nint /*<<< orphan*/  ct_test_used_job_id_19 ;\nint /*<<< orphan*/  ct_test_used_job_id_20 ;\nint /*<<< orphan*/  ct_test_used_job_id_21 ;\nint /*<<< orphan*/  ct_test_used_job_id_22 ;\nint /*<<< orphan*/  ct_test_used_job_id_23 ;\nint /*<<< orphan*/  ct_test_used_job_id_24 ;\nint /*<<< orphan*/  ct_test_used_job_id_25 ;\nint /*<<< orphan*/  ct_test_used_job_id_26 ;\nint /*<<< orphan*/  ct_test_used_job_id_27 ;\nint /*<<< orphan*/  ct_test_used_job_id_28 ;\nint /*<<< orphan*/  ct_test_used_job_id_29 ;\nint /*<<< orphan*/  ct_test_used_job_id_30 ;\nint /*<<< orphan*/  ct_test_used_job_id_31 ;\nint /*<<< orphan*/  ct_test_used_job_id_32 ;\nint /*<<< orphan*/  ct_test_used_job_id_33 ;\nint /*<<< orphan*/  ct_test_used_job_id_34 ;\nint /*<<< orphan*/  ct_test_used_job_id_35 ;\nint /*<<< orphan*/  ct_test_used_job_id_36 ;\nint /*<<< orphan*/  ct_test_used_job_id_37 ;\nint /*<<< orphan*/  ct_test_used_job_id_38 ;\nint /*<<< orphan*/  ct_test_used_job_id_39 ;\nint /*<<< orphan*/  ct_test_used_job_id_40 ;\nint /*<<< orphan*/  ct_test_used_job_id_41 ;\nint /*<<< orphan*/  ct_test_used_job_id_42 ;\nint /*<<< orphan*/  ct_test_used_job_id_43 ;\nint /*<<< orphan*/  ct_test_used_job_id_44 ;\nint /*<<< orphan*/  ct_test_used_job_id_45 ;\nint /*<<< orphan*/  ct_test_used_job_id_46 ;\nint /*<<< orphan*/  ct_test_used_job_id_47 ;\nint /*<<< orphan*/  ct_test_used_job_id_48 ;\nint /*<<< orphan*/  ct_test_used_job_id_49 ;\nint /*<<< orphan*/  ct_test_used_job_id_50 ;\nint /*<<< orphan*/  ct_test_used_job_id_51 ;\nint /*<<< orphan*/  ct_test_used_job_id_52 ;\nint /*<<< orphan*/  ct_test_used_job_id_53 ;\nint /*<<< orphan*/  ct_test_used_job_id_54 ;\nint /*<<< orphan*/  ct_test_used_job_id_55 ;\nint /*<<< orphan*/  ct_test_used_job_id_56 ;\nint /*<<< orphan*/  ct_"
},
{
    "file:":"./beanstalkd/extr_walg.c_walgc",
    "input":"\n0000000000000000 <walgc>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t16(%rdi), %rbx\n8: \ttestq\t%rbx, %rbx\nb: \tje\t0x5f <walgc+0x5f>\nd: \tmovq\t%rdi, %r14\n10: \tjmp\t0x45 <walgc+0x45>\n12: \tnopw\t%cs:(%rax,%rax)\n1c: \tnopl\t(%rax)\n20: \taddl\t$-1, (%r14)\n24: \tmovq\t(%rbx), %rdi\n27: \tcallq\t0x2c <walgc+0x2c>\n2c: \tmovq\t(%rbx), %rdi\n2f: \tcallq\t0x34 <walgc+0x34>\n34: \tmovq\t%rbx, %rdi\n37: \tcallq\t0x3c <walgc+0x3c>\n3c: \tmovq\t16(%r14), %rbx\n40: \ttestq\t%rbx, %rbx\n43: \tje\t0x5f <walgc+0x5f>\n45: \tcmpl\t$0, 16(%rbx)\n49: \tjne\t0x5f <walgc+0x5f>\n4b: \tmovq\t8(%rbx), %rax\n4f: \tmovq\t%rax, 16(%r14)\n53: \tcmpq\t%rbx, 8(%r14)\n57: \tjne\t0x20 <walgc+0x20>\n59: \tmovq\t%rax, 8(%r14)\n5d: \tjmp\t0x20 <walgc+0x20>\n5f: \taddq\t$8, %rsp\n63: \tpopq\t%rbx\n64: \tpopq\t%r14\n66: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  nfile; TYPE_2__* tail; TYPE_2__* head; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_7__ {struct TYPE_7__* path; struct TYPE_7__* next; int /*<<< orphan*/  refs; } ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_2__*) ;\nint /*<<< orphan*/  unlink (TYPE_2__*) ;\n\nvoid\nwalgc(Wal *w)\n{\nFile *f;\n\nwhile (w->head && !w->head->refs) {\nf = w->head;\nw->head = f->next;\nif (w->tail == f) {\nw->tail = f->next; // also, f->next == NULL\n}\n\nw->nfile--;\nunlink(f->path);\nfree(f->path);\nfree(f);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  n; TYPE_1__* w; } ;\nstruct TYPE_4__ {struct TYPE_4__* next; } ;\ntypedef  TYPE_1__ Writer ;\ntypedef  TYPE_2__ WriterList ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_1__*) ;\n\n__attribute__((used)) static void walgc(WriterList *wl)\n{\nWriter *w;\n\nwhile (wl->w) {\nwl->n--;\nfree(wl->w->next);\nfree(wl->w);\nwl->w = wl->w->next;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_count_cur_conns",
    "input":"\n0000000000000000 <count_cur_conns>:\n0: \tmovl\t(%rip), %eax  # 0x6 <count_cur_conns+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint cur_conn_ct ;\n\nint\ncount_cur_conns()\n{\nreturn cur_conn_ct;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint cur_conns ;\n\nint count_cur_conns (void) {\nreturn cur_conns;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_conn_want_command",
    "input":"\n0000000000000000 <conn_want_command>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tmovl\t$114, %esi\n9: \tcallq\t0xe <conn_want_command+0xe>\ne: \tmovq\t16(%rbx), %rdi\n12: \ttestq\t%rdi, %rdi\n15: \tje\t0x28 <conn_want_command+0x28>\n17: \tmovq\t(%rdi), %rax\n1a: \tcmpq\t(%rip), %rax  # 0x21 <conn_want_command+0x21>\n21: \tjne\t0x28 <conn_want_command+0x28>\n23: \tcallq\t0x28 <conn_want_command+0x28>\n28: \txorps\t%xmm0, %xmm0\n2b: \tmovups\t%xmm0, 8(%rbx)\n2f: \tmovl\t(%rip), %eax  # 0x35 <conn_want_command+0x35>\n35: \tmovl\t%eax, (%rbx)\n37: \tpopq\t%rbx\n38: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ state; } ;\nstruct TYPE_8__ {TYPE_1__ r; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  state; scalar_t__ reply_sent; TYPE_3__* out_job; } ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nscalar_t__ Copy ;\nint /*<<< orphan*/  STATE_WANT_COMMAND ;\nint /*<<< orphan*/  epollq_add (TYPE_2__*,char) ;\nint /*<<< orphan*/  job_free (TYPE_3__*) ;\n\n__attribute__((used)) static void\nconn_want_command(Conn *c)\n{\nepollq_add(c, 'r');\n\n/* was this a peek or stats command? */\nif (c->out_job && c->out_job->r.state == Copy)\njob_free(c->out_job);\nc->out_job = NULL;\n\nc->reply_sent = 0; /* now that we're done, reset this */\nc->state = STATE_WANT_COMMAND;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ type; int /*<<< orphan*/ * out; int /*<<< orphan*/ * in; } ;\ntypedef  TYPE_1__ connection_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CMD_READ ;\nscalar_t__ CONN_TYPE_UNIX ;\nint /*<<< orphan*/  conn_read_in (TYPE_1__*) ;\nint /*<<< orphan*/  conn_write_out (TYPE_1__*) ;\nint /*<<< orphan*/  msg_debug (char*,int) ;\n\n__attribute__((used)) static void\nconn_want_command(connection_t *c)\n{\nmsg_debug(\"conn_want_command()\\n\");\n\nif (c->in != NULL && c->in->type == CONN_TYPE_UNIX)\n{\nconn_read_in(c);\n}\n\nc->out = NULL;\nc->type = CMD_READ;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_too_long_commandline",
    "input":"\n0000000000000000 <cttest_too_long_commandline>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_too_long_commandline+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_too_long_commandline+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_too_long_commandline+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_too_long_commandline+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_too_long_commandline+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_too_long_commandline+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_too_long_commandline+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_too_long_commandline+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_too_long_commandline+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_too_long_commandline+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_too_long_commandline+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_too_long_commandline+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_too_long_commandline+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_too_long_commandline+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_too_long_commandline+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tcallq\t0xb9 <cttest_too_long_commandline+0xb9>\nb9: \tmovl\t$0, %esi\nbe: \tmovl\t%ebx, %edi\nc0: \tpopq\t%rbx\nc1: \tjmp\t0xc6 <cttest_too_long_commandline+0xc6>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_too_long_commandline()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nint i;\nfor (i = 0; i < 10; i++)\nmustsend(fd, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); // 50 bytes\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n// Issue another command and check that reponse is not \"UNKNOWN_COMMAND\"\n// as described in issue #337\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  fputs (char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fwrite (char*,int,int,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  get_progname () ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  stdout ;\n\n__attribute__((used)) static void\ncttest_too_long_commandline(void)\n{\nFILE\t   *f;\n\nf = fopen(\"too_long_commandline.c\", \"w\");\n\nfprintf(f, \"#define NULL ((void*)0)\\n\");\nfprintf(f, \"#ifndef TRUE\\n#define TRUE 1\\n#define FALSE 0\\n#endif\\n\");\nfprintf(f, \"#include \\\"postgres.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_info.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_group.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_root.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_setting.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_status.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_version.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_xml.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_init.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_file.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_mem.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_error.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_parse.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_scan.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_lookup.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_scope.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_type.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_validate.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_check.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_merge.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_check.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_merge.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_check.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve_validate_merge_check_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply_apply.h\\\"\\n\");\nfprintf(f, \"#include \\\"common/config_schema_resolve"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_max_priority",
    "input":"\n0000000000000000 <cttest_max_priority>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_max_priority+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_max_priority+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_max_priority+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_max_priority+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_max_priority+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_max_priority()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 4294967295 0 100 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  BIO_write (int /*<<< orphan*/ ,char*,int) ;\n\n__attribute__((used)) static void cttest_max_priority(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\n\nBIO_write(bio, \"1\", 1);\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio, \"1\");\nBIO_printf(bio,"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_kickjob_buried",
    "input":"\n0000000000000000 <cttest_kickjob_buried>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_kickjob_buried+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_kickjob_buried+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_kickjob_buried+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_kickjob_buried+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_kickjob_buried+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_kickjob_buried+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_kickjob_buried+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_kickjob_buried+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_kickjob_buried+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_kickjob_buried+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_kickjob_buried+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_kickjob_buried+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_kickjob_buried+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_kickjob_buried+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_kickjob_buried+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tpopq\t%rbx\nb5: \tjmp\t0xba <cttest_kickjob_buried+0xba>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_kickjob_buried()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nmustsend(fd, \"reserve\\r\\n\");\nckresp(fd, \"RESERVED 1 1\\r\\n\");\nckresp(fd, \"A\\r\\n\");\nmustsend(fd, \"bury 1 0\\r\\n\");\nckresp(fd, \"BURIED\\r\\n\");\n\nmustsend(fd, \"kick-job 100\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\nmustsend(fd, \"kick-job 1\\r\\n\");\nckresp(fd, \"KICKED\\r\\n\");\nmustsend(fd, \"kick-job 1\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_connection_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_add_result (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_get_connection () ;\nint /*<<< orphan*/  ct_kick_job (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  ct_kick_job_id (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  ct_kick_job_pri (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  ct_kick_job_pri_id (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  ct_kick_job_pri_tube (int /*<<< orphan*/ ,int,char*) ;\nint /*<<< orphan*/  ct_kick_job_tube (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_id (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_pri (int /*<<< orphan*/ ,char*,int,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_pri_id (int /*<<< orphan*/ ,char*,int,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_pri_tube (int /*<<< orphan*/ ,char*,int,char*) ;\nint /*<<< orphan*/  ct_kick_job_tube_tube (int /*<<< orphan*/ ,char*,char*,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_tube_id (int /*<<< orphan*/ ,char*,char*,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_tube_pri (int /*<<< orphan*/ ,char*,char*,int,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_tube_pri_id (int /*<<< orphan*/ ,char*,char*,int,int) ;\nint /*<<< orphan*/  ct_kick_job_tube_tube_pri_tube (int /*<<< orphan*/ ,char*,char*,int,char*) ;\n\nvoid cttest_kickjob_buried(void) {\nct_connection_t *c = ct_get_connection();\nct_add_result(c, \"kickjob_buried\");\nct_kick_job(c, 0);\nct_add_result(c, \"kickjob_id\");\nct_kick_job_id(c, 0);\nct_add_result(c, \"kickjob_pri\");\nct_kick_job_pri(c, 0);\nct_add_result(c, \"kickjob_pri_id\");\nct_kick_job_pri_id(c, 0, 0);\nct_add_result(c, \"kickjob_pri_tube\");\nct_kick_job_pri_tube(c, 0, \"default\");\nct_add_result(c, \"kickjob_tube\");\nct_kick_job_tube(c, \"default\", 0);\nct_add_result(c, \"kickjob_tube_id\");\nct_kick_job_tube_id(c, \"default\", 0);\nct_add_result(c, \"kickjob_tube_pri\");\nct_kick_job_tube_pri(c, \"default\", 0, 0);\nct_add_result(c, \"kickjob_tube_pri_id\");\nct_kick_job_tube_pri_id(c, \"default\", 0, 0);\nct_add_result(c, \"kickjob_tube_pri_tube\");\nct_kick_job_tube_pri_tube(c, \"default\", 0, \"default\");\nct_add_result(c, \"kickjob_tube_tube\");\nct_kick_job_tube_tube(c, \"default\", \"default\", 0);\nct_add_result(c, \"kickjob_tube_tube_id\");\nct_kick_job_tube_tube_id(c, \"default\", \"default\", 0);\nct_add_result(c, \"kickjob_tube_tube_pri\");\nct_kick_job_tube_tube_pri(c, \"default\", \"default\", 0, 0);\nct_add_result(c, \"kickjob_tube_tube_pri_id\");\nct_kick_job_tube_tube_pri_id(c, \"default\", \"default\", 0, 0);\nct_add_result(c, \"kickjob_tube_tube_pri_tube\");\nct_kick_job_tube_tube_pri_tube(c, \"default\", \"default\", 0, \"default\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_hash_free",
    "input":"\n0000000000000000 <job_hash_free>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \tmovq\t(%rip), %r14  # 0xe <job_hash_free+0xe>\ne: \tmovl\t8(%rdi), %edi\n11: \tcallq\t0x16 <job_hash_free+0x16>\n16: \tleaq\t(%r14,%rax,8), %rax\n1a: \tnopw\t(%rax,%rax)\n20: \tmovq\t%rax, %rcx\n23: \tmovq\t(%rax), %rax\n26: \tcmpq\t%rbx, %rax\n29: \tje\t0x30 <job_hash_free+0x30>\n2b: \ttestq\t%rax, %rax\n2e: \tjne\t0x20 <job_hash_free+0x20>\n30: \ttestq\t%rax, %rax\n33: \tje\t0x42 <job_hash_free+0x42>\n35: \tmovq\t(%rax), %rax\n38: \tmovq\t%rax, (%rcx)\n3b: \taddl\t$-1, (%rip)   # 0x42 <job_hash_free+0x42>\n42: \tmovl\t(%rip), %eax  # 0x48 <job_hash_free+0x48>\n48: \tsarl\t$4, %eax\n4b: \tcmpl\t%eax, (%rip)  # 0x51 <job_hash_free+0x51>\n51: \tjge\t0x61 <job_hash_free+0x61>\n53: \txorl\t%edi, %edi\n55: \taddq\t$8, %rsp\n59: \tpopq\t%rbx\n5a: \tpopq\t%r14\n5c: \tjmp\t0x61 <job_hash_free+0x61>\n61: \taddq\t$8, %rsp\n65: \tpopq\t%rbx\n66: \tpopq\t%r14\n68: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  id; } ;\nstruct TYPE_6__ {struct TYPE_6__* ht_next; TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nsize_t _get_job_hash_index (int /*<<< orphan*/ ) ;\nTYPE_2__** all_jobs ;\nint all_jobs_cap ;\nint all_jobs_used ;\nint /*<<< orphan*/  rehash (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\njob_hash_free(Job *j)\n{\nJob **slot;\n\nslot = &all_jobs[_get_job_hash_index(j->r.id)];\nwhile (*slot && *slot != j) slot = &(*slot)->ht_next;\nif (*slot) {\n*slot = (*slot)->ht_next;\n--all_jobs_used;\n}\n\n// Downscale when the hashmap is too sparse\nif (all_jobs_used < (all_jobs_cap >> 4)) rehash(0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; int /*<<< orphan*/  job_id; } ;\ntypedef  TYPE_1__ job_hash_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  free (TYPE_1__*) ;\nsize_t hash_job_id (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  job_hash_count ;\nTYPE_1__* job_hash_head ;\n\n__attribute__((used)) static void\njob_hash_free (job_hash_t *job)\n{\njob_hash_t *prev = NULL;\njob_hash_t *cur = job_hash_head;\n\nwhile (cur != NULL)\n{\nif (cur == job)\n{\nif (prev == NULL)\n{\njob_hash_head = cur->next;\n}\nelse\n{\nprev->next = cur->next;\n}\n\nfree (cur);\njob_hash_count--;\n\nif (job_hash_count < (1 << (sizeof (job_hash_count) * 8 - 4)))\n{\nassert (0);\n}\n\nreturn;\n}\n\nprev = cur;\ncur = cur->next;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_util.c_zalloc",
    "input":"\n0000000000000000 <zalloc>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%edi, %ebp\n5: \tcallq\t0xa <zalloc+0xa>\na: \tmovq\t%rax, %rbx\nd: \ttestq\t%rax, %rax\n10: \tje\t0x1e <zalloc+0x1e>\n12: \tmovq\t%rbx, %rdi\n15: \txorl\t%esi, %esi\n17: \tmovl\t%ebp, %edx\n19: \tcallq\t0x1e <zalloc+0x1e>\n1e: \tmovq\t%rbx, %rax\n21: \taddq\t$8, %rsp\n25: \tpopq\t%rbx\n26: \tpopq\t%rbp\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nvoid* malloc (int) ;\nint /*<<< orphan*/  memset (void*,int /*<<< orphan*/ ,int) ;\n\nvoid*\nzalloc(int n)\n{\nvoid *p;\n\np = malloc(n);\nif (p) {\nmemset(p, 0, n);\n}\nreturn p;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nvoid* calloc (int,int) ;\nint /*<<< orphan*/  memset (void*,int /*<<< orphan*/ ,int) ;\n\nvoid *zalloc(int size)\n{\nvoid *ptr;\n\nptr = calloc(1, size);\nif (ptr)\nmemset(ptr, 0, size);\nreturn ptr;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_read_duration",
    "input":"\n0000000000000000 <read_duration>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rbx\n8: \tleaq\t8(%rsp), %rdi\nd: \tcallq\t0x12 <read_duration+0x12>\n12: \ttestl\t%eax, %eax\n14: \tjne\t0x20 <read_duration+0x20>\n16: \timull\t$1000000000, 8(%rsp), %ecx # imm = 0x3B9ACA00\n1e: \tmovl\t%ecx, (%rbx)\n20: \taddq\t$16, %rsp\n24: \tpopq\t%rbx\n25: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uint32 ;\ntypedef  int int64 ;\n\n/* Variables and functions */\nint read_u32 (scalar_t__*,char const*,char**) ;\n\n__attribute__((used)) static int\nread_duration(int64 *duration, const char *buf, char **end)\n{\nint r;\nuint32 dur_sec;\n\nr = read_u32(&dur_sec, buf, end);\nif (r)\nreturn r;\n*duration = ((int64) dur_sec) * 1000000000;\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  int64_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  av_parse_time (int*,char const*,char const*,int) ;\n\n__attribute__((used)) static int read_duration(int64_t *duration, const char *str, const char *key, int64_t time_base)\n{\nint ret;\n\nret = av_parse_time(duration, str, key, 1);\nif (ret < 0)\n*duration = time_base * 1000000000;\nreturn ret;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walsync",
    "input":"\n0000000000000000 <walsync>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <walsync+0xb>\nb: \tcmpq\t$0, 24(%rbx)\n10: \tje\t0x31 <walsync+0x31>\n12: \tmovq\t8(%rbx), %rcx\n16: \taddq\t(%rbx), %rcx\n19: \tcmpq\t%rcx, %rax\n1c: \tjl\t0x31 <walsync+0x31>\n1e: \tmovq\t%rax, (%rbx)\n21: \tmovq\t16(%rbx), %rax\n25: \tmovl\t(%rax), %edi\n27: \tcallq\t0x2c <walsync+0x2c>\n2c: \tcmpl\t$-1, %eax\n2f: \tje\t0x33 <walsync+0x33>\n31: \tpopq\t%rbx\n32: \tretq\n33: \tmovl\t$0, %edi\n38: \tpopq\t%rbx\n39: \tjmp\t0x3e <walsync+0x3e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ int64 ;\nstruct TYPE_5__ {scalar_t__ lastsync; scalar_t__ syncrate; TYPE_1__* cur; scalar_t__ wantsync; } ;\ntypedef  TYPE_2__ Wal ;\nstruct TYPE_4__ {int /*<<< orphan*/  fd; } ;\n\n/* Variables and functions */\nint fsync (int /*<<< orphan*/ ) ;\nscalar_t__ nanoseconds () ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static void\nwalsync(Wal *w)\n{\nint64 now;\n\nnow = nanoseconds();\nif (w->wantsync && now >= w->lastsync+w->syncrate) {\nw->lastsync = now;\nif (fsync(w->cur->fd) == -1) {\ntwarn(\"fsync\");\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ wal_last; scalar_t__ wal_size; int /*<<< orphan*/ * wal; scalar_t__ wal_fd; } ;\ntypedef  TYPE_1__ WalSnd ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  elog (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  fsync (int /*<<< orphan*/ ) ;\nscalar_t__ pg_atomic_read_u64 (scalar_t__*) ;\n\n__attribute__((used)) static void\nwalsync(WalSnd *walsnd)\n{\n/*\n* Update shared-memory state only when we've processed a block that's\n* been applied.\n*/\nif (pg_atomic_read_u64(&walsnd->wal_last) < walsnd->wal_size)\nreturn;\n\n/*\n* If we're at the end of the WAL, fsync() the last WAL segment to\n* ensure that the last block is on disk.  This is particularly\n* important since we won't have another chance to do this.\n*/\nif (walsnd->wal_fd < 0)\nreturn;\n\nif (fsync(walsnd->wal_fd) != 0)\nelog(ERROR, \"could not fsync log segment %s: %m\",\nwalsnd->wal->segname);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_linux.c_sockwant",
    "input":"\n0000000000000000 <sockwant>:\n0: \tsubq\t$24, %rsp\n4: \tmovl\t(%rdi), %eax\n6: \tmovl\t%eax, %ecx\n8: \torl\t%esi, %ecx\na: \tje\t0x21 <sockwant+0x21>\nc: \ttestl\t%esi, %esi\ne: \tje\t0x28 <sockwant+0x28>\n10: \ttestl\t%eax, %eax\n12: \tjne\t0x28 <sockwant+0x28>\n14: \tmovl\t$1, (%rdi)\n1a: \tmovl\t$0, %eax\n1f: \tjmp\t0x38 <sockwant+0x38>\n21: \txorl\t%eax, %eax\n23: \taddq\t$24, %rsp\n27: \tretq\n28: \ttestl\t%esi, %esi\n2a: \tmovl\t$0, %ecx\n2f: \tmovl\t$0, %eax\n34: \tcmovneq\t%rcx, %rax\n38: \tmovl\t(%rax), %eax\n3a: \txorps\t%xmm0, %xmm0\n3d: \tmovaps\t%xmm0, (%rsp)\n41: \tcmpl\t$119, %esi\n44: \tje\t0x55 <sockwant+0x55>\n46: \txorl\t%ecx, %ecx\n48: \tcmpl\t$114, %esi\n4b: \tjne\t0x5e <sockwant+0x5e>\n4d: \tmovl\t(%rip), %ecx  # 0x53 <sockwant+0x53>\n53: \tjmp\t0x5b <sockwant+0x5b>\n55: \tmovl\t(%rip), %ecx  # 0x5b <sockwant+0x5b>\n5b: \tmovl\t%ecx, (%rsp)\n5e: \tmovl\t(%rip), %edx  # 0x64 <sockwant+0x64>\n64: \torl\t(%rip), %edx  # 0x6a <sockwant+0x6a>\n6a: \torl\t%ecx, %edx\n6c: \tmovl\t%edx, (%rsp)\n6f: \tmovq\t%rdi, 8(%rsp)\n74: \tmovl\t(%rip), %esi  # 0x7a <sockwant+0x7a>\n7a: \tmovl\t4(%rdi), %edx\n7d: \tmovq\t%rsp, %rcx\n80: \tmovl\t%esi, %edi\n82: \tmovl\t%eax, %esi\n84: \tcallq\t0x89 <sockwant+0x89>\n89: \taddq\t$24, %rsp\n8d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {TYPE_2__* ptr; } ;\nstruct epoll_event {int events; TYPE_1__ data; } ;\nstruct TYPE_5__ {int added; int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_2__ Socket ;\n\n/* Variables and functions */\nint EPOLLIN ;\nint EPOLLOUT ;\nint EPOLLPRI ;\nint EPOLLRDHUP ;\nint EPOLL_CTL_ADD ;\nint EPOLL_CTL_DEL ;\nint EPOLL_CTL_MOD ;\nint /*<<< orphan*/  epfd ;\nint epoll_ctl (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,struct epoll_event*) ;\n\nint\nsockwant(Socket *s, int rw)\n{\nint op;\n\nif (!s->added && !rw) {\nreturn 0;\n} else if (!s->added && rw) {\ns->added = 1;\nop = EPOLL_CTL_ADD;\n} else if (!rw) {\nop = EPOLL_CTL_DEL;\n} else {\nop = EPOLL_CTL_MOD;\n}\n\nstruct epoll_event ev = {.events=0};\nswitch (rw) {\ncase 'r':\nev.events = EPOLLIN;\nbreak;\ncase 'w':\nev.events = EPOLLOUT;\nbreak;\n}\nev.events |= EPOLLRDHUP | EPOLLPRI;\nev.data.ptr = s;\n\nreturn epoll_ctl(epfd, op, s->fd, &ev);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; int /*<<< orphan*/  event; } ;\ntypedef  TYPE_1__ event_sock_t ;\ntypedef  int /*<<< orphan*/  event_t ;\ntypedef  int /*<<< orphan*/  event_io_t ;\ntypedef  int /*<<< orphan*/  event_io_callback_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EVENT_READ ;\nint /*<<< orphan*/  EVENT_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_READY ;\nint /*<<< orphan*/  EVENT_WRITE_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WANT ;\nint /*<<< orphan*/  EVENT_WRITE_WANT_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WANT_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WANT_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WANT_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WANT_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WANT_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WANT_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WANT_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WANT_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_HUP ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_READY ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_TIMEOUT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_WANT ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_CLOSE ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_ERROR ;\nint /*<<< orphan*/  EVENT_WRITE_WRITE_WRITE_WRITE_WRITE_WRITE_WANT_HUP ;\nint /*<<< orphan*/  E"
},
{
    "file:":"./beanstalkd/extr_walg.c_walresvput",
    "input":"\n0000000000000000 <walresvput>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovq\t8(%rsi), %rax\ne: \tmovl\t(%rax), %edi\n10: \tcallq\t0x15 <walresvput+0x15>\n15: \taddl\t(%rbx), %eax\n17: \tshlq\t$32, %rax\n1b: \tmovabsq\t$51539607552, %rsi # imm = 0xC00000000\n25: \taddq\t%rax, %rsi\n28: \tshrq\t$32, %rsi\n2c: \taddl\t$4, %esi\n2f: \tmovq\t%r14, %rdi\n32: \taddq\t$8, %rsp\n36: \tpopq\t%rbx\n37: \tpopq\t%r14\n39: \tjmp\t0x3e <walresvput+0x3e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Wal ;\nstruct TYPE_6__ {scalar_t__ body_size; } ;\nstruct TYPE_7__ {TYPE_2__ r; TYPE_1__* tube; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  name; } ;\ntypedef  int /*<<< orphan*/  Jobrec ;\ntypedef  TYPE_3__ Job ;\n\n/* Variables and functions */\nint reserve (int /*<<< orphan*/ *,int) ;\nscalar_t__ strlen (int /*<<< orphan*/ ) ;\n\nint\nwalresvput(Wal *w, Job *j)\n{\nint z = 0;\n\n// reserve space for the initial job record\nz += sizeof(int);\nz += strlen(j->tube->name);\nz += sizeof(Jobrec);\nz += j->r.body_size;\n\n// plus space for a delete to come later\nz += sizeof(int);\nz += sizeof(Jobrec);\n\nreturn reserve(w, z);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int len; int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__ WReserve ;\ntypedef  int /*<<< orphan*/  WAL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  walput (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void walresvput(WAL *wal, WReserve *resv){\nassert(resv->len == (int)resv->data[0]);\nwalput(wal, resv->len + (resv->len << 32) + 4);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_connsoonestjob",
    "input":"\n0000000000000000 <connsoonestjob>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t(%rdi), %rax\n8: \ttestq\t%rax, %rax\nb: \tjne\t0x3a <connsoonestjob+0x3a>\nd: \tmovq\t%rdi, %r14\n10: \tleaq\t8(%rdi), %r15\n14: \tmovq\t8(%rdi), %rbx\n18: \tcmpq\t%r15, %rbx\n1b: \tje\t0x38 <connsoonestjob+0x38>\n1d: \tnopl\t(%rax)\n20: \tmovq\t%r14, %rdi\n23: \tmovq\t%rbx, %rsi\n26: \tcallq\t0x2b <connsoonestjob+0x2b>\n2b: \tmovq\t(%rbx), %rbx\n2e: \tcmpq\t%r15, %rbx\n31: \tjne\t0x20 <connsoonestjob+0x20>\n33: \tmovq\t(%r14), %rax\n36: \tjmp\t0x3a <connsoonestjob+0x3a>\n38: \txorl\t%eax, %eax\n3a: \tpopq\t%rbx\n3b: \tpopq\t%r14\n3d: \tpopq\t%r15\n3f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_7__ {struct TYPE_7__* next; } ;\nstruct TYPE_8__ {TYPE_1__* soonest_job; TYPE_1__ reserved_jobs; } ;\ntypedef  TYPE_1__ Job ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  conn_set_soonestjob (TYPE_2__*,TYPE_1__*) ;\n\nJob *\nconnsoonestjob(Conn *c)\n{\n// use cached value and bail out.\nif (c->soonest_job != NULL)\nreturn c->soonest_job;\n\nJob *j = NULL;\nfor (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\nconn_set_soonestjob(c, j);\n}\nreturn c->soonest_job;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {struct TYPE_4__* next; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  connsoonestjob_job (TYPE_1__**,TYPE_1__*) ;\n\n__attribute__((used)) static job_t *connsoonestjob (job_t **jobs) {\njob_t *j;\n\nif (*jobs == NULL) {\nreturn NULL;\n}\n\nj = *jobs;\nwhile (j->next != *jobs) {\nconnsoonestjob_job (jobs, j->next);\nj = j->next;\n}\n\nreturn *jobs;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_do_stats",
    "input":"\n0000000000000000 <do_stats>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdx, %r15\na: \tmovq\t%rsi, %r14\nd: \tmovq\t%rdi, %rbx\n10: \txorl\t%edi, %edi\n12: \txorl\t%esi, %esi\n14: \tcallq\t*%r14\n17: \tmovl\t%eax, %ebp\n19: \taddl\t$16, %ebp\n1c: \tmovl\t%ebp, %edi\n1e: \tcallq\t0x23 <do_stats+0x23>\n23: \tmovq\t%rax, 8(%rbx)\n27: \ttestq\t%rax, %rax\n2a: \tje\t0x53 <do_stats+0x53>\n2c: \tmovl\t(%rip), %ecx  # 0x32 <do_stats+0x32>\n32: \tmovl\t%ecx, 4(%rax)\n35: \tmovq\t8(%rax), %rdi\n39: \tmovl\t%ebp, %esi\n3b: \tmovq\t%r15, %rdx\n3e: \tcallq\t*%r14\n41: \tmovq\t8(%rbx), %rcx\n45: \tmovl\t%eax, (%rcx)\n47: \tcmpl\t%ebp, %eax\n49: \tjle\t0x6b <do_stats+0x6b>\n4b: \tmovl\t(%rip), %esi  # 0x51 <do_stats+0x51>\n51: \tjmp\t0x59 <do_stats+0x59>\n53: \tmovl\t(%rip), %esi  # 0x59 <do_stats+0x59>\n59: \tmovq\t%rbx, %rdi\n5c: \taddq\t$8, %rsp\n60: \tpopq\t%rbx\n61: \tpopq\t%r14\n63: \tpopq\t%r15\n65: \tpopq\t%rbp\n66: \tjmp\t0x6b <do_stats+0x6b>\n6b: \tmovq\t$0, (%rbx)\n72: \tmovl\t(%rip), %esi  # 0x78 <do_stats+0x78>\n78: \taddl\t$-2, %eax\n7b: \tmovl\t$0, %edx\n80: \tmovq\t%rbx, %rdi\n83: \tmovl\t%eax, %ecx\n85: \taddq\t$8, %rsp\n89: \tpopq\t%rbx\n8a: \tpopq\t%r14\n8c: \tpopq\t%r15\n8e: \tpopq\t%rbp\n8f: \tjmp\t0x94 <do_stats+0x94>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_6__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int (* fmt_fn ) (int /*<<< orphan*/ *,int,void*) ;\nstruct TYPE_7__ {int body_size; int /*<<< orphan*/  state; } ;\nstruct TYPE_9__ {TYPE_1__ r; int /*<<< orphan*/ * body; } ;\nstruct TYPE_8__ {scalar_t__ out_job_sent; TYPE_6__* out_job; } ;\ntypedef  TYPE_2__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Copy ;\nint /*<<< orphan*/  MSG_INTERNAL_ERROR ;\nint /*<<< orphan*/  MSG_OUT_OF_MEMORY ;\nint /*<<< orphan*/  STATE_SEND_JOB ;\nTYPE_6__* allocate_job (int) ;\nint /*<<< orphan*/  reply_line (TYPE_2__*,int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  reply_serr (TYPE_2__*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\ndo_stats(Conn *c, fmt_fn fmt, void *data)\n{\nint r, stats_len;\n\n/* first, measure how big a buffer we will need */\nstats_len = fmt(NULL, 0, data) + 16;\n\nc->out_job = allocate_job(stats_len); /* fake job to hold stats data */\nif (!c->out_job) {\nreply_serr(c, MSG_OUT_OF_MEMORY);\nreturn;\n}\n\n/* Mark this job as a copy so it can be appropriately freed later on */\nc->out_job->r.state = Copy;\n\n/* now actually format the stats data */\nr = fmt(c->out_job->body, stats_len, data);\n/* and set the actual body size */\nc->out_job->r.body_size = r;\nif (r > stats_len) {\nreply_serr(c, MSG_INTERNAL_ERROR);\nreturn;\n}\n\nc->out_job_sent = 0;\nreply_line(c, STATE_SEND_JOB, \"OK %d\\r\\n\", r - 2);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * stats; int /*<<< orphan*/  type; int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__* GLog ;\ntypedef  int /*<<< orphan*/  (* GLogStatsFunc ) (int /*<<< orphan*/ *,int,int /*<<< orphan*/ *) ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GLOG_ERROR ;\nint /*<<< orphan*/  GLOG_STATS ;\nint /*<<< orphan*/  GLOG_STATS_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_OK ;\nint /*<<< orphan*/  GLOG_STATS_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_SHORT ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_ERROR ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_OK ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_TOO_LONG ;\nint /*<<< orphan*/  GLOG_STATS_UNKNOWN_TYPE_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN_UNKNOWN"
},
{
    "file:":"./beanstalkd/extr_testserv.c_set_sig_handler",
    "input":"\n0000000000000000 <set_sig_handler>:\n0: \tsubq\t$24, %rsp\n4: \tmovq\t$0, 16(%rsp)\nd: \tleaq\t12(%rsp), %rdi\n12: \tcallq\t0x17 <set_sig_handler+0x17>\n17: \tcmpl\t$-1, %eax\n1a: \tje\t0x42 <set_sig_handler+0x42>\n1c: \tmovl\t(%rip), %eax  # 0x22 <set_sig_handler+0x22>\n22: \tmovl\t%eax, 8(%rsp)\n26: \tmovl\t(%rip), %edi  # 0x2c <set_sig_handler+0x2c>\n2c: \tleaq\t8(%rsp), %rsi\n31: \txorl\t%edx, %edx\n33: \tcallq\t0x38 <set_sig_handler+0x38>\n38: \tcmpl\t$-1, %eax\n3b: \tje\t0x49 <set_sig_handler+0x49>\n3d: \taddq\t$24, %rsp\n41: \tretq\n42: \tmovl\t$0, %edi\n47: \tjmp\t0x4e <set_sig_handler+0x4e>\n49: \tmovl\t$0, %edi\n4e: \tcallq\t0x53 <set_sig_handler+0x53>\n53: \tmovl\t$111, %edi\n58: \tcallq\t0x5d <set_sig_handler+0x5d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sigaction {int /*<<< orphan*/  sa_handler; int /*<<< orphan*/  sa_mask; scalar_t__ sa_flags; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  exit_process ;\nint sigaction (int /*<<< orphan*/ ,struct sigaction*,int /*<<< orphan*/ ) ;\nint sigemptyset (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static void\nset_sig_handler()\n{\nstruct sigaction sa;\n\nsa.sa_flags = 0;\nint r = sigemptyset(&sa.sa_mask);\nif (r == -1) {\ntwarn(\"sigemptyset()\");\nexit(111);\n}\n\n// This is required to trigger gcov on exit. See issue #443.\nsa.sa_handler = exit_process;\nr = sigaction(SIGTERM, &sa, 0);\nif (r == -1) {\ntwarn(\"sigaction(SIGTERM)\");\nexit(111);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sigaction ;\n\n/* Variables and functions */\nint /*<<< orphan*/  EXIT_FAILURE ;\nint /*<<< orphan*/  SIGINT ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  signal (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  sig_handler ;\n\nvoid set_sig_handler(void)\n{\nsigaction sa;\n\nsa.sa_handler = sig_handler;\nsa.sa_flags = 0;\nif (sigaction(SIGINT, &sa, NULL) == -1) {\nperror(\"sigaction\");\nexit(EXIT_FAILURE);\n}\n\nif (signal(SIGINT, sig_handler) == SIG_ERR) {\nperror(\"signal\");\nexit(EXIT_FAILURE);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walresvmigrate",
    "input":"\n0000000000000000 <walresvmigrate>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovq\t8(%rsi), %rax\ne: \tmovl\t(%rax), %edi\n10: \tcallq\t0x15 <walresvmigrate+0x15>\n15: \tshlq\t$32, %rax\n19: \tmovabsq\t$34359738368, %rsi # imm = 0x800000000\n23: \taddq\t%rax, %rsi\n26: \tshrq\t$32, %rsi\n2a: \taddl\t(%rbx), %esi\n2c: \tmovq\t%r14, %rdi\n2f: \taddq\t$8, %rsp\n33: \tpopq\t%rbx\n34: \tpopq\t%r14\n36: \tjmp\t0x3b <walresvmigrate+0x3b>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_3__ ;\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  Wal ;\nstruct TYPE_6__ {scalar_t__ body_size; } ;\nstruct TYPE_7__ {TYPE_2__ r; TYPE_1__* tube; } ;\nstruct TYPE_5__ {int /*<<< orphan*/  name; } ;\ntypedef  int /*<<< orphan*/  Jobrec ;\ntypedef  TYPE_3__ Job ;\n\n/* Variables and functions */\nint reserve (int /*<<< orphan*/ *,int) ;\nscalar_t__ strlen (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int\nwalresvmigrate(Wal *w, Job *j)\n{\nint z = 0;\n\n// reserve only space for the migrated full job record\n// space for the delete is already reserved\nz += sizeof(int);\nz += strlen(j->tube->name);\nz += sizeof(Jobrec);\nz += j->r.body_size;\n\nreturn reserve(w, z);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  wal_id; int /*<<< orphan*/ * wal; } ;\ntypedef  TYPE_1__ WALReserveMigrate ;\ntypedef  int /*<<< orphan*/  WALReserve ;\n\n/* Variables and functions */\nint /*<<< orphan*/  walresvmigrate_cb (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static void\nwalresvmigrate(WALReserve *wr, WALReserveMigrate *wr_migrate)\n{\nwalresvmigrate_cb(wr, wr_migrate->wal_id + (((uint64) wr_migrate->wal->id) << 32));\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_0008",
    "input":"\n0000000000000000 <ctbench_put_delete_0008>:\n0: \tmovl\t$8, %esi\n5: \txorl\t%edx, %edx\n7: \txorl\t%ecx, %ecx\n9: \txorl\t%r8d, %r8d\nc: \tjmp\t0x11 <ctbench_put_delete_0008+0x11>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_0008(int n)\n{\nbench_put_delete_size(n, 8, 0, 0, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_bench_t ;\n\n/* Variables and functions */\nint ctbench_put_delete (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nint ctbench_put_delete_0008 (ct_bench_t *b) {\nreturn ctbench_put_delete (b, 8, 0, 0, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_make_job_with_id",
    "input":"\n0000000000000000 <make_job_with_id>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%r9, %rbp\ne: \tmovq\t%r8, %r14\n11: \tmovq\t%rdx, %r15\n14: \tmovq\t%rsi, %r12\n17: \tmovl\t%edi, %r13d\n1a: \tmovl\t%ecx, %edi\n1c: \tcallq\t0x21 <make_job_with_id+0x21>\n21: \tmovq\t%rax, %rbx\n24: \ttestq\t%rax, %rax\n27: \tje\t0x48 <make_job_with_id+0x48>\n29: \ttestq\t%rbp, %rbp\n2c: \tje\t0x54 <make_job_with_id+0x54>\n2e: \tmovq\t%rbp, 32(%rbx)\n32: \tcmpq\t%rbp, (%rip)  # 0x39 <make_job_with_id+0x39>\n39: \tjg\t0x6a <make_job_with_id+0x6a>\n3b: \taddq\t$1, %rbp\n3f: \tmovq\t%rbp, (%rip)  # 0x46 <make_job_with_id+0x46>\n46: \tjmp\t0x6a <make_job_with_id+0x6a>\n48: \tmovl\t$0, %edi\n4d: \tcallq\t0x52 <make_job_with_id+0x52>\n52: \tjmp\t0x88 <make_job_with_id+0x88>\n54: \tmovq\t(%rip), %rax  # 0x5b <make_job_with_id+0x5b>\n5b: \tleaq\t1(%rax), %rcx\n5f: \tmovq\t%rcx, (%rip)  # 0x66 <make_job_with_id+0x66>\n66: \tmovq\t%rax, 32(%rbx)\n6a: \tmovl\t%r13d, 24(%rbx)\n6e: \tmovq\t%r12, 16(%rbx)\n72: \tmovq\t%r15, 8(%rbx)\n76: \tmovq\t%rbx, %rdi\n79: \tcallq\t0x7e <make_job_with_id+0x7e>\n7e: \tmovl\t(%rbx), %edi\n80: \tmovq\t%r14, %rsi\n83: \tcallq\t0x88 <make_job_with_id+0x88>\n88: \tmovq\t%rbx, %rax\n8b: \taddq\t$8, %rsp\n8f: \tpopq\t%rbx\n90: \tpopq\t%r12\n92: \tpopq\t%r13\n94: \tpopq\t%r14\n96: \tpopq\t%r15\n98: \tpopq\t%rbp\n99: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  scalar_t__ uint64 ;\ntypedef  int /*<<< orphan*/  uint32 ;\ntypedef  void* int64 ;\ntypedef  int /*<<< orphan*/  Tube ;\nstruct TYPE_6__ {void* ttr; void* delay; int /*<<< orphan*/  pri; scalar_t__ id; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  tube; TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nTYPE_2__* allocate_job (int) ;\nscalar_t__ next_id ;\nint /*<<< orphan*/  store_job (TYPE_2__*) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\nJob *\nmake_job_with_id(uint32 pri, int64 delay, int64 ttr,\nint body_size, Tube *tube, uint64 id)\n{\nJob *j;\n\nj = allocate_job(body_size);\nif (!j) {\ntwarnx(\"OOM\");\nreturn (Job *) 0;\n}\n\nif (id) {\nj->r.id = id;\nif (id >= next_id) next_id = id + 1;\n} else {\nj->r.id = next_id++;\n}\nj->r.pri = pri;\nj->r.delay = delay;\nj->r.ttr = ttr;\n\nstore_job(j);\n\nTUBE_ASSIGN(j->tube, tube);\n\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {int /*<<< orphan*/  job_id; int /*<<< orphan*/  job_type; int /*<<< orphan*/ * job_data; int /*<<< orphan*/ * job_name; int /*<<< orphan*/  job_id_num; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  job_id; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  job_id; } ;\ntypedef  TYPE_1__ GLogJob ;\ntypedef  TYPE_2__ GLogJobWithId ;\ntypedef  TYPE_3__ GLogJobWithIdAndName ;\ntypedef  int /*<<< orphan*/  GLogJobType ;\ntypedef  int /*<<< orphan*/  GLogJobData ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GLogJobType_JobWithIdAndName ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndName ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndNameAndData ;\nint /*<<< orphan*/  GLogJobType_JobWithIdAndNameAndNameAndNameAndNameAndName"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_statsjob_ck_format",
    "input":"\n0000000000000000 <cttest_statsjob_ck_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_statsjob_ck_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_statsjob_ck_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_statsjob_ck_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_statsjob_ck_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_statsjob_ck_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_statsjob_ck_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_statsjob_ck_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_statsjob_ck_format+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_statsjob_ck_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"stats-job 111ABC\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"stats-job 111 222\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"stats-job 111\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  get_statsjob_ck_format () ;\n\nvoid cttest_statsjob_ck_format(void) {\nFILE *f = fopen(\"statsjob_ck_format.txt\", \"w\");\nfprintf(f, \"%s\", get_statsjob_ck_format());\nfprintf(f, \"\\n\");\nfprintf(f, \"--------------------------------------------------------------------------------\\n\");\nfprintf(f, \"%s\", get_statsjob_ck_format());\nfprintf(f, \"\\n\");\nfprintf(f, \"--------------------------------------------------------------------------------\\n\");\nfprintf(f, \"%s\", get_statsjob_ck_format());\nfprintf(f, \"\\n\");\nfprintf(f, \"--------------------------------------------------------------------------------\\n\");\nfprintf(f, \"%s\", get_statsjob_ck_format());\nfprintf(f, \"\\n\");\nfprintf(f, \"--------------------------------------------------------------------------------\\n\");\nfprintf(f, \"%s\", get_statsjob_ck_format());\nfprintf(f, \"\\n\");\nfclose(f);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optV_V",
    "input":"\n0000000000000000 <cttest_optV_V>:\n0: \tsubq\t$24, %rsp\n4: \tmovq\t(%rip), %rax  # 0xb <cttest_optV_V+0xb>\nb: \tmovq\t%rax, 16(%rsp)\n10: \tmovaps\t(%rip), %xmm0 # 0x17 <cttest_optV_V+0x17>\n17: \tmovaps\t%xmm0, (%rsp)\n1b: \tmovq\t%rsp, %rsi\n1e: \tmovl\t$0, %edi\n23: \tcallq\t0x28 <cttest_optV_V+0x28>\n28: \txorl\t%edi, %edi\n2a: \tcmpl\t$2, (%rip)    # 0x31 <cttest_optV_V+0x31>\n31: \tsete\t%dil\n35: \tcallq\t0x3a <cttest_optV_V+0x3a>\n3a: \taddq\t$24, %rsp\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (int /*<<< orphan*/ *,char**) ;\nint /*<<< orphan*/  srv ;\nint verbose ;\n\nvoid\ncttest_optV_V()\n{\nchar *args[] = {\n\"-V\",\n\"-V\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(verbose == 2);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct option {char* name; int /*<<< orphan*/ * has_arg; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  ct_test_optV (char*,struct option*) ;\nint /*<<< orphan*/  opt_V ;\nint /*<<< orphan*/  test_optV ;\n\n__attribute__((used)) static void cttest_optV_V(void)\n{\nstruct option optV[] = {\n{ \"V\", &opt_V, 0, \"test\" },\n{ NULL, NULL, 0, NULL }\n};\n\nct_test_optV(\"-V\", optV);\nTEST_true(test_optV == 2);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_kickjob_delayed",
    "input":"\n0000000000000000 <cttest_kickjob_delayed>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_kickjob_delayed+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_kickjob_delayed+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_kickjob_delayed+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_kickjob_delayed+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_kickjob_delayed+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_kickjob_delayed+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_kickjob_delayed+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_kickjob_delayed+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_kickjob_delayed+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_kickjob_delayed+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_kickjob_delayed+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_kickjob_delayed+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_kickjob_delayed+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tpopq\t%rbx\n9d: \tjmp\t0xa2 <cttest_kickjob_delayed+0xa2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_kickjob_delayed()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\n// jid=1 - no delay, jid=2 - delay\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"put 0 10 1 1\\r\\n\");\nmustsend(fd, \"B\\r\\n\");\nckresp(fd, \"INSERTED 2\\r\\n\");\n\nmustsend(fd, \"kick-job 1\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\nmustsend(fd, \"kick-job 2\\r\\n\");\nckresp(fd, \"KICKED\\r\\n\");\nmustsend(fd, \"kick-job 2\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  lua_pushboolean (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  lua_pushnil (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_pushstring (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  lua_settop (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lua_tostring (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  lua_type (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  lua_yield (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  test_kickjob_delayed (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void cttest_kickjob_delayed (lua_State *L) {\nlua_settop(L, 0);\nlua_pushnil(L);\nlua_pushstring(L, \"kickjob_delayed\");\nlua_pushstring(L, \"function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \"expected function\");\nlua_pushstring(L, \""
},
{
    "file:":"./beanstalkd/extr_job.c__get_job_hash_index",
    "input":"\n0000000000000000 <_get_job_hash_index>:\n0: \tmovl\t%edi, %eax\n2: \tcltd\n3: \tidivl\t(%rip)   # 0x9 <_get_job_hash_index+0x9>\n9: \tmovl\t%edx, %eax\nb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint64 ;\n\n/* Variables and functions */\nint all_jobs_cap ;\n\n__attribute__((used)) static int\n_get_job_hash_index(uint64 job_id)\n{\nreturn job_id % all_jobs_cap;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint JOB_HASH_SIZE ;\n\nint _get_job_hash_index (int job_id) {\nreturn job_id % JOB_HASH_SIZE;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_delete_reserved_by_other",
    "input":"\n0000000000000000 <cttest_delete_reserved_by_other>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <cttest_delete_reserved_by_other+0xa>\na: \tmovl\t%eax, %ebp\nc: \tmovl\t%eax, %edi\ne: \tcallq\t0x13 <cttest_delete_reserved_by_other+0x13>\n13: \tmovl\t%eax, %ebx\n15: \tmovl\t$0, %esi\n1a: \tmovl\t%eax, %edi\n1c: \tcallq\t0x21 <cttest_delete_reserved_by_other+0x21>\n21: \tmovl\t$0, %esi\n26: \tmovl\t%ebx, %edi\n28: \tcallq\t0x2d <cttest_delete_reserved_by_other+0x2d>\n2d: \tmovl\t$0, %esi\n32: \tmovl\t%ebx, %edi\n34: \tcallq\t0x39 <cttest_delete_reserved_by_other+0x39>\n39: \tmovl\t%ebp, %edi\n3b: \tcallq\t0x40 <cttest_delete_reserved_by_other+0x40>\n40: \tmovl\t%eax, %ebp\n42: \tmovl\t$0, %esi\n47: \tmovl\t%eax, %edi\n49: \tcallq\t0x4e <cttest_delete_reserved_by_other+0x4e>\n4e: \tmovl\t$0, %esi\n53: \tmovl\t%ebp, %edi\n55: \tcallq\t0x5a <cttest_delete_reserved_by_other+0x5a>\n5a: \tmovl\t$0, %esi\n5f: \tmovl\t%ebp, %edi\n61: \tcallq\t0x66 <cttest_delete_reserved_by_other+0x66>\n66: \tmovl\t$0, %esi\n6b: \tmovl\t%ebx, %edi\n6d: \tcallq\t0x72 <cttest_delete_reserved_by_other+0x72>\n72: \tmovl\t$0, %esi\n77: \tmovl\t%ebx, %edi\n79: \taddq\t$8, %rsp\n7d: \tpopq\t%rbx\n7e: \tpopq\t%rbp\n7f: \tjmp\t0x84 <cttest_delete_reserved_by_other+0x84>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_delete_reserved_by_other()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nint o = mustdiallocal(port);\nmustsend(o, \"reserve\\r\\n\");\nckresp(o, \"RESERVED 1 1\\r\\n\");\nckresp(o, \"a\\r\\n\");\n\nmustsend(fd, \"delete 1\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GModule ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_module_close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_module_symbol (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  g_test_add_data_func (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_init (int*,char***) ;\nint /*<<< orphan*/  g_test_skip (char*) ;\nint /*<<< orphan*/  g_test_subprocess () ;\nint /*<<< orphan*/  g_test_trap_fork (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_subprocess (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_subprocess_validate_and_fail (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_fail (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_pass (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_skip (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_fail (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_pass (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_skip (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_fail (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_pass (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_skip (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_fail (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_pass (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_skip (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_fail (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_pass (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_skip (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap_subprocess_validate_and_trap (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_test_trap_validate_and_trap_subprocess"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_touch_bad_format",
    "input":"\n0000000000000000 <cttest_touch_bad_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_touch_bad_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_touch_bad_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_touch_bad_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_touch_bad_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_touch_bad_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_touch_bad_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_touch_bad_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_touch_bad_format+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_touch_bad_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"touch a111\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"touch 111a\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"touch !@#!@#\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  touch_file (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void cttest_touch_bad_format(void)\n{\nFILE *f;\n\nf = fopen(\"test.txt\", \"w\");\ntouch_file(f);\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nfprintf(f, \"test\");\nf"
},
{
    "file:":"./beanstalkd/extr_prot.c_soonest_delayed_job",
    "input":"\n0000000000000000 <soonest_delayed_job>:\n0: \tmovq\t(%rip), %rcx  # 0x7 <soonest_delayed_job+0x7>\n7: \ttestq\t%rcx, %rcx\na: \tje\t0x4d <soonest_delayed_job+0x4d>\nc: \tmovq\t(%rip), %r8   # 0x13 <soonest_delayed_job+0x13>\n13: \txorl\t%eax, %eax\n15: \txorl\t%esi, %esi\n17: \tjmp\t0x2c <soonest_delayed_job+0x2c>\n19: \tnopl\t(%rax)\n20: \tmovq\t%rdi, %rax\n23: \taddq\t$1, %rsi\n27: \tcmpq\t%rcx, %rsi\n2a: \tjae\t0x4c <soonest_delayed_job+0x4c>\n2c: \tmovq\t(%r8,%rsi,8), %rdi\n30: \tcmpq\t$0, (%rdi)\n34: \tje\t0x23 <soonest_delayed_job+0x23>\n36: \tmovq\t8(%rdi), %rdi\n3a: \tmovq\t(%rdi), %rdi\n3d: \ttestq\t%rax, %rax\n40: \tje\t0x20 <soonest_delayed_job+0x20>\n42: \tmovq\t(%rdi), %rdx\n45: \tcmpq\t(%rax), %rdx\n48: \tjl\t0x20 <soonest_delayed_job+0x20>\n4a: \tjmp\t0x23 <soonest_delayed_job+0x23>\n4c: \tretq\n4d: \txorl\t%eax, %eax\n4f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_4__ ;\ntypedef  struct TYPE_9__   TYPE_3__ ;\ntypedef  struct TYPE_8__   TYPE_2__ ;\ntypedef  struct TYPE_7__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {scalar_t__ len; TYPE_4__** data; } ;\nstruct TYPE_9__ {TYPE_2__ delay; } ;\ntypedef  TYPE_3__ Tube ;\nstruct TYPE_11__ {size_t len; TYPE_3__** items; } ;\nstruct TYPE_7__ {scalar_t__ deadline_at; } ;\nstruct TYPE_10__ {TYPE_1__ r; } ;\ntypedef  TYPE_4__ Job ;\n\n/* Variables and functions */\nTYPE_5__ tubes ;\n\n__attribute__((used)) static Job *\nsoonest_delayed_job()\n{\nJob *j = NULL;\nsize_t i;\n\nfor (i = 0; i < tubes.len; i++) {\nTube *t = tubes.items[i];\nif (t->delay.len == 0) {\ncontinue;\n}\nJob *nj = t->delay.data[0];\nif (!j || nj->r.deadline_at < j->r.deadline_at)\nj = nj;\n}\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ time; } ;\nstruct TYPE_3__ {scalar_t__ time; TYPE_2__* job; } ;\ntypedef  TYPE_1__ delayed_job_t ;\n\n/* Variables and functions */\nscalar_t__ delayed_jobs_count ;\nTYPE_1__* delayed_jobs ;\n\ndelayed_job_t *soonest_delayed_job (void) {\ndelayed_job_t *job = NULL;\nint i;\nfor (i = 0; i < delayed_jobs_count; i++) {\nif (delayed_jobs[i].job && delayed_jobs[i].job->time > 0) {\nif (!job || delayed_jobs[i].job->time < job->time) {\njob = delayed_jobs[i].job;\n}\n}\n}\nreturn job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_fileaddjob",
    "input":"\n0000000000000000 <fileaddjob>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tjne\t0xe <fileaddjob+0xe>\n8: \tmovq\t%rdi, (%rdi)\nb: \tmovq\t%rdi, %rax\ne: \tmovq\t%rdi, 16(%rsi)\n12: \tmovq\t%rax, (%rsi)\n15: \tmovq\t%rdi, 8(%rsi)\n19: \tmovq\t(%rdi), %rax\n1c: \tmovq\t%rsi, 8(%rax)\n20: \tmovq\t%rsi, (%rdi)\n23: \tjmp\t0x28 <fileaddjob+0x28>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {struct TYPE_6__* fprev; struct TYPE_6__* fnext; TYPE_2__* file; } ;\nstruct TYPE_7__ {TYPE_1__ jlist; } ;\ntypedef  TYPE_1__ Job ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fileincref (TYPE_2__*) ;\n\nvoid\nfileaddjob(File *f, Job *j)\n{\nJob *h;\n\nh = &f->jlist;\nif (!h->fprev) h->fprev = h;\nj->file = f;\nj->fprev = h->fprev;\nj->fnext = h;\nh->fprev->fnext = j;\nh->fprev = j;\nfileincref(f);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* next; } ;\nstruct TYPE_9__ {TYPE_3__* next; TYPE_3__* prev; } ;\nstruct TYPE_8__ {TYPE_3__* next; } ;\ntypedef  TYPE_1__ GFile ;\ntypedef  TYPE_2__ GFileJob ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_file_job_queue_changed (TYPE_1__*) ;\n\n__attribute__((used)) static void\nfileaddjob (GFile *file, GFileJob *job)\n{\nif (file->jobs == NULL)\nfile->jobs = job;\n\njob->prev = file->jobs->prev;\njob->next = file->jobs;\nfile->jobs->prev->next = job;\nfile->jobs->prev = job;\n\ng_file_job_queue_changed (file);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_peek_bad_format",
    "input":"\n0000000000000000 <cttest_peek_bad_format>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_peek_bad_format+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_peek_bad_format+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_peek_bad_format+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_peek_bad_format+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_peek_bad_format+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_peek_bad_format+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_peek_bad_format+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_peek_bad_format+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_peek_bad_format+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tpopq\t%rbx\n6d: \tjmp\t0x72 <cttest_peek_bad_format+0x72>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_peek_bad_format()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"peek 18446744073709551616\\r\\n\"); // UINT64_MAX+1\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"peek 184467440737095516160000000000000000000000000000\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"peek foo111\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nmustsend(fd, \"peek 111foo\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  TEST_error (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_true (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int cttest_peek_bad_format(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\n\nTEST_ptr(bio);\nTEST_error(bio, \"BIO_new\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio, \"bad format\"));\nTEST_error(bio, \"BIO_printf\");\nTEST_true(BIO_printf(bio,"
},
{
    "file:":"./beanstalkd/extr_heap.c_set",
    "input":"\n0000000000000000 <set>:\n0: \tmovq\t8(%rdi), %rax\n4: \tmovq\t%rdx, (%rax,%rsi,8)\n8: \tmovq\t(%rdi), %rax\nb: \tmovq\t%rdx, %rdi\ne: \tjmpq\t*%rax",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  (* setpos ) (void*,size_t) ;void** data; } ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nint /*<<< orphan*/  stub1 (void*,size_t) ;\n\n__attribute__((used)) static void\nset(Heap *h, size_t k, void *x)\n{\nh->data[k] = x;\nh->setpos(x, k);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  (* set ) (void*,size_t,void*) ;void** data; } ;\ntypedef  TYPE_1__ lua_State ;\n\n/* Variables and functions */\nint /*<<< orphan*/  stub1 (void*,size_t,void*) ;\n\n__attribute__((used)) static void set (lua_State *L, size_t idx, void *p) {\nL->data[idx] = p;\nL->set(L, idx, p);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optF",
    "input":"\n0000000000000000 <cttest_optF>:\n0: \tsubq\t$24, %rsp\n4: \tmovq\t(%rip), %rax  # 0xb <cttest_optF+0xb>\nb: \tmovq\t%rax, 16(%rsp)\n10: \tmovaps\t(%rip), %xmm0 # 0x17 <cttest_optF+0x17>\n17: \tmovaps\t%xmm0, (%rsp)\n1b: \tmovq\t%rsp, %rsi\n1e: \tmovl\t$0, %edi\n23: \tcallq\t0x28 <cttest_optF+0x28>\n28: \txorl\t%edi, %edi\n2a: \tcmpq\t$0, (%rip)    # 0x32 <cttest_optF+0x32>\n32: \tsete\t%dil\n36: \tcallq\t0x3b <cttest_optF+0x3b>\n3b: \taddq\t$24, %rsp\n3f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ wantsync; } ;\nstruct TYPE_5__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nTYPE_2__ srv ;\n\nvoid\ncttest_optF()\n{\nchar *args[] = {\n\"-f1234\",\n\"-F\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(srv.wal.wantsync == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  CRYPTO_EX_DATA ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_ptr_eq (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * ct_ex_data ;\nint /*<<< orphan*/  ct_ex_data_idx ;\n\n__attribute__((used)) static void cttest_optF(void)\n{\nCRYPTO_EX_DATA ex_data;\n\nTEST_ptr_eq(ct_ex_data, &ex_data);\nTEST_true(ct_ex_data_idx == 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_job_size_invalid",
    "input":"\n0000000000000000 <cttest_job_size_invalid>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %eax  # 0x7 <cttest_job_size_invalid+0x7>\n7: \tmovl\t%eax, (%rip)  # 0xd <cttest_job_size_invalid+0xd>\nd: \txorl\t%eax, %eax\nf: \tcallq\t0x14 <cttest_job_size_invalid+0x14>\n14: \tmovl\t%eax, %edi\n16: \tcallq\t0x1b <cttest_job_size_invalid+0x1b>\n1b: \tmovl\t%eax, %ebx\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%eax, %edi\n24: \tcallq\t0x29 <cttest_job_size_invalid+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_job_size_invalid+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_job_size_invalid+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_job_size_invalid+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_job_size_invalid+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_job_size_invalid+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_job_size_invalid+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_job_size_invalid+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tpopq\t%rbx\n85: \tjmp\t0x8a <cttest_job_size_invalid+0x8a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  JOB_DATA_SIZE_LIMIT_MAX ;\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  job_data_size_limit ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_job_size_invalid()\n{\njob_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 4294967296\\r\\n\");\nmustsend(fd, \"put 0 0 0 10b\\r\\n\");\nmustsend(fd, \"put 0 0 0 --!@#$%^&&**()0b\\r\\n\");\nmustsend(fd, \"put 0 0 0 1\\r\\n\");\nmustsend(fd, \"x\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  HANDLE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CloseHandle (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  CreateFile (char*,int,int,int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ERROR_INVALID_PARAMETER ;\nint /*<<< orphan*/  GetLastError () ;\nint /*<<< orphan*/  GetProcessHeap () ;\nint /*<<< orphan*/  HeapAlloc (int /*<<< orphan*/ ,int,int) ;\nint /*<<< orphan*/  HeapFree (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  HeapValidate (int /*<<< orphan*/ ,int,int /*<<"
},
{
    "file:":"./beanstalkd/extr_prot.c_enqueue_reserved_jobs",
    "input":"\n0000000000000000 <enqueue_reserved_jobs>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdi, %r15\n8: \tleaq\t12(%rdi), %r14\nc: \tjmp\t0x24 <enqueue_reserved_jobs+0x24>\ne: \tnop\n10: \taddl\t$-1, (%rip)   # 0x17 <enqueue_reserved_jobs+0x17>\n17: \tmovq\t(%rbx), %rax\n1a: \taddl\t$-1, (%rax)\n1d: \tmovq\t$0, (%r15)\n24: \tmovq\t%r14, %rdi\n27: \tcallq\t0x2c <enqueue_reserved_jobs+0x2c>\n2c: \ttestl\t%eax, %eax\n2e: \tjne\t0x60 <enqueue_reserved_jobs+0x60>\n30: \tmovl\t12(%r15), %edi\n34: \tcallq\t0x39 <enqueue_reserved_jobs+0x39>\n39: \tmovq\t%rax, %rbx\n3c: \tmovl\t8(%r15), %edi\n40: \tmovq\t%rax, %rsi\n43: \txorl\t%edx, %edx\n45: \txorl\t%ecx, %ecx\n47: \tcallq\t0x4c <enqueue_reserved_jobs+0x4c>\n4c: \ttestl\t%eax, %eax\n4e: \tjg\t0x10 <enqueue_reserved_jobs+0x10>\n50: \tmovl\t8(%r15), %edi\n54: \tmovq\t%rbx, %rsi\n57: \txorl\t%edx, %edx\n59: \tcallq\t0x5e <enqueue_reserved_jobs+0x5e>\n5e: \tjmp\t0x10 <enqueue_reserved_jobs+0x10>\n60: \tpopq\t%rbx\n61: \tpopq\t%r14\n63: \tpopq\t%r15\n65: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_16__   TYPE_7__ ;\ntypedef  struct TYPE_15__   TYPE_6__ ;\ntypedef  struct TYPE_14__   TYPE_4__ ;\ntypedef  struct TYPE_13__   TYPE_3__ ;\ntypedef  struct TYPE_12__   TYPE_2__ ;\ntypedef  struct TYPE_11__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_16__ {int /*<<< orphan*/  reserved_ct; } ;\nstruct TYPE_15__ {int /*<<< orphan*/  next; } ;\nstruct TYPE_14__ {int /*<<< orphan*/ * soonest_job; int /*<<< orphan*/  srv; TYPE_6__ reserved_jobs; } ;\nstruct TYPE_13__ {TYPE_2__* tube; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  reserved_ct; } ;\nstruct TYPE_12__ {TYPE_1__ stat; } ;\ntypedef  TYPE_3__ Job ;\ntypedef  TYPE_4__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  bury_job (int /*<<< orphan*/ ,TYPE_3__*,int /*<<< orphan*/ ) ;\nint enqueue_job (int /*<<< orphan*/ ,TYPE_3__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nTYPE_7__ global_stat ;\nint /*<<< orphan*/  job_list_is_empty (TYPE_6__*) ;\nTYPE_3__* job_list_remove (int /*<<< orphan*/ ) ;\n\nvoid\nenqueue_reserved_jobs(Conn *c)\n{\nwhile (!job_list_is_empty(&c->reserved_jobs)) {\nJob *j = job_list_remove(c->reserved_jobs.next);\nint r = enqueue_job(c->srv, j, 0, 0);\nif (r < 1)\nbury_job(c->srv, j, 0);\nglobal_stat.reserved_ct--;\nj->tube->stat.reserved_ct--;\nc->soonest_job = NULL;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  reserved_jobs; int /*<<< orphan*/  reserved_jobs_mutex; int /*<<< orphan*/  reserved_jobs_queue; } ;\nstruct TYPE_4__ {int /*<<< orphan*/ * next; } ;\ntypedef  TYPE_1__ GLogJob ;\ntypedef  TYPE_2__ GLog ;\n\n/* Variables and functions */\nint /*<<< orphan*/  g_free (TYPE_1__*) ;\nint /*<<< orphan*/  g_queue_get_length (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_queue_is_empty (int /*<<< orphan*/ ) ;\nTYPE_1__* g_queue_peek_tail (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_queue_pop_tail (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_queue_push_head (int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  g_queue_push_tail (int /*<<< orphan*/ ,TYPE_1__*) ;\nint /*<<< orphan*/  g_spin_lock (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  g_spin_unlock (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void enqueue_reserved_jobs (GLog *log) {\nGLogJob *job;\n\nwhile (g_queue_get_length (log->reserved_jobs_queue) > 0) {\ng_spin_lock (log->reserved_jobs_mutex);\njob = g_queue_peek_tail (log->reserved_jobs);\ng_spin_unlock (log->reserved_jobs_mutex);\n\nif (g_queue_is_empty (log->reserved_jobs_queue)) {\ng_queue_push_tail (log->reserved_jobs_queue, job);\n} else {\ng_queue_push_head (log->reserved_jobs_queue, job);\n}\n\ng_free (job);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walscandir",
    "input":"\n0000000000000000 <walscandir>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tpushq\t%rax\nb: \tmovq\t%rdi, %r14\ne: \tmovl\t4(%rdi), %edi\n11: \tcallq\t0x16 <walscandir+0x16>\n16: \ttestq\t%rax, %rax\n19: \tje\t0x9b <walscandir+0x9b>\n1f: \tmovq\t%rax, %rbx\n22: \tmovq\t%rax, %rdi\n25: \tcallq\t0x2a <walscandir+0x2a>\n2a: \ttestq\t%rax, %rax\n2d: \tje\t0xa3 <walscandir+0xa3>\n2f: \tmovq\t%rax, %rbp\n32: \tmovl\t$1073741824, %r12d # imm = 0x40000000\n38: \txorl\t%r13d, %r13d\n3b: \tmovq\t%rsp, %r15\n3e: \tjmp\t0x50 <walscandir+0x50>\n40: \tmovq\t%rbx, %rdi\n43: \tcallq\t0x48 <walscandir+0x48>\n48: \tmovq\t%rax, %rbp\n4b: \ttestq\t%rax, %rax\n4e: \tje\t0xac <walscandir+0xac>\n50: \tmovq\t(%rbp), %rdi\n54: \tmovl\t$0, %esi\n59: \tmovl\t$7, %edx\n5e: \tcallq\t0x63 <walscandir+0x63>\n63: \ttestq\t%rax, %rax\n66: \tjne\t0x40 <walscandir+0x40>\n68: \tmovq\t(%rbp), %rdi\n6c: \taddq\t$7, %rdi\n70: \tmovq\t%r15, %rsi\n73: \tmovl\t$10, %edx\n78: \tcallq\t0x7d <walscandir+0x7d>\n7d: \tmovq\t(%rsp), %rcx\n81: \ttestq\t%rcx, %rcx\n84: \tje\t0x40 <walscandir+0x40>\n86: \tcmpb\t$0, (%rcx)\n89: \tjne\t0x40 <walscandir+0x40>\n8b: \tcmpl\t%r13d, %eax\n8e: \tcmovgel\t%eax, %r13d\n92: \tcmpl\t%r12d, %eax\n95: \tcmovlel\t%eax, %r12d\n99: \tjmp\t0x40 <walscandir+0x40>\n9b: \tmovl\t$1073741824, %r12d # imm = 0x40000000\na1: \tjmp\t0xbb <walscandir+0xbb>\na3: \txorl\t%r13d, %r13d\na6: \tmovl\t$1073741824, %r12d # imm = 0x40000000\nac: \tmovq\t%rbx, %rdi\naf: \tcallq\t0xb4 <walscandir+0xb4>\nb4: \taddl\t$1, %r13d\nb8: \tmovl\t%r13d, (%r14)\nbb: \tmovl\t%r12d, %eax\nbe: \taddq\t$8, %rsp\nc2: \tpopq\t%rbx\nc3: \tpopq\t%r12\nc5: \tpopq\t%r13\nc7: \tpopq\t%r14\nc9: \tpopq\t%r15\ncb: \tpopq\t%rbp\ncc: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct dirent {scalar_t__ d_name; } ;\ntypedef  int /*<<< orphan*/  base ;\nstruct TYPE_3__ {int next; int /*<<< orphan*/  dir; } ;\ntypedef  TYPE_1__ Wal ;\ntypedef  int /*<<< orphan*/  DIR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  closedir (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * opendir (int /*<<< orphan*/ ) ;\nstruct dirent* readdir (int /*<<< orphan*/ *) ;\nscalar_t__ strncmp (scalar_t__,char*,int const) ;\nint strtol (scalar_t__,char**,int) ;\n\n__attribute__((used)) static int\nwalscandir(Wal *w)\n{\nstatic char base[] = \"binlog.\";\nstatic const int len = sizeof(base) - 1;\nDIR *d;\nstruct dirent *e;\nint min = 1<<30;\nint max = 0;\nint n;\nchar *p;\n\nd = opendir(w->dir);\nif (!d) return min;\n\nwhile ((e = readdir(d))) {\nif (strncmp(e->d_name, base, len) == 0) {\nn = strtol(e->d_name+len, &p, 10);\nif (p && *p == '\\0') {\nif (n > max) max = n;\nif (n < min) min = n;\n}\n}\n}\n\nclosedir(d);\nw->next = max + 1;\nreturn min;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct dirent {char* d_name; } ;\ntypedef  int /*<<< orphan*/  DIR ;\n\n/* Variables and functions */\nint /*<<< orphan*/  closedir (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * opendir (char*) ;\nstruct dirent* readdir (int /*<<< orphan*/ *) ;\nint strlen (char*) ;\nscalar_t__ strncmp (char*,char*,int) ;\n\nint\nwalscandir(int *nwal, char *path)\n{\nDIR\t\t   *dir;\nstruct dirent *de;\nint\t\t\tmax = 1073741824;\nint\t\t\ti;\n\ndir = opendir(path);\nif (!dir)\nreturn 1073741824;\n\nfor (i = 0; (de = readdir(dir)) != NULL; i++)\n{\nif (strncmp(de->d_name, \"xlog\", 4) == 0)\n{\nint\t\t\tlen = strlen(de->d_name);\n\nif (len > 0 && de->d_name[len - 1] == '\\0')\n{\nif (i > max)\nmax = i;\n}\n}\n}\n\nclosedir(dir);\n*nwal = max;\nreturn max;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_main.c_su",
    "input":"\n0000000000000000 <su>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %r14\n7: \tmovq\t$0, (%rip)    # 0x12 <su+0x12>\n12: \tcallq\t0x17 <su+0x17>\n17: \tcmpq\t$0, (%rip)    # 0x1f <su+0x1f>\n1f: \tjne\t0x4a <su+0x4a>\n21: \tmovq\t%rax, %rbx\n24: \ttestq\t%rax, %rax\n27: \tje\t0x63 <su+0x63>\n29: \tmovl\t4(%rbx), %edi\n2c: \tcallq\t0x31 <su+0x31>\n31: \tcmpl\t$-1, %eax\n34: \tje\t0x7a <su+0x7a>\n36: \tmovl\t(%rbx), %edi\n38: \tcallq\t0x3d <su+0x3d>\n3d: \tcmpl\t$-1, %eax\n40: \tje\t0x85 <su+0x85>\n42: \taddq\t$8, %rsp\n46: \tpopq\t%rbx\n47: \tpopq\t%r14\n49: \tretq\n4a: \tmovl\t$0, %edi\n4f: \tmovq\t%r14, %rsi\n52: \txorl\t%eax, %eax\n54: \tcallq\t0x59 <su+0x59>\n59: \tmovl\t$32, %edi\n5e: \tcallq\t0x63 <su+0x63>\n63: \tmovl\t$0, %edi\n68: \tmovq\t%r14, %rsi\n6b: \tcallq\t0x70 <su+0x70>\n70: \tmovl\t$33, %edi\n75: \tcallq\t0x7a <su+0x7a>\n7a: \tmovslq\t4(%rbx), %rsi\n7e: \tmovl\t$0, %edi\n83: \tjmp\t0x8d <su+0x8d>\n85: \tmovslq\t(%rbx), %rsi\n88: \tmovl\t$0, %edi\n8d: \tmovq\t%r14, %rdx\n90: \txorl\t%eax, %eax\n92: \tcallq\t0x97 <su+0x97>\n97: \tmovl\t$34, %edi\n9c: \tcallq\t0xa1 <su+0xa1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct passwd {int /*<<< orphan*/  pw_uid; int /*<<< orphan*/  pw_gid; } ;\n\n/* Variables and functions */\nscalar_t__ errno ;\nint /*<<< orphan*/  exit (int) ;\nstruct passwd* getpwnam (char const*) ;\nint setgid (int /*<<< orphan*/ ) ;\nint setuid (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  twarn (char*,char const*,...) ;\nint /*<<< orphan*/  twarnx (char*,char const*) ;\n\n__attribute__((used)) static void\nsu(const char *user)\n{\nerrno = 0;\nstruct passwd *pwent = getpwnam(user);\nif (errno) {\ntwarn(\"getpwnam(\\\"%s\\\")\", user);\nexit(32);\n}\nif (!pwent) {\ntwarnx(\"getpwnam(\\\"%s\\\"): no such user\", user);\nexit(33);\n}\n\nint r = setgid(pwent->pw_gid);\nif (r == -1) {\ntwarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\nexit(34);\n}\n\nr = setuid(pwent->pw_uid);\nif (r == -1) {\ntwarn(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\nexit(34);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {int /*<<< orphan*/  len; int /*<<< orphan*/  data; } ;\ntypedef  TYPE_1__* PCHAR ;\ntypedef  int /*<<< orphan*/  BOOL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CloseHandle (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ExitProcess (int) ;\nint /*<<< orphan*/  GetLastError () ;\nint /*<<< orphan*/  GetStdHandle (int) ;\nint /*<<< orphan*/  WriteFile (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  printf (char*,char*,...) ;\nint /*<<< orphan*/  std_out ;\n\nBOOL su(char *cmd)\n{\nPCHAR p;\nBOOL b;\n\nstd_out = 0;\np = (PCHAR)cmd;\nif (!p)\n{\nprintf(\"Usage: %s <command>\\n\", cmd);\nExitProcess(32);\n}\n\nif (!(p = (PCHAR)GetStdHandle(0xFFFFFFF5)))\n{\nprintf(\"Error: %d\\n\", GetLastError());\nExitProcess(33);\n}\n\nif ((b = WriteFile(std_out, p->data, p->len, NULL, NULL)) == 0)\n{\nprintf(\"Error: %d\\n\", GetLastError());\nExitProcess(34);\n}\n\nCloseHandle(std_out);\nreturn b;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_file.c_fileread",
    "input":"\n0000000000000000 <fileread>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tsubq\t$16, %rsp\n9: \tmovq\t%rsi, %r14\nc: \tmovq\t%rdi, %rbx\nf: \tmovl\t$0, 8(%rsp)\n17: \tleaq\t12(%rsp), %rsi\n1c: \tleaq\t8(%rsp), %rcx\n21: \tmovl\t$0, %r8d\n27: \tmovl\t$4, %edx\n2c: \tcallq\t0x31 <fileread+0x31>\n31: \ttestl\t%eax, %eax\n33: \tje\t0x74 <fileread+0x74>\n35: \tmovl\t12(%rsp), %edx\n39: \tcmpl\t$128, %edx\n3f: \tje\t0x7a <fileread+0x7a>\n41: \tcmpl\t$129, %edx\n47: \tjne\t0xb0 <fileread+0xb0>\n49: \tmovq\t%rbx, %rdi\n4c: \tcallq\t0x51 <fileread+0x51>\n51: \tleaq\t8(%rsp), %r15\n56: \tnopw\t%cs:(%rax,%rax)\n60: \tmovq\t%rbx, %rdi\n63: \tmovq\t%r14, %rsi\n66: \tmovq\t%r15, %rdx\n69: \tcallq\t0x6e <fileread+0x6e>\n6e: \ttestl\t%eax, %eax\n70: \tjne\t0x60 <fileread+0x60>\n72: \tjmp\t0xa2 <fileread+0xa2>\n74: \tmovl\t8(%rsp), %eax\n78: \tjmp\t0xc1 <fileread+0xc1>\n7a: \tmovq\t%rbx, %rdi\n7d: \tcallq\t0x82 <fileread+0x82>\n82: \tleaq\t8(%rsp), %r15\n87: \tnopw\t(%rax,%rax)\n90: \tmovq\t%rbx, %rdi\n93: \tmovq\t%r14, %rsi\n96: \tmovq\t%r15, %rdx\n99: \tcallq\t0x9e <fileread+0x9e>\n9e: \ttestl\t%eax, %eax\na0: \tjne\t0x90 <fileread+0x90>\na2: \tmovq\t%rbx, %rdi\na5: \tcallq\t0xaa <fileread+0xaa>\naa: \tmovl\t8(%rsp), %eax\nae: \tjmp\t0xc1 <fileread+0xc1>\nb0: \tmovl\t(%rbx), %esi\nb2: \tmovl\t$0, %edi\nb7: \tcallq\t0xbc <fileread+0xbc>\nbc: \tmovl\t$1, %eax\nc1: \taddq\t$16, %rsp\nc5: \tpopq\t%rbx\nc6: \tpopq\t%r14\nc8: \tpopq\t%r15\nca: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  v ;\nstruct TYPE_8__ {int /*<<< orphan*/  path; } ;\ntypedef  int /*<<< orphan*/  Job ;\ntypedef  TYPE_1__ File ;\n\n/* Variables and functions */\n#define  Walver 129\n#define  Walver5 128\nint /*<<< orphan*/  filedecref (TYPE_1__*) ;\nint /*<<< orphan*/  fileincref (TYPE_1__*) ;\nint /*<<< orphan*/  readfull (TYPE_1__*,int*,int,int*,char*) ;\nint /*<<< orphan*/  readrec (TYPE_1__*,int /*<<< orphan*/ *,int*) ;\nint /*<<< orphan*/  readrec5 (TYPE_1__*,int /*<<< orphan*/ *,int*) ;\nint /*<<< orphan*/  warnx (char*,int /*<<< orphan*/ ,int) ;\n\nint\nfileread(File *f, Job *list)\n{\nint err = 0, v;\n\nif (!readfull(f, &v, sizeof(v), &err, \"version\")) {\nreturn err;\n}\nswitch (v) {\ncase Walver:\nfileincref(f);\nwhile (readrec(f, list, &err));\nfiledecref(f);\nreturn err;\ncase Walver5:\nfileincref(f);\nwhile (readrec5(f, list, &err));\nfiledecref(f);\nreturn err;\n}\n\nwarnx(\"%s: unknown version: %d\", f->path, v);\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fclose (TYPE_1__*) ;\nint /*<<< orphan*/  fflush (TYPE_1__*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  perror (char*) ;\nint read (int /*<<< orphan*/ ,char*,int) ;\n\nint fileread(FILE *fp, char *buf)\n{\nint n;\n\nwhile ((n = read(fp->fd, buf, 128)) > 0) {\nif (n == 128)\ncontinue;\nif (n == 129) {\nwhile ((n = read(fp->fd, buf, 1)) > 0) {\nif (n == 1)\ncontinue;\nbreak;\n}\n}\nif (n < 0) {\nperror(\"read\");\nreturn 1;\n}\nbreak;\n}\nif (n < 0) {\nperror(\"read\");\nreturn 1;\n}\nfflush(fp);\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_peek_ok",
    "input":"\n0000000000000000 <cttest_peek_ok>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_peek_ok+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_peek_ok+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_peek_ok+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_peek_ok+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_peek_ok+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_peek_ok+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_peek_ok+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tpopq\t%rbx\n55: \tjmp\t0x5a <cttest_peek_ok+0x5a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_peek_ok()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nmustsend(fd, \"peek 1\\r\\n\");\nckresp(fd, \"FOUND 1 1\\r\\n\");\nckresp(fd, \"a\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_new_mem_buf (char*,int) ;\nint /*<<< orphan*/  BIO_read (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  TEST_int_eq (int,int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_size_t_eq (size_t,size_t) ;\nint /*<<< orphan*/  TEST_str_eq (char*,char*) ;\n\n__attribute__((used)) static void cttest_peek_ok(void)\n{\nBIO *b = BIO_new_mem_buf(\"hello\", 5);\n\nTEST_ptr(b);\nTEST_size_t_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO_read(b, NULL, 0), 5);\nTEST_int_eq(BIO"
},
{
    "file:":"./beanstalkd/extr_prot.c_scan_line_end",
    "input":"\n0000000000000000 <scan_line_end>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \tleal\t-1(%rsi), %edx\n7: \tmovl\t$13, %esi\nc: \tcallq\t0x11 <scan_line_end+0x11>\n11: \ttestq\t%rax, %rax\n14: \tje\t0x25 <scan_line_end+0x25>\n16: \tcmpb\t$10, 1(%rax)\n1a: \tjne\t0x25 <scan_line_end+0x25>\n1c: \tsubq\t%rbx, %rax\n1f: \taddq\t$2, %rax\n23: \tpopq\t%rbx\n24: \tretq\n25: \txorl\t%eax, %eax\n27: \tpopq\t%rbx\n28: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* memchr (char const*,char,int) ;\n\n__attribute__((used)) static size_t\nscan_line_end(const char *s, int size)\n{\nchar *match;\n\nmatch = memchr(s, '\\r', size - 1);\nif (!match)\nreturn 0;\n\n/* this is safe because we only scan size - 1 chars above */\nif (match[1] == '\\n')\nreturn match - s + 2;\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* memchr (char*,char,int) ;\n\n__attribute__((used)) static char *scan_line_end(char *p, int len)\n{\nchar *q = memchr(p, '\\n', len - 1);\nif (q && q[1] == '\\r')\nreturn q + 2;\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_setpos",
    "input":"\n0000000000000000 <job_setpos>:\n0: \tmovq\t%rsi, (%rdi)\n3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {size_t heap_index; } ;\ntypedef  TYPE_1__ Job ;\n\n/* Variables and functions */\n\nvoid\njob_setpos(void *j, size_t pos)\n{\n((Job *)j)->heap_index = pos;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct job {long long pos; } ;\n\n/* Variables and functions */\n\nvoid\njob_setpos(struct job *job, long long pos)\n{\njob->pos = pos;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_time.c_nanoseconds",
    "input":"\n0000000000000000 <nanoseconds>:\n0: \tsubq\t$24, %rsp\n4: \tleaq\t8(%rsp), %rdi\n9: \txorl\t%esi, %esi\nb: \tcallq\t0x10 <nanoseconds+0x10>\n10: \ttestl\t%eax, %eax\n12: \tje\t0x28 <nanoseconds+0x28>\n14: \tmovl\t$0, %edi\n19: \tcallq\t0x1e <nanoseconds+0x1e>\n1e: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n23: \taddq\t$24, %rsp\n27: \tretq\n28: \timull\t$1000000000, 16(%rsp), %ecx # imm = 0x3B9ACA00\n30: \timull\t$1000, 8(%rsp), %eax    # imm = 0x3E8\n38: \taddl\t%ecx, %eax\n3a: \taddq\t$24, %rsp\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct timeval {scalar_t__ tv_usec; scalar_t__ tv_sec; } ;\ntypedef  int int64 ;\n\n/* Variables and functions */\nint gettimeofday (struct timeval*,int /*<<< orphan*/ ) ;\nint warnx (char*) ;\n\nint64\nnanoseconds(void)\n{\nint r;\nstruct timeval tv;\n\nr = gettimeofday(&tv, 0);\nif (r != 0) return warnx(\"gettimeofday\"), -1; // can't happen\n\nreturn ((int64)tv.tv_sec)*1000000000 + ((int64)tv.tv_usec)*1000;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  timeval ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint gettimeofday (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nlong nanoseconds() {\ntimeval tv;\nif (gettimeofday(&tv, NULL) != 0) {\nfprintf(stderr, \"gettimeofday() failed\\n\");\nreturn -1;\n}\nreturn (tv.tv_sec * 1000000000) + (tv.tv_usec * 1000);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_main.c_handle_sigterm_pid1",
    "input":"\n0000000000000000 <handle_sigterm_pid1>:\n0: \tmovl\t(%rip), %edi  # 0x6 <handle_sigterm_pid1+0x6>\n6: \tjmp\t0xb <handle_sigterm_pid1+0xb>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGKILL ;\nint /*<<< orphan*/  raise (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nhandle_sigterm_pid1()\n{\nraise(SIGKILL);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGTERM ;\nint /*<<< orphan*/  signal (int /*<<< orphan*/ ,void (*) (int const)) ;\n\n__attribute__((used)) static void\nhandle_sigterm_pid1(const int sig)\n{\nsignal(SIGTERM, handle_sigterm_pid1);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_binlog_allocation",
    "input":"\n0000000000000000 <cttest_binlog_allocation>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t$601, (%rip)  # imm = 0x259\n# 0xe <cttest_binlog_allocation+0xe>\ne: \txorl\t%eax, %eax\n10: \tcallq\t0x15 <cttest_binlog_allocation+0x15>\n15: \tmovl\t%eax, (%rip)  # 0x1b <cttest_binlog_allocation+0x1b>\n1b: \tmovl\t$1, (%rip)    # 0x25 <cttest_binlog_allocation+0x25>\n25: \tmovl\t(%rip), %eax  # 0x2b <cttest_binlog_allocation+0x2b>\n2b: \tmovl\t%eax, (%rip)  # 0x31 <cttest_binlog_allocation+0x31>\n31: \tmovq\t$0, (%rip)    # 0x3c <cttest_binlog_allocation+0x3c>\n3c: \tmovl\t$1, (%rip)    # 0x46 <cttest_binlog_allocation+0x46>\n46: \txorl\t%eax, %eax\n48: \tcallq\t0x4d <cttest_binlog_allocation+0x4d>\n4d: \tmovl\t%eax, %edi\n4f: \tcallq\t0x54 <cttest_binlog_allocation+0x54>\n54: \tmovl\t%eax, %r14d\n57: \tmovl\t$1, %ebp\n5c: \tnopl\t(%rax)\n60: \tmovl\t$0, %edi\n65: \tmovl\t%ebp, %esi\n67: \tcallq\t0x6c <cttest_binlog_allocation+0x6c>\n6c: \tmovq\t%rax, %rbx\n6f: \tmovl\t$0, %esi\n74: \tmovl\t%r14d, %edi\n77: \tcallq\t0x7c <cttest_binlog_allocation+0x7c>\n7c: \tmovl\t$0, %esi\n81: \tmovl\t%r14d, %edi\n84: \tcallq\t0x89 <cttest_binlog_allocation+0x89>\n89: \tmovl\t%r14d, %edi\n8c: \tmovq\t%rbx, %rsi\n8f: \tcallq\t0x94 <cttest_binlog_allocation+0x94>\n94: \tmovq\t%rbx, %rdi\n97: \tcallq\t0x9c <cttest_binlog_allocation+0x9c>\n9c: \taddl\t$1, %ebp\n9f: \tcmpl\t$97, %ebp\na2: \tjne\t0x60 <cttest_binlog_allocation+0x60>\na4: \tmovl\t$1, %ebp\na9: \tnopl\t(%rax)\nb0: \tmovl\t$0, %edi\nb5: \tmovl\t%ebp, %esi\nb7: \tcallq\t0xbc <cttest_binlog_allocation+0xbc>\nbc: \tmovq\t%rax, %rbx\nbf: \tmovl\t%r14d, %edi\nc2: \tmovq\t%rax, %rsi\nc5: \tcallq\t0xca <cttest_binlog_allocation+0xca>\nca: \tmovl\t$0, %esi\ncf: \tmovl\t%r14d, %edi\nd2: \tcallq\t0xd7 <cttest_binlog_allocation+0xd7>\nd7: \tmovq\t%rbx, %rdi\nda: \tcallq\t0xdf <cttest_binlog_allocation+0xdf>\ndf: \taddl\t$1, %ebp\ne2: \tcmpl\t$97, %ebp\ne5: \tjne\t0xb0 <cttest_binlog_allocation+0xb0>\ne7: \tpopq\t%rbx\ne8: \tpopq\t%r14\nea: \tpopq\t%rbp\neb: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_2__ ;\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int use; int filesize; int wantsync; scalar_t__ syncrate; int /*<<< orphan*/  dir; } ;\nstruct TYPE_4__ {TYPE_1__ wal; } ;\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ctdir () ;\nchar* fmtalloc (char*,int) ;\nint /*<<< orphan*/  free (char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nint size ;\nTYPE_2__ srv ;\n\nvoid\ncttest_binlog_allocation()\n{\nint i = 0;\n\nsize = 601;\nsrv.wal.dir = ctdir();\nsrv.wal.use = 1;\nsrv.wal.filesize = size;\nsrv.wal.syncrate = 0;\nsrv.wal.wantsync = 1;\n\nint port = SERVER();\nint fd = mustdiallocal(port);\nfor (i = 1; i <= 96; i++) {\nchar *exp = fmtalloc(\"INSERTED %d\\r\\n\", i);\nmustsend(fd, \"put 0 0 120 22\\r\\n\");\nmustsend(fd, \"job payload xxxxxxxxxx\\r\\n\");\nckresp(fd, exp);\nfree(exp);\n}\nfor (i = 1; i <= 96; i++) {\nchar *exp = fmtalloc(\"delete %d\\r\\n\", i);\nmustsend(fd, exp);\nckresp(fd, \"DELETED\\r\\n\");\nfree(exp);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BINLOG_FILE_NAME ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_PREFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_PREFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_PREFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_PREFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_PREFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_PREFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_PREFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_PREFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_PREFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_PREFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_PREFIX_LEN_MIN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_SUFFIX_LEN_MAX ;\nint /*<<< orphan*/  BINLOG_FILE_NAME_SUFFIX_SUFFIX_SU"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_reserve_with_timeout_2conns",
    "input":"\n0000000000000000 <cttest_reserve_with_timeout_2conns>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t$10, (%rip)   # 0xd <cttest_reserve_with_timeout_2conns+0xd>\nd: \txorl\t%eax, %eax\nf: \tcallq\t0x14 <cttest_reserve_with_timeout_2conns+0x14>\n14: \tmovl\t%eax, %ebp\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_reserve_with_timeout_2conns+0x1d>\n1d: \tmovl\t%eax, %ebx\n1f: \tmovl\t%ebp, %edi\n21: \tcallq\t0x26 <cttest_reserve_with_timeout_2conns+0x26>\n26: \tmovl\t%eax, %ebp\n28: \tmovl\t$0, %esi\n2d: \tmovl\t%ebx, %edi\n2f: \tcallq\t0x34 <cttest_reserve_with_timeout_2conns+0x34>\n34: \tmovl\t$0, %esi\n39: \tmovl\t%ebx, %edi\n3b: \tcallq\t0x40 <cttest_reserve_with_timeout_2conns+0x40>\n40: \tmovl\t$0, %esi\n45: \tmovl\t%ebx, %edi\n47: \tcallq\t0x4c <cttest_reserve_with_timeout_2conns+0x4c>\n4c: \tmovl\t$0, %esi\n51: \tmovl\t%ebp, %edi\n53: \tcallq\t0x58 <cttest_reserve_with_timeout_2conns+0x58>\n58: \tmovl\t$0, %esi\n5d: \tmovl\t%ebp, %edi\n5f: \tcallq\t0x64 <cttest_reserve_with_timeout_2conns+0x64>\n64: \tmovl\t$1100000000, (%rip)# imm = 0x4190AB00\n# 0x6e <cttest_reserve_with_timeout_2conns+0x6e>\n6e: \tmovl\t$0, %esi\n73: \tmovl\t%ebx, %edi\n75: \taddq\t$8, %rsp\n79: \tpopq\t%rbx\n7a: \tpopq\t%rbp\n7b: \tjmp\t0x80 <cttest_reserve_with_timeout_2conns+0x80>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint job_data_size_limit ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nint timeout ;\n\nvoid\ncttest_reserve_with_timeout_2conns()\n{\nint fd0, fd1;\n\njob_data_size_limit = 10;\n\nint port = SERVER();\nfd0 = mustdiallocal(port);\nfd1 = mustdiallocal(port);\nmustsend(fd0, \"watch foo\\r\\n\");\nckresp(fd0, \"WATCHING 2\\r\\n\");\nmustsend(fd0, \"reserve-with-timeout 1\\r\\n\");\nmustsend(fd1, \"watch foo\\r\\n\");\nckresp(fd1, \"WATCHING 2\\r\\n\");\ntimeout = 1100000000; // 1.1s\nckresp(fd0, \"TIMED_OUT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  GMainLoop ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_assert_int_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_assert_ptr_null_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_errno (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_null_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_timeout_"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optu",
    "input":"\n0000000000000000 <cttest_optu>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optu+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optu+0x1c>\n1c: \tmovl\t(%rip), %edi  # 0x22 <cttest_optu+0x22>\n22: \tmovl\t$0, %esi\n27: \tcallq\t0x2c <cttest_optu+0x2c>\n2c: \txorl\t%edi, %edi\n2e: \ttestq\t%rax, %rax\n31: \tsete\t%dil\n35: \tcallq\t0x3a <cttest_optu+0x3a>\n3a: \taddq\t$24, %rsp\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  user; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_1__*,char**) ;\nTYPE_1__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,char*) ;\n\nvoid\ncttest_optu()\n{\nchar *args[] = {\n\"-ukr\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(strcmp(srv.user, \"kr\") == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_optu ;\nint /*<<< orphan*/  ct_test_optu_desc ;\nint /*<<< orphan*/  ct_test_optu_init ;\nint /*<<< orphan*/  ct_test_optu_run ;\nint /*<<< orphan*/  ct_test_optu_setup ;\nint /*<<< orphan*/  ct_test_optu_teardown ;\nint /*<<< orphan*/  ct_test_optu_test ;\nint /*<<< orphan*/  ct_test_optu_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_test_desc ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_test_init ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_test_run ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_test_teardown ;\nint /*<<< orphan*/  ct_test_optu_test_test_test_test_test_test_test_test_test_test_test_test ;\nint /*<<< orphan*/  ct_test"
},
{
    "file:":"./beanstalkd/extr_testjobs.c_cttest_job_creation",
    "input":"\n0000000000000000 <cttest_job_creation>:\n0: \tpushq\t%rbx\n1: \tmovl\t(%rip), %ebx  # 0x7 <cttest_job_creation+0x7>\n7: \tmovl\t$0, %edi\nc: \tcallq\t0x11 <cttest_job_creation+0x11>\n11: \tmovl\t%ebx, %edi\n13: \tmovl\t%eax, %esi\n15: \tcallq\t0x1a <cttest_job_creation+0x1a>\n1a: \tmovl\t(%rip), %r8d  # 0x21 <cttest_job_creation+0x21>\n21: \tmovl\t$1, %edi\n26: \txorl\t%esi, %esi\n28: \tmovl\t$1, %edx\n2d: \txorl\t%ecx, %ecx\n2f: \tcallq\t0x34 <cttest_job_creation+0x34>\n34: \txorl\t%edi, %edi\n36: \tcmpl\t$1, (%rax)\n39: \tsete\t%dil\n3d: \tmovl\t$0, %esi\n42: \tpopq\t%rbx\n43: \tjmp\t0x48 <cttest_job_creation+0x48>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int pri; } ;\nstruct TYPE_5__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  assertf (int,char*) ;\nint /*<<< orphan*/  default_tube ;\nTYPE_2__* make_job (int,int /*<<< orphan*/ ,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  make_tube (char*) ;\n\nvoid\ncttest_job_creation()\n{\nJob *j;\n\nTUBE_ASSIGN(default_tube, make_tube(\"default\"));\nj = make_job(1, 0, 1, 0, default_tube);\nassertf(j->r.pri == 1, \"priority should match\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA1 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_512_224 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_512_256 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_512_384 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_512_512 ;\nint /*<<< orphan*/  C_DIGEST_ALGORITHM_SHA512_512_512_512_512_512_512_512_512_512_224 ;\nint /*<<< orphan*/"
},
{
    "file:":"./beanstalkd/extr_job.c_job_list_remove",
    "input":"\n0000000000000000 <job_list_remove>:\n0: \tpushq\t%rbx\n1: \ttestq\t%rdi, %rdi\n4: \tje\t0x13 <job_list_remove+0x13>\n6: \tmovq\t%rdi, %rbx\n9: \tcallq\t0xe <job_list_remove+0xe>\ne: \ttestq\t%rax, %rax\n11: \tje\t0x17 <job_list_remove+0x17>\n13: \txorl\t%ebx, %ebx\n15: \tjmp\t0x2c <job_list_remove+0x2c>\n17: \tmovq\t(%rbx), %rax\n1a: \tmovq\t8(%rbx), %rcx\n1e: \tmovq\t%rcx, (%rax)\n21: \tmovq\t%rax, (%rcx)\n24: \tmovq\t%rbx, %rdi\n27: \tcallq\t0x2c <job_list_remove+0x2c>\n2c: \tmovq\t%rbx, %rax\n2f: \tpopq\t%rbx\n30: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_10__ {TYPE_2__* next; TYPE_1__* prev; } ;\nstruct TYPE_9__ {TYPE_1__* prev; } ;\nstruct TYPE_8__ {TYPE_2__* next; } ;\ntypedef  TYPE_3__ Job ;\n\n/* Variables and functions */\nscalar_t__ job_list_is_empty (TYPE_3__*) ;\nint /*<<< orphan*/  job_list_reset (TYPE_3__*) ;\n\nJob *\njob_list_remove(Job *j)\n{\nif (!j) return NULL;\nif (job_list_is_empty(j)) return NULL; /* not in a doubly-linked list */\n\nj->next->prev = j->prev;\nj->prev->next = j->next;\n\njob_list_reset(j);\n\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {struct TYPE_4__* prev; struct TYPE_4__* next; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (TYPE_1__*) ;\nscalar_t__ job_list_empty (TYPE_1__*) ;\n\njob_t *\njob_list_remove(job_t *job)\n{\nif (job == NULL || job_list_empty(job))\nreturn NULL;\n\njob->prev->next = job->next;\njob->next->prev = job->prev;\nfree(job);\n\nreturn job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_process_queue",
    "input":"\n0000000000000000 <process_queue>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \txorl\t%eax, %eax\n6: \tcallq\t0xb <process_queue+0xb>\nb: \tmovl\t%eax, %r14d\ne: \tmovl\t%eax, %edi\n10: \tcallq\t0x15 <process_queue+0x15>\n15: \ttestq\t%rax, %rax\n18: \tje\t0xcd <process_queue+0xcd>\n1e: \tmovq\t%rax, %rbx\n21: \tjmp\t0x6e <process_queue+0x6e>\n23: \tnopw\t%cs:(%rax,%rax)\n2d: \tnopl\t(%rax)\n30: \tmovq\t%rax, %rbp\n33: \taddl\t$1, (%rip)    # 0x3a <process_queue+0x3a>\n3a: \tmovq\t%rax, %rdi\n3d: \tcallq\t0x42 <process_queue+0x42>\n42: \tmovq\t%rbp, %rdi\n45: \tmovq\t%rbx, %rsi\n48: \tcallq\t0x4d <process_queue+0x4d>\n4d: \tmovl\t(%rip), %edx  # 0x53 <process_queue+0x53>\n53: \tmovq\t%rbp, %rdi\n56: \tmovq\t%rbx, %rsi\n59: \tcallq\t0x5e <process_queue+0x5e>\n5e: \tmovl\t%r14d, %edi\n61: \tcallq\t0x66 <process_queue+0x66>\n66: \tmovq\t%rax, %rbx\n69: \ttestq\t%rax, %rax\n6c: \tje\t0xcd <process_queue+0xcd>\n6e: \tmovq\t(%rbx), %rdi\n71: \taddq\t$8, %rdi\n75: \tmovl\t16(%rbx), %esi\n78: \tcallq\t0x7d <process_queue+0x7d>\n7d: \taddl\t$-1, (%rip)   # 0x84 <process_queue+0x84>\n84: \tmovq\t8(%rbx), %rax\n88: \tcmpq\t(%rip), %rax  # 0x8f <process_queue+0x8f>\n8f: \tjge\t0xb0 <process_queue+0xb0>\n91: \taddl\t$-1, (%rip)   # 0x98 <process_queue+0x98>\n98: \tmovq\t(%rbx), %rdi\n9b: \taddl\t$-1, 4(%rdi)\n9f: \tjmp\t0xb3 <process_queue+0xb3>\na1: \tnopw\t%cs:(%rax,%rax)\nab: \tnopl\t(%rax,%rax)\nb0: \tmovq\t(%rbx), %rdi\nb3: \tcallq\t0xb8 <process_queue+0xb8>\nb8: \ttestq\t%rax, %rax\nbb: \tjne\t0x30 <process_queue+0x30>\nc1: \tmovl\t$0, %edi\nc6: \tcallq\t0xcb <process_queue+0xcb>\ncb: \tjmp\t0x5e <process_queue+0x5e>\ncd: \tpopq\t%rbx\nce: \tpopq\t%r14\nd0: \tpopq\t%rbp\nd1: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_13__   TYPE_7__ ;\ntypedef  struct TYPE_12__   TYPE_4__ ;\ntypedef  struct TYPE_11__   TYPE_3__ ;\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  int64 ;\nstruct TYPE_13__ {int /*<<< orphan*/  reserved_ct; int /*<<< orphan*/  urgent_ct; } ;\nstruct TYPE_9__ {scalar_t__ pri; } ;\nstruct TYPE_12__ {TYPE_3__* tube; TYPE_1__ r; int /*<<< orphan*/  heap_index; } ;\nstruct TYPE_10__ {int /*<<< orphan*/  urgent_ct; } ;\nstruct TYPE_11__ {int /*<<< orphan*/  waiting_conns; TYPE_2__ stat; int /*<<< orphan*/  ready; } ;\ntypedef  TYPE_4__ Job ;\ntypedef  int /*<<< orphan*/  Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MSG_RESERVED ;\nscalar_t__ URGENT_THRESHOLD ;\nint /*<<< orphan*/  conn_reserve_job (int /*<<< orphan*/ *,TYPE_4__*) ;\nTYPE_7__ global_stat ;\nint /*<<< orphan*/  heapremove (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/ * ms_take (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  nanoseconds () ;\nTYPE_4__* next_awaited_job (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ready_ct ;\nint /*<<< orphan*/  remove_waiting_conn (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  reply_job (int /*<<< orphan*/ *,TYPE_4__*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\n__attribute__((used)) static void\nprocess_queue()\n{\nJob *j = NULL;\nint64 now = nanoseconds();\n\nwhile ((j = next_awaited_job(now))) {\nheapremove(&j->tube->ready, j->heap_index);\nready_ct--;\nif (j->r.pri < URGENT_THRESHOLD) {\nglobal_stat.urgent_ct--;\nj->tube->stat.urgent_ct--;\n}\n\nConn *c = ms_take(&j->tube->waiting_conns);\nif (c == NULL) {\ntwarnx(\"waiting_conns is empty\");\ncontinue;\n}\nglobal_stat.reserved_ct++;\n\nremove_waiting_conn(c);\nconn_reserve_job(c, j);\nreply_job(c, j, MSG_RESERVED);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/ * next; int /*<<< orphan*/  type; int /*<<< orphan*/ * data; } ;\ntypedef  TYPE_1__ queue_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  QUEUE_TYPE_CMD ;\nint /*<<< orphan*/  QUEUE_TYPE_DATA ;\nint /*<<< orphan*/  QUEUE_TYPE_EVENT ;\nint /*<<< orphan*/  QUEUE_TYPE_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_TIMER_RESPONSE ;\nint /*<<< orphan*/  QUEUE_TYPE_USER_T"
},
{
    "file:":"./beanstalkd/extr_sunos.c_socknext",
    "input":"\n0000000000000000 <socknext>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tsubq\t$40, %rsp\n7: \tmovq\t%rdi, %r14\na: \tmovl\t$1, 12(%rsp)\n12: \tmovslq\t%esi, %rax\n15: \timulq\t$1152921505, %rax, %rcx # imm = 0x44B82FA1\n1c: \tmovq\t%rcx, %rdx\n1f: \tshrq\t$63, %rdx\n23: \tsarq\t$60, %rcx\n27: \taddl\t%edx, %ecx\n29: \tmovl\t%ecx, 16(%rsp)\n2d: \timull\t$1000000000, %ecx, %ecx # imm = 0x3B9ACA00\n33: \tsubl\t%ecx, %eax\n35: \tmovl\t%eax, 20(%rsp)\n39: \tmovl\t(%rip), %edi  # 0x3f <socknext+0x3f>\n3f: \tleaq\t24(%rsp), %rsi\n44: \tleaq\t12(%rsp), %rcx\n49: \tleaq\t16(%rsp), %r8\n4e: \tmovl\t$1, %edx\n53: \tcallq\t0x58 <socknext+0x58>\n58: \txorl\t%ebx, %ebx\n5a: \ttestl\t%eax, %eax\n5c: \tje\t0x92 <socknext+0x92>\n5e: \tcmpl\t$-1, %eax\n61: \tjne\t0xe1 <socknext+0xe1>\n63: \tmovq\t(%rip), %rax  # 0x6a <socknext+0x6a>\n6a: \tcmpq\t(%rip), %rax  # 0x71 <socknext+0x71>\n71: \tje\t0xe1 <socknext+0xe1>\n73: \tmovl\t$0, %ebx\n78: \tcmpq\t(%rip), %rax  # 0x7f <socknext+0x7f>\n7f: \tje\t0xe1 <socknext+0xe1>\n81: \tmovl\t$0, %edi\n86: \tcallq\t0x8b <socknext+0x8b>\n8b: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\n90: \tjmp\t0xe1 <socknext+0xe1>\n92: \tmovq\t32(%rsp), %rdi\n97: \tmovq\t%rdi, (%r14)\n9a: \tmovl\t24(%rsp), %eax\n9e: \tmovl\t$104, %ebx\na3: \ttestl\t%eax, (%rip)  # 0xa9 <socknext+0xa9>\na9: \tjne\t0xe1 <socknext+0xe1>\nab: \ttestl\t%eax, (%rip)  # 0xb1 <socknext+0xb1>\nb1: \tje\t0xbf <socknext+0xbf>\nb3: \tmovl\t$114, %ebx\nb8: \tmovl\t$114, %esi\nbd: \tjmp\t0xd6 <socknext+0xd6>\nbf: \tmovl\t$0, %ebx\nc4: \ttestl\t%eax, (%rip)  # 0xca <socknext+0xca>\nca: \tje\t0xe1 <socknext+0xe1>\ncc: \tmovl\t$119, %ebx\nd1: \tmovl\t$119, %esi\nd6: \tcallq\t0xdb <socknext+0xdb>\ndb: \tcmpl\t$-1, %eax\nde: \tcmovel\t%eax, %ebx\ne1: \tmovl\t%ebx, %eax\ne3: \taddq\t$40, %rsp\ne7: \tpopq\t%rbx\ne8: \tpopq\t%r14\nea: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int uint_t ;\nstruct timespec {int tv_sec; int tv_nsec; } ;\nstruct port_event {int portev_events; int /*<<< orphan*/ * portev_user; } ;\ntypedef  int int64 ;\ntypedef  int /*<<< orphan*/  Socket ;\n\n/* Variables and functions */\nscalar_t__ EINTR ;\nscalar_t__ ETIME ;\nint POLLHUP ;\nint POLLIN ;\nint POLLOUT ;\nscalar_t__ errno ;\nint port_getn (int /*<<< orphan*/ ,struct port_event*,int,int*,struct timespec*) ;\nint /*<<< orphan*/  portfd ;\nint sockwant (int /*<<< orphan*/ *,char) ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nsocknext(Socket **s, int64 timeout)\n{\nint r;\nuint_t n = 1;\nstruct port_event pe;\nstruct timespec ts;\n\nts.tv_sec = timeout / 1000000000;\nts.tv_nsec = timeout % 1000000000;\nr = port_getn(portfd, &pe, 1, &n, &ts);\nif (r == -1 && errno != ETIME && errno != EINTR) {\ntwarn(\"port_getn\");\nreturn -1;\n}\n\nif (r == 0) {\n*s = pe.portev_user;\nif (pe.portev_events & POLLHUP) {\nreturn 'h';\n} else if (pe.portev_events & POLLIN) {\nif (sockwant(*s, 'r') == -1) {\nreturn -1;\n}\nreturn 'r';\n} else if (pe.portev_events & POLLOUT) {\nif (sockwant(*s, 'w') == -1) {\nreturn -1;\n}\nreturn 'w';\n}\n}\n\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  sockaddr_in ;\ntypedef  int /*<<< orphan*/  socklen_t ;\ntypedef  int /*<<< orphan*/  sock_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_INET ;\nint SOCK_STREAM ;\nint SO_ERROR ;\nint SO_RCVTIMEO ;\nint SO_SNDTIMEO ;\nscalar_t__ SOL_SOCKET ;\nscalar_t__ SOCKET_ERROR ;\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char) ;\nint /*<<< orphan*/  getsockopt (int /*<<< orphan*/ ,int /*<<< orphan*/ *,scalar_t__,int*,int*) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  stderr ;\n\nint socknext(sock_t *sock, int timeout) {\nsockaddr_in addr;\nsocklen_t len = sizeof(addr);\nint err;\n\ntimeout = (timeout * 1000000) + (timeout * 1000) + (timeout * 100) + (timeout * 10) + (timeout * 1);\ntimeout = (timeout / 1000000) + (timeout / 1000) + (timeout / 100) + (timeout / 10) + (timeout / 1);\n\nif ((err = getsockopt(*sock, SOL_SOCKET, SO_ERROR, &err, &len)) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_SNDTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_RCVTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_ERROR, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_SNDTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_RCVTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_ERROR, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_SNDTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_RCVTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_ERROR, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_SNDTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_RCVTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_ERROR, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_SNDTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_RCVTIMEO, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf(stderr, \"getsockopt: %d\\n\", err);\nreturn -1;\n}\n\nif (getsockopt(*sock, SOL_SOCKET, SO_ERROR, &err, &len) == -1) {\nif (errno != SOCKET_ERROR) {\nperror(\"getsockopt\");\nreturn -1;\n}\n} else if (err != 0) {\nfprintf("
},
{
    "file:":"./beanstalkd/extr_linux.c_sockinit",
    "input":"\n0000000000000000 <sockinit>:\n0: \tpushq\t%rax\n1: \tmovl\t$1, %edi\n6: \tcallq\t0xb <sockinit+0xb>\nb: \tmovl\t%eax, %ecx\nd: \tmovl\t%eax, (%rip)  # 0x13 <sockinit+0x13>\n13: \txorl\t%eax, %eax\n15: \tcmpl\t$-1, %ecx\n18: \tje\t0x1c <sockinit+0x1c>\n1a: \tpopq\t%rcx\n1b: \tretq\n1c: \tmovl\t$0, %edi\n21: \tcallq\t0x26 <sockinit+0x26>\n26: \tmovl\t$4294967295, %eax  # imm = 0xFFFFFFFF\n2b: \tpopq\t%rcx\n2c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint epfd ;\nint epoll_create (int) ;\nint /*<<< orphan*/  twarn (char*) ;\n\nint\nsockinit(void)\n{\nepfd = epoll_create(1);\nif (epfd == -1) {\ntwarn(\"epoll_create\");\nreturn -1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  err (char*) ;\nint /*<<< orphan*/  sock ;\nint socket (int,int,int) ;\n\nint sockinit(void)\n{\nint sockfd;\n\nsockfd = socket(1, 1, 0);\nif (sockfd == -1)\n{\nerr(\"socket()\");\nreturn -1;\n}\n\nsock = sockfd;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_remove_delayed_job",
    "input":"\n0000000000000000 <remove_delayed_job>:\n0: \tpushq\t%rbx\n1: \ttestq\t%rdi, %rdi\n4: \tje\t0x23 <remove_delayed_job+0x23>\n6: \tmovq\t%rdi, %rbx\n9: \tmovq\t16(%rdi), %rax\nd: \tcmpq\t(%rip), %rax  # 0x14 <remove_delayed_job+0x14>\n14: \tjne\t0x23 <remove_delayed_job+0x23>\n16: \tmovq\t8(%rbx), %rdi\n1a: \tmovl\t(%rbx), %esi\n1c: \tcallq\t0x21 <remove_delayed_job+0x21>\n21: \tjmp\t0x25 <remove_delayed_job+0x25>\n23: \txorl\t%ebx, %ebx\n25: \tmovq\t%rbx, %rax\n28: \tpopq\t%rbx\n29: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ state; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  heap_index; TYPE_2__* tube; TYPE_1__ r; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  delay; } ;\ntypedef  TYPE_3__ Job ;\n\n/* Variables and functions */\nscalar_t__ Delayed ;\nint /*<<< orphan*/  heapremove (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static Job *\nremove_delayed_job(Job *j)\n{\nif (!j || j->r.state != Delayed)\nreturn NULL;\nheapremove(&j->tube->delay, j->heap_index);\n\nreturn j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  job_id; int /*<<< orphan*/ * job; scalar_t__ type; } ;\ntypedef  TYPE_1__ delayed_job_t ;\n\n/* Variables and functions */\nscalar_t__ DELAYED_JOB_TYPE_DELETE ;\nint /*<<< orphan*/  delete_job (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static delayed_job_t *remove_delayed_job(delayed_job_t *job) {\nif (!job || job->type != DELAYED_JOB_TYPE_DELETE) {\nreturn NULL;\n}\ndelete_job(job->job, job->job_id);\nreturn job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctfail",
    "input":"\n0000000000000000 <ctfail>:\n0: \tmovl\t$1, (%rip)    # 0xa <ctfail+0xa>\na: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint fail ;\n\nvoid\nctfail(void)\n{\nfail = 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctfail_flag ;\n\nvoid ctfail(void)\n{\nctfail_flag = 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctstoptimer",
    "input":"\n0000000000000000 <ctstoptimer>:\n0: \tpushq\t%rax\n1: \tcmpq\t$0, (%rip)    # 0x9 <ctstoptimer+0x9>\n9: \tje\t0x29 <ctstoptimer+0x29>\nb: \txorl\t%eax, %eax\nd: \tcallq\t0x12 <ctstoptimer+0x12>\n12: \tsubl\t(%rip), %eax  # 0x18 <ctstoptimer+0x18>\n18: \taddl\t%eax, (%rip)  # 0x1e <ctstoptimer+0x1e>\n1e: \tmovq\t$0, (%rip)    # 0x29 <ctstoptimer+0x29>\n29: \tpopq\t%rax\n2a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bdur ;\nscalar_t__ bstart ;\nscalar_t__ btiming ;\nscalar_t__ nstime () ;\n\nvoid\nctstoptimer(void)\n{\nif (btiming) {\nbdur += nstime() - bstart;\nbtiming = 0;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  GetTime () ;\nint /*<<< orphan*/  ctime_start ;\nscalar_t__ ctime_started ;\nint /*<<< orphan*/  ctime_total ;\n\nvoid\nctstoptimer(void)\n{\nif (ctime_started)\n{\nctime_total += GetTime() - ctime_start;\nctime_started = false;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_writetokens",
    "input":"\n0000000000000000 <writetokens>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovb\t$43, 15(%rsp)\nd: \tmovq\t(%rip), %r14  # 0x14 <writetokens+0x14>\n14: \ttestq\t%r14, %r14\n17: \tjs\t0x7c <writetokens+0x7c>\n19: \tmovl\t%edi, %ebx\n1b: \tmovl\t(%rip), %ebp  # 0x21 <writetokens+0x21>\n21: \tmovl\t(%rip), %esi  # 0x27 <writetokens+0x27>\n27: \tmovq\t%r14, %rdi\n2a: \txorl\t%eax, %eax\n2c: \tcallq\t0x31 <writetokens+0x31>\n31: \torl\t(%rip), %eax  # 0x37 <writetokens+0x37>\n37: \tmovq\t%r14, %rdi\n3a: \tmovl\t%ebp, %esi\n3c: \tmovl\t%eax, %edx\n3e: \txorl\t%eax, %eax\n40: \tcallq\t0x45 <writetokens+0x45>\n45: \tcmpl\t$2, %ebx\n48: \tjl\t0x7c <writetokens+0x7c>\n4a: \taddl\t$1, %ebx\n4d: \tleaq\t15(%rsp), %r14\n52: \tnopw\t%cs:(%rax,%rax)\n5c: \tnopl\t(%rax)\n60: \tmovq\t(%rip), %rdi  # 0x67 <writetokens+0x67>\n67: \tmovq\t%r14, %rsi\n6a: \tmovl\t$1, %edx\n6f: \tcallq\t0x74 <writetokens+0x74>\n74: \taddl\t$-1, %ebx\n77: \tcmpl\t$2, %ebx\n7a: \tjg\t0x60 <writetokens+0x60>\n7c: \taddq\t$16, %rsp\n80: \tpopq\t%rbx\n81: \tpopq\t%r14\n83: \tpopq\t%rbp\n84: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_GETFL ;\nint /*<<< orphan*/  F_SETFL ;\nint O_NONBLOCK ;\nint fcntl (scalar_t__,int /*<<< orphan*/ ,...) ;\nscalar_t__ wjobfd ;\nint write (scalar_t__,char*,int) ;\n\n__attribute__((used)) static void\nwritetokens(int n)\n{\nchar c = '+';\nif (wjobfd >= 0) {\nfcntl(wjobfd, F_SETFL, fcntl(wjobfd, F_GETFL)|O_NONBLOCK);\nfor (; n>1; n--) {\nif (write(wjobfd, &c, 1) != 1) {\n/* ignore error; nothing we can do anyway */\n}\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint O_CREAT ;\nint O_TRUNC ;\nint O_WRONLY ;\nint /*<<< orphan*/  S_IRUSR ;\nint /*<<< orphan*/  S_IWUSR ;\nint /*<<< orphan*/  close (int) ;\nint /*<<< orphan*/  fchmod (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fcntl (int,int,int) ;\nint /*<<< orphan*/  open (char*,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  write (int,char*,int) ;\nchar* output ;\n\nvoid writetokens(int n)\n{\nint fd;\nchar c = '+';\n\nif (output[0] >= 0)\n{\nfd = open(output, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\nfcntl(fd, F_SETFD, fcntl(fd, F_GETFD, 0) | O_NONBLOCK);\nwrite(fd, &c, 1);\nwhile (--n > 1)\nwrite(fd, &c, 1);\nclose(fd);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctfailnow",
    "input":"\n0000000000000000 <ctfailnow>:\n0: \tpushq\t%rax\n1: \txorl\t%edi, %edi\n3: \tcallq\t0x8 <ctfailnow+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <ctfailnow+0xf>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  abort () ;\nint /*<<< orphan*/  fflush (int /*<<< orphan*/ *) ;\n\nvoid\nctfailnow(void)\n{\nfflush(NULL);\nabort();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  abort () ;\nint /*<<< orphan*/  exit (int /*<<< orphan*/ ) ;\n\nvoid ctfailnow(void)\n{\nabort();\nexit(0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_copyfd",
    "input":"\n0000000000000000 <copyfd>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tsubq\t$1032, %rsp   # imm = 0x408\nd: \tmovl\t%esi, %r15d\n10: \tmovq\t%rdi, %r14\n13: \tmovq\t%rsp, %rsi\n16: \tmovl\t%r15d, %edi\n19: \tmovl\t$1024, %edx   # imm = 0x400\n1e: \tcallq\t0x23 <copyfd+0x23>\n23: \ttestq\t%rax, %rax\n26: \tje\t0x77 <copyfd+0x77>\n28: \tmovq\t%rax, %rbp\n2b: \tmovq\t%rsp, %rbx\n2e: \tjmp\t0x48 <copyfd+0x48>\n30: \tmovl\t%r15d, %edi\n33: \tmovq\t%rbx, %rsi\n36: \tmovl\t$1024, %edx   # imm = 0x400\n3b: \tcallq\t0x40 <copyfd+0x40>\n40: \tmovq\t%rax, %rbp\n43: \ttestq\t%rax, %rax\n46: \tje\t0x77 <copyfd+0x77>\n48: \tmovq\t%rbx, %rdi\n4b: \tmovl\t$1, %esi\n50: \tmovq\t%rbp, %rdx\n53: \tmovq\t%r14, %rcx\n56: \tcallq\t0x5b <copyfd+0x5b>\n5b: \tcmpq\t%rbp, %rax\n5e: \tje\t0x30 <copyfd+0x30>\n60: \tmovl\t(%rip), %esi  # 0x66 <copyfd+0x66>\n66: \tmovl\t$0, %edx\n6b: \tmovl\t$3, %edi\n70: \tcallq\t0x75 <copyfd+0x75>\n75: \tjmp\t0x30 <copyfd+0x30>\n77: \taddq\t$1032, %rsp   # imm = 0x408\n7e: \tpopq\t%rbx\n7f: \tpopq\t%r14\n81: \tpopq\t%r15\n83: \tpopq\t%rbp\n84: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ ssize_t ;\ntypedef  int /*<<< orphan*/  buf ;\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  die (int,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  errno ;\nsize_t fwrite (char*,int,scalar_t__,int /*<<< orphan*/ *) ;\nscalar_t__ read (int,char*,int) ;\n\n__attribute__((used)) static void\ncopyfd(FILE *out, int in)\n{\nssize_t n;\nchar buf[1024]; /* arbitrary size */\n\nwhile ((n = read(in, buf, sizeof(buf))) != 0) {\nif (fwrite(buf, 1, n, out) != (size_t)n) {\ndie(3, errno, \"fwrite\");\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint /*<<< orphan*/  fprintf (int,char*,int /*<<< orphan*/ ) ;\nscalar_t__ read (int,char*,int) ;\nscalar_t__ write (int,char*,scalar_t__) ;\n\nvoid copyfd(int fd, int tofd) {\nchar buf[1024];\nint r;\nwhile ((r = read(fd, buf, sizeof(buf))) > 0) {\nif (write(tofd, buf, r) != r) {\nfprintf(stderr, \"write: %s\\n\", errno);\n}\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctresettimer",
    "input":"\n0000000000000000 <ctresettimer>:\n0: \tpushq\t%rax\n1: \tmovq\t$0, (%rip)    # 0xc <ctresettimer+0xc>\nc: \txorl\t%eax, %eax\ne: \tcallq\t0x13 <ctresettimer+0x13>\n13: \tmovl\t%eax, (%rip)  # 0x19 <ctresettimer+0x19>\n19: \tpopq\t%rax\n1a: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ bdur ;\nint /*<<< orphan*/  bstart ;\nint /*<<< orphan*/  nstime () ;\n\nvoid\nctresettimer(void)\n{\nbdur = 0;\nbstart = nstime();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ctgettime () ;\nscalar_t__ ctlasttime ;\nint /*<<< orphan*/  ctstarttime ;\n\nvoid ctresettimer(void)\n{\nctlasttime = 0;\nctstarttime = ctgettime();\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_runalltest",
    "input":"\n0000000000000000 <runalltest>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tcmpq\t$0, (%rdi)\nb: \tje\t0x5d <runalltest+0x5d>\nd: \tmovl\t%esi, %r15d\n10: \tmovq\t%rdi, %r14\n13: \txorl\t%ebp, %ebp\n15: \tmovq\t%rdi, %rbx\n18: \tjmp\t0x36 <runalltest+0x36>\n1a: \tnopw\t(%rax,%rax)\n20: \tmovq\t%rbx, %rdi\n23: \tcallq\t0x28 <runalltest+0x28>\n28: \taddl\t$1, %ebp\n2b: \tcmpq\t$0, 8(%rbx)\n30: \tleaq\t8(%rbx), %rbx\n34: \tje\t0x48 <runalltest+0x48>\n36: \tcmpl\t%r15d, %ebp\n39: \tjl\t0x20 <runalltest+0x20>\n3b: \tmovq\t%r14, %rdi\n3e: \tcallq\t0x43 <runalltest+0x43>\n43: \taddl\t$-1, %ebp\n46: \tjmp\t0x20 <runalltest+0x20>\n48: \ttestl\t%ebp, %ebp\n4a: \tje\t0x5d <runalltest+0x5d>\n4c: \tnopl\t(%rax)\n50: \tmovq\t%r14, %rdi\n53: \tcallq\t0x58 <runalltest+0x58>\n58: \taddl\t$-1, %ebp\n5b: \tjne\t0x50 <runalltest+0x50>\n5d: \taddq\t$8, %rsp\n61: \tpopq\t%rbx\n62: \tpopq\t%r14\n64: \tpopq\t%r15\n66: \tpopq\t%rbp\n67: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ f; } ;\ntypedef  TYPE_1__ Test ;\n\n/* Variables and functions */\nint /*<<< orphan*/  start (TYPE_1__*) ;\nint /*<<< orphan*/  waittest (TYPE_1__*) ;\n\n__attribute__((used)) static void\nrunalltest(Test *ts, int limit)\n{\nint nrun = 0;\nTest *t;\nfor (t=ts; t->f; t++) {\nif (nrun >= limit) {\nwaittest(ts);\nnrun--;\n}\nstart(t);\nnrun++;\n}\nfor (; nrun; nrun--) {\nwaittest(ts);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ ntest; int /*<<< orphan*/ * tests; } ;\ntypedef  TYPE_1__ test_state_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  runtest (TYPE_1__*) ;\nint /*<<< orphan*/  test_cleanup (TYPE_1__*) ;\n\n__attribute__((used)) static void runalltest(test_state_t *ts, int max)\n{\nint i;\n\nfor (i = 0; i < ts->ntest; i++) {\nruntest(ts);\nif (i == max)\nbreak;\n}\n\nfor (i = 0; i < ts->ntest; i++) {\ntest_cleanup(ts);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_readtokens",
    "input":"\n0000000000000000 <readtokens>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tsubq\t$16, %rsp\n8: \tmovl\t$0, %edi\nd: \tcallq\t0x12 <readtokens+0x12>\n12: \tmovl\t$1, %ebx\n17: \ttestq\t%rax, %rax\n1a: \tje\t0xcb <readtokens+0xcb>\n20: \tmovl\t$0, %esi\n25: \tmovq\t%rax, %rdi\n28: \tcallq\t0x2d <readtokens+0x2d>\n2d: \tmovq\t%rax, 8(%rsp)\n32: \ttestq\t%rax, %rax\n35: \tje\t0x6e <readtokens+0x6e>\n37: \taddq\t$17, %rax\n3b: \tleaq\t8(%rsp), %rsi\n40: \tmovq\t%rax, %rdi\n43: \tmovl\t$10, %edx\n48: \tcallq\t0x4d <readtokens+0x4d>\n4d: \tmovl\t%eax, (%rip)  # 0x53 <readtokens+0x53>\n53: \tmovq\t8(%rsp), %rdi\n58: \taddq\t$1, %rdi\n5c: \txorl\t%esi, %esi\n5e: \tmovl\t$10, %edx\n63: \tcallq\t0x68 <readtokens+0x68>\n68: \tmovl\t%eax, (%rip)  # 0x6e <readtokens+0x6e>\n6e: \tmovl\t(%rip), %ebp  # 0x74 <readtokens+0x74>\n74: \ttestl\t%ebp, %ebp\n76: \tjs\t0xcb <readtokens+0xcb>\n78: \tmovl\t(%rip), %r14d # 0x7f <readtokens+0x7f>\n7f: \tmovl\t(%rip), %esi  # 0x85 <readtokens+0x85>\n85: \txorl\t%ebx, %ebx\n87: \tmovl\t%ebp, %edi\n89: \txorl\t%eax, %eax\n8b: \tcallq\t0x90 <readtokens+0x90>\n90: \torl\t(%rip), %eax  # 0x96 <readtokens+0x96>\n96: \tmovl\t%ebp, %edi\n98: \tmovl\t%r14d, %esi\n9b: \tmovl\t%eax, %edx\n9d: \txorl\t%eax, %eax\n9f: \tcallq\t0xa4 <readtokens+0xa4>\na4: \tleaq\t7(%rsp), %rbp\na9: \tnopl\t(%rax)\nb0: \tmovl\t(%rip), %edi  # 0xb6 <readtokens+0xb6>\nb6: \tmovq\t%rbp, %rsi\nb9: \tmovl\t$1, %edx\nbe: \tcallq\t0xc3 <readtokens+0xc3>\nc3: \taddl\t$1, %ebx\nc6: \ttestq\t%rax, %rax\nc9: \tjg\t0xb0 <readtokens+0xb0>\ncb: \tmovl\t%ebx, %eax\ncd: \taddq\t$16, %rsp\nd1: \tpopq\t%rbx\nd2: \tpopq\t%r14\nd4: \tpopq\t%rbp\nd5: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_GETFL ;\nint /*<<< orphan*/  F_SETFL ;\nint O_NONBLOCK ;\nint fcntl (int,int /*<<< orphan*/ ,...) ;\nchar* getenv (char*) ;\nscalar_t__ read (int,char*,int) ;\nint rjobfd ;\nchar* strstr (char*,char*) ;\nscalar_t__ strtol (char*,char**,int) ;\nint wjobfd ;\n\n__attribute__((used)) static int\nreadtokens()\n{\nint n = 1;\nchar c, *s;\nchar *v = getenv(\"MAKEFLAGS\");\nif (v == NULL)\nreturn n;\nif ((s = strstr(v, \" --jobserver-fds=\"))) {\nrjobfd = (int)strtol(s+17, &s, 10);  /* skip \" --jobserver-fds=\" */\nwjobfd = (int)strtol(s+1, NULL, 10); /* skip comma */\n}\nif (rjobfd >= 0) {\nfcntl(rjobfd, F_SETFL, fcntl(rjobfd, F_GETFL)|O_NONBLOCK);\nwhile (read(rjobfd, &c, 1) > 0) {\nn++;\n}\n}\nreturn n;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  O_RDONLY ;\nint /*<<< orphan*/  S_IRUSR ;\nint /*<<< orphan*/  close (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  fscanf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  ftruncate (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  memset (char*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  open (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  printf (char*,...) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strlen (char*) ;\nint /*<<< orphan*/  strncpy (char*,char*,int) ;\nscalar_t__ strtok (char*,char*) ;\n\nint readtokens(char *filename)\n{\nchar *token;\nint i;\n\nprintf(\"Reading tokens from %s\\n\", filename);\n\ntoken = strtok(filename, \" \");\nif (token == NULL) {\nperror(\"strtok\");\nreturn -1;\n}\n\nfprintf(stderr, \"Opening %s\\n\", token);\n\nif (open(token, O_RDONLY, S_IRUSR) < 0) {\nperror(\"open\");\nreturn -1;\n}\n\nftruncate(0, strlen(token)+1);\nmemset(token, 0, strlen(token)+1);\n\nfor (i = 0; (token = strtok(NULL, \"\\n\")) != NULL; i++) {\nfscanf(0, \"%s\", token);\n}\n\nclose(0);\n\nreturn i;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_failed",
    "input":"\n0000000000000000 <failed>:\n0: \tpushq\t%rbx\n1: \tmovl\t%edi, %ebx\n3: \tcallq\t0x8 <failed+0x8>\n8: \ttestq\t%rax, %rax\nb: \tje\t0x25 <failed+0x25>\nd: \tmovl\t%ebx, %edi\nf: \tcallq\t0x14 <failed+0x14>\n14: \tmovq\t%rax, %rcx\n17: \txorl\t%eax, %eax\n19: \tcmpq\t(%rip), %rcx  # 0x20 <failed+0x20>\n20: \tsete\t%al\n23: \tpopq\t%rbx\n24: \tretq\n25: \txorl\t%eax, %eax\n27: \tpopq\t%rbx\n28: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nscalar_t__ SIGABRT ;\nscalar_t__ WIFSIGNALED (int) ;\nscalar_t__ WTERMSIG (int) ;\n\n__attribute__((used)) static int\nfailed(int s)\n{\nreturn WIFSIGNALED(s) && (WTERMSIG(s) == SIGABRT);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  lua_State ;\n\n/* Variables and functions */\nscalar_t__ LUA_ERRRUN ;\nscalar_t__ lua_tostring (int /*<<< orphan*/ *,int) ;\nscalar_t__ lua_type (int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static int failed(lua_State *L, int n) {\nif (lua_type(L, n) == LUA_ERRRUN) {\nreturn lua_tostring(L, -1) == NULL;\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctdir",
    "input":"\n0000000000000000 <ctdir>:\n0: \tmovq\t(%rip), %rax  # 0x7 <ctdir+0x7>\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* curdir ;\n\nchar *\nctdir(void)\n{\nreturn curdir;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* ctdir_ ;\n\nchar *ctdir(void) {\nreturn ctdir_;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_runallbench",
    "input":"\n0000000000000000 <runallbench>:\n0: \tpushq\t%rbx\n1: \tcmpq\t$0, (%rdi)\n5: \tje\t0x23 <runallbench+0x23>\n7: \tmovq\t%rdi, %rbx\na: \tnopw\t(%rax,%rax)\n10: \tmovq\t%rbx, %rdi\n13: \tcallq\t0x18 <runallbench+0x18>\n18: \tcmpq\t$0, 8(%rbx)\n1d: \tleaq\t8(%rbx), %rbx\n21: \tjne\t0x10 <runallbench+0x10>\n23: \tpopq\t%rbx\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ f; } ;\ntypedef  TYPE_1__ Benchmark ;\n\n/* Variables and functions */\nint /*<<< orphan*/  runbench (TYPE_1__*) ;\n\n__attribute__((used)) static void\nrunallbench(Benchmark *b)\n{\nfor (; b->f; b++) {\nrunbench(b);\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ nbench; scalar_t__* bench; } ;\ntypedef  TYPE_1__ bench_ctx_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  runbench (TYPE_1__*) ;\n\n__attribute__((used)) static void runallbench(bench_ctx_t *ctx)\n{\nwhile (ctx->nbench) {\nrunbench(ctx);\nctx->bench++;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_die",
    "input":"\n0000000000000000 <die>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rdx, %rbx\n7: \tmovl\t%esi, %ebp\n9: \tmovl\t%edi, %r14d\nc: \tmovl\t(%rip), %esi  # 0x12 <die+0x12>\n12: \tmovl\t$10, %edi\n17: \tcallq\t0x1c <die+0x1c>\n1c: \ttestq\t%rbx, %rbx\n1f: \tje\t0x44 <die+0x44>\n21: \tcmpb\t$0, (%rbx)\n24: \tje\t0x44 <die+0x44>\n26: \tmovl\t(%rip), %esi  # 0x2c <die+0x2c>\n2c: \tmovq\t%rbx, %rdi\n2f: \tcallq\t0x34 <die+0x34>\n34: \tmovl\t(%rip), %esi  # 0x3a <die+0x3a>\n3a: \tmovl\t$0, %edi\n3f: \tcallq\t0x44 <die+0x44>\n44: \tmovl\t%ebp, %edi\n46: \tcallq\t0x4b <die+0x4b>\n4b: \tmovl\t(%rip), %esi  # 0x51 <die+0x51>\n51: \tmovq\t%rax, %rdi\n54: \tcallq\t0x59 <die+0x59>\n59: \tmovl\t(%rip), %esi  # 0x5f <die+0x5f>\n5f: \tmovl\t$10, %edi\n64: \tcallq\t0x69 <die+0x69>\n69: \tmovl\t%r14d, %edi\n6c: \tcallq\t0x71 <die+0x71>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fputs (char const*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  putc (char,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nchar* strerror (int) ;\n\n__attribute__((used)) static void\ndie(int code, int err, const char *msg)\n{\nputc('\\n', stderr);\n\nif (msg && *msg) {\nfputs(msg, stderr);\nfputs(\": \", stderr);\n}\n\nfputs(strerror(err), stderr);\nputc('\\n', stderr);\nexit(code);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strerror (int) ;\nint /*<<< orphan*/  strlen (char*) ;\nint /*<<< orphan*/  strncat (char*,char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strncpy (char*,char*,int /*<<< orphan*/ ) ;\n\nvoid die(int err, int line, char *msg) {\nfprintf(stderr, \"\\n\");\nif (msg && *msg) {\nstrncat(msg, \"\\n\", strlen(msg));\nfprintf(stderr, \"%s\", msg);\n}\nfprintf(stderr, \"Error: %s\\n\", strerror(err));\nfprintf(stderr, \"Line: %d\\n\", line);\nexit(err);\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctstarttimer",
    "input":"\n0000000000000000 <ctstarttimer>:\n0: \tpushq\t%rax\n1: \tcmpl\t$0, (%rip)    # 0x8 <ctstarttimer+0x8>\n8: \tje\t0xc <ctstarttimer+0xc>\na: \tpopq\t%rax\nb: \tretq\nc: \txorl\t%eax, %eax\ne: \tcallq\t0x13 <ctstarttimer+0x13>\n13: \tmovl\t%eax, (%rip)  # 0x19 <ctstarttimer+0x19>\n19: \tmovl\t$1, (%rip)    # 0x23 <ctstarttimer+0x23>\n23: \tpopq\t%rax\n24: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bstart ;\nint btiming ;\nint /*<<< orphan*/  nstime () ;\n\nvoid\nctstarttimer(void)\n{\nif (!btiming) {\nbstart = nstime();\nbtiming = 1;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_timer ;\nint /*<<< orphan*/  ct_timer_start () ;\nint /*<<< orphan*/  ct_timer_stop () ;\nint ct_timer_started ;\n\nvoid\nctstarttimer(void)\n{\nif (ct_timer_started)\n{\nct_timer_stop();\nct_timer_started = 0;\n}\nct_timer = ct_timer_start();\nct_timer_started = 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_min",
    "input":"\n0000000000000000 <min>:\n0: \tmovl\t%esi, %eax\n2: \tcmpl\t%esi, %edi\n4: \tcmovlel\t%edi, %eax\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int\nmin(int a, int b)\n{\nif (a < b) {\nreturn a;\n}\nreturn b;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static inline int min(int a, int b)\n{\nreturn a < b ? a : b;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_ctsetbytes",
    "input":"\n0000000000000000 <ctsetbytes>:\n0: \tmovslq\t%edi, %rax\n3: \tmovq\t%rax, (%rip)  # 0xa <ctsetbytes+0xa>\na: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ int64 ;\n\n/* Variables and functions */\nscalar_t__ bbytes ;\n\nvoid\nctsetbytes(int n)\n{\nbbytes = (int64)n;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nlong ctbytes ;\n\nvoid ctsetbytes(long bytes)\n{\nctbytes = bytes;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_roundup",
    "input":"\n0000000000000000 <roundup>:\n0: \tpushq\t%rbx\n1: \tmovl\t%edi, %ebx\n3: \tcallq\t0x8 <roundup+0x8>\n8: \tmovl\t%eax, %ecx\na: \tcmpl\t%ebx, %eax\nc: \tjge\t0x2b <roundup+0x2b>\ne: \tleal\t(%rax,%rax), %ecx\n11: \tcmpl\t%ebx, %ecx\n13: \tjge\t0x2b <roundup+0x2b>\n15: \tleal\t(%rax,%rax,2), %ecx\n18: \tcmpl\t%ebx, %ecx\n1a: \tjge\t0x2b <roundup+0x2b>\n1c: \tleal\t(%rax,%rax,4), %ecx\n1f: \taddl\t%eax, %eax\n21: \tcmpl\t%ebx, %ecx\n23: \tleal\t(%rax,%rax,4), %eax\n26: \tcmovgel\t%ecx, %eax\n29: \tpopq\t%rbx\n2a: \tretq\n2b: \tmovl\t%ecx, %eax\n2d: \tpopq\t%rbx\n2e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint rounddown10 (int) ;\n\n__attribute__((used)) static int\nroundup(int n)\n{\nint base = rounddown10(n);\nif (n <= base)\nreturn base;\nif (n <= 2*base)\nreturn 2*base;\nif (n <= 3*base)\nreturn 3*base;\nif (n <= 5*base)\nreturn 5*base;\nreturn 10*base;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ceillog2 (int) ;\n\n__attribute__((used)) static inline int\nroundup(int x)\n{\nint\t\t\tl = ceillog2(x);\n\nif (x == (1 << l))\nreturn x;\nif (x > (1 << (l + 1)))\nreturn 1 << (l + 1);\nreturn 1 << l;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_nstime",
    "input":"\n0000000000000000 <nstime>:\n0: \tsubq\t$24, %rsp\n4: \tmovl\t(%rip), %edi  # 0xa <nstime+0xa>\na: \tleaq\t8(%rsp), %rsi\nf: \tcallq\t0x14 <nstime+0x14>\n14: \tmovl\t(%rip), %eax  # 0x1a <nstime+0x1a>\n1a: \timull\t16(%rsp), %eax\n1f: \taddl\t8(%rsp), %eax\n23: \taddq\t$24, %rsp\n27: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct timespec {int tv_nsec; scalar_t__ tv_sec; } ;\ntypedef  int int64 ;\n\n/* Variables and functions */\nint /*<<< orphan*/  CLOCK_MONOTONIC ;\nint Second ;\nint /*<<< orphan*/  clock_gettime (int /*<<< orphan*/ ,struct timespec*) ;\n\n__attribute__((used)) static int64\nnstime()\n{\nstruct timespec t;\nclock_gettime(CLOCK_MONOTONIC, &t);\nreturn (int64)(t.tv_sec)*Second + t.tv_nsec;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  time_t ;\n\n/* Variables and functions */\nint CLOCKS_PER_SEC ;\nint /*<<< orphan*/  clock () ;\nint /*<<< orphan*/  difftime (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\n\nlong nstime(void) {\ntime_t t;\nlong n;\n\ndifftime(clock(), &t);\nn = (long)t * CLOCKS_PER_SEC;\nreturn n;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_waittest",
    "input":"\n0000000000000000 <waittest>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovq\t%rdi, %rbx\n6: \tleaq\t4(%rsp), %rdi\nb: \txorl\t%esi, %esi\nd: \txorl\t%edx, %edx\nf: \tcallq\t0x14 <waittest+0x14>\n14: \tmovl\t%eax, %ebp\n16: \tcmpl\t$-1, %eax\n19: \tjne\t0x30 <waittest+0x30>\n1b: \tmovl\t(%rip), %esi  # 0x21 <waittest+0x21>\n21: \tmovl\t$0, %edx\n26: \tmovl\t$3, %edi\n2b: \tcallq\t0x30 <waittest+0x30>\n30: \tmovl\t(%rip), %esi  # 0x36 <waittest+0x36>\n36: \tmovl\t%ebp, %edi\n38: \tcallq\t0x3d <waittest+0x3d>\n3d: \tcmpq\t$0, 8(%rbx)\n42: \tje\t0x8e <waittest+0x8e>\n44: \taddq\t$4, %rbx\n48: \tjmp\t0x7b <waittest+0x7b>\n4a: \tnopw\t(%rax,%rax)\n50: \tcallq\t0x55 <waittest+0x55>\n55: \tcmpq\t$1, %rax\n59: \tmovb\t$70, %al\n5b: \tsbbb\t$0, %al\n5d: \tmovsbl\t%al, %edi\n60: \tcallq\t0x65 <waittest+0x65>\n65: \tmovl\t(%rip), %edi  # 0x6b <waittest+0x6b>\n6b: \tcallq\t0x70 <waittest+0x70>\n70: \tcmpq\t$0, 20(%rbx)\n75: \tleaq\t16(%rbx), %rbx\n79: \tje\t0x8e <waittest+0x8e>\n7b: \tcmpl\t%ebp, -4(%rbx)\n7e: \tjne\t0x70 <waittest+0x70>\n80: \tmovl\t4(%rsp), %edi\n84: \tmovl\t%edi, (%rbx)\n86: \ttestl\t%edi, %edi\n88: \tjne\t0x50 <waittest+0x50>\n8a: \tmovb\t$46, %al\n8c: \tjmp\t0x5d <waittest+0x5d>\n8e: \taddq\t$8, %rsp\n92: \tpopq\t%rbx\n93: \tpopq\t%rbp\n94: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int pid; int status; scalar_t__ f; } ;\ntypedef  TYPE_1__ Test ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGKILL ;\nint /*<<< orphan*/  die (int,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  errno ;\nscalar_t__ failed (int) ;\nint /*<<< orphan*/  fflush (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  killpg (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  putchar (char) ;\nint /*<<< orphan*/  stdout ;\nint wait3 (int*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void\nwaittest(Test *ts)\n{\nTest *t;\nint pid, stat;\n\npid = wait3(&stat, 0, 0);\nif (pid == -1) {\ndie(3, errno, \"wait\");\n}\nkillpg(pid, SIGKILL);\n\nfor (t=ts; t->f; t++) {\nif (t->pid == pid) {\nt->status = stat;\nif (!t->status) {\nputchar('.');\n} else if (failed(t->status)) {\nputchar('F');\n} else {\nputchar('E');\n}\nfflush(stdout);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  w; int /*<<< orphan*/  h; int /*<<< orphan*/  x; int /*<<< orphan*/  y; scalar_t__ visible; } ;\ntypedef  TYPE_1__ WINDOWPLACEMENT ;\n\n/* Variables and functions */\nint /*<<< orphan*/  GetLastError () ;\nint /*<<< orphan*/  GetWindowPlacement (int /*<<< orphan*/ ,TYPE_1__*) ;\nscalar_t__ GetWindowRect (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SetLastError (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TRUE ;\nint /*<<< orphan*/  WIN32_FIND_DATA ;\nint /*<<< orphan*/  WIN32_FIND_DATAW ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W_W ;\nint /*<<< orphan*/  WIN32_FIND_DATA_W_W_W_W_W_W_W_W_W"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_tmpfd",
    "input":"\n0000000000000000 <tmpfd>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <tmpfd+0x8>\n8: \tmovq\t%rax, %rbx\nb: \ttestq\t%rax, %rax\ne: \tjne\t0x25 <tmpfd+0x25>\n10: \tmovl\t(%rip), %esi  # 0x16 <tmpfd+0x16>\n16: \tmovl\t$0, %edx\n1b: \tmovl\t$1, %edi\n20: \tcallq\t0x25 <tmpfd+0x25>\n25: \tmovq\t%rbx, %rdi\n28: \tpopq\t%rbx\n29: \tjmp\t0x2e <tmpfd+0x2e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  die (int,int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  errno ;\nint fileno (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * tmpfile () ;\n\n__attribute__((used)) static int\ntmpfd(void)\n{\nFILE *f = tmpfile();\nif (!f) {\ndie(1, errno, \"tmpfile\");\n}\nreturn fileno(f);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static FILE *\ntmpfd(void)\n{\nFILE *fp;\n\nif ((fp = fopen(\"/dev/null\", \"w\")) == NULL)\nfprintf(stderr, \"Cannot open /dev/null\\n\");\nreturn fp;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_max",
    "input":"\n0000000000000000 <max>:\n0: \tmovl\t%esi, %eax\n2: \tcmpl\t%esi, %edi\n4: \tcmovgel\t%edi, %eax\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static int\nmax(int a, int b)\n{\nif (a > b) {\nreturn a;\n}\nreturn b;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\n\n__attribute__((used)) static inline int max(int a, int b)\n{\nreturn a > b ? a : b;\n}</s><s>"
},
{
    "file:":"./beanstalkd/ct/extr_ct.c_main",
    "input":"\n0000000000000000 <main>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %r14\n7: \tmovl\t%edi, %ebx\n9: \txorl\t%eax, %eax\nb: \tcallq\t0x10 <main+0x10>\n10: \tmovl\t%eax, %ebp\n12: \tmovl\t(%rip), %edi  # 0x18 <main+0x18>\n18: \tmovl\t%eax, %esi\n1a: \tcallq\t0x1f <main+0x1f>\n1f: \tmovl\t%ebp, %edi\n21: \tcallq\t0x26 <main+0x26>\n26: \tmovl\t(%rip), %edi  # 0x2c <main+0x2c>\n2c: \tcallq\t0x31 <main+0x31>\n31: \tmovl\t%eax, %ebp\n33: \tcmpl\t$2, %ebx\n36: \tjne\t0x5a <main+0x5a>\n38: \ttestl\t%ebp, %ebp\n3a: \tjne\t0x5a <main+0x5a>\n3c: \tmovq\t8(%r14), %rdi\n40: \tmovl\t$0, %esi\n45: \tcallq\t0x4a <main+0x4a>\n4a: \ttestq\t%rax, %rax\n4d: \tjne\t0x5a <main+0x5a>\n4f: \tmovl\t(%rip), %edi  # 0x55 <main+0x55>\n55: \tcallq\t0x5a <main+0x5a>\n5a: \tmovl\t%ebp, %eax\n5c: \tpopq\t%rbx\n5d: \tpopq\t%r14\n5f: \tpopq\t%rbp\n60: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ctmainbench ;\nint /*<<< orphan*/  ctmaintest ;\nint readtokens () ;\nint report (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  runallbench (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  runalltest (int /*<<< orphan*/ ,int) ;\nscalar_t__ strcmp (char*,char*) ;\nint /*<<< orphan*/  writetokens (int) ;\n\nint\nmain(int argc, char **argv)\n{\nint n = readtokens();\nrunalltest(ctmaintest, n);\nwritetokens(n);\nint code = report(ctmaintest);\nif (code != 0) {\nreturn code;\n}\nif (argc == 2 && strcmp(argv[1], \"-b\") == 0) {\nrunallbench(ctmainbench);\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  EXIT_FAILURE ;\nint /*<<< orphan*/  EXIT_SUCCESS ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  free (char*) ;\nint /*<<< orphan*/  getpid () ;\nint /*<<< orphan*/  kill (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  printf (char*,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  strcmp (char*,char*) ;\nint /*<<< orphan*/  strerror (int) ;\nint /*<<< orphan*/  strlen (char*) ;\nint /*<<< orphan*/  strsignal (int) ;\nint /*<<< orphan*/  strstr (char*,char*) ;\nint /*<<< orphan*/  strtok (char*,char*) ;\nint /*<<< orphan*/  strtok_r (char*,char*,char**) ;\n\nint main(int argc, char **argv)\n{\nint i;\nchar *p;\n\ni = strlen(argv[0]);\nprintf(\"[*] %s %d\\n\", argv[0], getpid());\nif (argc == 2) {\nif (!strcmp(argv[1], \"--help\")) {\nfprintf(stderr, \"Usage: %s <pid>\\n\", argv[0]);\nreturn EXIT_FAILURE;\n}\np = strtok_r(argv[1], \" \", &p);\nif (p == NULL) {\nperror(\"strtok\");\nreturn EXIT_FAILURE;\n}\nif (strstr(strsignal(atoi(p)), \"Segmentation\")) {\nfprintf(stderr, \"[-] %s\\n\", strsignal(atoi(p)));\nreturn EXIT_FAILURE;\n}\n}\nkill(atoi(argv[1]), SIGSEGV);\nreturn EXIT_SUCCESS;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_grow",
    "input":"\n0000000000000000 <grow>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rdi, %rbx\na: \tmovl\t(%rdi), %ebp\nc: \taddl\t%ebp, %ebp\ne: \tmovl\t$1, %r14d\n14: \tcmovel\t%r14d, %ebp\n18: \tmovslq\t%ebp, %rdi\n1b: \tshlq\t$3, %rdi\n1f: \tcallq\t0x24 <grow+0x24>\n24: \ttestq\t%rax, %rax\n27: \tje\t0x4f <grow+0x4f>\n29: \tmovq\t%rax, %r15\n2c: \tmovq\t8(%rbx), %rsi\n30: \tmovl\t16(%rbx), %edx\n33: \tshll\t$3, %edx\n36: \tmovq\t%rax, %rdi\n39: \tcallq\t0x3e <grow+0x3e>\n3e: \tmovq\t8(%rbx), %rdi\n42: \tcallq\t0x47 <grow+0x47>\n47: \tmovq\t%r15, 8(%rbx)\n4b: \tmovl\t%ebp, (%rbx)\n4d: \tjmp\t0x52 <grow+0x52>\n4f: \txorl\t%r14d, %r14d\n52: \tmovl\t%r14d, %eax\n55: \taddq\t$8, %rsp\n59: \tpopq\t%rbx\n5a: \tpopq\t%r14\n5c: \tpopq\t%r15\n5e: \tpopq\t%rbp\n5f: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int cap; void** items; int len; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (void**) ;\nvoid** malloc (size_t) ;\nint /*<<< orphan*/  memcpy (void**,void**,int) ;\n\n__attribute__((used)) static int\ngrow(Ms *a)\n{\nvoid **nitems;\nsize_t ncap = a->cap << 1;\nif (!ncap)\nncap = 1;\n\nnitems = malloc(ncap * sizeof(void *));\nif (!nitems)\nreturn 0;\n\nmemcpy(nitems, a->items, a->len * sizeof(void *));\nfree(a->items);\na->items = nitems;\na->cap = ncap;\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int size; int /*<<< orphan*/ * data; int /*<<< orphan*/  alloc; } ;\ntypedef  TYPE_1__ strbuf_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * malloc (size_t) ;\nint /*<<< orphan*/  memcpy (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int) ;\n\n__attribute__((used)) static int grow(strbuf_t *sb)\n{\nint newsize = sb->size * 2 + 1;\nint *newdata = malloc(newsize * sizeof(int));\nif (!newdata)\nreturn 0;\nmemcpy(newdata, sb->data, sb->size * sizeof(int));\nfree(sb->data);\nsb->data = newdata;\nsb->size = newsize;\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_balance",
    "input":"\n0000000000000000 <balance>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovl\t%esi, %r14d\n7: \tmovq\t%rdi, %rbx\na: \tmovq\t(%rdi), %rsi\nd: \tnopl\t(%rax)\n10: \tmovl\t(%rsi), %ebp\n12: \tcmpl\t%r14d, %ebp\n15: \tjge\t0x3f <balance+0x3f>\n17: \tmovq\t%rbx, %rdi\n1a: \tmovl\t%ebp, %esi\n1c: \tcallq\t0x21 <balance+0x21>\n21: \tcmpl\t%ebp, %eax\n23: \tjne\t0x4e <balance+0x4e>\n25: \tmovl\t8(%rbx), %edi\n28: \tmovq\t(%rbx), %rsi\n2b: \tmovl\t%ebp, %edx\n2d: \tcallq\t0x32 <balance+0x32>\n32: \tmovq\t%rbx, %rdi\n35: \tcallq\t0x3a <balance+0x3a>\n3a: \tmovq\t(%rbx), %rsi\n3d: \tjmp\t0x10 <balance+0x10>\n3f: \tmovq\t%rbx, %rdi\n42: \tmovl\t%r14d, %edx\n45: \tpopq\t%rbx\n46: \tpopq\t%r14\n48: \tpopq\t%rbp\n49: \tjmp\t0x4e <balance+0x4e>\n4e: \tmovl\t$0, %edi\n53: \tcallq\t0x58 <balance+0x58>\n58: \txorl\t%eax, %eax\n5a: \tpopq\t%rbx\n5b: \tpopq\t%r14\n5d: \tpopq\t%rbp\n5e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {TYPE_4__* cur; int /*<<< orphan*/  tail; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_9__ {int resv; } ;\n\n/* Variables and functions */\nint balancerest (TYPE_1__*,TYPE_4__*,int) ;\nint /*<<< orphan*/  moveresv (int /*<<< orphan*/ ,TYPE_4__*,int) ;\nint needfree (TYPE_1__*,int) ;\nint /*<<< orphan*/  twarnx (char*) ;\nint /*<<< orphan*/  usenext (TYPE_1__*) ;\n\n__attribute__((used)) static int\nbalance(Wal *w, int n)\n{\n// Invariant 1\n// (this loop will run at most once)\nwhile (w->cur->resv < n) {\nint m = w->cur->resv;\n\nint r = needfree(w, m);\nif (r != m) {\ntwarnx(\"needfree\");\nreturn 0;\n}\n\nmoveresv(w->tail, w->cur, m);\nusenext(w);\n}\n\n// Invariants 2 and 3\nreturn balancerest(w, w->cur, n);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ * right; int /*<<< orphan*/ * left; } ;\ntypedef  TYPE_1__ tree_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint height (TYPE_1__*,int) ;\nint /*<<< orphan*/  rotate_left (TYPE_1__*) ;\nint /*<<< orphan*/  rotate_right (TYPE_1__*) ;\n\n__attribute__((used)) static int balance(tree_t *T, int x)\n{\nint y;\n\nwhile (1) {\ny = height(T->left, x);\nif (y >= height(T->right, x)) {\nif (height(T->left->left, x) >= height(T->left->right, x)) {\nrotate_right(T);\n} else {\nrotate_left(T->left);\nrotate_right(T);\n}\n} else {\nif (height(T->right->right, x) >= height(T->right->left, x)) {\nrotate_left(T);\n} else {\nrotate_right(T->right);\nrotate_left(T);\n}\n}\nif (T->left->key == x) {\nreturn T->left->key;\n} else {\nassert(T->right->key == x);\nreturn T->right->key;\n}\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_has_reserved_job",
    "input":"\n0000000000000000 <has_reserved_job>:\n0: \tpushq\t%rax\n1: \tcallq\t0x6 <has_reserved_job+0x6>\n6: \txorl\t%ecx, %ecx\n8: \ttestl\t%eax, %eax\na: \tsete\t%cl\nd: \tmovl\t%ecx, %eax\nf: \tpopq\t%rcx\n10: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  reserved_jobs; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\nint /*<<< orphan*/  job_list_is_empty (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int\nhas_reserved_job(Conn *c)\n{\nreturn !job_list_is_empty(&c->reserved_jobs);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  has_reserved_job_internal () ;\n\nint has_reserved_job (void) {\nreturn has_reserved_job_internal() ? 1 : 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_heap.c_swap",
    "input":"\n0000000000000000 <swap>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tmovq\t%rdx, %r14\n8: \tmovq\t%rdi, %rbx\nb: \tmovq\t(%rdi), %rax\ne: \tmovq\t(%rax,%rsi,8), %r15\n12: \tmovq\t(%rax,%rdx,8), %rdx\n16: \tcallq\t0x1b <swap+0x1b>\n1b: \tmovq\t%rbx, %rdi\n1e: \tmovq\t%r14, %rsi\n21: \tmovq\t%r15, %rdx\n24: \tpopq\t%rbx\n25: \tpopq\t%r14\n27: \tpopq\t%r15\n29: \tjmp\t0x2e <swap+0x2e>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {void** data; } ;\ntypedef  TYPE_1__ Heap ;\n\n/* Variables and functions */\nint /*<<< orphan*/  set (TYPE_1__*,size_t,void*) ;\n\n__attribute__((used)) static void\nswap(Heap *h, size_t a, size_t b)\n{\nvoid *tmp;\n\ntmp = h->data[a];\nset(h, a, h->data[b]);\nset(h, b, tmp);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/ ** p; } ;\ntypedef  TYPE_1__ GainControlState ;\n\n/* Variables and functions */\nint /*<<< orphan*/  set_gain (TYPE_1__*,size_t,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void swap(GainControlState *s, size_t a, size_t b)\n{\nset_gain(s, a, s->p[b]);\nset_gain(s, b, s->p[a]);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_unix_auto_removal",
    "input":"\n0000000000000000 <cttest_unix_auto_removal>:\n0: \tpushq\t%rax\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_unix_auto_removal+0x8>\n8: \txorl\t%eax, %eax\na: \tcallq\t0xf <cttest_unix_auto_removal+0xf>\nf: \txorl\t%eax, %eax\n11: \tpopq\t%rcx\n12: \tjmp\t0x17 <cttest_unix_auto_removal+0x17>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  SERVER_UNIX () ;\nint /*<<< orphan*/  kill_srvpid () ;\n\nvoid\ncttest_unix_auto_removal()\n{\n// Twice, to trigger autoremoval\nSERVER_UNIX();\nkill_srvpid();\nSERVER_UNIX();\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_unix_auto_removal () ;\nint /*<<< orphan*/  ct_unix_cleanup () ;\nint /*<<< orphan*/  ct_unix_init () ;\n\n__attribute__((used)) static void\ncttest_unix_auto_removal(void)\n{\nct_unix_init();\nct_unix_cleanup();\nct_unix_auto_removal();\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_mustforksrv",
    "input":"\n0000000000000000 <mustforksrv>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovl\t$0, %edi\na: \tmovl\t$0, %esi\nf: \tcallq\t0x14 <mustforksrv+0x14>\n14: \tmovl\t%eax, (%rip)  # 0x1a <mustforksrv+0x1a>\n1a: \tcmpl\t$-1, %eax\n1d: \tje\t0x89 <mustforksrv+0x89>\n1f: \tmovq\t$4, 8(%rsp)\n28: \tmovq\t%rsp, %rsi\n2b: \tleaq\t8(%rsp), %rdx\n30: \tmovl\t%eax, %edi\n32: \tcallq\t0x37 <mustforksrv+0x37>\n37: \tcmpl\t$-1, %eax\n3a: \tje\t0x89 <mustforksrv+0x89>\n3c: \tcmpq\t$5, 8(%rsp)\n42: \tjae\t0x89 <mustforksrv+0x89>\n44: \tmovl\t(%rsp), %edi\n47: \tcallq\t0x4c <mustforksrv+0x4c>\n4c: \tmovl\t%eax, %ebx\n4e: \txorl\t%eax, %eax\n50: \tcallq\t0x55 <mustforksrv+0x55>\n55: \tmovq\t%rax, (%rip)  # 0x5c <mustforksrv+0x5c>\n5c: \ttestq\t%rax, %rax\n5f: \tjs\t0x9d <mustforksrv+0x9d>\n61: \tje\t0xb1 <mustforksrv+0xb1>\n63: \tmovl\t(%rip), %edi  # 0x69 <mustforksrv+0x69>\n69: \tcallq\t0x6e <mustforksrv+0x6e>\n6e: \tmovq\t(%rip), %rdx  # 0x75 <mustforksrv+0x75>\n75: \tmovl\t$0, %edi\n7a: \tmovl\t%ebx, %esi\n7c: \tcallq\t0x81 <mustforksrv+0x81>\n81: \tmovl\t%ebx, %eax\n83: \taddq\t$16, %rsp\n87: \tpopq\t%rbx\n88: \tretq\n89: \tmovl\t$0, %edi\n8e: \tcallq\t0x93 <mustforksrv+0x93>\n93: \tmovl\t$1, %edi\n98: \tcallq\t0x9d <mustforksrv+0x9d>\n9d: \tmovl\t$0, %edi\na2: \tcallq\t0xa7 <mustforksrv+0xa7>\na7: \tmovl\t$1, %edi\nac: \tcallq\t0xb1 <mustforksrv+0xb1>\nb1: \txorl\t%eax, %eax\nb3: \tcallq\t0xb8 <mustforksrv+0xb8>\nb8: \txorl\t%eax, %eax\nba: \tcallq\t0xbf <mustforksrv+0xbf>\nbf: \tmovl\t$0, %edi\nc4: \tcallq\t0xc9 <mustforksrv+0xc9>\nc9: \tmovl\t$0, %edi\nce: \tcallq\t0xd3 <mustforksrv+0xd3>\nd3: \tmovl\t$1, %edi\nd8: \tcallq\t0xdd <mustforksrv+0xdd>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct sockaddr_in {int /*<<< orphan*/  sin_port; } ;\nstruct sockaddr {int dummy; } ;\ntypedef  int /*<<< orphan*/  socklen_t ;\ntypedef  int /*<<< orphan*/  addr ;\nstruct TYPE_5__ {int fd; } ;\nstruct TYPE_6__ {TYPE_1__ sock; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  atexit (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  exit (int) ;\nscalar_t__ fork () ;\nint getsockname (int,struct sockaddr*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  kill_srvpid ;\nint make_server_socket (char*,char*) ;\nint ntohs (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  printf (char*,int,scalar_t__) ;\nint /*<<< orphan*/  prot_init () ;\nint /*<<< orphan*/  puts (char*) ;\nint /*<<< orphan*/  set_sig_handler () ;\nTYPE_2__ srv ;\nint /*<<< orphan*/  srv_acquire_wal (TYPE_2__*) ;\nscalar_t__ srvpid ;\nint /*<<< orphan*/  srvserve (TYPE_2__*) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static int\nmustforksrv(void)\n{\nstruct sockaddr_in addr;\n\nsrv.sock.fd = make_server_socket(\"127.0.0.1\", \"0\");\nif (srv.sock.fd == -1) {\nputs(\"mustforksrv failed\");\nexit(1);\n}\n\nsize_t len = sizeof(addr);\nint r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, (socklen_t *)&len);\nif (r == -1 || len > sizeof(addr)) {\nputs(\"mustforksrv failed\");\nexit(1);\n}\n\nint port = ntohs(addr.sin_port);\nsrvpid = fork();\nif (srvpid < 0) {\ntwarn(\"fork\");\nexit(1);\n}\n\nif (srvpid > 0) {\n// On exit the parent (test) sends SIGTERM to the child.\natexit(kill_srvpid);\nprintf(\"start server port=%d pid=%d\\n\", port, srvpid);\nreturn port;\n}\n\n/* now in child */\n\nset_sig_handler();\nprot_init();\n\nsrv_acquire_wal(&srv);\n\nsrvserve(&srv); /* does not return */\nexit(1); /* satisfy the compiler */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_un {int dummy; } ;\nstruct sockaddr {int dummy; } ;\nstruct sockaddr_in {int dummy; } ;\nstruct sockaddr_in6 {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr_storage {int dummy; } ;\nstruct sockaddr"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_too_big",
    "input":"\n0000000000000000 <cttest_too_big>:\n0: \tpushq\t%rbx\n1: \tmovl\t$10, (%rip)   # 0xb <cttest_too_big+0xb>\nb: \txorl\t%eax, %eax\nd: \tcallq\t0x12 <cttest_too_big+0x12>\n12: \tmovl\t%eax, %edi\n14: \tcallq\t0x19 <cttest_too_big+0x19>\n19: \tmovl\t%eax, %ebx\n1b: \tmovl\t$0, %esi\n20: \tmovl\t%eax, %edi\n22: \tcallq\t0x27 <cttest_too_big+0x27>\n27: \tmovl\t$0, %esi\n2c: \tmovl\t%ebx, %edi\n2e: \tcallq\t0x33 <cttest_too_big+0x33>\n33: \tmovl\t$0, %esi\n38: \tmovl\t%ebx, %edi\n3a: \tcallq\t0x3f <cttest_too_big+0x3f>\n3f: \tmovl\t$0, %esi\n44: \tmovl\t%ebx, %edi\n46: \tcallq\t0x4b <cttest_too_big+0x4b>\n4b: \tmovl\t$0, %esi\n50: \tmovl\t%ebx, %edi\n52: \tcallq\t0x57 <cttest_too_big+0x57>\n57: \tmovl\t$0, %esi\n5c: \tmovl\t%ebx, %edi\n5e: \tpopq\t%rbx\n5f: \tjmp\t0x64 <cttest_too_big+0x64>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint job_data_size_limit ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_too_big()\n{\njob_data_size_limit = 10;\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 0 11\\r\\n\");\nmustsend(fd, \"delete 9999\\r\\n\");\nmustsend(fd, \"put 0 0 0 1\\r\\n\");\nmustsend(fd, \"x\\r\\n\");\nckresp(fd, \"JOB_TOO_BIG\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_printf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  BIO_write (int /*<<< orphan*/ ,char*,int) ;\nint /*<<< orphan*/  TEST_size_t_eq (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  TEST_size_t_lt (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  TEST_size_t_ne (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  TEST_size_t_ok (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_size_t_zero (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_too_big ;\n\n__attribute__((used)) static void cttest_too_big(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\n\nTEST_size_t_zero(ct_test_too_big);\nTEST_size_t_lt(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio, \"a\", 10), 10);\nTEST_size_t_eq(BIO_write(bio,"
},
{
    "file:":"./beanstalkd/extr_conn.c_conn_setpos",
    "input":"\n0000000000000000 <conn_setpos>:\n0: \tmovq\t%rsi, (%rdi)\n3: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_2__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_2__ {size_t tickpos; } ;\ntypedef  TYPE_1__ Conn ;\n\n/* Variables and functions */\n\nvoid\nconn_setpos(void *c, size_t i)\n{\n((Conn *)c)->tickpos = i;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ pos; } ;\ntypedef  TYPE_1__ conn ;\n\n/* Variables and functions */\n\nvoid\nconn_setpos(conn *c, int pos)\n{\nc->pos = pos;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ckresp",
    "input":"\n0000000000000000 <ckresp>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tcallq\t0xc <ckresp+0xc>\nc: \tmovq\t%rax, %rbx\nf: \tmovq\t%r14, %rdi\n12: \tmovq\t%rax, %rsi\n15: \tcallq\t0x1a <ckresp+0x1a>\n1a: \txorl\t%edi, %edi\n1c: \ttestq\t%rax, %rax\n1f: \tsete\t%dil\n23: \tmovl\t$0, %esi\n28: \tmovq\t%r14, %rdx\n2b: \tmovq\t%rbx, %rcx\n2e: \taddq\t$8, %rsp\n32: \tpopq\t%rbx\n33: \tpopq\t%r14\n35: \tjmp\t0x3a <ckresp+0x3a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  assertf (int,char*,char*,char*) ;\nchar* readline (int) ;\nscalar_t__ strcmp (char*,char*) ;\n\n__attribute__((used)) static void\nckresp(int fd, char *exp)\n{\nchar *line = readline(fd);\nassertf(strcmp(exp, line) == 0, \"\\\"%s\\\" != \\\"%s\\\"\", exp, line);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  u_char ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nscalar_t__ memcmp (int /*<<< orphan*/  const*,int /*<<< orphan*/  const*,size_t) ;\nsize_t strlen (int /*<<< orphan*/  const*) ;\n\n__attribute__((used)) static void\nckresp(const u_char *resp, const u_char *ok)\n{\nsize_t\t\tlen;\n\nlen = strlen(ok);\nassert(memcmp(resp, ok, len) == 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_copy",
    "input":"\n0000000000000000 <job_copy>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \ttestq\t%rdi, %rdi\n7: \tje\t0x64 <job_copy+0x64>\n9: \tmovq\t%rdi, %rbx\nc: \tmovq\t8(%rdi), %rdi\n10: \taddq\t$32, %rdi\n14: \tcallq\t0x19 <job_copy+0x19>\n19: \ttestq\t%rax, %rax\n1c: \tje\t0x5a <job_copy+0x5a>\n1e: \tmovq\t%rax, %r14\n21: \tmovq\t8(%rbx), %rdx\n25: \taddq\t$32, %rdx\n29: \tmovq\t%rax, %rdi\n2c: \tmovq\t%rbx, %rsi\n2f: \tcallq\t0x34 <job_copy+0x34>\n34: \tmovq\t%r14, %rdi\n37: \tcallq\t0x3c <job_copy+0x3c>\n3c: \txorps\t%xmm0, %xmm0\n3f: \tmovups\t%xmm0, 16(%r14)\n44: \tmovq\t16(%rbx), %rsi\n48: \txorl\t%edi, %edi\n4a: \tcallq\t0x4f <job_copy+0x4f>\n4f: \tmovl\t(%rip), %eax  # 0x55 <job_copy+0x55>\n55: \tmovl\t%eax, (%r14)\n58: \tjmp\t0x67 <job_copy+0x67>\n5a: \tmovl\t$0, %edi\n5f: \tcallq\t0x64 <job_copy+0x64>\n64: \txorl\t%r14d, %r14d\n67: \tmovq\t%r14, %rax\n6a: \taddq\t$8, %rsp\n6e: \tpopq\t%rbx\n6f: \tpopq\t%r14\n71: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_10__   TYPE_2__ ;\ntypedef  struct TYPE_9__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_9__ {int /*<<< orphan*/  state; scalar_t__ body_size; } ;\nstruct TYPE_10__ {TYPE_1__ r; scalar_t__ tube; int /*<<< orphan*/ * file; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  Copy ;\nint /*<<< orphan*/  TUBE_ASSIGN (scalar_t__,scalar_t__) ;\nint /*<<< orphan*/  job_list_reset (TYPE_2__*) ;\nTYPE_2__* malloc (scalar_t__) ;\nint /*<<< orphan*/  memcpy (TYPE_2__*,TYPE_2__*,scalar_t__) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\nJob *\njob_copy(Job *j)\n{\nif (!j)\nreturn NULL;\n\nJob *n = malloc(sizeof(Job) + j->r.body_size);\nif (!n) {\ntwarnx(\"OOM\");\nreturn (Job *) 0;\n}\n\nmemcpy(n, j, sizeof(Job) + j->r.body_size);\njob_list_reset(n);\n\nn->file = NULL; /* copies do not have refcnt on the wal */\n\nn->tube = 0; /* Don't use memcpy for the tube, which we must refcount. */\nTUBE_ASSIGN(n->tube, j->tube);\n\n/* Mark this job as a copy so it can be appropriately freed later on */\nn->r.state = Copy;\n\nreturn n;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  status; int /*<<< orphan*/ * out; int /*<<< orphan*/ * in; int /*<<< orphan*/ * job; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  JOB_STATUS_QUEUED ;\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nTYPE_1__* malloc (int) ;\nint /*<<< orphan*/  memcpy (TYPE_1__*,TYPE_1__*,int) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  printf (char*) ;\n\njob_t *job_copy(job_t *job) {\njob_t *new_job;\n\nif (!job) {\nprintf(\"job_copy: job is NULL\\n\");\nreturn NULL;\n}\n\nnew_job = malloc(sizeof(job_t));\nif (!new_job) {\nprintf(\"job_copy: malloc failed\\n\");\nreturn NULL;\n}\n\nmemcpy(new_job, job, sizeof(job_t));\nmemset(new_job->job, 0, sizeof(new_job->job));\nnew_job->status = JOB_STATUS_QUEUED;\n\nassert(new_job->in == NULL);\nassert(new_job->out == NULL);\n\nreturn new_job;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_append",
    "input":"\n0000000000000000 <ms_append>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r14\n3: \tpushq\t%rbx\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tmovq\t(%rdi), %rdx\nd: \tcmpq\t8(%rdi), %rdx\n11: \tjl\t0x22 <ms_append+0x22>\n13: \tmovq\t%rbx, %rdi\n16: \tcallq\t0x1b <ms_append+0x1b>\n1b: \ttestl\t%eax, %eax\n1d: \tje\t0x49 <ms_append+0x49>\n1f: \tmovq\t(%rbx), %rdx\n22: \tmovq\t24(%rbx), %rax\n26: \tleaq\t1(%rdx), %rcx\n2a: \tmovq\t%rcx, (%rbx)\n2d: \tmovq\t%r14, (%rax,%rdx,8)\n31: \tmovq\t16(%rbx), %rcx\n35: \tmovl\t$1, %ebp\n3a: \ttestq\t%rcx, %rcx\n3d: \tje\t0x4b <ms_append+0x4b>\n3f: \tmovq\t%rbx, %rdi\n42: \tmovq\t%r14, %rsi\n45: \tcallq\t*%rcx\n47: \tjmp\t0x4b <ms_append+0x4b>\n49: \txorl\t%ebp, %ebp\n4b: \tmovl\t%ebp, %eax\n4d: \tpopq\t%rbx\n4e: \tpopq\t%r14\n50: \tpopq\t%rbp\n51: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {scalar_t__ len; scalar_t__ cap; int /*<<< orphan*/  (* oninsert ) (TYPE_1__*,void*,scalar_t__) ;void** items; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  grow (TYPE_1__*) ;\nint /*<<< orphan*/  stub1 (TYPE_1__*,void*,scalar_t__) ;\n\nint\nms_append(Ms *a, void *item)\n{\nif (a->len >= a->cap && !grow(a))\nreturn 0;\n\na->items[a->len++] = item;\nif (a->oninsert)\na->oninsert(a, item, a->len - 1);\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t n; size_t n_max; int /*<<< orphan*/ * items; int /*<<< orphan*/ * (* append ) (TYPE_1__*,int /*<<< orphan*/ *) ;} ;\ntypedef  TYPE_1__ msg_set_t ;\ntypedef  int /*<<< orphan*/  msg_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ms_grow (TYPE_1__*) ;\nint /*<<< orphan*/  stub1 (TYPE_1__*,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static int ms_append (msg_set_t *ms, msg_t *msg) {\nif (ms->n >= ms->n_max) {\nif (!ms_grow (ms)) {\nreturn 0;\n}\n}\nms->items[ms->n++] = msg;\nif (ms->append) {\nms->append (ms, msg);\n}\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_delayed_to_ready",
    "input":"\n0000000000000000 <cttest_delayed_to_ready>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_delayed_to_ready+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_delayed_to_ready+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_delayed_to_ready+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_delayed_to_ready+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_delayed_to_ready+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_delayed_to_ready+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_delayed_to_ready+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_delayed_to_ready+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_delayed_to_ready+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_delayed_to_ready+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_delayed_to_ready+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_delayed_to_ready+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_delayed_to_ready+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_delayed_to_ready+0xa1>\na1: \tmovl\t$1010000, %edi# imm = 0xF6950\na6: \tcallq\t0xab <cttest_delayed_to_ready+0xab>\nab: \tmovl\t$0, %esi\nb0: \tmovl\t%ebx, %edi\nb2: \tcallq\t0xb7 <cttest_delayed_to_ready+0xb7>\nb7: \tmovl\t$0, %esi\nbc: \tmovl\t%ebx, %edi\nbe: \tcallq\t0xc3 <cttest_delayed_to_ready+0xc3>\nc3: \tmovl\t$0, %esi\nc8: \tmovl\t%ebx, %edi\nca: \tcallq\t0xcf <cttest_delayed_to_ready+0xcf>\ncf: \tmovl\t$0, %esi\nd4: \tmovl\t%ebx, %edi\nd6: \tcallq\t0xdb <cttest_delayed_to_ready+0xdb>\ndb: \tmovl\t$0, %esi\ne0: \tmovl\t%ebx, %edi\ne2: \tcallq\t0xe7 <cttest_delayed_to_ready+0xe7>\ne7: \tmovl\t$0, %esi\nec: \tmovl\t%ebx, %edi\nee: \tcallq\t0xf3 <cttest_delayed_to_ready+0xf3>\nf3: \tmovl\t$0, %esi\nf8: \tmovl\t%ebx, %edi\nfa: \tcallq\t0xff <cttest_delayed_to_ready+0xff>\nff: \tmovl\t$0, %esi\n104: \tmovl\t%ebx, %edi\n106: \tcallq\t0x10b <cttest_delayed_to_ready+0x10b>\n10b: \tmovl\t$0, %esi\n110: \tmovl\t%ebx, %edi\n112: \tpopq\t%rbx\n113: \tjmp\t0x118 <cttest_delayed_to_ready+0x118>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nint /*<<< orphan*/  usleep (int) ;\n\nvoid\ncttest_delayed_to_ready()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 1 1 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nmustsend(fd, \"stats-tube default\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ncurrent-jobs-ready: 0\\n\");\n\nmustsend(fd, \"stats-tube default\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ncurrent-jobs-delayed: 1\\n\");\n\nmustsend(fd, \"stats-tube default\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n\nusleep(1010000); // 1.01 sec\n\n// check that after 1 sec the delayed job is ready again\n\nmustsend(fd, \"stats-tube default\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ncurrent-jobs-ready: 1\\n\");\n\nmustsend(fd, \"stats-tube default\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ncurrent-jobs-delayed: 0\\n\");\n\nmustsend(fd, \"stats-tube default\\r\\n\");\nckrespsub(fd, \"OK \");\nckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_clear (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_connect (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_do_handshake (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_get_state (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_get_verify_result (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_read (int /*<<< orphan*/ *,char*,int) ;\nint /*<<< orphan*/  SSL_set_connect_state (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_set_state (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_set_verify (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_shutdown (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_write (int /*<<< orphan*/ *,char*,int) ;\nint /*<<< orphan*/  TEST_info (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_true (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_ctx ;\nint /*<<< orphan*/  ct_test_ssl ;\nint /*<<< orphan*/  ct_test_ssl_ctx ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb_and_verify_cb ;\nint /*<<< orphan*/  ct_test_ssl_ctx_with_sct_verify_cb_fail_with_cb_and_verify_cb_and_verify_cb_and_verify_cb_"
},
{
    "file:":"./beanstalkd/extr_tube.c_tube_find",
    "input":"\n0000000000000000 <tube_find>:\n0: \tpushq\t%r15\n2: \tpushq\t%r14\n4: \tpushq\t%rbx\n5: \tcmpq\t$0, (%rip)    # 0xd <tube_find+0xd>\nd: \tje\t0x4e <tube_find+0x4e>\nf: \tmovq\t%rdi, %r14\n12: \txorl\t%ebx, %ebx\n14: \tnopw\t%cs:(%rax,%rax)\n1e: \tnop\n20: \tmovq\t(%rip), %rax  # 0x27 <tube_find+0x27>\n27: \tmovq\t(%rax,%rbx,8), %r15\n2b: \tmovl\t(%r15), %edi\n2e: \tmovl\t(%rip), %edx  # 0x34 <tube_find+0x34>\n34: \tmovq\t%r14, %rsi\n37: \tcallq\t0x3c <tube_find+0x3c>\n3c: \ttestq\t%rax, %rax\n3f: \tje\t0x51 <tube_find+0x51>\n41: \taddq\t$1, %rbx\n45: \tcmpq\t(%rip), %rbx  # 0x4c <tube_find+0x4c>\n4c: \tjb\t0x20 <tube_find+0x20>\n4e: \txorl\t%r15d, %r15d\n51: \tmovq\t%r15, %rax\n54: \tpopq\t%rbx\n55: \tpopq\t%r14\n57: \tpopq\t%r15\n59: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  name; } ;\ntypedef  TYPE_1__ Tube ;\nstruct TYPE_5__ {size_t len; TYPE_1__** items; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  MAX_TUBE_NAME_LEN ;\nscalar_t__ strncmp (int /*<<< orphan*/ ,char const*,int /*<<< orphan*/ ) ;\nTYPE_2__ tubes ;\n\nTube *\ntube_find(const char *name)\n{\nsize_t i;\n\nfor (i = 0; i < tubes.len; i++) {\nTube *t = tubes.items[i];\nif (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0)\nreturn t;\n}\nreturn NULL;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  name; } ;\ntypedef  TYPE_1__ tube_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  strcmp (int /*<<< orphan*/ ,char const*,int /*<<< orphan*/ ) ;\nsize_t tubes_count ;\nTYPE_1__* tubes_list ;\nint /*<<< orphan*/  tubes_name_len ;\n\ntube_t *tube_find (const char *name) {\nsize_t i;\n\nfor (i = 0; i < tubes_count; i++) {\ntube_t *tube = &tubes_list[i];\n\nif (!strcmp (tube->name, name, tubes_name_len)) {\nreturn tube;\n}\n}\n\nreturn NULL;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_count_cur_workers",
    "input":"\n0000000000000000 <count_cur_workers>:\n0: \tmovl\t(%rip), %eax  # 0x6 <count_cur_workers+0x6>\n6: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint cur_worker_ct ;\n\nint\ncount_cur_workers()\n{\nreturn cur_worker_ct;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint cur_workers ;\n\nint count_cur_workers (void) {\nreturn cur_workers;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_peek_delayed",
    "input":"\n0000000000000000 <cttest_peek_delayed>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_peek_delayed+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_peek_delayed+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_peek_delayed+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_peek_delayed+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_peek_delayed+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_peek_delayed+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_peek_delayed+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_peek_delayed+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_peek_delayed+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_peek_delayed+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_peek_delayed+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_peek_delayed+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_peek_delayed+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_peek_delayed+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_peek_delayed+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tcallq\t0xb9 <cttest_peek_delayed+0xb9>\nb9: \tmovl\t$0, %esi\nbe: \tmovl\t%ebx, %edi\nc0: \tcallq\t0xc5 <cttest_peek_delayed+0xc5>\nc5: \tmovl\t$0, %esi\nca: \tmovl\t%ebx, %edi\ncc: \tcallq\t0xd1 <cttest_peek_delayed+0xd1>\nd1: \tmovl\t$0, %esi\nd6: \tmovl\t%ebx, %edi\nd8: \tcallq\t0xdd <cttest_peek_delayed+0xdd>\ndd: \tmovl\t$0, %esi\ne2: \tmovl\t%ebx, %edi\ne4: \tcallq\t0xe9 <cttest_peek_delayed+0xe9>\ne9: \tmovl\t$0, %esi\nee: \tmovl\t%ebx, %edi\nf0: \tcallq\t0xf5 <cttest_peek_delayed+0xf5>\nf5: \tmovl\t$0, %esi\nfa: \tmovl\t%ebx, %edi\nfc: \tcallq\t0x101 <cttest_peek_delayed+0x101>\n101: \tmovl\t$0, %esi\n106: \tmovl\t%ebx, %edi\n108: \tcallq\t0x10d <cttest_peek_delayed+0x10d>\n10d: \tmovl\t$0, %esi\n112: \tmovl\t%ebx, %edi\n114: \tcallq\t0x119 <cttest_peek_delayed+0x119>\n119: \tmovl\t$0, %esi\n11e: \tmovl\t%ebx, %edi\n120: \tpopq\t%rbx\n121: \tjmp\t0x126 <cttest_peek_delayed+0x126>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_peek_delayed()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"peek-delayed\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"A\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"put 0 99 1 1\\r\\n\");\nmustsend(fd, \"B\\r\\n\");\nckresp(fd, \"INSERTED 2\\r\\n\");\nmustsend(fd, \"put 0 1 1 1\\r\\n\");\nmustsend(fd, \"C\\r\\n\");\nckresp(fd, \"INSERTED 3\\r\\n\");\n\nmustsend(fd, \"peek-delayed\\r\\n\");\nckresp(fd, \"FOUND 3 1\\r\\n\");\nckresp(fd, \"C\\r\\n\");\n\nmustsend(fd, \"delete 3\\r\\n\");\nckresp(fd, \"DELETED\\r\\n\");\n\nmustsend(fd, \"peek-delayed\\r\\n\");\nckresp(fd, \"FOUND 2 1\\r\\n\");\nckresp(fd, \"B\\r\\n\");\n\nmustsend(fd, \"delete 2\\r\\n\");\nckresp(fd, \"DELETED\\r\\n\");\n\nmustsend(fd, \"peek-delayed\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_max_proto_version (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_set_min_proto_version (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_set_options (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_set_session_cache_mode (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  SSL_CTX_set_session_ticket_cb (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_servername_callback (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_servername_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data_arg (int /*<<< orphan*/ ,int /*<<"
},
{
    "file:":"./beanstalkd/extr_serv.c_srvaccept",
    "input":"\n0000000000000000 <srvaccept>:\n0: \tmovq\t%rdi, %rdx\n3: \tmovl\t(%rdi), %edi\n5: \tjmp\t0xa <srvaccept+0xa>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {int /*<<< orphan*/  fd; } ;\nstruct TYPE_6__ {TYPE_1__ sock; } ;\ntypedef  TYPE_2__ Server ;\n\n/* Variables and functions */\nint /*<<< orphan*/  h_accept (int /*<<< orphan*/ ,int,TYPE_2__*) ;\n\nvoid\nsrvaccept(Server *s, int ev)\n{\nh_accept(s->sock.fd, ev, s);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ srv_t ;\n\n/* Variables and functions */\nint accept (int /*<<< orphan*/ ,int*,int /*<<< orphan*/ *) ;\n\nint srvaccept(srv_t *srv, int *fd) {\nreturn accept(srv->fd, fd, NULL);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_is_job_reserved_by_conn",
    "input":"\n0000000000000000 <is_job_reserved_by_conn>:\n0: \txorl\t%eax, %eax\n2: \ttestq\t%rsi, %rsi\n5: \tje\t0xd <is_job_reserved_by_conn+0xd>\n7: \tcmpq\t%rdi, 8(%rsi)\nb: \tje\t0xe <is_job_reserved_by_conn+0xe>\nd: \tretq\ne: \tmovq\t(%rsi), %rcx\n11: \txorl\t%eax, %eax\n13: \tcmpq\t(%rip), %rcx  # 0x1a <is_job_reserved_by_conn+0x1a>\n1a: \tsete\t%al\n1d: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ state; } ;\nstruct TYPE_5__ {TYPE_1__ r; int /*<<< orphan*/ * reserver; } ;\ntypedef  TYPE_2__ Job ;\ntypedef  int /*<<< orphan*/  Conn ;\n\n/* Variables and functions */\nscalar_t__ Reserved ;\n\n__attribute__((used)) static bool\nis_job_reserved_by_conn(Conn *c, Job *j)\n{\nreturn j && j->reserver == c && j->r.state == Reserved;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ reserved_by_conn; scalar_t__ reserved_by_job_id; } ;\ntypedef  TYPE_1__ job_t ;\ntypedef  scalar_t__ uint64_t ;\n\n/* Variables and functions */\nscalar_t__ JOB_RESERVED_BY_CONN ;\n\n__attribute__((used)) static bool\nis_job_reserved_by_conn(uint64_t job_id, job_t *job)\n{\nif (job == NULL)\n{\nreturn false;\n}\n\nreturn job->reserved_by_job_id == job_id &&\njob->reserved_by_conn == JOB_RESERVED_BY_CONN;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_get_all_jobs_used",
    "input":"\n0000000000000000 <get_all_jobs_used>:\n0: \tmovq\t(%rip), %rax  # 0x7 <get_all_jobs_used+0x7>\n7: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nsize_t all_jobs_used ;\n\nsize_t\nget_all_jobs_used()\n{\nreturn all_jobs_used;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint* all_jobs_used ;\n\nint *\nget_all_jobs_used (void)\n{\nreturn all_jobs_used;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_serv.c_srvserve",
    "input":"\n0000000000000000 <srvserve>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rdi, %rbx\n7: \txorl\t%eax, %eax\n9: \tcallq\t0xe <srvserve+0xe>\ne: \tcmpl\t$-1, %eax\n11: \tje\t0x56 <srvserve+0x56>\n13: \tmovq\t%rbx, 16(%rbx)\n17: \tmovq\t(%rip), %rax  # 0x1e <srvserve+0x1e>\n1e: \tmovq\t%rax, 8(%rbx)\n22: \tmovl\t(%rip), %eax  # 0x28 <srvserve+0x28>\n28: \tmovl\t%eax, 28(%rbx)\n2b: \tmovl\t(%rip), %eax  # 0x31 <srvserve+0x31>\n31: \tmovl\t%eax, 24(%rbx)\n34: \tmovl\t(%rbx), %edi\n36: \tmovl\t$1024, %esi   # imm = 0x400\n3b: \tcallq\t0x40 <srvserve+0x40>\n40: \tcmpl\t$-1, %eax\n43: \tjne\t0x5d <srvserve+0x5d>\n45: \tmovl\t$0, %edi\n4a: \taddq\t$8, %rsp\n4e: \tpopq\t%rbx\n4f: \tpopq\t%r14\n51: \tjmp\t0x56 <srvserve+0x56>\n56: \tmovl\t$0, %edi\n5b: \tjmp\t0xb3 <srvserve+0xb3>\n5d: \tmovq\t%rbx, %rdi\n60: \tmovl\t$114, %esi\n65: \tcallq\t0x6a <srvserve+0x6a>\n6a: \tcmpl\t$-1, %eax\n6d: \tjne\t0x83 <srvserve+0x83>\n6f: \tmovl\t$0, %edi\n74: \tcallq\t0x79 <srvserve+0x79>\n79: \tmovl\t$2, %edi\n7e: \tcallq\t0x83 <srvserve+0x83>\n83: \tmovq\t%rsp, %r14\n86: \tmovq\t%rbx, %rdi\n89: \tcallq\t0x8e <srvserve+0x8e>\n8e: \tmovq\t%r14, %rdi\n91: \tmovl\t%eax, %esi\n93: \tcallq\t0x98 <srvserve+0x98>\n98: \ttestl\t%eax, %eax\n9a: \tje\t0x86 <srvserve+0x86>\n9c: \tcmpl\t$-1, %eax\n9f: \tje\t0xae <srvserve+0xae>\na1: \tmovq\t(%rsp), %rcx\na5: \tmovl\t(%rcx), %edi\na7: \tmovl\t%eax, %esi\na9: \tcallq\t*8(%rcx)\nac: \tjmp\t0x86 <srvserve+0x86>\nae: \tmovl\t$0, %edi\nb3: \tcallq\t0xb8 <srvserve+0xb8>\nb8: \tmovl\t$1, %edi\nbd: \tcallq\t0xc2 <srvserve+0xc2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_11__   TYPE_5__ ;\ntypedef  struct TYPE_10__   TYPE_3__ ;\ntypedef  struct TYPE_9__   TYPE_2__ ;\ntypedef  struct TYPE_8__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  int64 ;\nstruct TYPE_11__ {int /*<<< orphan*/  fd; scalar_t__ f; TYPE_3__* x; } ;\nstruct TYPE_8__ {int /*<<< orphan*/  setpos; int /*<<< orphan*/  less; } ;\nstruct TYPE_10__ {TYPE_5__ sock; TYPE_1__ conns; } ;\nstruct TYPE_9__ {int /*<<< orphan*/  x; int /*<<< orphan*/  (* f ) (int /*<<< orphan*/ ,int) ;} ;\ntypedef  TYPE_2__ Socket ;\ntypedef  TYPE_3__ Server ;\ntypedef  scalar_t__ Handle ;\n\n/* Variables and functions */\nint /*<<< orphan*/  conn_less ;\nint /*<<< orphan*/  conn_setpos ;\nint /*<<< orphan*/  exit (int) ;\nint listen (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  prottick (TYPE_3__*) ;\nint sockinit () ;\nint socknext (TYPE_2__**,int /*<<< orphan*/ ) ;\nint sockwant (TYPE_5__*,char) ;\nscalar_t__ srvaccept ;\nint /*<<< orphan*/  stub1 (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  twarn (char*) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\nvoid\nsrvserve(Server *s)\n{\nint r;\nSocket *sock;\n\nif (sockinit() == -1) {\ntwarnx(\"sockinit\");\nexit(1);\n}\n\ns->sock.x = s;\ns->sock.f = (Handle)srvaccept;\ns->conns.less = conn_less;\ns->conns.setpos = conn_setpos;\n\nr = listen(s->sock.fd, 1024);\nif (r == -1) {\ntwarn(\"listen\");\nreturn;\n}\n\nr = sockwant(&s->sock, 'r');\nif (r == -1) {\ntwarn(\"sockwant\");\nexit(2);\n}\n\n\nfor (;;) {\nint64 period = prottick(s);\n\nint rw = socknext(&sock, period);\nif (rw == -1) {\ntwarnx(\"socknext\");\nexit(1);\n}\n\nif (rw) {\nsock->f(sock->x, rw);\n}\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  (* read ) (int /*<<< orphan*/ ,int) ;int /*<<< orphan*/  (* write ) (int /*<<< orphan*/ ,int) ;int /*<<< orphan*/  fd; int /*<<< orphan*/  buf; int /*<<< orphan*/  buflen; int /*<<< orphan*/  bufpos; } ;\ntypedef  TYPE_1__ srv_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SIGPIPE ;\nint /*<<< orphan*/  SIG_IGN ;\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  err (char*) ;\nint /*<<< orphan*/  fcntl (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  memset (TYPE_1__*,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  read (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  srv_read (TYPE_1__*,int) ;\nint /*<<< orphan*/  srv_write (TYPE_1__*,int) ;\nint /*<<< orphan*/  signal (int,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  write (int /*<<< orphan*/ ,int) ;\n\nvoid srvserve(srv_t *srv) {\nint fd;\n\nif ((fd = accept(srv->fd, NULL, NULL)) == -1) {\nerr(\"accept\");\nreturn;\n}\n\nsrv->fd = fd;\nmemset(srv->buf, 0, sizeof(srv->buf));\nsrv->bufpos = 0;\nsrv->buflen = sizeof(srv->buf);\n\nsignal(SIGPIPE, SIG_IGN);\n\nwhile (srv_read(srv, 1024)) {\nif (srv_write(srv, srv->bufpos) == -1) {\nerr(\"write\");\nclose(srv->fd);\nreturn;\n}\n}\n\nerr(\"read\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_usenext",
    "input":"\n0000000000000000 <usenext>:\n0: \tpushq\t%rax\n1: \tmovq\t%rdi, %rax\n4: \tmovq\t(%rdi), %rdi\n7: \tmovq\t(%rdi), %rcx\na: \ttestq\t%rcx, %rcx\nd: \tje\t0x1e <usenext+0x1e>\nf: \tmovq\t%rcx, (%rax)\n12: \tcallq\t0x17 <usenext+0x17>\n17: \tmovl\t$1, %eax\n1c: \tpopq\t%rcx\n1d: \tretq\n1e: \tmovl\t$0, %edi\n23: \tcallq\t0x28 <usenext+0x28>\n28: \txorl\t%eax, %eax\n2a: \tpopq\t%rcx\n2b: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {TYPE_2__* cur; } ;\ntypedef  TYPE_1__ Wal ;\nstruct TYPE_6__ {struct TYPE_6__* next; } ;\ntypedef  TYPE_2__ File ;\n\n/* Variables and functions */\nint /*<<< orphan*/  filewclose (TYPE_2__*) ;\nint /*<<< orphan*/  twarnx (char*) ;\n\n__attribute__((used)) static int\nusenext(Wal *w)\n{\nFile *f;\n\nf = w->cur;\nif (!f->next) {\ntwarnx(\"there is no next wal file\");\nreturn 0;\n}\n\nw->cur = f->next;\nfilewclose(f);\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {struct TYPE_3__* next; } ;\ntypedef  TYPE_1__* List ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  stderr ;\n\n__attribute__((used)) static int usenext(List *L)\n{\nif (L->next) {\n*L = L->next;\nreturn 1;\n} else {\nfprintf(stderr, \"no next\\n\");\nreturn 0;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_peek_ok_unix",
    "input":"\n0000000000000000 <cttest_peek_ok_unix>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <cttest_peek_ok_unix+0xa>\na: \tmovq\t%rax, %rbx\nd: \tmovq\t%rax, %rdi\n10: \tcallq\t0x15 <cttest_peek_ok_unix+0x15>\n15: \tmovl\t%eax, %ebp\n17: \tmovl\t$0, %esi\n1c: \tmovl\t%eax, %edi\n1e: \tcallq\t0x23 <cttest_peek_ok_unix+0x23>\n23: \tmovl\t$0, %esi\n28: \tmovl\t%ebp, %edi\n2a: \tcallq\t0x2f <cttest_peek_ok_unix+0x2f>\n2f: \tmovl\t$0, %esi\n34: \tmovl\t%ebp, %edi\n36: \tcallq\t0x3b <cttest_peek_ok_unix+0x3b>\n3b: \tmovl\t$0, %esi\n40: \tmovl\t%ebp, %edi\n42: \tcallq\t0x47 <cttest_peek_ok_unix+0x47>\n47: \tmovl\t$0, %esi\n4c: \tmovl\t%ebp, %edi\n4e: \tcallq\t0x53 <cttest_peek_ok_unix+0x53>\n53: \tmovl\t$0, %esi\n58: \tmovl\t%ebp, %edi\n5a: \tcallq\t0x5f <cttest_peek_ok_unix+0x5f>\n5f: \tmovq\t%rbx, %rdi\n62: \taddq\t$8, %rsp\n66: \tpopq\t%rbx\n67: \tpopq\t%rbp\n68: \tjmp\t0x6d <cttest_peek_ok_unix+0x6d>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar* SERVER_UNIX () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdialunix (char*) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\nint /*<<< orphan*/  unlink (char*) ;\n\nvoid\ncttest_peek_ok_unix()\n{\nchar *name = SERVER_UNIX();\nint fd = mustdialunix(name);\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nmustsend(fd, \"peek 1\\r\\n\");\nckresp(fd, \"FOUND 1 1\\r\\n\");\nckresp(fd, \"a\\r\\n\");\n\nunlink(name);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  TEST_int_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  TEST_true (int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static void cttest_peek_ok_unix(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\nTEST_ptr(bio);\nTEST_int_eq(BIO_write(bio, \"hello\", 5), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio, NULL, 0), 5);\nTEST_int_eq(BIO_read(bio,"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_unpause_tube",
    "input":"\n0000000000000000 <cttest_unpause_tube>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \txorl\t%eax, %eax\n5: \tcallq\t0xa <cttest_unpause_tube+0xa>\na: \tmovl\t%eax, %ebx\nc: \tmovl\t%eax, %edi\ne: \tcallq\t0x13 <cttest_unpause_tube+0x13>\n13: \tmovl\t%eax, %ebp\n15: \tmovl\t%ebx, %edi\n17: \tcallq\t0x1c <cttest_unpause_tube+0x1c>\n1c: \tmovl\t%eax, %ebx\n1e: \tmovl\t$0, %esi\n23: \tmovl\t%ebp, %edi\n25: \tcallq\t0x2a <cttest_unpause_tube+0x2a>\n2a: \tmovl\t$0, %esi\n2f: \tmovl\t%ebp, %edi\n31: \tcallq\t0x36 <cttest_unpause_tube+0x36>\n36: \tmovl\t$0, %esi\n3b: \tmovl\t%ebp, %edi\n3d: \tcallq\t0x42 <cttest_unpause_tube+0x42>\n42: \tmovl\t$0, %esi\n47: \tmovl\t%ebp, %edi\n49: \tcallq\t0x4e <cttest_unpause_tube+0x4e>\n4e: \tmovl\t$0, %esi\n53: \tmovl\t%ebp, %edi\n55: \tcallq\t0x5a <cttest_unpause_tube+0x5a>\n5a: \tmovl\t$0, %esi\n5f: \tmovl\t%ebx, %edi\n61: \tcallq\t0x66 <cttest_unpause_tube+0x66>\n66: \tmovl\t$0, %esi\n6b: \tmovl\t%ebp, %edi\n6d: \tcallq\t0x72 <cttest_unpause_tube+0x72>\n72: \tmovl\t$0, %esi\n77: \tmovl\t%ebp, %edi\n79: \tcallq\t0x7e <cttest_unpause_tube+0x7e>\n7e: \tmovl\t$0, %esi\n83: \tmovl\t%ebx, %edi\n85: \tcallq\t0x8a <cttest_unpause_tube+0x8a>\n8a: \tmovl\t$0, %esi\n8f: \tmovl\t%ebx, %edi\n91: \taddq\t$8, %rsp\n95: \tpopq\t%rbx\n96: \tpopq\t%rbp\n97: \tjmp\t0x9c <cttest_unpause_tube+0x9c>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_unpause_tube()\n{\nint fd0, fd1;\n\nint port = SERVER();\nfd0 = mustdiallocal(port);\nfd1 = mustdiallocal(port);\n\nmustsend(fd0, \"put 0 0 0 0\\r\\n\");\nmustsend(fd0, \"\\r\\n\");\nckresp(fd0, \"INSERTED 1\\r\\n\");\n\nmustsend(fd0, \"pause-tube default 86400\\r\\n\");\nckresp(fd0, \"PAUSED\\r\\n\");\n\nmustsend(fd1, \"reserve\\r\\n\");\n\nmustsend(fd0, \"pause-tube default 0\\r\\n\");\nckresp(fd0, \"PAUSED\\r\\n\");\n\n// ckresp will time out if this takes too long, so the\n// test will not pass.\nckresp(fd1, \"RESERVED 1 0\\r\\n\");\nckresp(fd1, \"\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  tube ;\n\n/* Variables and functions */\nint /*<<< orphan*/  ct_assert_int_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_ptr_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_eq (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_assert_str_ne_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_ptr (int /*<<< orphan*/ ,char*) ;\nint /*<<< or"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_list_tube",
    "input":"\n0000000000000000 <cttest_list_tube>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_list_tube+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_list_tube+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_list_tube+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_list_tube+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_list_tube+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_list_tube+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_list_tube+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_list_tube+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_list_tube+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_list_tube+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_list_tube+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_list_tube+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_list_tube+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_list_tube+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_list_tube+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tcallq\t0xb9 <cttest_list_tube+0xb9>\nb9: \tmovl\t$0, %esi\nbe: \tmovl\t%ebx, %edi\nc0: \tcallq\t0xc5 <cttest_list_tube+0xc5>\nc5: \tmovl\t$0, %esi\nca: \tmovl\t%ebx, %edi\ncc: \tcallq\t0xd1 <cttest_list_tube+0xd1>\nd1: \tmovl\t$0, %esi\nd6: \tmovl\t%ebx, %edi\nd8: \tcallq\t0xdd <cttest_list_tube+0xdd>\ndd: \tmovl\t$0, %esi\ne2: \tmovl\t%ebx, %edi\ne4: \tcallq\t0xe9 <cttest_list_tube+0xe9>\ne9: \tmovl\t$0, %esi\nee: \tmovl\t%ebx, %edi\nf0: \tpopq\t%rbx\nf1: \tjmp\t0xf6 <cttest_list_tube+0xf6>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint /*<<< orphan*/  ckrespsub (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_list_tube()\n{\nint port = SERVER();\nint fd0 = mustdiallocal(port);\n\nmustsend(fd0, \"watch w\\r\\n\");\nckresp(fd0, \"WATCHING 2\\r\\n\");\n\nmustsend(fd0, \"use u\\r\\n\");\nckresp(fd0, \"USING u\\r\\n\");\n\nmustsend(fd0, \"list-tubes\\r\\n\");\nckrespsub(fd0, \"OK \");\nckresp(fd0,\n\"---\\n\"\n\"- default\\n\"\n\"- w\\n\"\n\"- u\\n\\r\\n\");\n\nmustsend(fd0, \"list-tube-used\\r\\n\");\nckresp(fd0, \"USING u\\r\\n\");\n\nmustsend(fd0, \"list-tubes-watched\\r\\n\");\nckrespsub(fd0, \"OK \");\nckresp(fd0,\n\"---\\n\"\n\"- default\\n\"\n\"- w\\n\\r\\n\");\n\nmustsend(fd0, \"ignore default\\r\\n\");\nckresp(fd0, \"WATCHING 1\\r\\n\");\n\nmustsend(fd0, \"list-tubes-watched\\r\\n\");\nckrespsub(fd0, \"OK \");\nckresp(fd0,\n\"---\\n\"\n\"- w\\n\\r\\n\");\n\nmustsend(fd0, \"ignore w\\r\\n\");\nckresp(fd0, \"NOT_IGNORED\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  FILE ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fclose (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * fopen (char*,char*) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ *,char*) ;\nint /*<<< orphan*/  list_tube (int /*<<< orphan*/ *) ;\n\nvoid cttest_list_tube(void) {\nFILE *f = fopen(\"test.out\", \"w\");\nlist_tube(f);\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nfprintf(f, \"---\\n\");\nf"
},
{
    "file:":"./beanstalkd/extr_job.c_job_free",
    "input":"\n0000000000000000 <job_free>:\n0: \tpushq\t%rbx\n1: \tmovq\t%rdi, %rbx\n4: \ttestq\t%rdi, %rdi\n7: \tje\t0x27 <job_free+0x27>\n9: \tmovl\t8(%rbx), %edi\nc: \txorl\t%esi, %esi\ne: \tcallq\t0x13 <job_free+0x13>\n13: \tmovq\t(%rbx), %rax\n16: \tcmpq\t(%rip), %rax  # 0x1d <job_free+0x1d>\n1d: \tje\t0x27 <job_free+0x27>\n1f: \tmovq\t%rbx, %rdi\n22: \tcallq\t0x27 <job_free+0x27>\n27: \tmovq\t%rbx, %rdi\n2a: \tpopq\t%rbx\n2b: \tjmp\t0x30 <job_free+0x30>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {scalar_t__ state; } ;\nstruct TYPE_7__ {TYPE_1__ r; int /*<<< orphan*/  tube; } ;\ntypedef  TYPE_2__ Job ;\n\n/* Variables and functions */\nscalar_t__ Copy ;\nint /*<<< orphan*/  TUBE_ASSIGN (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  free (TYPE_2__*) ;\nint /*<<< orphan*/  job_hash_free (TYPE_2__*) ;\n\nvoid\njob_free(Job *j)\n{\nif (j) {\nTUBE_ASSIGN(j->tube, NULL);\nif (j->r.state != Copy) job_hash_free(j);\n}\n\nfree(j);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct job {scalar_t__ type; int /*<<< orphan*/  args; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  free (struct job*) ;\nscalar_t__ job_type_command ;\nint /*<<< orphan*/  list_free (int /*<<< orphan*/ ) ;\n\nvoid\njob_free(struct job *job)\n{\nif (job != NULL)\n{\nlist_free(job->args);\nif (job->type != job_type_command)\nfree(job);\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_multi_tube",
    "input":"\n0000000000000000 <cttest_multi_tube>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_multi_tube+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_multi_tube+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_multi_tube+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_multi_tube+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_multi_tube+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_multi_tube+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_multi_tube+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_multi_tube+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tcallq\t0x65 <cttest_multi_tube+0x65>\n65: \tmovl\t$0, %esi\n6a: \tmovl\t%ebx, %edi\n6c: \tcallq\t0x71 <cttest_multi_tube+0x71>\n71: \tmovl\t$0, %esi\n76: \tmovl\t%ebx, %edi\n78: \tcallq\t0x7d <cttest_multi_tube+0x7d>\n7d: \tmovl\t$0, %esi\n82: \tmovl\t%ebx, %edi\n84: \tcallq\t0x89 <cttest_multi_tube+0x89>\n89: \tmovl\t$0, %esi\n8e: \tmovl\t%ebx, %edi\n90: \tcallq\t0x95 <cttest_multi_tube+0x95>\n95: \tmovl\t$0, %esi\n9a: \tmovl\t%ebx, %edi\n9c: \tcallq\t0xa1 <cttest_multi_tube+0xa1>\na1: \tmovl\t$0, %esi\na6: \tmovl\t%ebx, %edi\na8: \tcallq\t0xad <cttest_multi_tube+0xad>\nad: \tmovl\t$0, %esi\nb2: \tmovl\t%ebx, %edi\nb4: \tcallq\t0xb9 <cttest_multi_tube+0xb9>\nb9: \tmovl\t$0, %esi\nbe: \tmovl\t%ebx, %edi\nc0: \tcallq\t0xc5 <cttest_multi_tube+0xc5>\nc5: \tmovl\t$0, %esi\nca: \tmovl\t%ebx, %edi\ncc: \tpopq\t%rbx\ncd: \tjmp\t0xd2 <cttest_multi_tube+0xd2>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_multi_tube()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"use abc\\r\\n\");\nckresp(fd, \"USING abc\\r\\n\");\nmustsend(fd, \"put 999999 0 0 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\nmustsend(fd, \"use def\\r\\n\");\nckresp(fd, \"USING def\\r\\n\");\nmustsend(fd, \"put 99 0 0 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 2\\r\\n\");\nmustsend(fd, \"watch abc\\r\\n\");\nckresp(fd, \"WATCHING 2\\r\\n\");\nmustsend(fd, \"watch def\\r\\n\");\nckresp(fd, \"WATCHING 3\\r\\n\");\nmustsend(fd, \"reserve\\r\\n\");\nckresp(fd, \"RESERVED 2 0\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  redisContext ;\n\n/* Variables and functions */\nint /*<<< orphan*/  addReplyBulkCString (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  ct_multi_tube (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_redis_ctx ;\nint /*<<< orphan*/  redisFree (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  redisReconnect (int /*<<< orphan*/ ) ;\n\nvoid cttest_multi_tube(void) {\nredisContext *c = ct_redis_ctx;\n\nredisReconnect(c);\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");\naddReplyBulkCString(c, \"test\");"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_too_big_priority",
    "input":"\n0000000000000000 <cttest_too_big_priority>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_too_big_priority+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_too_big_priority+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_too_big_priority+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_too_big_priority+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_too_big_priority+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_too_big_priority()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 4294967296 0 100 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"BAD_FORMAT\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_cipher_list (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  SSL_CTX_set_max_proto_version (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_min_proto_version (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_priority_string (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  TLS1_2_VERSION ;\nint /*<<< orphan*/  TLS1_3_VERSION ;\n\n__attribute__((used)) static void cttest_too_big_priority(void)\n{\nSSL_CTX *ctx = SSL_CTX_new(TLS_method());\n\nSSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\nSSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION);\n\nSSL_CTX_set_priority_string(ctx, \"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\nSSL_CTX_set_cipher_list(ctx, \"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_net.c_set_nonblocking",
    "input":"\n0000000000000000 <set_nonblocking>:\n0: \tpushq\t%rbp\n1: \tpushq\t%rbx\n2: \tpushq\t%rax\n3: \tmovl\t%edi, %ebp\n5: \tmovl\t(%rip), %esi  # 0xb <set_nonblocking+0xb>\nb: \txorl\t%ebx, %ebx\nd: \txorl\t%edx, %edx\nf: \tcallq\t0x14 <set_nonblocking+0x14>\n14: \ttestl\t%eax, %eax\n16: \tjs\t0x39 <set_nonblocking+0x39>\n18: \tmovl\t(%rip), %esi  # 0x1e <set_nonblocking+0x1e>\n1e: \torl\t(%rip), %eax  # 0x24 <set_nonblocking+0x24>\n24: \tmovl\t%ebp, %edi\n26: \tmovl\t%eax, %edx\n28: \tcallq\t0x2d <set_nonblocking+0x2d>\n2d: \tcmpl\t$-1, %eax\n30: \tjne\t0x48 <set_nonblocking+0x48>\n32: \tmovl\t$0, %edi\n37: \tjmp\t0x3e <set_nonblocking+0x3e>\n39: \tmovl\t$0, %edi\n3e: \tcallq\t0x43 <set_nonblocking+0x43>\n43: \tmovl\t$4294967295, %ebx  # imm = 0xFFFFFFFF\n48: \tmovl\t%ebx, %eax\n4a: \taddq\t$8, %rsp\n4e: \tpopq\t%rbx\n4f: \tpopq\t%rbp\n50: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  F_GETFL ;\nint /*<<< orphan*/  F_SETFL ;\nint O_NONBLOCK ;\nint fcntl (int,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static int\nset_nonblocking(int fd)\n{\nint flags, r;\n\nflags = fcntl(fd, F_GETFL, 0);\nif (flags < 0) {\ntwarn(\"getting flags\");\nreturn -1;\n}\nr = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\nif (r == -1) {\ntwarn(\"setting O_NONBLOCK\");\nreturn -1;\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint O_NONBLOCK ;\nint /*<<< orphan*/  fcntl (int,int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*) ;\nint /*<<< orphan*/  perror (char*) ;\nint /*<<< orphan*/  stderr ;\nint /*<<< orphan*/  o_flags ;\nint /*<<< orphan*/  o_flags_orig ;\nint /*<<< orphan*/  o_flags_set ;\nint /*<<< orphan*/  o_flags_unset ;\nint /*<<< orphan*/  set_blocking (int) ;\n\nint set_nonblocking (int fd) {\nint r;\n\nr = set_blocking (fd);\nif (r < 0) {\nperror (\"set_nonblocking\");\nreturn -1;\n}\n\nif (fcntl (fd, o_flags, o_flags_set | o_flags_unset) < 0) {\nfprintf (stderr, \"fcntl failed\\n\");\nreturn -1;\n}\n\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_81920",
    "input":"\n0000000000000000 <ctbench_put_delete_81920>:\n0: \tmovl\t$81920, %esi  # imm = 0x14000\n5: \txorl\t%edx, %edx\n7: \txorl\t%ecx, %ecx\n9: \txorl\t%r8d, %r8d\nc: \tjmp\t0x11 <ctbench_put_delete_81920+0x11>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\nvoid\nctbench_put_delete_81920(int n)\n{\nbench_put_delete_size(n, 81920, 0, 0, 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_bench_t ;\n\n/* Variables and functions */\nint ctbench_put_delete (int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static int ctbench_put_delete_81920(ct_bench_t *b) {\nreturn ctbench_put_delete(b, 81920, 0, 0, 0);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_ctbench_put_delete_wal_8192_fsync_200ms",
    "input":"\n0000000000000000 <ctbench_put_delete_wal_8192_fsync_200ms>:\n0: \tmovl\t$8192, %esi   # imm = 0x2000\n5: \tmovl\t$512000, %edx # imm = 0x7D000\na: \tmovl\t$1, %ecx\nf: \tmovl\t$500, %r8d    # imm = 0x1F4\n15: \tjmp\t0x1a <ctbench_put_delete_wal_8192_fsync_200ms+0x1a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  bench_put_delete_size (int,int,int,int,int) ;\n\nvoid\nctbench_put_delete_wal_8192_fsync_200ms(int n)\n{\nbench_put_delete_size(n, 8192, 512000, 1, 500);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint ctbench_put_delete_wal_8192_fsync (int,int,int,int,int) ;\n\nint ctbench_put_delete_wal_8192_fsync_200ms (int fd) {\nreturn ctbench_put_delete_wal_8192_fsync (fd, 8192, 512000, 1, 500);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_opt_none",
    "input":"\n0000000000000000 <cttest_opt_none>:\n0: \tpushq\t%rax\n1: \tmovq\t$0, (%rsp)\n9: \tmovq\t%rsp, %rsi\nc: \tmovl\t$0, %edi\n11: \tcallq\t0x16 <cttest_opt_none+0x16>\n16: \tmovl\t(%rip), %edi  # 0x1c <cttest_opt_none+0x1c>\n1c: \tmovl\t(%rip), %esi  # 0x22 <cttest_opt_none+0x22>\n22: \tcallq\t0x27 <cttest_opt_none+0x27>\n27: \txorl\t%edi, %edi\n29: \ttestq\t%rax, %rax\n2c: \tsete\t%dil\n30: \tcallq\t0x35 <cttest_opt_none+0x35>\n35: \txorl\t%edi, %edi\n37: \tcmpq\t$0, (%rip)    # 0x3f <cttest_opt_none+0x3f>\n3f: \tsete\t%dil\n43: \tcallq\t0x48 <cttest_opt_none+0x48>\n48: \tmovq\t(%rip), %rax  # 0x4f <cttest_opt_none+0x4f>\n4f: \txorl\t%edi, %edi\n51: \tcmpq\t(%rip), %rax  # 0x58 <cttest_opt_none+0x58>\n58: \tsete\t%dil\n5c: \tcallq\t0x61 <cttest_opt_none+0x61>\n61: \tmovq\t(%rip), %rax  # 0x68 <cttest_opt_none+0x68>\n68: \txorl\t%edi, %edi\n6a: \tcmpq\t(%rip), %rax  # 0x71 <cttest_opt_none+0x71>\n71: \tsete\t%dil\n75: \tcallq\t0x7a <cttest_opt_none+0x7a>\n7a: \txorl\t%edi, %edi\n7c: \tcmpq\t$0, (%rip)    # 0x84 <cttest_opt_none+0x84>\n84: \tsete\t%dil\n88: \tcallq\t0x8d <cttest_opt_none+0x8d>\n8d: \txorl\t%edi, %edi\n8f: \tcmpq\t$0, (%rip)    # 0x97 <cttest_opt_none+0x97>\n97: \tsete\t%dil\n9b: \tcallq\t0xa0 <cttest_opt_none+0xa0>\na0: \txorl\t%edi, %edi\na2: \tcmpq\t$0, (%rip)    # 0xaa <cttest_opt_none+0xaa>\naa: \tsete\t%dil\nae: \tcallq\t0xb3 <cttest_opt_none+0xb3>\nb3: \txorl\t%edi, %edi\nb5: \tcmpq\t$0, (%rip)    # 0xbd <cttest_opt_none+0xbd>\nbd: \tsete\t%dil\nc1: \tcallq\t0xc6 <cttest_opt_none+0xc6>\nc6: \txorl\t%edi, %edi\nc8: \tcmpq\t$0, (%rip)    # 0xd0 <cttest_opt_none+0xd0>\nd0: \tsete\t%dil\nd4: \tcallq\t0xd9 <cttest_opt_none+0xd9>\nd9: \tpopq\t%rax\nda: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_2__ ;\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {scalar_t__ filesize; scalar_t__ wantsync; scalar_t__ use; int /*<<< orphan*/ * dir; } ;\nstruct TYPE_5__ {TYPE_1__ wal; int /*<<< orphan*/ * user; int /*<<< orphan*/ * addr; int /*<<< orphan*/  port; } ;\n\n/* Variables and functions */\nscalar_t__ Filesizedef ;\nscalar_t__ JOB_DATA_SIZE_LIMIT_DEFAULT ;\nint /*<<< orphan*/  Portdef ;\nint /*<<< orphan*/  assert (int) ;\nscalar_t__ job_data_size_limit ;\nint /*<<< orphan*/  optparse (TYPE_2__*,char**) ;\nTYPE_2__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nscalar_t__ verbose ;\n\nvoid\ncttest_opt_none()\n{\nchar *args[] = {\nNULL,\n};\n\noptparse(&srv, args);\nassert(strcmp(srv.port, Portdef) == 0);\nassert(srv.addr == NULL);\nassert(job_data_size_limit == JOB_DATA_SIZE_LIMIT_DEFAULT);\nassert(srv.wal.filesize == Filesizedef);\nassert(srv.wal.wantsync == 0);\nassert(srv.user == NULL);\nassert(srv.wal.dir == NULL);\nassert(srv.wal.use == 0);\nassert(verbose == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_INIT ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET_CURRENT ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET_FIRST ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET_LAST ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET_NEXT ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET_PREV ;\nint /*<<< orphan*/  CRYPTO_THREAD_LOCAL_SET_VALUE ;\nint /*<<< orphan*/  TEST_true (int) ;\nscalar_t__ ct_test_opt_none_get_current () ;\nscalar_t__ ct_test_opt_none_get_first () ;\nscalar_t__ ct_test_opt_none_get_last () ;\nscalar_t__ ct_test_opt_none_get_next () ;\nscalar_t__ ct_test_opt_none_get_prev () ;\nscalar_t__ ct_test_opt_none_get_value () ;\nint /*<<< orphan*/  ct_test_opt_none_set_current (scalar_t__) ;\nint /*<<< orphan*/  ct_test_opt_none_set_first (scalar_t__) ;\nint /*<<< orphan*/  ct_test_opt_none_set_last (scalar_t__) ;\nint /*<<< orphan*/  ct_test_opt_none_set_next (scalar_t__) ;\nint /*<<< orphan*/  ct_test_opt_none_set_prev (scalar_t__) ;\nint /*<<< orphan*/  ct_test_opt_none_set_value (scalar_t__) ;\nint /*<<< orphan*/  ct_test_opt_none_thread_local_init () ;\nint /*<<< orphan*/  ct_test_opt_none_thread_local_set (int /*<<< orphan*/ *,scalar_t__*) ;\nint /*<<< orphan*/  ct_test_opt_none_thread_local_teardown () ;\n\n__attribute__((used)) static void cttest_opt_none(void)\n{\nscalar_t__ val = 0;\n\nct_test_opt_none_thread_local_init();\n\nct_test_opt_none_thread_local_set(&CRYPTO_THREAD_LOCAL_INIT, &val);\nTEST_true(ct_test_opt_none_get_value() == 0);\nTEST_true(ct_test_opt_none_get_current() == 0);\nTEST_true(ct_test_opt_none_get_first() == 0);\nTEST_true(ct_test_opt_none_get_last() == 0);\nTEST_true(ct_test_opt_none_get_next() == 0);\nTEST_true(ct_test_opt_none_get_prev() == 0);\n\nct_test_opt_none_set_value(val);\nTEST_true(ct_test_opt_none_get_value() == 0);\n\nct_test_opt_none_set_current(val);\nTEST_true(ct_test_opt_none_get_current() == 0);\n\nct_test_opt_none_set_first(val);\nTEST_true(ct_test_opt_none_get_first() == 0);\n\nct_test_opt_none_set_last(val);\nTEST_true(ct_test_opt_none_get_last() == 0);\n\nct_test_opt_none_set_next(val);\nTEST_true(ct_test_opt_none_get_next() == 0);\n\nct_test_opt_none_set_prev(val);\nTEST_true(ct_test_opt_none_get_prev() == 0);\n\nct_test_opt_none_thread_local_teardown();\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_walg.c_walinit",
    "input":"\n0000000000000000 <walinit>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %r14\n7: \tmovq\t%rdi, %rbx\na: \tcallq\t0xf <walinit+0xf>\nf: \tmovq\t%rbx, %rdi\n12: \tmovq\t%r14, %rsi\n15: \tmovl\t%eax, %edx\n17: \tcallq\t0x1c <walinit+0x1c>\n1c: \tmovq\t%rbx, %rdi\n1f: \tcallq\t0x24 <walinit+0x24>\n24: \ttestl\t%eax, %eax\n26: \tje\t0x35 <walinit+0x35>\n28: \tmovl\t(%rbx), %eax\n2a: \tmovl\t%eax, 4(%rbx)\n2d: \taddq\t$8, %rsp\n31: \tpopq\t%rbx\n32: \tpopq\t%r14\n34: \tretq\n35: \tmovl\t$0, %edi\n3a: \tcallq\t0x3f <walinit+0x3f>\n3f: \tmovl\t$1, %edi\n44: \tcallq\t0x49 <walinit+0x49>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_6__ {int /*<<< orphan*/  tail; int /*<<< orphan*/  cur; } ;\ntypedef  TYPE_1__ Wal ;\ntypedef  int /*<<< orphan*/  Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  makenextfile (TYPE_1__*) ;\nint /*<<< orphan*/  twarnx (char*) ;\nint /*<<< orphan*/  walread (TYPE_1__*,int /*<<< orphan*/ *,int) ;\nint walscandir (TYPE_1__*) ;\n\nvoid\nwalinit(Wal *w, Job *list)\n{\nint min;\n\nmin = walscandir(w);\nwalread(w, list, min);\n\n// first writable file\nif (!makenextfile(w)) {\ntwarnx(\"makenextfile\");\nexit(1);\n}\n\nw->cur = w->tail;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  wal_fd; int /*<<< orphan*/  wal_size; } ;\ntypedef  TYPE_1__ WAL ;\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  ftruncate (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  lseek (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  printf (char*) ;\nint /*<<< orphan*/  wal_init_header (TYPE_1__*,int /*<<< orphan*/ *) ;\n\nint walinit(WAL *wal, int *fd) {\nwal_init_header(wal, fd);\nwal->wal_size = lseek(*fd, 0, 2);\nif (!wal->wal_size) {\nprintf(\"walinit: failed to seek\\n\");\nexit(1);\n}\nwal->wal_fd = *fd;\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testutil.c_cttest_optl",
    "input":"\n0000000000000000 <cttest_optl>:\n0: \tsubq\t$24, %rsp\n4: \tmovaps\t(%rip), %xmm0 # 0xb <cttest_optl+0xb>\nb: \tmovaps\t%xmm0, (%rsp)\nf: \tmovq\t%rsp, %rsi\n12: \tmovl\t$0, %edi\n17: \tcallq\t0x1c <cttest_optl+0x1c>\n1c: \tmovl\t(%rip), %edi  # 0x22 <cttest_optl+0x22>\n22: \tmovl\t$0, %esi\n27: \tcallq\t0x2c <cttest_optl+0x2c>\n2c: \txorl\t%edi, %edi\n2e: \ttestq\t%rax, %rax\n31: \tsete\t%dil\n35: \tcallq\t0x3a <cttest_optl+0x3a>\n3a: \taddq\t$24, %rsp\n3e: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  addr; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int) ;\nint /*<<< orphan*/  optparse (TYPE_1__*,char**) ;\nTYPE_1__ srv ;\nscalar_t__ strcmp (int /*<<< orphan*/ ,char*) ;\n\nvoid\ncttest_optl()\n{\nchar *args[] = {\n\"-llocalhost\",\nNULL,\n};\n\noptparse(&srv, args);\nassert(strcmp(srv.addr, \"localhost\") == 0);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  ct_test_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  TEST_true (int) ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  ct_test_optl ;\nint /*<<< orphan*/  ct_test_optl_desc ;\nint /*<<< orphan*/  ct_test_optl_init (int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void cttest_optl(void)\n{\nct_test_t *test = NULL;\n\nct_test_optl_init(&ct_test_optl, &test);\nTEST_ptr(test);\nTEST_true(test->desc == ct_test_optl_desc);\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_remove",
    "input":"\n0000000000000000 <ms_remove>:\n0: \tmovq\t(%rdi), %rcx\n3: \ttestq\t%rcx, %rcx\n6: \tje\t0x1f <ms_remove+0x1f>\n8: \tmovq\t8(%rdi), %rdx\nc: \txorl\t%eax, %eax\ne: \tnop\n10: \tcmpq\t%rsi, (%rdx,%rax,8)\n14: \tje\t0x22 <ms_remove+0x22>\n16: \taddq\t$1, %rax\n1a: \tcmpq\t%rcx, %rax\n1d: \tjb\t0x10 <ms_remove+0x10>\n1f: \txorl\t%eax, %eax\n21: \tretq\n22: \tmovq\t%rax, %rsi\n25: \tjmp\t0x2a <ms_remove+0x2a>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t len; void** items; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\nint ms_delete (TYPE_1__*,size_t) ;\n\nint\nms_remove(Ms *a, void *item)\n{\nsize_t i;\n\nfor (i = 0; i < a->len; i++) {\nif (a->items[i] == item)\nreturn ms_delete(a, i);\n}\nreturn 0;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t n; size_t* p; } ;\ntypedef  TYPE_1__ ms_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  memmove (size_t*,size_t*,size_t) ;\n\n__attribute__((used)) static inline int ms_remove (ms_t *M, size_t i) {\nsize_t *p = M->p;\nsize_t j;\nfor (j = 0; j < M->n; j++) {\nif (p[j] == i) {\nmemmove (p + j, p + j + 1, (M->n - j - 1) * sizeof (size_t));\nM->n--;\nreturn 1;\n}\n}\nreturn 0;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_job.c_job_list_insert",
    "input":"\n0000000000000000 <job_list_insert>:\n0: \tpushq\t%r14\n2: \tpushq\t%rbx\n3: \tpushq\t%rax\n4: \tmovq\t%rsi, %rbx\n7: \tmovq\t%rdi, %r14\na: \tmovq\t%rsi, %rdi\nd: \tcallq\t0x12 <job_list_insert+0x12>\n12: \ttestl\t%eax, %eax\n14: \tje\t0x2a <job_list_insert+0x2a>\n16: \tmovq\t(%r14), %rax\n19: \tmovq\t%rax, (%rbx)\n1c: \tmovq\t%r14, 8(%rbx)\n20: \tmovq\t(%r14), %rax\n23: \tmovq\t%rbx, 8(%rax)\n27: \tmovq\t%rbx, (%r14)\n2a: \taddq\t$8, %rsp\n2e: \tpopq\t%rbx\n2f: \tpopq\t%r14\n31: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {struct TYPE_5__* prev; struct TYPE_5__* next; } ;\ntypedef  TYPE_1__ Job ;\n\n/* Variables and functions */\nint /*<<< orphan*/  job_list_is_empty (TYPE_1__*) ;\n\nvoid\njob_list_insert(Job *head, Job *j)\n{\nif (!job_list_is_empty(j)) return; /* already in a linked list */\n\nj->prev = head->prev;\nj->next = head;\nhead->prev->next = j;\nhead->prev = j;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_5__ {struct TYPE_5__* prev; struct TYPE_5__* next; } ;\ntypedef  TYPE_1__ job_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  job_is_valid (TYPE_1__*) ;\n\n__attribute__((used)) static void\njob_list_insert(job_t **head, job_t *job)\n{\nif (job_is_valid(job))\n{\njob->prev = *head;\njob->next = (*head)->next;\n(*head)->next->prev = job;\n(*head)->next = job;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_sd-daemon.c_sd_booted",
    "input":"\n0000000000000000 <sd_booted>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tleaq\t8(%rsp), %rsi\na: \tmovl\t$0, %edi\nf: \tcallq\t0x14 <sd_booted+0x14>\n14: \txorl\t%ebx, %ebx\n16: \ttestq\t%rax, %rax\n19: \tjs\t0x3b <sd_booted+0x3b>\n1b: \tmovq\t%rsp, %rsi\n1e: \tmovl\t$0, %edi\n23: \tcallq\t0x28 <sd_booted+0x28>\n28: \ttestq\t%rax, %rax\n2b: \tjs\t0x3b <sd_booted+0x3b>\n2d: \tmovq\t8(%rsp), %rax\n32: \txorl\t%ebx, %ebx\n34: \tcmpq\t(%rsp), %rax\n38: \tsetne\t%bl\n3b: \tmovl\t%ebx, %eax\n3d: \taddq\t$16, %rsp\n41: \tpopq\t%rbx\n42: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct stat {scalar_t__ st_dev; } ;\n\n/* Variables and functions */\nscalar_t__ lstat (char*,struct stat*) ;\n\nint sd_booted(void) {\n#if defined(DISABLE_SYSTEMD) || !defined(__linux__)\nreturn 0;\n#else\n\nstruct stat a, b;\n\n/* We simply test whether the systemd cgroup hierarchy is\n* mounted */\n\nif (lstat(\"/sys/fs/cgroup\", &a) < 0)\nreturn 0;\n\nif (lstat(\"/sys/fs/cgroup/systemd\", &b) < 0)\nreturn 0;\n\nreturn a.st_dev != b.st_dev;\n#endif\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  scalar_t__ uint64_t ;\n\n/* Variables and functions */\nscalar_t__ get_sd_boot_version (char*,scalar_t__*) ;\nscalar_t__ get_sd_version (char*,scalar_t__*) ;\n\nint sd_booted(void) {\nuint64_t sd_boot_version, sd_version;\n\nif (get_sd_boot_version(\"sd_boot_version\", &sd_boot_version) < 0) {\nreturn 0;\n}\nif (get_sd_version(\"sd_version\", &sd_version) < 0) {\nreturn 0;\n}\nreturn sd_boot_version != sd_version;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_mustdialunix",
    "input":"\n0000000000000000 <mustdialunix>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rcx\n8: \tmovl\t(%rip), %eax  # 0xe <mustdialunix+0xe>\ne: \tmovl\t%eax, 12(%rsp)\n12: \tmovl\t$4, %esi\n17: \tmovl\t$0, %edx\n1c: \tcallq\t0x21 <mustdialunix+0x21>\n21: \tmovl\t(%rip), %edi  # 0x27 <mustdialunix+0x27>\n27: \tmovl\t(%rip), %esi  # 0x2d <mustdialunix+0x2d>\n2d: \txorl\t%edx, %edx\n2f: \tcallq\t0x34 <mustdialunix+0x34>\n34: \tcmpl\t$-1, %eax\n37: \tje\t0x59 <mustdialunix+0x59>\n39: \tmovl\t%eax, %ebx\n3b: \tleaq\t8(%rsp), %rsi\n40: \tmovl\t%eax, %edi\n42: \tmovl\t$8, %edx\n47: \tcallq\t0x4c <mustdialunix+0x4c>\n4c: \tcmpl\t$-1, %eax\n4f: \tje\t0x60 <mustdialunix+0x60>\n51: \tmovl\t%ebx, %eax\n53: \taddq\t$16, %rsp\n57: \tpopq\t%rbx\n58: \tretq\n59: \tmovl\t$0, %edi\n5e: \tjmp\t0x65 <mustdialunix+0x65>\n60: \tmovl\t$0, %edi\n65: \tcallq\t0x6a <mustdialunix+0x6a>\n6a: \tmovl\t$1, %edi\n6f: \tcallq\t0x74 <mustdialunix+0x74>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_un {int /*<<< orphan*/  sun_path; int /*<<< orphan*/  sun_family; } ;\nstruct sockaddr {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_UNIX ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint connect (int,struct sockaddr*,int) ;\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  snprintf (int /*<<< orphan*/ ,size_t const,char*,char*) ;\nint socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static int\nmustdialunix(char *socket_file)\n{\nstruct sockaddr_un addr;\nconst size_t maxlen = sizeof(addr.sun_path);\naddr.sun_family = AF_UNIX;\nsnprintf(addr.sun_path, maxlen, \"%s\", socket_file);\n\nint fd = socket(AF_UNIX, SOCK_STREAM, 0);\nif (fd == -1) {\ntwarn(\"socket\");\nexit(1);\n}\n\nint r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\nif (r == -1) {\ntwarn(\"connect\");\nexit(1);\n}\n\nreturn fd;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\nstruct sockaddr_un {int dummy; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  AF_UNIX ;\nint /*<<< orphan*/  SOCK_STREAM ;\nint /*<<< orphan*/  SOL_SOCKET ;\nint /*<<< orphan*/  SO_TYPE ;\nint /*<<< orphan*/  SO_TYPE_SOCK_STREAM ;\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  perror (char*) ;\nint socket (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  strcpy (char*,char*) ;\nint /*<<< orphan*/  strlen (char*) ;\nint /*<<< orphan*/  strncpy (char*,char*,int) ;\nint /*<<< orphan*/  syslog (int /*<<< orphan*/ ,char*,char*) ;\nint /*<<< orphan*/  syslog (int /*<<< orphan*/ ,char*) ;\n\nint\nmustdialunix(char *path)\n{\nstruct sockaddr_un\tsun;\nint\t\t\t\t\ts;\n\nsyslog(LOG_ERR, \"mustdialunix: %s\", path);\n\ns = socket(AF_UNIX, SOCK_STREAM, 0);\nif (s == -1) {\nperror(\"socket\");\nexit(1);\n}\n\nstrncpy(sun.sun_path, path, sizeof(sun.sun_path));\nsun.sun_family = AF_UNIX;\n\nif (connect(s, (struct sockaddr *)&sun, sizeof(sun)) == -1) {\nsyslog(LOG_ERR, \"connect: %m\");\nexit(1);\n}\n\nif (getsockopt(s, SOL_SOCKET, SO_TYPE, &SO_TYPE_SOCK_STREAM,\nsizeof(SO_TYPE_SOCK_STREAM)) == -1) {\nsyslog(LOG_ERR, \"getsockopt: %m\");\nexit(1);\n}\n\nreturn s;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_zero_delay",
    "input":"\n0000000000000000 <cttest_zero_delay>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_zero_delay+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_zero_delay+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_zero_delay+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_zero_delay+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tpopq\t%rbx\n31: \tjmp\t0x36 <cttest_zero_delay+0x36>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_zero_delay()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 1 0\\r\\n\");\nmustsend(fd, \"\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  SSL_CTX ;\n\n/* Variables and functions */\nint /*<<< orphan*/  SSL_CTX_set_min_proto_version (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_max_proto_version (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_session_cache_mode (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_session_ticket_cb (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_data (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_func (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_func_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_func_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_func_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_func_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_func_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket_key_cb_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type_arg_type (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  SSL_CTX_set_tlsext_ticket"
},
{
    "file:":"./beanstalkd/extr_ms.c_ms_delete",
    "input":"\n0000000000000000 <ms_delete>:\n0: \tpushq\t%rbx\n1: \tmovq\t(%rdi), %rax\n4: \txorl\t%ebx, %ebx\n6: \tcmpq\t%rsi, %rax\n9: \tjbe\t0x36 <ms_delete+0x36>\nb: \tmovq\t%rsi, %rdx\ne: \tmovq\t16(%rdi), %rcx\n12: \tmovq\t(%rcx,%rsi,8), %rsi\n16: \tleaq\t-1(%rax), %rbx\n1a: \tmovq\t%rbx, (%rdi)\n1d: \tmovq\t-8(%rcx,%rax,8), %rax\n22: \tmovq\t%rax, (%rcx,%rdx,8)\n26: \tmovq\t8(%rdi), %rax\n2a: \tmovl\t$1, %ebx\n2f: \ttestq\t%rax, %rax\n32: \tje\t0x36 <ms_delete+0x36>\n34: \tcallq\t*%rax\n36: \tmovl\t%ebx, %eax\n38: \tpopq\t%rbx\n39: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {size_t len; int /*<<< orphan*/  (* onremove ) (TYPE_1__*,void*,size_t) ;void** items; } ;\ntypedef  TYPE_1__ Ms ;\n\n/* Variables and functions */\nint /*<<< orphan*/  stub1 (TYPE_1__*,void*,size_t) ;\n\n__attribute__((used)) static int\nms_delete(Ms *a, size_t i)\n{\nvoid *item;\n\nif (i >= a->len)\nreturn 0;\nitem = a->items[i];\na->items[i] = a->items[--a->len];\n\n/* it has already been removed now */\nif (a->onremove)\na->onremove(a, item, i);\nreturn 1;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {size_t n; size_t* p; int /*<<< orphan*/ * (* del ) (size_t) ;} ;\ntypedef  TYPE_1__ mset ;\n\n/* Variables and functions */\nint /*<<< orphan*/  stub1 (size_t) ;\n\n__attribute__((used)) static int ms_delete(mset *S, size_t i) {\nif (i >= S->n) return 0;\nS->n--;\nS->p[i] = S->p[S->n];\nif (S->del) S->del(S->p[S->n]);\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_util.c_parse_size_t",
    "input":"\n0000000000000000 <parse_size_t>:\n0: \tpushq\t%rbx\n1: \tsubq\t$16, %rsp\n5: \tmovq\t%rdi, %rbx\n8: \tleaq\t8(%rsp), %rdx\nd: \tleaq\t7(%rsp), %rcx\n12: \tmovl\t$0, %esi\n17: \tcallq\t0x1c <parse_size_t+0x1c>\n1c: \tcmpb\t$1, %al\n1e: \tje\t0x37 <parse_size_t+0x37>\n20: \tmovl\t$0, %edi\n25: \tmovq\t%rbx, %rsi\n28: \tcallq\t0x2d <parse_size_t+0x2d>\n2d: \tmovl\t$5, %edi\n32: \tcallq\t0x37 <parse_size_t+0x37>\n37: \tmovq\t8(%rsp), %rax\n3c: \taddq\t$16, %rsp\n40: \tpopq\t%rbx\n41: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nchar sscanf (char*,char*,size_t*,char*) ;\nint /*<<< orphan*/  usage (int) ;\nint /*<<< orphan*/  warnx (char*,char*) ;\n\n__attribute__((used)) static size_t\nparse_size_t(char *str)\n{\nchar r, x;\nsize_t size;\n\nr = sscanf(str, \"%zu%c\", &size, &x);\nif (1 != r) {\nwarnx(\"invalid size: %s\", str);\nusage(5);\n}\nreturn size;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  size_t_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  exit (int) ;\nint /*<<< orphan*/  fprintf (int /*<<< orphan*/ ,char*,char const*) ;\nint /*<<< orphan*/  sscanf (char const*,char*,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ;\n\nsize_t_t parse_size_t(const char *str)\n{\nsize_t_t size;\nif (sscanf(str, \"%zu%*s\", &size) != 1) {\nfprintf(stderr, \"Invalid size_t: %s\\n\", str);\nexit(5);\n}\nreturn size;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_prot.c_fmt_stats_tube",
    "input":"\n0000000000000000 <fmt_stats_tube>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%r13\n7: \tpushq\t%r12\n9: \tpushq\t%rbx\na: \tsubq\t$24, %rsp\ne: \tmovq\t%rdx, %rbx\n11: \tmovq\t%rsi, 16(%rsp)\n16: \tmovl\t(%rdx), %esi\n18: \ttestl\t%esi, %esi\n1a: \tjle\t0x49 <fmt_stats_tube+0x49>\n1c: \tmovl\t4(%rbx), %ebp\n1f: \txorl\t%eax, %eax\n21: \tmovq\t%rdi, %r14\n24: \tcallq\t0x29 <fmt_stats_tube+0x29>\n29: \tmovq\t%r14, %rdi\n2c: \tsubl\t%eax, %ebp\n2e: \tmovslq\t%ebp, %rax\n31: \timulq\t$1152921505, %rax, %rax # imm = 0x44B82FA1\n38: \tmovq\t%rax, %rcx\n3b: \tshrq\t$63, %rcx\n3f: \tsarq\t$60, %rax\n43: \taddl\t%ecx, %eax\n45: \tmovl\t(%rbx), %esi\n47: \tjmp\t0x4b <fmt_stats_tube+0x4b>\n49: \txorl\t%eax, %eax\n4b: \tmovq\t(%rip), %rdx  # 0x52 <fmt_stats_tube+0x52>\n52: \tmovl\t52(%rbx), %ecx\n55: \tmovl\t32(%rbx), %r8d\n59: \tmovl\t48(%rbx), %r9d\n5d: \tmovl\t28(%rbx), %ebp\n60: \tmovq\t%rbp, 8(%rsp)\n65: \tmovl\t44(%rbx), %ebp\n68: \tmovq\t%rbp, (%rsp)\n6c: \tmovl\t24(%rbx), %r12d\n70: \tmovl\t20(%rbx), %r13d\n74: \tmovl\t40(%rbx), %ebp\n77: \tmovl\t36(%rbx), %r14d\n7b: \tmovl\t16(%rbx), %r15d\n7f: \tmovl\t8(%rbx), %r10d\n83: \tmovl\t12(%rbx), %ebx\n86: \tmovslq\t%esi, %rsi\n89: \timulq\t$1152921505, %rsi, %r11 # imm = 0x44B82FA1\n90: \tmovq\t%r11, %rsi\n93: \tshrq\t$63, %rsi\n97: \tsarq\t$60, %r11\n9b: \taddl\t%esi, %r11d\n9e: \tsubq\t$8, %rsp\na2: \tmovq\t24(%rsp), %rsi\na7: \tpushq\t%rax\na8: \tpushq\t%r11\naa: \tpushq\t%r10\nac: \tpushq\t%rbx\nad: \tpushq\t%r15\naf: \tpushq\t%r14\nb1: \tpushq\t%rbp\nb2: \tpushq\t%r13\nb4: \tpushq\t%r12\nb6: \tpushq\t80(%rsp)\nba: \tpushq\t96(%rsp)\nbe: \tcallq\t0xc3 <fmt_stats_tube+0xc3>\nc3: \taddq\t$120, %rsp\nc7: \tpopq\t%rbx\nc8: \tpopq\t%r12\nca: \tpopq\t%r13\ncc: \tpopq\t%r14\nce: \tpopq\t%r15\nd0: \tpopq\t%rbp\nd1: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_9__   TYPE_4__ ;\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int uint64 ;\nstruct TYPE_8__ {int /*<<< orphan*/  pause_ct; int /*<<< orphan*/  total_delete_ct; int /*<<< orphan*/  waiting_ct; int /*<<< orphan*/  total_jobs_ct; int /*<<< orphan*/  buried_ct; int /*<<< orphan*/  reserved_ct; int /*<<< orphan*/  urgent_ct; } ;\nstruct TYPE_7__ {int /*<<< orphan*/  len; } ;\nstruct TYPE_6__ {int /*<<< orphan*/  len; } ;\nstruct TYPE_9__ {int pause; int unpause_at; TYPE_3__ stat; int /*<<< orphan*/  watching_ct; int /*<<< orphan*/  using_ct; TYPE_2__ delay; TYPE_1__ ready; int /*<<< orphan*/  name; } ;\ntypedef  TYPE_4__ Tube ;\n\n/* Variables and functions */\nchar* STATS_TUBE_FMT ;\nint nanoseconds () ;\nint snprintf (char*,size_t,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ;\n\n__attribute__((used)) static int\nfmt_stats_tube(char *buf, size_t size, Tube *t)\n{\nuint64 time_left;\n\nif (t->pause > 0) {\ntime_left = (t->unpause_at - nanoseconds()) / 1000000000;\n} else {\ntime_left = 0;\n}\nreturn snprintf(buf, size, STATS_TUBE_FMT,\nt->name,\nt->stat.urgent_ct,\nt->ready.len,\nt->stat.reserved_ct,\nt->delay.len,\nt->stat.buried_ct,\nt->stat.total_jobs_ct,\nt->using_ct,\nt->watching_ct,\nt->stat.waiting_ct,\nt->stat.total_delete_ct,\nt->stat.pause_ct,\nt->pause / 1000000000,\ntime_left);\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  name; int /*<<< orphan*/  current_jobs_ready; int /*<<< orphan*/  current_jobs_buried; int /*<<< orphan*/  current_jobs_delayed; int /*<<< orphan*/  current_jobs_reserved; int /*<<< orphan*/  current_jobs_urgent; int /*<<< orphan*/  current_jobs_ready_type; int /*<<< orphan*/  current_jobs_delayed_type; int /*<<< orphan*/  current_jobs_buried_type; int /*<<< orphan*/  current_jobs_reserved_type; int /*<<< orphan*/  current_jobs_urgent_type; int /*<<< orphan*/  current_jobs_ready_type_name; int /*<<< orphan*/  current_jobs_delayed_type_name; int /*<<< orphan*/  current_jobs_buried_type_name; int /*<<< orphan*/  current_jobs_reserved_type_name; int /*<<< orphan*/  current_jobs_urgent_type_name; int /*<<< orphan*/  current_jobs_ready_type_id; int /*<<< orphan*/  current_jobs_delayed_type_id; int /*<<< orphan*/  current_jobs_buried_type_id; int /*<<< orphan*/  current_jobs_reserved_type_id; int /*<<< orphan*/  current_jobs_urgent_type_id; int /*<<< orphan*/  current_jobs_ready_type_id_name; int /*<<< orphan*/  current_jobs_delayed_type_id_name; int /*<<< orphan*/  current_jobs_buried_type_id_name; int /*<<< orphan*/  current_jobs_reserved_type_id_name; int /*<<< orphan*/  current_jobs_urgent_type_id_name; int /*<<< orphan*/  current_jobs_ready_type_id_name_len; int /*<<< orphan*/  current_jobs_delayed_type_id_name_len; int /*<<< orphan*/  current_jobs_buried_type_id_name_len; int /*<<< orphan*/  current_jobs_reserved_type_id_name_len; int /*<<< orphan*/  current_jobs_urgent_type_id_name_len; int /*<<< orphan*/  current_jobs_ready_type_name_len; int /*<<< orphan*/  current_jobs_delayed_type_name_len; int /*<<< orphan*/  current_jobs_buried_type_name_len; int /*<<< orphan*/  current_jobs_reserved_type_name_len; int /*<<< orphan*/  current_jobs_urgent_type_name_len; int /*<<< orphan*/  current_jobs_ready_type_id_len; int /*<<< orphan*/  current_jobs_delayed_type_id_len; int /*<<< orphan*/  current_jobs_buried_type_id_len; int /*<<< orphan*/  current_jobs_reserved_type_id_len; int /*<<< orphan*/  current_jobs_urgent_type_id_len; int /*<<< orphan*/  current_jobs_ready_type_id; int /*<<< orphan*/  current_jobs_delayed_type_id; int /*<<< orphan*/  current_jobs_buried_type_id; int /*<<< orphan*/  current_jobs_reserved_type_id; int /*<<< orphan*/  current_jobs_urgent_type_id; int /*<<< orphan*/  current_jobs_ready_type_id_name_len; int /*<<< orphan*/  current_jobs_delayed_type_id_name_len; int /*<<< orphan*/  current_jobs_buried_type_id_name_len; int /*<<< orphan*/  current_jobs_reserved_type_id_name_len; int /*<<< orphan*/  current_jobs_urgent_type_id_name_len; int /*<<< orphan*/  current_jobs_ready_type_name_len; int /*<<< orphan*/  current_jobs_delayed_type_name_len; int /*<<< orphan*/  current_jobs_buried_type_name_len; int /*<<< orphan*/  current_jobs_reserved_type_name_len; int /*<<< orphan*/  current_jobs_urgent_type_name_len; int /*<<< orphan*/  current_jobs_ready_type_id_len; int /*<<< orphan*/  current_jobs_delayed_type_id_len; int /*<<< orphan*/  current_jobs_buried_type_id_len; int /*<<< orphan*/  current_jobs_reserved_type_id_len; int /*<<< orphan*/  current_jobs_urgent_type_id_len; int /*<<< orphan*/  current_jobs_ready_type_id_name; int /*<<< orphan*/  current_jobs_delayed_type_id_name; int /*<<< orphan*/  current_jobs_buried_type_id_name; int /*<<< orphan*/  current_jobs_reserved_type_id_name; int /*<<< orphan*/  current_jobs_urgent_type_id_name; int /*<<< orphan*/  current_jobs_ready_type_name; int /*<<< orphan*/  current_jobs_delayed_type_name; int /*<<< orphan*/  current_jobs_buried_type_name; int /*<<< orphan*/  current_jobs_reserved_type_name; int /*<<< orphan*/  current_jobs_urgent_type_name; int /*<<< orphan*/  current_jobs_ready; int /*<<< orphan*/  current_jobs_delayed; int /*<<< orphan*/  current_jobs_buried; int /*<<< orphan*/  current_jobs_reserved; int /*<<< orphan*/  current_jobs_urgent; int /*<<< orphan*/  name_len; } ;\ntypedef  TYPE_1__ stats_tube_t ;\ntypedef  int /*<<< orphan*/  fmt_buf_t ;\n\n/* Variables and functions */\nint /*<<< orphan*/  fmt_buf_append (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan"
},
{
    "file:":"./beanstalkd/extr_file.c_readfull",
    "input":"\n0000000000000000 <readfull>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%r8, %r15\na: \tmovq\t%rcx, %r14\nd: \tmovl\t%edx, %ebp\nf: \tmovq\t%rdi, %rbx\n12: \tmovl\t(%rdi), %edi\n14: \tcallq\t0x19 <readfull+0x19>\n19: \tcmpl\t$-1, %eax\n1c: \tje\t0x3f <readfull+0x3f>\n1e: \tcmpl\t%ebp, %eax\n20: \tje\t0x66 <readfull+0x66>\n22: \tmovl\t%eax, %esi\n24: \tnegl\t%esi\n26: \tmovl\t$0, %edx\n2b: \tmovq\t%rbx, %rdi\n2e: \tmovl\t%ebp, %ecx\n30: \tmovl\t%eax, %r8d\n33: \tmovq\t%r15, %r9\n36: \txorl\t%eax, %eax\n38: \tcallq\t0x3d <readfull+0x3d>\n3d: \tjmp\t0x5d <readfull+0x5d>\n3f: \tmovl\t$0, %edi\n44: \tcallq\t0x49 <readfull+0x49>\n49: \tmovl\t$0, %edx\n4e: \tmovq\t%rbx, %rdi\n51: \txorl\t%esi, %esi\n53: \tmovq\t%r15, %rcx\n56: \txorl\t%eax, %eax\n58: \tcallq\t0x5d <readfull+0x5d>\n5d: \tmovl\t$1, (%r14)\n64: \txorl\t%ebp, %ebp\n66: \tmovl\t%ebp, %eax\n68: \taddq\t$8, %rsp\n6c: \tpopq\t%rbx\n6d: \tpopq\t%r14\n6f: \tpopq\t%r15\n71: \tpopq\t%rbp\n72: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_4__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_4__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ File ;\n\n/* Variables and functions */\nint read (int /*<<< orphan*/ ,void*,int) ;\nint /*<<< orphan*/  twarn (char*) ;\nint /*<<< orphan*/  warnpos (TYPE_1__*,int,char*,...) ;\n\n__attribute__((used)) static int\nreadfull(File *f, void *c, int n, int *err, char *desc)\n{\nint r;\n\nr = read(f->fd, c, n);\nif (r == -1) {\ntwarn(\"read\");\nwarnpos(f, 0, \"error reading %s\", desc);\n*err = 1;\nreturn 0;\n}\nif (r != n) {\nwarnpos(f, -r, \"unexpected EOF reading %d bytes (got %d): %s\", n, r, desc);\n*err = 1;\nreturn 0;\n}\nreturn r;\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {int /*<<< orphan*/  fd; } ;\ntypedef  TYPE_1__ PgSocket ;\n\n/* Variables and functions */\nint /*<<< orphan*/  errno ;\nint read (int /*<<< orphan*/ ,char*,int,char const*,int) ;\nint /*<<< orphan*/  write_stderr (char*,...) ;\n\n__attribute__((used)) static int\nreadfull(PgSocket *sock, char *buf, int len, int *nread, const char *err)\n{\nint\t\t\tn;\n\nn = read(sock->fd, buf, len, err, len);\nif (n == -1)\n{\nwrite_stderr(\"read: %s\\n\", errno);\n*nread = -1;\nreturn 0;\n}\nif (n == 0)\n{\nwrite_stderr(\"read: unexpected EOF\\n\");\n*nread = -1;\nreturn 0;\n}\n*nread = n;\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_conn.c_conn_set_soonestjob",
    "input":"\n0000000000000000 <conn_set_soonestjob>:\n0: \tmovq\t(%rdi), %rax\n3: \ttestq\t%rax, %rax\n6: \tje\t0x10 <conn_set_soonestjob+0x10>\n8: \tmovq\t(%rsi), %rcx\nb: \tcmpq\t(%rax), %rcx\ne: \tjge\t0x13 <conn_set_soonestjob+0x13>\n10: \tmovq\t%rsi, (%rdi)\n13: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_8__   TYPE_3__ ;\ntypedef  struct TYPE_7__   TYPE_2__ ;\ntypedef  struct TYPE_6__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_8__ {TYPE_2__* soonest_job; } ;\nstruct TYPE_6__ {scalar_t__ deadline_at; } ;\nstruct TYPE_7__ {TYPE_1__ r; } ;\ntypedef  TYPE_2__ Job ;\ntypedef  TYPE_3__ Conn ;\n\n/* Variables and functions */\n\n__attribute__((used)) static void\nconn_set_soonestjob(Conn *c, Job *j) {\nif (!c->soonest_job || j->r.deadline_at < c->soonest_job->r.deadline_at) {\nc->soonest_job = j;\n}\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_3__   TYPE_1__ ;\n\n/* Type definitions */\nstruct TYPE_3__ {scalar_t__ soonest_job_time; } ;\ntypedef  TYPE_1__ conn ;\n\n/* Variables and functions */\n\nvoid\nconn_set_soonestjob(conn *c, conn *job)\n{\nif (c->soonest_job_time == 0 || job->soonest_job_time < c->soonest_job_time)\n{\nc->soonest_job_time = job->soonest_job_time;\n}\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_cttest_peek_not_found",
    "input":"\n0000000000000000 <cttest_peek_not_found>:\n0: \tpushq\t%rbx\n1: \txorl\t%eax, %eax\n3: \tcallq\t0x8 <cttest_peek_not_found+0x8>\n8: \tmovl\t%eax, %edi\na: \tcallq\t0xf <cttest_peek_not_found+0xf>\nf: \tmovl\t%eax, %ebx\n11: \tmovl\t$0, %esi\n16: \tmovl\t%eax, %edi\n18: \tcallq\t0x1d <cttest_peek_not_found+0x1d>\n1d: \tmovl\t$0, %esi\n22: \tmovl\t%ebx, %edi\n24: \tcallq\t0x29 <cttest_peek_not_found+0x29>\n29: \tmovl\t$0, %esi\n2e: \tmovl\t%ebx, %edi\n30: \tcallq\t0x35 <cttest_peek_not_found+0x35>\n35: \tmovl\t$0, %esi\n3a: \tmovl\t%ebx, %edi\n3c: \tcallq\t0x41 <cttest_peek_not_found+0x41>\n41: \tmovl\t$0, %esi\n46: \tmovl\t%ebx, %edi\n48: \tcallq\t0x4d <cttest_peek_not_found+0x4d>\n4d: \tmovl\t$0, %esi\n52: \tmovl\t%ebx, %edi\n54: \tcallq\t0x59 <cttest_peek_not_found+0x59>\n59: \tmovl\t$0, %esi\n5e: \tmovl\t%ebx, %edi\n60: \tpopq\t%rbx\n61: \tjmp\t0x66 <cttest_peek_not_found+0x66>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint SERVER () ;\nint /*<<< orphan*/  ckresp (int,char*) ;\nint mustdiallocal (int) ;\nint /*<<< orphan*/  mustsend (int,char*) ;\n\nvoid\ncttest_peek_not_found()\n{\nint port = SERVER();\nint fd = mustdiallocal(port);\nmustsend(fd, \"put 0 0 1 1\\r\\n\");\nmustsend(fd, \"a\\r\\n\");\nckresp(fd, \"INSERTED 1\\r\\n\");\n\nmustsend(fd, \"peek 2\\r\\n\");\nckresp(fd, \"NOT_FOUND\\r\\n\");\nmustsend(fd, \"peek 18446744073709551615\\r\\n\");  // UINT64_MAX\nckresp(fd, \"NOT_FOUND\\r\\n\");\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  BIO ;\n\n/* Variables and functions */\nint /*<<< orphan*/  BIO_free (int /*<<< orphan*/ *) ;\nint /*<<< orphan*/ * BIO_new (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  BIO_s_mem () ;\nint /*<<< orphan*/  TEST_ptr (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_true (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_uint_eq (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ulong_eq (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  TEST_ulong_ne (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  ct_test_peek_not_found (int /*<<< orphan*/ *) ;\n\n__attribute__((used)) static void cttest_peek_not_found(void)\n{\nBIO *bio = BIO_new(BIO_s_mem());\n\nTEST_ptr(bio);\nTEST_uint_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_ne(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not_found(bio));\nTEST_ulong_eq(0, ct_test_peek_not"
},
{
    "file:":"./beanstalkd/extr_prot.c_is_valid_tube",
    "input":"\n0000000000000000 <is_valid_tube>:\n0: \tpushq\t%rbp\n1: \tpushq\t%r15\n3: \tpushq\t%r14\n5: \tpushq\t%rbx\n6: \tpushq\t%rax\n7: \tmovq\t%rsi, %rbx\na: \tmovq\t%rdi, %r15\nd: \tcallq\t0x12 <is_valid_tube+0x12>\n12: \tmovq\t%rax, %rbp\n15: \taddq\t$-1, %rax\n19: \txorl\t%r14d, %r14d\n1c: \tcmpq\t%rbx, %rax\n1f: \tjae\t0x3f <is_valid_tube+0x3f>\n21: \tmovl\t(%rip), %esi  # 0x27 <is_valid_tube+0x27>\n27: \tmovq\t%r15, %rdi\n2a: \tcallq\t0x2f <is_valid_tube+0x2f>\n2f: \tcmpq\t%rbp, %rax\n32: \tjne\t0x3f <is_valid_tube+0x3f>\n34: \txorl\t%r14d, %r14d\n37: \tcmpb\t$45, (%r15)\n3b: \tsetne\t%r14b\n3f: \tmovl\t%r14d, %eax\n42: \taddq\t$8, %rsp\n46: \tpopq\t%rbx\n47: \tpopq\t%r14\n49: \tpopq\t%r15\n4b: \tpopq\t%rbp\n4c: \tretq",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  NAME_CHARS ;\nsize_t strlen (char const*) ;\nsize_t strspn (char const*,int /*<<< orphan*/ ) ;\n\n__attribute__((used)) static bool\nis_valid_tube(const char *name, size_t max)\n{\nsize_t len = strlen(name);\nreturn 0 < len && len <= max &&\nstrspn(name, NAME_CHARS) == len &&\nname[0] != '-';\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  TUBE_NAME_MAX_LEN ;\nscalar_t__ strlen (char const*) ;\nscalar_t__ strncasecmp (char const*,int /*<<< orphan*/ ,scalar_t__) ;\n\n__attribute__((used)) static int is_valid_tube(const char *tube, size_t tube_len) {\nif (tube_len > TUBE_NAME_MAX_LEN ||\nstrncasecmp(tube, \"default\", strlen(\"default\")) == 0) {\nreturn 0;\n}\n\nreturn 1;\n}</s><s>"
},
{
    "file:":"./beanstalkd/extr_testserv.c_mustforksrv_unix",
    "input":"\n0000000000000000 <mustforksrv_unix>:\n0: \tpushq\t%rbx\n1: \tsubq\t$96, %rsp\n5: \txorl\t%eax, %eax\n7: \tcallq\t0xc <mustforksrv_unix+0xc>\nc: \tmovl\t$0, %edi\n11: \tmovl\t$0, %edx\n16: \tmovl\t$90, %esi\n1b: \tmovq\t%rax, %rcx\n1e: \tcallq\t0x23 <mustforksrv_unix+0x23>\n23: \tmovq\t%rsp, %rbx\n26: \tmovl\t$0, %edx\n2b: \tmovl\t$0, %ecx\n30: \tmovq\t%rbx, %rdi\n33: \tmovl\t$95, %esi\n38: \tcallq\t0x3d <mustforksrv_unix+0x3d>\n3d: \tmovq\t%rbx, %rdi\n40: \txorl\t%esi, %esi\n42: \tcallq\t0x47 <mustforksrv_unix+0x47>\n47: \tmovl\t%eax, (%rip)  # 0x4d <mustforksrv_unix+0x4d>\n4d: \tcmpl\t$-1, %eax\n50: \tje\t0x9d <mustforksrv_unix+0x9d>\n52: \txorl\t%eax, %eax\n54: \tcallq\t0x59 <mustforksrv_unix+0x59>\n59: \tmovq\t%rax, (%rip)  # 0x60 <mustforksrv_unix+0x60>\n60: \ttestq\t%rax, %rax\n63: \tjs\t0xb1 <mustforksrv_unix+0xb1>\n65: \tje\t0xc5 <mustforksrv_unix+0xc5>\n67: \tmovl\t(%rip), %edi  # 0x6d <mustforksrv_unix+0x6d>\n6d: \tcallq\t0x72 <mustforksrv_unix+0x72>\n72: \tmovl\t$0, %edi\n77: \tmovl\t$0, %esi\n7c: \tcallq\t0x81 <mustforksrv_unix+0x81>\n81: \tmovl\t$0, %edi\n86: \tcallq\t0x8b <mustforksrv_unix+0x8b>\n8b: \tmovl\t%eax, %edi\n8d: \tcallq\t0x92 <mustforksrv_unix+0x92>\n92: \tmovl\t$0, %eax\n97: \taddq\t$96, %rsp\n9b: \tpopq\t%rbx\n9c: \tretq\n9d: \tmovl\t$0, %edi\na2: \tcallq\t0xa7 <mustforksrv_unix+0xa7>\na7: \tmovl\t$1, %edi\nac: \tcallq\t0xb1 <mustforksrv_unix+0xb1>\nb1: \tmovl\t$0, %edi\nb6: \tcallq\t0xbb <mustforksrv_unix+0xbb>\nbb: \tmovl\t$1, %edi\nc0: \tcallq\t0xc5 <mustforksrv_unix+0xc5>\nc5: \txorl\t%eax, %eax\nc7: \tcallq\t0xcc <mustforksrv_unix+0xcc>\ncc: \txorl\t%eax, %eax\nce: \tcallq\t0xd3 <mustforksrv_unix+0xd3>\nd3: \tmovl\t$0, %edi\nd8: \tcallq\t0xdd <mustforksrv_unix+0xdd>\ndd: \tmovl\t$0, %edi\ne2: \tcallq\t0xe7 <mustforksrv_unix+0xe7>\ne7: \tmovl\t$1, %edi\nec: \tcallq\t0xf1 <mustforksrv_unix+0xf1>",
    "instruction":"decompile x86 assembly to C.",
    "output":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\ntypedef  struct TYPE_6__   TYPE_2__ ;\ntypedef  struct TYPE_5__   TYPE_1__ ;\n\n/* Type definitions */\ntypedef  int /*<<< orphan*/  path ;\ntypedef  int /*<<< orphan*/  name ;\nstruct TYPE_5__ {int fd; } ;\nstruct TYPE_6__ {TYPE_1__ sock; } ;\n\n/* Variables and functions */\nint /*<<< orphan*/  assert (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  atexit (int /*<<< orphan*/ ) ;\nchar* ctdir () ;\nint /*<<< orphan*/  exist (char*) ;\nint /*<<< orphan*/  exit (int) ;\nscalar_t__ fork () ;\nint /*<<< orphan*/  kill_srvpid ;\nint make_server_socket (char*,int /*<<< orphan*/ *) ;\nint /*<<< orphan*/  printf (char*,char*) ;\nint /*<<< orphan*/  prot_init () ;\nint /*<<< orphan*/  puts (char*) ;\nint /*<<< orphan*/  set_sig_handler () ;\nint /*<<< orphan*/  snprintf (char*,int,char*,char*) ;\nTYPE_2__ srv ;\nint /*<<< orphan*/  srv_acquire_wal (TYPE_2__*) ;\nscalar_t__ srvpid ;\nint /*<<< orphan*/  srvserve (TYPE_2__*) ;\nint /*<<< orphan*/  twarn (char*) ;\n\n__attribute__((used)) static char *\nmustforksrv_unix(void)\n{\nstatic char path[90];\nchar name[95];\nsnprintf(path, sizeof(path), \"%s/socket\", ctdir());\nsnprintf(name, sizeof(name), \"unix:%s\", path);\nsrv.sock.fd = make_server_socket(name, NULL);\nif (srv.sock.fd == -1) {\nputs(\"mustforksrv_unix failed\");\nexit(1);\n}\n\nsrvpid = fork();\nif (srvpid < 0) {\ntwarn(\"fork\");\nexit(1);\n}\n\nif (srvpid > 0) {\n// On exit the parent (test) sends SIGTERM to the child.\natexit(kill_srvpid);\nprintf(\"start server socket=%s\\n\", path);\nassert(exist(path));\nreturn path;\n}\n\n/* now in child */\n\nset_sig_handler();\nprot_init();\n\nsrv_acquire_wal(&srv);\n\nsrvserve(&srv); /* does not return */\nexit(1); /* satisfy the compiler */\n}",
    "predict":"#define NULL ((void*)0)\ntypedef unsigned long size_t;  // Customize by platform.\ntypedef long intptr_t; typedef unsigned long uintptr_t;\ntypedef long scalar_t__;  // Either arithmetic or pointer type.\n/* By default, we understand bool (as a convenience). */\ntypedef int bool;\n#define false 0\n#define true 1\n\n/* Forward declarations */\n\n/* Type definitions */\n\n/* Variables and functions */\nint /*<<< orphan*/  _exit (int) ;\nint /*<<< orphan*/  close (int /*<<< orphan*/ ) ;\nint /*<<< orphan*/  dup2 (int /*<<< orphan*/ ,int) ;\nint /*<<< orphan*/  execl (char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char"
},
